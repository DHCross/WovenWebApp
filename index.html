<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Woven Map Report Generator</title>
    <link href="dist/output.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a202c;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
        .animate-fade-in-out {
            animation: fadeInOut 8s ease-in-out forwards;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateY(-20px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Woven Map Report Generator</h1>
            <p class="text-gray-400 mt-2 flex items-center justify-center gap-2">Math Brain
                <button id="math-brain-info-btn" class="ml-2 text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">What is this? (Glossary)</button>
            </p>
        </header>

        <!-- Math Brain Modal -->
        <div id="math-brain-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 hidden">
          <div class="bg-gray-900 rounded-lg shadow-xl max-w-lg w-full p-6 relative border border-teal-500">
            <button id="close-math-brain-modal" class="absolute top-2 right-2 text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            <h2 class="text-xl font-bold text-teal-300 mb-2">Math Brain & Poetic Brain: The Woven Map Framework</h2>
            <p class="text-sm text-gray-200 mb-3">The <b>Math Brain</b> is the symbolic scaffolding engine. It computes exact planetary positions, aspects, and house placements, and outputs a structured dataset of alignments (e.g., Venus square Pluto at 2° orb). It gives no meaning on its own—only the raw geometry. This is the MAP layer of FIELD → MAP → VOICE.<br><br>
            The <b>Poetic Brain</b> (Raven Calder) translates this geometry into emotional, somatic, and narrative language. It asks: “Does this land for you?”—never prescribes meaning. The Poetic Brain is diagnostic, not predictive, and always testable by lived experience.<br><br>
            <b>TL;DR:</b> The Math Brain finds the coordinates. The Poetic Brain speaks the language you can feel. Math Brain = telescope; Poetic Brain = translator.</p>
            <h3 class="text-teal-200 font-semibold mt-4 mb-1">Glossary (Core Terms)</h3>
            <ul class="text-xs text-gray-300 space-y-1 max-h-48 overflow-y-auto pr-2">
              <li><b>FIELD → MAP → VOICE</b>: The interpretive structure. FIELD = energetic climate, MAP = geometry, VOICE = felt reflection.</li>
              <li><b>Ping</b>: A moment of recognized resonance between chart and experience. No ping, no claim.</li>
              <li><b>SST (Symbolic Spectrum Table)</b>: Falsifiability filter. WB = Within Boundary, ABE = At Boundary Edge, OSR = Outside Symbolic Range.</li>
              <li><b>OSR</b>: No resonance. Not failure—just honest silence.</li>
              <li><b>Echo Loop</b>: Repeating dynamic between two people, usually &lt;1° orb.</li>
              <li><b>REF (Relational Echo Field)</b>: Macro-pattern resonance between two charts.</li>
              <li><b>Intimacy Tier</b>: P1 = Platonic Partners, P2 = Friends-with-benefits, P3 = Romantic Partners.</li>
              <li><b>Clear Mirror Language</b>: Testable, non-mystical, emotionally grounded phrasing.</li>
              <li><b>29° Crisis Node</b>: Any planet at 29°, indicating volatility or urgency.</li>
              <li><b>Symbolic Weather Overlay</b>: Optional summary of current transits as energetic "weather" (not predictive).</li>
              <li><b>Poetic Codex</b>: System that turns geometry into poetic inquiries (not random poems).</li>
              <li><b>Translation Bridge</b>: Converting geometry (MAP) into felt language (VOICE).</li>
              <li><b>Resonance Line</b>: Dominant energetic vector in a chart.</li>
              <li><b>Paradox Line</b>: Highlights internal contradictions or conflicting drives.</li>
            </ul>
            <div class="mt-4 text-right">
              <button id="close-math-brain-modal-bottom" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-1 px-4 rounded">Close</button>
            </div>
          </div>
        </div>

        <main>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div id="personA-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Person A / Natal Chart</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameA" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="DH Cross">
                            <input type="text" id="cityA" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="Bryn Mawr">
                             <input type="text" id="stateA" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="PA">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="dateA" placeholder="Date (MM-DD-YYYY)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="07-24-1973">
                            <input type="text" id="timeA" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="14:30">
                            <select id="offsetA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Chicago">Central (Chicago)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska (Anchorage)</option>
                                <option value="Pacific/Honolulu">Hawaii (Honolulu)</option>
                            </select>
                        </div>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="nationA" placeholder="Country" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="US">
                            <select id="zodiacA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-4 pt-2">
                           <label class="flex items-center"><input type="radio" name="coordModeA" value="combined" class="form-radio h-4 w-4 text-indigo-600" checked><span class="ml-2 text-gray-300">Combined</span></label>
                        </div>
                        <div id="combinedCoordsA"><input type="text" id="astroA" placeholder="Birth Coordinates" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="40°1'N, 75°19'W"></div>
                    </div>
                </div>

                <div id="personB-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Person B (Optional)</h2>
                    <div class="space-y-4">
                         <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameB" placeholder="Name" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <input type="text" id="cityB" placeholder="Birth City" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <input type="text" id="stateB" placeholder="Birth State/Prov" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="dateB" placeholder="Date (MM-DD-YYYY)" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <input type="text" id="timeB" placeholder="Time (24h HH:MM)" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                             <select id="offsetB" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Chicago">Central (Chicago)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska (Anchorage)</option>
                                <option value="Pacific/Honolulu">Hawaii (Honolulu)</option>
                            </select>
                        </div>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="nationB" placeholder="Country" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <select id="zodiacB" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-4 pt-2">
                           <label class="flex items-center"><input type="radio" name="coordModeB" value="combined" class="form-radio h-4 w-4 text-indigo-600" checked><span class="ml-2 text-gray-300">Combined</span></label>
                        </div>
                        <div id="combinedCoordsB"><input type="text" id="astroB" placeholder="Birth Coordinates" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value=""></div>
                        <button id="pasteAstroB" class="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded text-sm">
                          Paste AstroSeek Data
                        </button>
                    </div>
                </div>
            </div>

            <div id="relational-context-stack" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 hidden border border-teal-500">
                <div class="flex items-center mb-4">
                <h2 class="text-2xl font-semibold text-white border-b border-gray-700 pb-2 mr-3">Relational Context Query Stack</h2>
                <button id="echo-loop-info-btn" type="button" class="relative group ml-2 text-xs text-indigo-300 underline hover:text-indigo-400 focus:outline-none">
                  What’s an Echo Loop?
                  <span class="hidden sm:block absolute left-1/2 transform -translate-x-1/2 mt-2 w-72 bg-gray-900 text-gray-200 text-xs rounded-lg shadow-lg p-3 border border-indigo-500 opacity-0 group-hover:opacity-100 group-focus:opacity-100 transition-opacity z-50 pointer-events-none">
                    <b>An Echo Loop</b> is a repeating dynamic between two people, formed by tight (usually <1° orb) aspects that go both ways.<br><br>
                    Think of it as a pattern you both co-create—often magnetic, sometimes difficult to break.<br><br>
                    Echo Loops form the core of Relational Echo Fields (REFs) when multiple loops share a theme.<br><br>
                    <span class="block mt-2 text-indigo-300 font-semibold">✅ Protocol Alignment: Why This Works</span>
                    <ul class="list-disc list-inside text-gray-300 text-xs mt-1">
                      <li>Does not override user autonomy (only describes mechanics)</li>
                      <li>Preserves Recognition-first model (no "you're feeling X")</li>
                      <li>Clarifies Math Brain’s role (no interpretive ambiguity)</li>
                      <li>Prepares user for Poetic Brain handoff without overexplanation</li>
                    </ul>
                  </span>
                  <span class="block sm:hidden mt-2 w-full bg-gray-900 text-gray-200 text-xs rounded-lg shadow-lg p-3 border border-indigo-500">
                    <b>An Echo Loop</b> is a repeating dynamic between two people, formed by tight (usually <1° orb) aspects that go both ways.<br><br>
                    Think of it as a pattern you both co-create—often magnetic, sometimes difficult to break.<br><br>
                    Echo Loops form the core of Relational Echo Fields (REFs) when multiple loops share a theme.<br><br>
                    <span class="block mt-2 text-indigo-300 font-semibold">✅ Protocol Alignment: Why This Works</span>
                    <ul class="list-disc list-inside text-gray-300 text-xs mt-1">
                      <li>Does not override user autonomy (only describes mechanics)</li>
                      <li>Preserves Recognition-first model (no "you're feeling X")</li>
                      <li>Clarifies Math Brain’s role (no interpretive ambiguity)</li>
                      <li>Prepares user for Poetic Brain handoff without overexplanation</li>
                    </ul>
                  </span>
                </button>
            </div>
            <!-- Diagnostics Preview Strip -->
            <div id="diagnostics-strip" class="mb-4 hidden">
              <button id="diagnostics-toggle" class="text-xs bg-indigo-700 text-white rounded px-2 py-1 mr-2">Show Diagnostics</button>
              <div id="diagnostics-panel" class="inline-block align-middle"></div>
            </div>
            <p class="text-gray-400 text-sm mb-4">Based on initial geometry, the Math Brain has detected the following potential dynamics:</p>
            <ul id="context-readout" class="list-disc list-inside space-y-2 mb-4 text-gray-300">
                </ul>
                <div id="relationship-type-query">
                    <p class="text-lg font-medium text-white mb-2">How would you categorize this connection?</p>
                    <div class="flex flex-col space-y-2">
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="Partner" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Partner (romantic/undefined-intimate)</span></label>
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="Friend" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Friend or colleague</span></label>
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="Family" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Family</span></label>
                    </div>
                    <div id="intimacy-tier-dropdown" class="mt-4 hidden">
                        <p class="text-md font-medium text-white mb-2">What best describes the intimacy tier of this connection?</p>
                        <div class="flex flex-col space-y-2">
                            <label class="flex items-center"><input type="radio" name="intimacyTier" value="P1" class="form-radio h-4 w-4 text-pink-400"><span class="ml-2 text-gray-300">P1 – Platonic partners</span></label>
                            <label class="flex items-center"><input type="radio" name="intimacyTier" value="P2" class="form-radio h-4 w-4 text-pink-400"><span class="ml-2 text-gray-300">P2 – Friends with benefits</span></label>
                            <label class="flex items-center"><input type="radio" name="intimacyTier" value="P3" class="form-radio h-4 w-4 text-pink-400"><span class="ml-2 text-gray-300">P3 – Romantic partners</span></label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mb-8">
                <label class="flex items-center">
                    <input type="checkbox" id="synastryToggle" class="form-checkbox h-5 w-5 text-teal-400" checked>
                    <span class="ml-3 text-white font-medium">Include Synastry Analysis</span>
                </label>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
                <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Step 1: Generate Natal & Transit Data</h2>
                <div>
                     <label class="text-lg text-gray-200">Date Range (Defaults to Today)</label>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                       <input type="text" id="startDate" placeholder="Start Date (MM-DD-YYYY)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                       <input type="text" id="endDate"   placeholder="End Date (optional)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                    </div>
                     <p class="text-gray-400 text-sm mt-2">Generates natal charts and transits for the date range, always calculated for the birth location.</p>
                     <div class="mt-4 bg-gray-700/50 p-4 rounded-md">
                        <label class="flex items-center">
                            <input type="checkbox" id="relocationToggle" class="form-checkbox h-5 w-5 text-teal-400">
                            <span class="ml-3 text-white font-medium">Add Relocation Overlay (Optional)</span>
                        </label>
                        <div id="relocationFields" class="hidden mt-3">
                            <p class="text-sm text-gray-400 mb-2">Enter coordinates (e.g., <b>30°10′N, 85°40′W</b>) to see a side-by-side comparison of how transits fall in the relocated house system.</p>
                            <input type="text"
                                   id="relocationCoords"
                                   placeholder="30°10′N, 85°40′W"
                                   class="w-full bg-gray-800 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-teal-500 focus:outline-none"
                                   value="30°10′N, 85°40′W">
                            <div id="relocationError" class="text-red-500 text-xs mt-1 hidden"></div>
                            <p class="text-xs text-gray-500 italic text-right pr-1 pt-1">
                                You can also paste decimal degrees (e.g., 30.1588, -85.6602).
                            </p>
                        </div>
                    </div>
                     <button id="generate-btn" class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:bg-indigo-400 disabled:cursor-not-allowed">
                        Generate Full Report
                    </button>
                </div>
            </div>
             <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
                 <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Step 2 (Optional): Get Local Astrological Forecast</h2>
                 <p class="text-gray-400 text-sm mb-4 italic">This generates a standalone chart of the sky for a specific location and time, which can be used as a contextual overlay. For a full transit analysis, provide this data to your Poetic Brain along with the main report.</p>
                 <p class="text-gray-400 text-sm mb-4 italic font-semibold">Note: This app is built to generate input for astrology AI apps (GPTs). If you only generate the astrological weather (Step 2) without a natal chart, it won’t connect to personal dynamics and will be symbolically meaningless.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                        <label class="text-lg text-gray-200">Location</label>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                           <input type="text" id="weatherLat" placeholder="Latitude (e.g. 30.1588)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="30.1588">
                           <input type="text" id="weatherLon" placeholder="Longitude (e.g. -85.6602)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="-85.6602">
                        </div>
                        <p class="text-xs text-gray-500 italic text-right pr-1 pt-1">Find coordinates with a web search, e.g., "coordinates for Panama City, FL".</p>
                    </div>
                    <div>
                        <label class="text-lg text-gray-200">Date Range (Defaults to Today)</label>
                         <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                           <input type="text" id="weatherStartDate" placeholder="Start Date (MM-DD-YYYY)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                           <input type="text" id="weatherEndDate"   placeholder="End Date (optional)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                        </div>
                    </div>
                </div>
                <button id="getWeatherBtn" class="mt-4 w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Get Forecast
                </button>
            </div>


            <div id="output-section" class="bg-gray-800 p-6 rounded-lg shadow-lg hidden">
                 <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 id="report-title" class="text-2xl font-semibold text-white">Generated Report</h2>
                    <div class="flex space-x-2">
                        <button id="copy-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">Copy Markdown</button>
                        <button id="save-md-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">Save Markdown</button>
                        <button id="save-json-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">Save JSON</button>
                    </div>
                </div>
                <pre id="report-output" class="w-full h-96 bg-gray-900 text-gray-300 rounded-md p-4 overflow-auto font-mono text-sm whitespace-pre-wrap"></pre>
            </div>
             <div id="message-box" class="fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg hidden"></div>
        </main>
    </div>

    <script>
        // --- DOM Elements ---
        const generateBtn = document.getElementById('generate-btn');
        const getWeatherBtn = document.getElementById('getWeatherBtn');
        const outputSection = document.getElementById('output-section');
        const reportOutput = document.getElementById('report-output');
        const reportTitle = document.getElementById('report-title');
        const copyBtn = document.getElementById('copy-btn');
        const saveJsonBtn = document.getElementById('save-json-btn');
        const saveMdBtn = document.getElementById('save-md-btn');
        const messageBox = document.getElementById('message-box');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const weatherStartDateInput = document.getElementById('weatherStartDate');
        const weatherEndDateInput = document.getElementById('weatherEndDate');
        const relocationToggle = document.getElementById('relocationToggle');
        const relocationFields = document.getElementById('relocationFields');
        const relocationCoordsInput = document.getElementById('relocationCoords');
        const relocationError = document.getElementById('relocationError');
        const synastryToggle = document.getElementById('synastryToggle');
        const relationalContextStack = document.getElementById('relational-context-stack');
        const contextReadout = document.getElementById('context-readout');

        // --- Global State ---
        let fullReportData = {};
        let markdownReport = '';
        let contextCheckTimeout;

        // --- API & LOCAL ENGINE CONFIG ---
        const ORBS = { "conjunction": 8, "opposition": 8, "square": 5, "trine": 6, "sextile": 4 };
        const ASPECT_DEGREES = { "conjunction": 0, "opposition": 180, "square": 90, "trine": 120, "sextile": 60 };
        const HOUSE_NAMES = ["First_House", "Second_House", "Third_House", "Fourth_House", "Fifth_House", "Sixth_House", "Seventh_House", "Eighth_House", "Ninth_House", "Tenth_House", "Eleventh_House", "Twelfth_House"];
        const SYMBOLS = {"conjunction": "☌", "opposition": "☍", "square": "□", "trine": "△", "sextile": "✶"};

        // --- HELPER FUNCTIONS ---
        const showMessage = (message, type = 'error') => {
            messageBox.textContent = message;
            messageBox.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg ${type === 'error' ? 'bg-red-600' : 'bg-green-600'}`;
            messageBox.classList.remove('hidden');
            messageBox.classList.add('animate-fade-in-out');
            setTimeout(() => { messageBox.classList.add('hidden'); messageBox.classList.remove('animate-fade-in-out'); }, 7900);
        };

        const parseCoordinate = (input) => {
            let s = String(input).trim();
            if (!s) throw new Error("Coordinate input is empty.");
            let sign = /[SW]/i.test(s) ? -1 : 1;
            s = s.replace(/[NSEW]/ig, '');
            if (s.startsWith('-')) { sign = -1; s = s.slice(1); }
            s = s.replace(/[°º]/g, ' ').replace(/[\'′’]/g, ' ').replace(/[\"″]/g, ' ');
            const parts = s.trim().split(/\s+/).filter(Boolean);
            if (parts.length === 0) throw new Error(`Invalid coordinate format for "${input}".`);

            const deg = parseFloat(parts[0]);
            if (isNaN(deg)) throw new Error(`Invalid degrees in coordinate "${input}".`);
            const min = parts[1] ? parseFloat(parts[1]) : 0;
            const sec = parts[2] ? parseFloat(parts[2]) : 0;
            if ((parts[1] && isNaN(min)) || (parts[2] && isNaN(sec))) {
                throw new Error(`Invalid minutes or seconds in coordinate "${input}".`);
            }
            const val = Math.abs(deg) + (min / 60) + (sec / 3600);
            return sign * val;
        };

        const parseCombinedCoords = (txt) => {
            if (!txt) throw new Error("Coordinate input is empty.");
            let parts = txt.split(',');
            if (parts.length >= 2) {
                const latitude = parseCoordinate(parts[0]);
                const longitude = parseCoordinate(parts.slice(1).join(','));
                return { latitude, longitude };
            }
            const match = txt.match(/([\d°º'"′″\.\s+-]+[NS])[^\dA-Z+-]*([\d°º'"′″\.\s+-]+[EW])/i);
            if (match) return { latitude: parseCoordinate(match[1]), longitude: parseCoordinate(match[2]) };
            throw new Error('Invalid combined coordinate format.');
        };

        const getSubjectData = (personPrefix) => {
            const name = document.getElementById(`name${personPrefix}`).value;
            const city = document.getElementById(`city${personPrefix}`).value;
            const state = document.getElementById(`state${personPrefix}`).value;
            const date = document.getElementById(`date${personPrefix}`).value;
            const time = document.getElementById(`time${personPrefix}`).value;
            const timezone = document.getElementById(`offset${personPrefix}`).value;
            const nation = document.getElementById(`nation${personPrefix}`).value;
            const zodiac_type = document.getElementById(`zodiac${personPrefix}`).value;

            // Basic validation for required fields
            if (!name || !city || !state || !date || !time || !nation) {
                return null;
            }
            // Date and time format validation
            if (!/^\d{2}-\d{2}-\d{4}$/.test(date) || !/^\d{2}:\d{2}$/.test(time)) {
                return null;
            }

            let latitude, longitude;
            const coordMode = document.querySelector(`input[name="coordMode${personPrefix}"]:checked`).value;

            try {
                // Always use combined coordinate input
                const astroValue = document.getElementById(`astro${personPrefix}`).value;
                if (!astroValue) return null;
                const coords = parseCombinedCoords(astroValue);
                latitude = coords.latitude;
                longitude = coords.longitude;
                if (isNaN(latitude) || isNaN(longitude)) {
                   return null;
                }
            } catch (error) {
                // Don't show a popup for real-time validation, just return null
                return null;
            }

            const [month, day, year] = date.split('-').map(Number);
            const [hour, minute] = time.split(':').map(Number);

            return { name, city, state, date, time, timezone, latitude, longitude, year, month, day, hour, minute, nation, zodiac_type };
        };

        const getChartDataFromApi = async (payload) => {
            const res = await fetch('/.netlify/functions/astrology', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const text = await res.text();
            let responsePayload;

            try {
                responsePayload = JSON.parse(text);
            } catch {
                console.error('Non-JSON response from Netlify function:', text);
                throw new Error(`Server returned invalid data (status ${res.status}):\n` + text);
            }

            if (!res.ok) {
                // Show detailed error if available
                const errorMsg = responsePayload.error || responsePayload.details || 'An unknown server error occurred.';
                throw new Error(errorMsg);
            }

            return responsePayload;
        };

        const calculateAspects = (chartA, chartB, orbOverrides = {}) => {
            const aspects = [];
            const planetsA = chartA.planets_names_list.concat(chartA.axial_cusps_names_list);
            const planetsB = chartB.planets_names_list.concat(chartB.axial_cusps_names_list);

            for (const p1Name of planetsA) {
                const p1 = chartA[p1Name.toLowerCase()];
                if (!p1) continue;
                for (const p2Name of planetsB) {
                    const p2 = chartB[p2Name.toLowerCase()];
                    if (!p2) continue;
                    // Avoid self-aspects in natal calculations
                    if (chartA === chartB && p1.name === p2.name) continue;

                    const diff = Math.abs((p1.abs_pos - p2.abs_pos + 180) % 360 - 180);
                    for (const [aspectName, aspectDeg] of Object.entries(ASPECT_DEGREES)) {
                        const orbLimit = orbOverrides[aspectName] || ORBS[aspectName];
                        const orb = Math.abs(diff - aspectDeg);
                        if (orb < orbLimit) {
                            aspects.push({
                                p1_name: p1.name, p2_name: p2.name,
                                p1_pos: p1.position, p2_pos: p2.position,
                                aspect: aspectName, orb: parseFloat(orb.toFixed(2))
                            });
                        }
                    }
                }
            }
            return aspects;
        };

        const calculateHouseOverlays = (planetsChart, housesChart) => {
            const overlays = {};
            const houseCusps = HOUSE_NAMES.map(name => housesChart[name.toLowerCase()].abs_pos);

            for (const planetName of planetsChart.planets_names_list) {
                const planet = planetsChart[planetName.toLowerCase()];
                if (!planet) continue;

                for (let i = 0; i < 12; i++) {
                    const cuspStart = houseCusps[i];
                    const cuspEnd = houseCusps[(i + 1) % 12];

                    let inHouse = false;
                    if (cuspStart < cuspEnd) {
                        if (planet.abs_pos >= cuspStart && planet.abs_pos < cuspEnd) inHouse = true;
                    } else { // Wraps around 0° Aries
                        if (planet.abs_pos >= cuspStart || planet.abs_pos < cuspEnd) inHouse = true;
                    }

                    if (inHouse) {
                        overlays[planet.name] = HOUSE_NAMES[i];
                        break;
                    }
                }
            }
            return overlays;
        };
        
        // --- RELATIONAL CONTEXT STACK LOGIC ---
        function updateRelationalContext() {
            const personAData = getSubjectData('A');
            const personBData = getSubjectData('B');

            if (!personAData || !personBData) {
                relationalContextStack.classList.add('hidden');
                return;
            }

            // Show placeholder message only, no API calls
            contextReadout.innerHTML = '<li>Relationship context will be analyzed and shown here after you generate the full report.</li>';
            relationalContextStack.classList.remove('hidden');
        }


        // --- MARKDOWN FORMATTING ENGINE ---
        const formatMdNatalChart = (personData) => {
            const { details, chart: apiResponse } = personData;
            // The API response for a natal call is nested under 'data', then 'subject'
            const chart = apiResponse.data.subject;
            const aspects = apiResponse.aspects;

            const degToDMS = (deg) => `${Math.floor(deg)}°${Math.round((deg % 1) * 60).toString().padStart(2, '0')}'`;

            let report = [`# ${details.name}`];
            report.push(`> Birth Location: ${details.city}, ${details.state} *(For reference only; uses coordinates below)*`);
            report.push(`> Birth Coordinates: ${details.latitude.toFixed(4)}, ${details.longitude.toFixed(4)}`);
            report.push(`> Birth Date: ${details.date}`);
            report.push(`> Birth Time: ${details.time} (Timezone: ${details.timezone})`);

            report.push(`\n## Natal Chart – ${chart.houses_system_name}`);
            let planetTable = '| Planet | AEL | Sign | Pos | 29° |\n|---|---|---|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p) planetTable += `| ${p.name} | ${p.abs_pos.toFixed(2)}° | ${p.sign} | ${degToDMS(p.position)} | ${p.position >= 29 ? '★' : ''} |\n`;
            });
            report.push(planetTable);

            report.push(`\n## Planet House Placements`);
             let placementTable = '| Planet | House |\n|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p && p.house) placementTable += `| ${p.name} | ${p.house} |\n`;
            });
            report.push(placementTable);

            report.push(`\n## Natal Aspects`);
            const aspectList = aspects.map(a => {
                const core = a.orbit <= 3 ? ' (Core Pressure Point)' : '';
                return `- ${a.p1_name} ${SYMBOLS[a.aspect.toLowerCase()]} ${a.p2_name} (${a.orbit.toFixed(1)}°)${core}`;
            }).join('\n');
            report.push(aspectList || '- None found.');

            return report.join('\n');
        };

        const formatMdTransit = (transitData, personData, isRelocated) => {
            const chart = transitData.chart.data.subject;
            const aspects = transitData.aspects;
            const degToDMS = (deg) => `${Math.floor(deg)}°${Math.round((deg % 1) * 60).toString().padStart(2, '0')}'`;

            let report = [];
            if (isRelocated) {
                report.push(`\n### Relocation Overlay for ${transitData.date}`);
                const lat = chart.lat;
                const lon = chart.lng;
                if (typeof lat === 'number' && typeof lon === 'number') {
                    report.push(`*Houses & Angles recalculated for ${lat.toFixed(4)}, ${lon.toFixed(4)}*`);
                }
            } else {
                report.push(`\n## Transits for ${transitData.date}`);
                report.push(`*Transits calculated for birth location: ${personData.details.city}.*`);
            }
            let planetTable = '| Planet | AEL | Sign | Pos | 29° |\n|---|---|---|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p) planetTable += `| ${p.name} | ${p.abs_pos.toFixed(2)}° | ${p.sign} | ${degToDMS(p.position)} | ${p.position >= 29 ? '★' : ''} |\n`;
            });
            report.push(planetTable);

            report.push(`\n### Transit → Natal Aspects (${personData.details.name})`);
            const aspectList = aspects.map(a => {
                 const core = a.orb <= 3 ? ' (Core Pressure Point)' : '';
                return `- Transiting ${a.p1_name} ${SYMBOLS[a.aspect.toLowerCase()]} Natal ${a.p2_name} (${a.orb.toFixed(1)}°)${core}`;
            }).join('\n');
            report.push(aspectList || '- None found.');

            return report.join('\n');
        };

        const formatMdWeather = (weatherData) => {
            const chart = weatherData.chart.data.subject;
            const degToDMS = (deg) => `${Math.floor(deg)}°${Math.round((deg % 1) * 60).toString().padStart(2, '0')}'`;

            let report = [`# Local Astrological Forecast for ${weatherData.date}`];
            report.push(`> This is a standalone chart of the sky for the specified date and location. It is not a transit report and does not contain aspects to a natal chart.`);

            let planetTable = '| Planet | AEL | Sign | Pos |\n|---|---|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p) planetTable += `| ${p.name} | ${p.abs_pos.toFixed(2)}° | ${p.sign} | ${degToDMS(p.position)} |\n`;
            });
            report.push(planetTable);
            return report.join('\n\n');
        };

        const formatMdSynastry = (synData, personA, personB) => {
            const aspects = synData.aspects || [];
            // The synastry response directly contains the two subjects' data
            const chartA = synData.data.first_subject;
            const chartB = synData.data.second_subject;
            const aInB = calculateHouseOverlays(chartA, chartB);
            const bInA = calculateHouseOverlays(chartB, chartA);

            const clean = h => h.replace(/_/g, ' ');

            let report = [`## Synastry: ${personA.details.name} & ${personB.details.name}`];
            report.push('### Interplanetary Aspects');
            if (aspects.length) {
                aspects.forEach(a => {
                    const core = a.orb <= 3 ? ' (Core Pressure Point)' : '';
                    report.push(`- ${a.p1_name} ${SYMBOLS[a.aspect.toLowerCase()]} ${a.p2_name} (${a.orb.toFixed(1)}°)${core}`);
                });
            } else {
                report.push('- None found.');
            }

            report.push(`\n### ${personA.details.name}'s Planets in ${personB.details.name}'s Houses`);
            const aLines = Object.entries(aInB).map(([p, h]) => `- ${p} in ${clean(h)}`);
            report.push(aLines.join('\n') || '- None.');

            report.push(`\n### ${personB.details.name}'s Planets in ${personA.details.name}'s Houses`);
            const bLines = Object.entries(bInA).map(([p, h]) => `- ${p} in ${clean(h)}`);
            report.push(bLines.join('\n') || '- None.');

            return report.join('\n');
        };


        // --- MAIN REPORT GENERATION LOGIC (RESTRUCTURED) ---
        async function generateReport() {
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';
            outputSection.classList.add('hidden');

            try {
                const personAData = getSubjectData('A');
                if (!personAData) {
                    throw new Error("Person A's data is incomplete or invalid.");
                }
                const personBData = getSubjectData('B');
                const useSynastry = personBData && synastryToggle.checked;

                // --- Relationship Type & Intimacy Tier ---
                const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value || '';
                let intimacyTier = '';
                if (relationshipType === 'Partner') {
                    intimacyTier = document.querySelector('input[name="intimacyTier"]:checked')?.value || '';
                }

                // --- Diagnostics (from context stack, or recompute here) ---
                let diagnostics = [];
                if (useSynastry) {
                    // We'll compute these after API calls below
                }

                let markdownParts = [
                    `> ★ = Planet is within the last degree of a sign (the 29th degree).\n> **Aspect Symbols:** ☌ = Conjunction, ☍ = Opposition, □ = Square, △ = Trine, ✶ = Sextile\n> **\"Core Pressure Point\"** = aspect orb ≤ 3° (the strongest and most direct influences).`
                ];
                fullReportData = { schema: "WM-Chart-1.0" };

                // --- Relationship context for Poetic Brain ---
                fullReportData.relationship_type = relationshipType;
                fullReportData.intimacy_tier = intimacyTier;

                // --- SYNASTRY/NATAL LOGIC ---
                if (useSynastry) {
                    const payload = {
                        first_subject: personAData,
                        second_subject: personBData
                    };
                    const synastryResponse = await getChartDataFromApi(payload);
                    const natalAFromSynastry = await getChartDataFromApi({ subject: personAData });
                    const natalBFromSynastry = await getChartDataFromApi({ subject: personBData });
                    fullReportData.person_a = { details: personAData, chart: natalAFromSynastry };
                    fullReportData.person_b = { details: personBData, chart: natalBFromSynastry };
                    fullReportData.synastry = synastryResponse;

                    // --- Compute Diagnostics ---
                    diagnostics = [];
                    // 29° placement in close synastry contact
                    const synAspects = synastryResponse.aspects || [];
                    if (synAspects.some(a => a.p1_pos >= 29 || a.p2_pos >= 29)) {
                        diagnostics.push('29° placement in close synastry contact');
                    }
                    // Resonant aspect forming <1° orb (possible echo loop)
                    const tight = synAspects.filter(a => a.orb < 1.0);
                    if (tight.length > 0) {
                        diagnostics.push('Resonant aspect forming <1° orb (possible echo loop)');
                    }
                    // Overlay present in 4th/7th house sectors
                    const chartA = synastryResponse.data.first_subject;
                    const chartB = synastryResponse.data.second_subject;
                    const overlaysAinB = calculateHouseOverlays(chartA, chartB);
                    const overlaysBinA = calculateHouseOverlays(chartB, chartA);
                    const pressureHouses = ['Fourth_House', 'Seventh_House'];
                    if (Object.values(overlaysAinB).some(h => pressureHouses.includes(h)) || Object.values(overlaysBinA).some(h => pressureHouses.includes(h))) {
                        diagnostics.push('Overlay present in 4th/7th house sectors');
                    }
                    fullReportData.diagnostics = diagnostics;

                    // --- Markdown: Relational Context & Diagnostics ---
                    markdownParts.unshift(
                        '## Relational Context',
                        `- Relationship Type: ${relationshipType || 'N/A'}` + (intimacyTier ? `\n- Intimacy Tier: ${intimacyTier}` : ''),
                        '## Initial Geometry Diagnostics',
                        diagnostics.length ? diagnostics.map(f => `- ⚠️ ${f}`).join('\n') : '- None.'
                    );

                    markdownParts.push(formatMdNatalChart(fullReportData.person_a));
                    markdownParts.push(formatMdNatalChart(fullReportData.person_b));
                    markdownParts.push(formatMdSynastry(synastryResponse, fullReportData.person_a, fullReportData.person_b));
                } else {
                    // --- NATAL-ONLY REPORT ---
                    const apiResponseA = await getChartDataFromApi({ subject: personAData });
                    fullReportData.person_a = { details: personAData, chart: apiResponseA };
                    markdownParts.unshift(
                        '## Relational Context',
                        `- Relationship Type: ${relationshipType || 'N/A'}` + (intimacyTier ? `\n- Intimacy Tier: ${intimacyTier}` : '')
                    );
                    markdownParts.push(formatMdNatalChart(fullReportData.person_a));
                    if (personBData) {
                        const apiResponseB = await getChartDataFromApi({ subject: personBData });
                        fullReportData.person_b = { details: personBData, chart: apiResponseB };
                        markdownParts.push(formatMdNatalChart(fullReportData.person_b));
                    }
                }

                // --- TRANSIT CALCULATIONS (COMMON LOGIC) ---
                let startStr = startDateInput.value;
                 if (!startStr) {
                    const today = new Date();
                    startStr = `${String(today.getMonth() + 1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}-${today.getFullYear()}`;
                }

                const [sm, sd, sy] = startStr.split('-').map(Number);
                const start = new Date(Date.UTC(sy, sm - 1, sd));
                let end = start;
                if (endDateInput.value) {
                    const [em, ed, ey] = endDateInput.value.split('-').map(Number);
                    end = new Date(Date.UTC(ey, em - 1, ed));
                }

                fullReportData.transits = [];
                const relocationChecked = relocationToggle.checked;
                let relocationCoords = getRelocationLatLonOrNull();
                if (relocationChecked && !relocationCoords) throw new Error("Relocation coordinates are invalid.");

                for (let d = new Date(start); d <= end; d.setUTCDate(d.getUTCDate() + 1)) {
                     const ds = (d.getUTCMonth()+1).toString().padStart(2,'0') + '-' +
                                 d.getUTCDate().toString().padStart(2,'0') + '-' +
                                 d.getUTCFullYear();

                    // Person A Transits
                    const transitSubjectA = { ...personAData, year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(), name: `Transit ${ds}` };
                    const transitApiResponseA = await getChartDataFromApi({ subject: transitSubjectA });
                    const chartA = fullReportData.person_a.chart.data.subject;
                    const entryA = { person: 'a', date: ds, chart: transitApiResponseA, aspects: calculateAspects(transitApiResponseA.data.subject, chartA), location_type: 'birth' };
                    fullReportData.transits.push(entryA);
                    markdownParts.push(formatMdTransit(entryA, fullReportData.person_a, false));

                    // Relocation for A
                    if (relocationChecked && relocationCoords) {
                         const relocationSubjectA = { ...transitSubjectA, latitude: relocationCoords.latitude, longitude: relocationCoords.longitude, city: 'Relocated', nation: '' };
                         const relocationApiResponseA = await getChartDataFromApi({ subject: relocationSubjectA });
                         const entryRelocA = { person: 'a', date: ds, chart: relocationApiResponseA, aspects: calculateAspects(relocationApiResponseA.data.subject, chartA), location_type: 'relocated' };
                         fullReportData.transits.push(entryRelocA);
                         markdownParts.push(formatMdTransit(entryRelocA, fullReportData.person_a, true));
                    }

                    // Person B Transits (if they exist)
                    if (fullReportData.person_b) {
                        const transitSubjectB = { ...personBData, year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(), name: `Transit ${ds}` };
                        const transitApiResponseB = await getChartDataFromApi({ subject: transitSubjectB });
                        const chartB = fullReportData.person_b.chart.data.subject;
                        const entryB = { person: 'b', date: ds, chart: transitApiResponseB, aspects: calculateAspects(transitApiResponseB.data.subject, chartB), location_type: 'birth' };
                        fullReportData.transits.push(entryB);
                        markdownParts.push(formatMdTransit(entryB, fullReportData.person_b, false));

                         // Relocation for B
                        if (relocationChecked && relocationCoords) {
                             const relocationSubjectB = { ...transitSubjectB, latitude: relocationCoords.latitude, longitude: relocationCoords.longitude, city: 'Relocated', nation: '' };
                             const relocationApiResponseB = await getChartDataFromApi({ subject: relocationSubjectB });
                             const entryRelocB = { person: 'b', date: ds, chart: relocationApiResponseB, aspects: calculateAspects(relocationApiResponseB.data.subject, chartB), location_type: 'relocated' };
                             fullReportData.transits.push(entryRelocB);
                             markdownParts.push(formatMdTransit(entryRelocB, fullReportData.person_b, true));
                        }
                    }
                }

                markdownReport = markdownParts.join('\n\n');
                reportTitle.textContent = "Generated Report";
                reportOutput.textContent = markdownReport;
                outputSection.classList.remove('hidden');

            } catch (error) {
                showMessage(error.message, 'error');
                console.error(error);
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Full Report';
            }
        }

        async function generateWeatherReport() {
            getWeatherBtn.disabled = true;
            getWeatherBtn.textContent = 'Fetching...';
            outputSection.classList.add('hidden');

            try {
                const lat = parseFloat(document.getElementById('weatherLat').value);
                const lon = parseFloat(document.getElementById('weatherLon').value);
                if (isNaN(lat) || isNaN(lon)) throw new Error("Latitude and Longitude are required for the forecast.");

                let startStr = weatherStartDateInput.value;
                if (!startStr) {
                    const today = new Date();
                    startStr = `${String(today.getMonth() + 1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}-${today.getFullYear()}`;
                }

                const [sm, sd, sy] = startStr.split('-').map(Number);
                const start = new Date(Date.UTC(sy, sm - 1, sd));
                let end = start;
                if (weatherEndDateInput.value) {
                    const [em, ed, ey] = weatherEndDateInput.value.split('-').map(Number);
                    end = new Date(Date.UTC(ey, em - 1, ed));
                }

                let markdownParts = [];
                fullReportData = { schema: "WM-Forecast-1.0", forecasts: [] };

                for (let d = new Date(start); d <= end; d.setUTCDate(d.getUTCDate() + 1)) {
                    const ds = (d.getUTCMonth()+1).toString().padStart(2,'0') + '-' +
                                 d.getUTCDate().toString().padStart(2,'0') + '-' +
                                 d.getUTCFullYear();

                    const weatherSubject = {
                        year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(),
                        hour: 12, minute: 0,
                        city: "Local Forecast",
                        name: `Forecast for ${ds}`,
                        latitude: lat, longitude: lon,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                        zodiac_type: 'Tropic'
                    };

                    const apiResponse = await getChartDataFromApi({ subject: weatherSubject });
                    const weatherEntry = { date: ds, chart: apiResponse };
                    fullReportData.forecasts.push(weatherEntry);
                    markdownParts.push(formatMdWeather(weatherEntry));
                }

                markdownReport = markdownParts.join('\n\n');
                reportTitle.textContent = `Local Astrological Forecast`;
                reportOutput.textContent = markdownReport;
                outputSection.classList.remove('hidden');

            } catch(error) {
                showMessage(error.message, 'error');
                console.error(error);
            } finally {
                getWeatherBtn.disabled = false;
                getWeatherBtn.textContent = 'Get Forecast';
            }
        }

        // --- EVENT LISTENERS ---
        generateBtn.addEventListener('click', generateReport);
        getWeatherBtn.addEventListener('click', generateWeatherReport);

        copyBtn.addEventListener('click', () => {
            const textarea = document.createElement('textarea');
            textarea.value = markdownReport;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('Copied to clipboard!', 'success');
                } else {
                    showMessage('Failed to copy.', 'error');
                }
            } catch (err) {
                showMessage('Failed to copy.', 'error');
                console.error('Clipboard copy failed:', err);
            }
            document.body.removeChild(textarea);
        });

        const downloadFile = (filename, content, contentType) => {
            const element = document.createElement('a');
            const blob = new Blob([content], { type: contentType });
            element.href = URL.createObjectURL(blob);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
            URL.revokeObjectURL(element.href);
        };

        const generateFilename = (extension) => {
            const nameA = document.getElementById('nameA').value.replace(/\s+/g, '_') || 'PersonA';
            const nameB = document.getElementById('nameB').value.replace(/\s+/g, '_');
            const finalName = nameB ? `${nameA}_and_${nameB}` : nameA;
            
            const startDateStr = startDateInput.value;
            const endDateStr = endDateInput.value;
            let datePart = `_on_${new Date().toISOString().split('T')[0]}`;

            if (startDateStr) {
                const reformatDate = (dateStr) => {
                    if (!/^\d{2}-\d{2}-\d{4}$/.test(dateStr)) return new Date().toISOString().split('T')[0];
                    const [m, d, y] = dateStr.split('-');
                    return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                }
                const formattedStart = reformatDate(startDateStr);
                if (endDateStr && endDateStr !== startDateStr) {
                    const formattedEnd = reformatDate(endDateStr);
                    datePart = `_from_${formattedStart}_to_${formattedEnd}`;
                } else {
                    datePart = `_on_${formattedStart}`;
                }
            }
            return `report_${finalName}${datePart}.${extension}`;
        };

        saveJsonBtn.addEventListener('click', () => {
            const filename = generateFilename('json');
            downloadFile(filename, JSON.stringify(fullReportData, null, 2), 'application/json');
        });

        saveMdBtn.addEventListener('click', () => {
            const filename = generateFilename('md');
            downloadFile(filename, markdownReport, 'text/markdown');
        });

        relocationToggle.addEventListener('change', () => {
            relocationFields.style.display = relocationToggle.checked ? 'block' : 'none';
        });

        relocationCoordsInput.addEventListener('input', () => {
            if (relocationToggle.checked) {
                getRelocationLatLonOrNull();
            }
        });

        function getRelocationLatLonOrNull() {
            if (!relocationToggle.checked) return null;
            try {
                const coords = parseCombinedCoords(relocationCoordsInput.value);
                relocationError.classList.add('hidden');
                return coords;
            } catch (e) {
                relocationError.textContent = e.message;
                relocationError.classList.remove('hidden');
                return null;
            }
        }
        
        // --- Trigger for the Relational Context Stack ---
        function triggerContextCheck() {
            clearTimeout(contextCheckTimeout);
            contextCheckTimeout = setTimeout(updateRelationalContext, 1000); // Debounce to avoid rapid firing
        }
        
        document.querySelectorAll('.person-b-field').forEach(field => {
            field.addEventListener('input', triggerContextCheck);
            field.addEventListener('change', triggerContextCheck); // For select dropdown
        });

        // Relationship type conditional intimacy tier logic
        const relationshipTypeRadios = document.querySelectorAll('input[name="relationshipType"]');
        const intimacyTierDropdown = document.getElementById('intimacy-tier-dropdown');
        relationshipTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.value === 'Partner') {
                    intimacyTierDropdown.classList.remove('hidden');
                } else {
                    intimacyTierDropdown.classList.add('hidden');
                    // Optionally clear selection
                    document.querySelectorAll('input[name="intimacyTier"]').forEach(tier => tier.checked = false);
                }
            });
        });

        // --- For Poetic Brain Export Button ---
const poeticBrainBtn = document.createElement('button');
poeticBrainBtn.id = 'poetic-brain-btn';
poeticBrainBtn.textContent = 'Export for Poetic Brain';
poeticBrainBtn.className = 'bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors ml-2';
document.querySelector('#output-section .flex').appendChild(poeticBrainBtn);
poeticBrainBtn.addEventListener('click', () => {
    // Minimal export: relationship_type, intimacy_tier, diagnostics
    const minimal = {
        relationship_type: fullReportData.relationship_type || '',
        intimacy_tier: fullReportData.intimacy_tier || '',
        diagnostics: fullReportData.diagnostics || []
    };
    const filename = 'poetic_brain_context.json';
    const element = document.createElement('a');
    const blob = new Blob([JSON.stringify(minimal, null, 2)], { type: 'application/json' });
    element.href = URL.createObjectURL(blob);
    element.download = filename;
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    URL.revokeObjectURL(element.href);
});

// --- Math Brain Modal Logic ---
        const mathBrainBtn = document.getElementById('math-brain-info-btn');
        const mathBrainModal = document.getElementById('math-brain-modal');
        const closeMathBrainModal = document.getElementById('close-math-brain-modal');
        const closeMathBrainModalBottom = document.getElementById('close-math-brain-modal-bottom');
        
        function openMathBrainModal() {
          mathBrainModal.classList.remove('hidden');
        }
        function closeMathBrainModalFn() {
          mathBrainModal.classList.add('hidden');
        }
        mathBrainBtn.addEventListener('click', openMathBrainModal);
        closeMathBrainModal.addEventListener('click', closeMathBrainModalFn);
        closeMathBrainModalBottom.addEventListener('click', closeMathBrainModalFn);
        // Optional: close modal on Escape key
        document.addEventListener('keydown', (e) => {
          if (!mathBrainModal.classList.contains('hidden') && e.key === 'Escape') closeMathBrainModalFn();
        });
        
        // Close modal on outside click
        window.addEventListener('click', (e) => {
            if (mathBrainModal.classList.contains('hidden') === false && !mathBrainModal.contains(e.target) && !mathBrainBtn.contains(e.target)) {
                closeMathBrainModalFn();
            }
        });
    </script>
</body>
</html>
        // --- AstroSeek Clipboard Paste for Person B ---
        const pasteAstroBtn = document.getElementById('pasteAstroB');
        pasteAstroBtn.addEventListener('click', async () => {
          try {
            const text = await navigator.clipboard.readText();
            const lines = text.split('\n').map(l => l.trim()).filter(Boolean);

            // Name
            document.getElementById('nameB').value = lines[0] || '';

            // Local Date & Time with timezone
            const dobLine = lines.find(l => l.startsWith('Date of Birth'));
            if (dobLine) {
              const match = dobLine.match(/:\s*(\d{1,2}) (\w+) (\d{4})\s*-\s*(\d{2}:\d{2}).*?\((\w+)\)/);
              if (match) {
                const [ , day, monthName, year, time, tzAbbrev ] = match;
                const monthMap = { January:1, February:2, March:3, April:4, May:5, June:6, July:7, August:8, September:9, October:10, November:11, December:12 };
                const mm = String(monthMap[monthName] || 1).padStart(2, '0');
                const dd = day.padStart(2, '0');
                document.getElementById('dateB').value = `${mm}-${dd}-${year}`;
                document.getElementById('timeB').value = time;
                // Map common abbreviations to TZ select values
                const tzMap = { EST: 'America/New_York', CST: 'America/Chicago', MST: 'America/Denver', PST: 'America/Los_Angeles' };
                document.getElementById('offsetB').value = tzMap[tzAbbrev] || 'America/New_York';
              }
            }

            // Coordinates
            const coordLine = lines.find(l => l.startsWith('Latitude, Longitude'));
            if (coordLine) {
              document.getElementById('astroB').value = coordLine.split(':')[1].trim();
            }

            // City
            const cityLine = lines.find(l => l.startsWith('City:'));
            if (cityLine) {
              document.getElementById('cityB').value = cityLine.split(':')[1].trim();
            }

            // Country and State
            const countryLine = lines.find(l => l.startsWith('Country:'));
            if (countryLine) {
              const parts = countryLine.split(':')[1].split(',');
              document.getElementById('nationB').value = parts[0].trim();
              if (parts[1]) {
                document.getElementById('stateB').value = parts[1].trim();
              }
            }

            showMessage('AstroSeek data pasted successfully.', 'success');
            // Trigger context update
            triggerContextCheck();
          } catch (err) {
            showMessage('Failed to read clipboard: ' + err.message, 'error');
          }
        });
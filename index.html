    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Woven Map Math Brain - Pure Astrological Geometry</title>
        <link href="dist/output.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <style>
            body { font-family: 'Inter', sans-serif; }
            ::-webkit-scrollbar { width: 8px; }
            ::-webkit-scrollbar-track { background: #1a202c; }
            ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
            ::-webkit-scrollbar-thumb:hover { background: #718096; }
            .animate-fade-in-out { animation: fadeInOut 8s ease-in-out forwards; }
            @keyframes fadeInOut { 0%, 100% { opacity: 0; transform: translateY(-20px); } 10%, 90% { opacity: 1; transform: translateY(0); } }
            .bg-gray-750 { background-color: #334155; }
        </style>
    </head>
<body class="bg-gray-900 text-gray-200">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Woven Map Math Brain</h1>
            <p class="text-gray-400 mt-2 flex items-center justify-center gap-2">Pure Astrological Geometry Computation
                <button id="math-brain-info-btn" class="ml-2 text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                    What is Math Brain? (Glossary)
                </button>
            </p>
        </header>

        <!-- Glossary Modal -->
        <div id="math-brain-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 hidden">
          <div class="bg-gray-900 rounded-lg shadow-xl max-w-lg w-full p-6 relative border border-teal-500">
            <button id="close-math-brain-modal" class="absolute top-2 right-2 text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            <h2 class="text-xl font-bold text-teal-300 mb-2">Math Brain & Poetic Brain: The Woven Map Framework</h2>
            <p class="text-sm text-gray-200 mb-3">
              <b>Math Brain</b>: computes planetary positions, aspects, house placements. Outputs geometry, no meaning.<br>
              <b>Poetic Brain</b>: translates geometry into felt/narrative language. Diagnostic, not predictive.<br>
              <b>TL;DR</b>: Math Brain finds the coordinates. Poetic Brain speaks the language you can feel.
            </p>
            <h3 class="text-teal-200 font-semibold mt-4 mb-1">Glossary</h3>
            <ul class="text-xs text-gray-300 space-y-1 max-h-48 overflow-y-auto pr-2">
              <li><b>FIELD → MAP → VOICE</b>: FIELD = energetic climate, MAP = geometry, VOICE = felt reflection.</li>
              <li><b>Recognition-First Principle</b>: Choose diagnostic mode based on real question, not technical curiosity.</li>
              <li><b>Context Modes</b>: Natal (single person), Synastry (interaction), Transit (current pressure), Composite (relationship entity).</li>
              <li><b>Ping</b>: Recognized resonance between chart and experience.</li>
              <li><b>SST</b>: Falsifiability filter. WB = Within Boundary, ABE = At Boundary Edge, OSR = Outside Symbolic Range.</li>
              <li><b>Echo Loop</b>: Dyadic cycle under 1° orb.</li>
              <li><b>REF</b>: Relational Echo Field, macro-pattern resonance between two charts.</li>
              <li><b>Intimacy Tier</b>: P1 = Platonic, P2 = FWB, P3 = Romantic.</li>
              <li><b>Clear Mirror</b>: Testable, non-mystical phrasing.</li>
              <li><b>29° Crisis Node</b>: Planet at 29°, volatility.</li>
              <li><b>Symbolic Weather Overlay</b>: Current transits as energetic "weather".</li>
              <li><b>Paradox Line</b>: Internal contradiction.</li>
            </ul>
            <div class="mt-4 text-right">
              <button id="close-math-brain-modal-bottom" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-1 px-4 rounded">Close</button>
            </div>
          </div>
        </div>

        <main>
            <!-- Person A & B Cards -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div id="personA-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Person A / Natal Chart</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameA" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="DH Cross">
                            <input type="text" id="birth_cityA" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="Bryn Mawr">
                            <input type="text" id="birth_stateA" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="PA">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="date" id="birth_dateA" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="1973-07-24">
                            <input type="text" id="birth_timeA" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="14:30">
                            <select id="offsetA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Chicago">Central (Chicago)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska</option>
                                <option value="Pacific/Honolulu">Hawaii</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="birth_countryA" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="US">
                            <select id="zodiacA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div>
                            <label for="astroA" class="block mb-1 text-sm font-medium text-gray-300">Birth Coordinates</label>
                            <input type="text" id="astroA" placeholder="e.g., 40°1'N, 75°18'W or 40.01, -75.31" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="40°1'N, 75°18'W">
                        </div>
                    </div>
                </div>
                <div id="personB-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Person B (Optional)</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameB" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <input type="text" id="birth_cityB" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <input type="text" id="birth_stateB" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="date" id="birth_dateB" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <input type="text" id="birth_timeB" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <select id="offsetB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Chicago">Central (Chicago)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska</option>
                                <option value="Pacific/Honolulu">Hawaii</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="birth_countryB" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <select id="zodiacB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div>
                           <label for="astroB" class="block mb-1 text-sm font-medium text-gray-300">Birth Coordinates</label>
                           <input type="text" id="astroB" placeholder="e.g., 30.16, -85.66" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                        </div>
                        <button id="pasteAstroB" class="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded text-sm">
                          Paste AstroSeek Data
                        </button>
                    </div>
                </div>
            </div>

            <!-- Context Mode Section -->
            <div id="context-mode-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-semibold text-white">Context Mode</h2>
                    <button id="toggle-mode-help" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 What does each mode do?
                    </button>
                </div>
                
                <!-- Symbolic Purpose Guide (initially hidden) -->
                <div id="mode-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Mode Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Natal+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current planetary pressure on individual chart. <em>"How is today pressing on me?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: If a date range is added, the system checks for all periods of exact or near-exact pressure between those dates—not just today.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Comp+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current pressure on the shared field. <em>"How is today pressing on our connection?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: Adding a date range means the system maps every significant pressure on the connection during that window. Results are limited to that span.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Syn+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current pressure on relational dynamics. <em>"How is today pressing on our interaction?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: With a date range, the system searches for all windows where relational tension or harmony becomes active during the specified time frame.</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity. 
                            Each mode serves a specific diagnostic purpose within the FIELD → MAP → VOICE framework.
                        </p>
                        <p class="text-xs text-gray-400 mt-2">
                            <strong class="text-teal-300">Date Range Effect:</strong> Adding a date range turns a "today" reading into a scan for all matching patterns over that period, revealing pressure windows and thresholds—not just a snapshot.
                        </p>
                    </div>
                </div>
                
                <div id="context-toggle" class="flex items-center mb-4">
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_transits" class="mr-2" checked>
                        <span class="text-gray-300">Natal Chart + Transits</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="composite_transits" class="mr-2">
                        <span class="text-gray-300">Composite + Transits</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="contextMode" value="synastry_transits" class="mr-2">
                        <span class="text-gray-300">Synastry + Transits</span>
                    </label>
                </div>
                
                <!-- Relocation Overlay Section -->
                <div id="relocation-section" class="mt-6 border-t border-gray-700 pt-4">
                    <div class="flex items-center mb-4">
                        <input type="checkbox" id="relocationToggle" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                        <label for="relocationToggle" class="text-gray-300 font-medium">
                            Enable Relocation Overlay
                            <span class="text-xs text-gray-500 block">Relocation affects house angles and overlay geometry. Available in all modes.</span>
                        </label>
                    </div>
                    
                    <!-- Relocation Fields (initially hidden) -->
                    <div id="relocationFields" class="hidden space-y-4 bg-gray-750 p-4 rounded-lg border border-gray-600">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label for="relocationCity" class="block mb-1 text-sm font-medium text-gray-300">Relocation City</label>
                                <input type="text" id="relocationCity" placeholder="e.g., Panama City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="Panama City">
                            </div>
                            <div>
                                <label for="relocationState" class="block mb-1 text-sm font-medium text-gray-300">State/Province</label>
                                <input type="text" id="relocationState" placeholder="e.g., FL" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="FL">
                            </div>
                        </div>
                        
                        <div>
                            <label for="relocationCoords" class="block mb-1 text-sm font-medium text-gray-300">
                                Relocation Coordinates
                                <span class="text-xs text-gray-500">(Required for overlay calculations)</span>
                            </label>
                            <input type="text" id="relocationCoords" placeholder="e.g., 30°10'N, 85°40'W or 34.0522, -118.2437" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="30°10'N, 85°40'W">
                            <div class="mt-1 text-xs text-gray-500">
                                Format: latitude, longitude (decimal degrees)
                                <br>Examples: "40.7128, -74.0060" (NYC) or "34.0522, -118.2437" (LA)
                            </div>
                            
                            <!-- Validation Error for Relocation Coords -->
                            <div id="relocationCoordsError" class="hidden mt-1 text-xs text-red-400">
                                Please enter valid coordinates in format: latitude, longitude
                            </div>
                        </div>
                        
                        <div class="bg-gray-800 p-3 rounded border border-gray-600">
                            <h4 class="text-sm font-medium text-teal-300 mb-2">How Relocation Overlay Works:</h4>
                            <ul class="text-xs text-gray-400 space-y-1">
                                <li>• Birth chart remains at original location</li>
                                <li>• Transits/progressions calculated for new location</li>
                                <li>• Shows how planetary energy shifts in different places</li>
                                <li>• Useful for travel, relocation, or understanding location-based influences</li>
                            </ul>
                        </div>
                        
                        <!-- Person B Relocation Option (only visible when Person B is present) -->
                        <div id="relocationPersonBOption" class="hidden">
                            <div class="flex items-center p-3 bg-gray-800 rounded border border-gray-600">
                                <input type="checkbox" id="excludePersonBFromRelocation" class="mr-3 h-4 w-4 text-orange-600 focus:ring-orange-500 border-gray-600 rounded bg-gray-700">
                                <label for="excludePersonBFromRelocation" class="text-gray-300 font-medium">
                                    Exclude Person B from relocation
                                    <span class="text-xs text-gray-500 block">By default, both people are relocated together. Check this to only relocate Person A.</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Transit Date Range Fields (always visible - all modes include transits) -->
                <div id="transit-date-range-fields" class="mb-6">
                  <div class="flex justify-between items-center mb-2">
                    <label for="transitStartDate" class="block text-gray-300 font-medium">Transit Start Date (YYYY-MM-DD):</label>
                    <button id="prefillToday" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                        📅 Use Today for Quick Check
                    </button>
                  </div>
                  <input type="date" id="transitStartDate" name="transitStartDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 mb-2" required>
                  <label for="transitEndDate" class="block text-gray-300 font-medium mb-1">Transit End Date (YYYY-MM-DD):</label>
                  <input type="date" id="transitEndDate" name="transitEndDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 mb-2" required>
                  <div class="flex justify-between items-center mb-1">
                    <label for="transitStep" class="block text-gray-300 font-medium">Step Size:</label>
                    <button id="stepSizeHelp" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                        ❓ What does this do?
                    </button>
                  </div>
                  <select id="transitStep" name="transitStep" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                    <option value="1d">Daily (1 day intervals)</option>
                    <option value="7d">Weekly (7 day intervals)</option>
                    <option value="1m">Monthly (1 month intervals)</option>
                  </select>
                  <!-- Step Size Help Panel (initially hidden) -->
                  <div id="stepSizeHelpPanel" class="hidden mt-2 p-3 bg-gray-750 rounded-lg border border-teal-600 text-sm">
                    <h4 class="text-teal-300 font-semibold mb-2">📊 Step Size Explained</h4>
                    <p class="text-gray-200 mb-2">Step size controls how frequently transit calculations are performed within your date range:</p>
                    <ul class="text-gray-300 space-y-1 ml-4">
                      <li><b>Daily</b>: Calculate transits for every single day (most detailed, slower for long ranges)</li>
                      <li><b>Weekly</b>: Calculate transits every 7 days (good balance for monthly+ ranges)</li>
                      <li><b>Monthly</b>: Calculate transits once per month (fastest, good for yearly overviews)</li>
                    </ul>
                    <p class="text-yellow-200 mt-2 text-xs"><b>Tip</b>: For quick current checks, use "Daily" with today's date. For longer ranges (months/years), "Weekly" or "Monthly" will be faster.</p>
                  </div>
                </div>
                
                <!-- Additional Context Options -->
                <div id="context-options" class="space-y-4">
                    <div class="bg-yellow-900 border border-yellow-700 text-yellow-100 px-4 py-3 rounded mb-4">
                        <div class="flex">
                            <div class="flex-shrink-0">
                                <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="ml-3">
                                <h3 class="text-sm font-medium">Math Brain Protocol Active</h3>
                                <div class="mt-2 text-sm">
                                    This interface computes pure astrological geometry only. Focus area and report style preferences have been moved to the VOICE layer for proper FIELD → MAP → VOICE separation.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Relational Context Section (only if Person B is present) -->
            <div id="relational-context-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500 hidden">
                <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Relational Context Query Stack</h2>
                <p class="text-gray-400 text-sm mb-4">Based on initial geometry, the Math Brain has detected the following potential dynamics:</p>
                <ul id="context-readout" class="list-disc list-inside space-y-2 mb-4 text-gray-300"></ul>
                <div id="relationship-type-query">
                    <p class="text-lg font-medium text-white mb-2">How would you categorize this connection?</p>
                    <div class="flex flex-col space-y-2">
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="partner" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Partner (romantic/undefined-intimate)</span></label>
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="friend" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Friend or colleague</span></label>
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="family" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Family</span></label>
                    </div>
                    <div class="mt-3 pt-2 border-t border-gray-600">
                        <label class="flex items-center">
                            <input type="checkbox" id="exRelationship" class="form-checkbox h-4 w-4 text-red-400">
                            <span class="ml-2 text-gray-300">Ex (no longer active relationship)</span>
                        </label>
                    </div>
                    <div id="intimacy-tier-dropdown" class="mt-4 hidden">
                        <p class="text-md font-medium text-white mb-2">What best describes the intimacy tier of this connection?</p>
                        <div class="flex flex-col space-y-2">
                            <label class="flex items-center"><input type="radio" name="intimacyTier" value="P1" class="form-radio h-4 w-4 text-pink-400"><span class="ml-2 text-gray-300">P1 – Platonic partners</span></label>
                            <label class="flex items-center"><input type="radio" name="intimacyTier" value="P2" class="form-radio h-4 w-4 text-pink-400"><span class="ml-2 text-gray-300">P2 – Friends with benefits</span></label>
                            <label class="flex items-center"><input type="radio" name="intimacyTier" value="P3" class="form-radio h-4 w-4 text-pink-400"><span class="ml-2 text-gray-300">P3 – Romantic partners</span></label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Generate Button -->
            <div class="text-center mb-8">
                <button id="generateReport" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    Compute Astrological Geometry
                </button>
            </div>

            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center mb-8">
                <div class="inline-flex items-center px-4 py-2 font-semibold leading-6 text-sm shadow rounded-md text-white bg-teal-600 transition ease-in-out duration-150">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Computing Astrological Geometry...
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorDisplay" class="hidden bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-8">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium">Error computing geometry</h3>
                        <div id="errorMessage" class="mt-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Report Output -->
            <div id="reportOutput" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-white">Pure Astrological Geometry</h2>
                    <div class="flex gap-2">
                        <button id="downloadMarkdown" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded text-sm">
                            📄 Download MD
                        </button>
                        <button id="copyReport" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded text-sm">
                            Copy Data
                        </button>
                    </div>
                </div>
                                <!-- Simple Mode: Hook / Aspect Filter Controls intentionally hidden (retained for future advanced mode) -->
                                <div id="hookFilters" class="hidden"></div>
                <div id="reportContent" class="text-gray-200 whitespace-pre-wrap font-mono text-sm bg-gray-900 p-4 rounded border border-gray-700 overflow-auto max-h-96">
                </div>
            </div>
        </main>

        <footer class="text-center text-gray-500 text-sm mt-12">
            <p>&copy; 2024 Woven Map Report Generator. Math Brain + Poetic Brain Framework.</p>
        </footer>
    </div>

    <script src="config.js"></script>
    <script>
// --- Global row counter for report summary ---
let totalRowCount = 0;
// UI Filter State (persist across renders)
// Simple Mode defaults (no user toggles rendered)
window.WOVEN_UI_FILTERS = { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };

// Universal context reference for browser/server compatibility
const WOVEN_GLOBAL = (typeof globalThis !== 'undefined') ? globalThis : (typeof window !== 'undefined' ? window : {});

// --- Helper for lean/legacy aspect/transit row keys ---
function rowNamesAndOrb(r) {
    const transit = r.transit_body ?? r.p1_name ?? r.planet_a ?? '—';
    const natal   = r.natal_target ?? r.p2_name ?? r.planet_b ?? '—';
    const aspect  = r.aspect ?? r.aspect_name ?? r.name ?? '—';
    let orb = r.orb;
    if (!Number.isFinite(orb)) orb = Number(r.orbit);
    if (!Number.isFinite(orb)) orb = null;
    return { transit, natal, aspect, orb };
}
// --- Dual-read helpers for natal/synastry aspects ---
function nameA(r){ return r.p1_name ?? (legacyTouch('natal/synastry:p1_name'), r.planet_a) ?? r.transit_body ?? '—'; }
function nameB(r){ return r.p2_name ?? (legacyTouch('natal/synastry:p2_name'), r.planet_b) ?? r.natal_target ?? '—'; }
function aspectA(r){ return r.aspect ?? (legacyTouch('natal/synastry:aspect_name'), r.aspect_name) ?? '—'; }
function orbA(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('natal/synastry:orbit/diff'), (r.orbit ?? r.diff)); }

function formatAspectRow(r){
    const A = nameA(r), B = nameB(r), asp = aspectA(r);
    const o = orbA(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// --- Global legacy usage telemetry ---
window.WM_LEGACY_HITS = 0;
function legacyTouch(tag){ 
    window.WM_LEGACY_HITS++; 
    console.warn(`[LEGACY] used: ${tag}`); 
}

function nameT(r){ return r.transit_body ?? (legacyTouch('p1_name'), r.p1_name); }
function nameN(r){ return r.natal_target ?? (legacyTouch('p2_name'), r.p2_name); }
function aspectT(r){ return r.aspect ?? (legacyTouch('aspect_name'), r.aspect_name); }
function orbT(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('orbit/diff'), (r.orbit ?? r.diff)); }

function formatTransitRow(r){
    const A = nameT(r), B = nameN(r), asp = aspectT(r);
    const o = orbT(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// ---- aspect math (for fallback orb) ----
const ASPECTS = { conjunction:0, sextile:60, square:90, trine:120, opposition:180,
    quincunx:150, quintile:72, biquintile:144, 'semi-square':45, semisquare:45, sesquiquadrate:135 };
function degNorm(d){ let x=d%360; return x<0?x+360:x; }
function sep(a,b){ const d=Math.abs(degNorm(a)-degNorm(b)); return d>180?360-d:d; }
function computeOrbFromLongitudes(lon1, lon2, aspectName){
    if(!Number.isFinite(lon1) || !Number.isFinite(lon2)) return null;
    const exact = ASPECTS[(aspectName||'').toLowerCase()];
    if(!Number.isFinite(exact)) return null;
    return Math.abs(sep(lon1, lon2) - exact);
}
function bandOrb(orb){ if(!Number.isFinite(orb)) return 'wide';
    if(orb<=1) return 'tight'; if(orb<=3) return 'close'; if(orb<=6) return 'medium'; return 'wide';
}
function valenceHint(aspect){
    const a=(aspect||'').toLowerCase();
    if(['square','opposition','sesquiquadrate','semisquare','semi-square','quincunx'].includes(a)) return 'hot';
    if(['trine','sextile','quintile','biquintile'].includes(a)) return 'cool';
    return 'neutral_to_hot';
}

// ---- normalizers that accept any shape ----
function normalizeTransitRow(row){
    if (row && row.transit_body && row.natal_target) {
        const aspect = row.aspect || row.aspect_name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.transit_lon, row.natal_lon, aspect);
        return {
            transit_body: row.transit_body,
            natal_target: row.natal_target,
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.transit_lon ?? null,
            natal_lon: row.natal_lon ?? null,
            transit_house: row.transit_house ?? null,
            natal_house: row.natal_house ?? null,
            transit_is_retrograde: !!row.transit_is_retrograde,
            natal_is_retrograde: !!row.natal_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.planet_a || row.planet_b)) {
        const aspect = row.aspect_name || row.aspect || row.type || '';
        let orb = Number.isFinite(row.orbit) ? row.orbit
                        : Number.isFinite(row.orb) ? row.orb
                        : computeOrbFromLongitudes(row.abs_pos_a, row.abs_pos_b, aspect);
        return {
            transit_body: row.planet_a || '—',
            natal_target: row.planet_b || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.abs_pos_a ?? null,
            natal_lon: row.abs_pos_b ?? null,
            transit_house: row.p1_house ?? row.house1 ?? null,
            natal_house: row.p2_house ?? row.house2 ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.p1_name || row.p2_name)) {
        const aspect = row.aspect || row.name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.p1_abs_pos, row.p2_abs_pos, aspect);
        return {
            transit_body: row.p1_name || '—',
            natal_target: row.p2_name || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.p1_abs_pos ?? null,
            natal_lon: row.p2_abs_pos ?? null,
            transit_house: row.p1_house ?? null,
            natal_house: row.p2_house ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    return null;
}
function normalizeTransitBlock(block){
    if (Array.isArray(block)) {
        return block.map(normalizeTransitRow).filter(Boolean);
    }
    if (block && block.chart && Array.isArray(block.chart.aspects)) {
        return block.chart.aspects.map(normalizeTransitRow).filter(Boolean);
    }
    return [];
}
function renderTransitDay(dateStr, items){
    const rows = normalizeTransitBlock(items);
    if (!Array.isArray(rows) || rows.length === 0) return `<h4>${dateStr}</h4><p><em>No computed aspects.</em></p>`;
    const lines = rows.map(r => {
        const orbTxt = (r && typeof r.orb === 'number' && Number.isFinite(r.orb)) ? `${r.orb.toFixed(2)}°` : '—';
        return `• <strong>${r.transit_body}</strong> ${r.aspect} <strong>${r.natal_target}</strong> (${orbTxt}, ${r.orb_band}, ${r.valence_hint})`;
    });
    return `<h4>${dateStr}</h4><ul><li>${lines.join("</li><li>")}</li></ul>`;
}
        // Global UI element references
        let generateBtn, loadingIndicator, errorDisplay, errorMessage, reportOutput, reportContent, copyBtn, downloadMarkdownBtn, mathBrainInfoBtn, mathBrainModal, closeMathBrainModal, closeMathBrainModalBottom, relocationToggle, relocationFields, transitDateFields, personBCard, relocationSection, relationalContextSection, intimacyTierDropdown, toggleModeHelp, modeHelpPanel, prefillTodayBtn, stepSizeHelpBtn, stepSizeHelpPanel, exRelationshipCheckbox, relocationPersonBOption, excludePersonBFromRelocation, transitStartDate, transitEndDate, transitStep, relocationCoordsInput;

        // Defensive check for window/globalThis
        if (typeof window === 'undefined') {
            console.warn('window is not defined; running in non-browser context');
        }

        // Store the latest result data for downloads
        let latestResultData = null;

        // --- Utility Functions ---

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
            reportOutput.classList.add('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        // Helper function to get opposite zodiac sign for South Node calculation
        function getOppositeSign(sign) {
            const opposites = {
                'Ari': 'Lib', 'Tau': 'Sco', 'Gem': 'Sag', 'Can': 'Cap',
                'Leo': 'Aqu', 'Vir': 'Pis', 'Lib': 'Ari', 'Sco': 'Tau',
                'Sag': 'Gem', 'Cap': 'Can', 'Aqu': 'Leo', 'Pis': 'Vir'
            };
            return opposites[sign] || sign;
        }

        // Helper function to check if any house cusps are available in chart data
        function hasAnyHouseCusps(chart) {
            const houseKeys = [
                'first_house', 'second_house', 'third_house', 'fourth_house',
                'fifth_house', 'sixth_house', 'seventh_house', 'eighth_house', 
                'ninth_house', 'tenth_house', 'eleventh_house', 'twelfth_house'
            ];
            return houseKeys.some(key => chart[key] && chart[key].sign && chart[key].position !== undefined);
        }

        // Reusable function to render natal chart data for any person
        function renderNatalChartData(chart, personName) {
            let md = '';
            
            try {
                // Chart Angles - only show if available
                if (chart.asc || chart.ascendant) {
                    md += `### Chart Angles\n\n`;
                    const asc = chart.asc || chart.ascendant;
                    const mc = chart.mc || chart.midheaven;
                    const dsc = chart.dsc || chart.descendant;
                    const ic = chart.ic || chart.imum_coeli;
                    
                    if (asc && asc.sign && asc.position !== undefined) {
                        md += `- **Ascendant (ASC)**: ${asc.sign} ${asc.position.toFixed(2)}°\n`;
                    }
                    if (mc && mc.sign && mc.position !== undefined) {
                        md += `- **Midheaven (MC)**: ${mc.sign} ${mc.position.toFixed(2)}°\n`;
                    }
                    if (dsc && dsc.sign && dsc.position !== undefined) {
                        md += `- **Descendant (DSC)**: ${dsc.sign} ${dsc.position.toFixed(2)}°\n`;
                    }
                    if (ic && ic.sign && ic.position !== undefined) {
                        md += `- **Imum Coeli (IC)**: ${ic.sign} ${ic.position.toFixed(2)}°\n`;
                    }
                    md += `\n`;
                }
                
                // Natal Planet Positions  
                md += `### Natal Planet Positions\n\n`;
                
                // Core planets in standard order
                const planets = [
                    { key: 'sun', name: 'Sun' },
                    { key: 'moon', name: 'Moon' },
                    { key: 'mercury', name: 'Mercury' },
                    { key: 'venus', name: 'Venus' },
                    { key: 'mars', name: 'Mars' },
                    { key: 'jupiter', name: 'Jupiter' },
                    { key: 'saturn', name: 'Saturn' },
                    { key: 'uranus', name: 'Uranus' },
                    { key: 'neptune', name: 'Neptune' },
                    { key: 'pluto', name: 'Pluto' },
                    { key: 'chiron', name: 'Chiron' }
                ];
                
                planets.forEach(planet => {
                    const planetData = chart[planet.key];
                    if (planetData && planetData.sign && planetData.position !== undefined) {
                        const house = planetData.house || 'Unknown';
                        const retrograde = planetData.retrograde ? ' ℞' : '';
                        md += `- **${planet.name}**: ${planetData.sign} ${planetData.position.toFixed(2)}° (House ${house})${retrograde}\n`;
                    }
                });
                
                // Lunar Nodes if available - prioritize true_node over mean_node for accuracy
                const northNode = chart.true_node || chart.mean_node || chart.north_node;
                if (northNode && northNode.sign && northNode.position !== undefined) {
                    md += `\n### Lunar Nodes\n\n`;
                    const house = northNode.house || 'Unknown';
                    const nodeType = chart.true_node ? 'True' : chart.mean_node ? 'Mean' : '';
                    md += `- **North Node${nodeType ? ` (${nodeType})` : ''}**: ${northNode.sign} ${northNode.position.toFixed(2)}° (House ${house})\n`;
                    
                    // South Node is opposite North Node
                    const southNodePos = (northNode.position + 180) % 360;
                    const southNodeSign = getOppositeSign(northNode.sign);
                    if (southNodeSign) {
                        md += `- **South Node${nodeType ? ` (${nodeType})` : ''}**: ${southNodeSign} ${southNodePos.toFixed(2)}°\n`;
                    }
                }
                
                // House Cusps if available - check all 12 houses
                if (hasAnyHouseCusps(chart)) {
                    md += `\n### House Cusps\n\n`;
                    const houses = [
                        { key: 'first_house', name: '1st House', description: 'Identity, Stance' },
                        { key: 'second_house', name: '2nd House', description: 'Resource, Security' },
                        { key: 'third_house', name: '3rd House', description: 'Exchange, Signals' },
                        { key: 'fourth_house', name: '4th House', description: 'Root, Anchor' },
                        { key: 'fifth_house', name: '5th House', description: 'Creative, Expression' },
                        { key: 'sixth_house', name: '6th House', description: 'Craft, Rhythm' },
                        { key: 'seventh_house', name: '7th House', description: 'Relational, Mirror' },
                        { key: 'eighth_house', name: '8th House', description: 'Depth, Crossing' },
                        { key: 'ninth_house', name: '9th House', description: 'Horizon, Philosophy' },
                        { key: 'tenth_house', name: '10th House', description: 'Apex, Projection' },
                        { key: 'eleventh_house', name: '11th House', description: 'Network, Belonging' },
                        { key: 'twelfth_house', name: '12th House', description: 'Dream, Spirit' }
                    ];
                    
                    houses.forEach(house => {
                        const houseData = chart[house.key];
                        if (houseData && houseData.sign && houseData.position !== undefined) {
                            md += `- **${house.name}**: ${houseData.sign} ${houseData.position.toFixed(2)}° (${house.description})\n`;
                        }
                    });
                }
                
                md += `\n`;
            } catch (error) {
                console.log(`Error rendering ${personName} natal chart data:`, error);
                md += `*Natal chart data available but could not be displayed due to formatting.*\n\n`;
            }
            
            return md;
        }

        // --- Date Utility Functions ---

        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function prefillTodayDates() {
            const todayStr = getTodayDateString();
            document.getElementById('transitStartDate').value = todayStr;
            document.getElementById('transitEndDate').value = todayStr;
            
            // Brief visual feedback
            prefillTodayBtn.textContent = '✅ Set to Today';
            setTimeout(() => { 
                prefillTodayBtn.textContent = '📅 Use Today for Quick Check'; 
            }, 2000);
        }

        // --- Download Functions ---

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        function generateMarkdownReport(data) {
            const formData = collectFormData();
            const currentDate = new Date().toISOString().split('T')[0];
            // Prefer authoritative server-returned details if present (may include normalization/zodiac defaults)
            const personA = (data.person_a && data.person_a.details) ? data.person_a.details : formData.personA;
            const personB = (data.person_b && data.person_b.details) ? data.person_b.details : formData.personB;
            const mode = formData.context.mode;
            
            let md = `# Woven Map Astrological Geometry Report\n\n`;
            md += `**Generated**: ${currentDate}\n`;
            md += `**Context Mode**: ${mode.replace(/_/g, ' ').toUpperCase()}\n`;
            md += `**Schema**: ${data.schema || 'WM-Chart-1.0'}\n\n`;

            // Person A Details
            md += `## Person A: ${personA.name}\n\n`;
            md += `- **Birth Date**: ${personA.year}-${String(personA.month).padStart(2, '0')}-${String(personA.day).padStart(2, '0')}\n`;
            md += `- **Birth Time**: ${String(personA.hour).padStart(2, '0')}:${String(personA.minute).padStart(2, '0')}\n`;
            md += `- **Location**: ${personA.city}, ${personA.nation}\n`;
            md += `- **Coordinates**: ${personA.latitude}, ${personA.longitude}\n`;
            md += `- **Timezone**: ${personA.timezone}\n`;
            md += `- **Zodiac Type**: ${personA.zodiac_type}\n\n`;

            // Person B Details (if present)
            if (personB) {
                md += `## Person B: ${personB.name}\n\n`;
                md += `- **Birth Date**: ${personB.year}-${String(personB.month).padStart(2, '0')}-${String(personB.day).padStart(2, '0')}\n`;
                md += `- **Birth Time**: ${String(personB.hour).padStart(2, '0')}:${String(personB.minute).padStart(2, '0')}\n`;
                md += `- **Location**: ${personB.city}, ${personB.nation}\n`;
                md += `- **Coordinates**: ${personB.latitude}, ${personB.longitude}\n`;
                md += `- **Timezone**: ${personB.timezone}\n`;
                md += `- **Zodiac Type**: ${personB.zodiac_type}\n\n`;

                // Relationship Context (if present)
                if (formData.context.relationship_type) {
                    md += `## Relationship Context\n\n`;
                    md += `- **Type**: ${formData.context.relationship_type}`;
                    if (formData.context.is_ex_relationship) {
                        md += ` (ex - no longer active)`;
                    }
                    md += `\n`;
                    if (formData.context.intimacy_tier) {
                        md += `- **Intimacy Tier**: ${formData.context.intimacy_tier}\n`;
                    }
                    md += `\n`;
                }
            }

            // Relocation (if present)
            if (data.relocation_a && data.relocation_a.status === 'OK') {
                md += `## Relocation Overlay\n\n`;
                md += `- **Location**: ${formData.relocation?.city || 'Unknown'}\n`;
                md += `- **Coordinates**: ${formData.relocation?.latitude}, ${formData.relocation?.longitude}\n`;
                
                if (data.relocation_b && data.relocation_b.status === 'OK') {
                    md += `- **Scope**: Both Person A and Person B relocated\n`;
                } else if (formData.relocation?.excludePersonB) {
                    md += `- **Scope**: Only Person A relocated (Person B excluded)\n`;
                } else {
                    md += `- **Scope**: Person A relocated\n`;
                }
                md += `\n`;
            }

            // Chart Data Summary
            if (data.person_a?.chart && (data.person_a.chart.status === 'OK' || data.person_a.chart.sun)) {
                md += `## ${personA.name} Natal Chart\n\n`;
                
                // The chart data can be in different structures depending on API endpoint used
                const chart = data.person_a.chart.data || data.person_a.chart;
                md += renderNatalChartData(chart, personA.name);
            }

            if (data.person_b?.chart && (data.person_b.chart.status === 'OK' || data.person_b.chart.sun)) {
                md += `## ${personB.name} Natal Chart\n\n`;
                
                // The chart data can be in different structures depending on API endpoint used
                const chart = data.person_b.chart.data || data.person_b.chart;
                md += renderNatalChartData(chart, personB.name);
            }

            // Relocation Chart Summaries (if present)
            if (data.relocation_a?.status === 'OK') {
                md += `## ${personA.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_a.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            if (data.relocation_b?.status === 'OK') {
                md += `## ${personB.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_b.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Composite Chart Summary (if present)
            if (data.composite?.chart?.status === 'OK') {
                md += `## Composite Chart Summary\n\n`;
                const chart = data.composite.chart.data.subject;
                md += `- **Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Aspects Summary
            if (data.person_a?.chart?.aspects && data.person_a.chart.aspects.length > 0) {
                md += `## Person A Major Aspects\n\n`;
                data.person_a.chart.aspects.slice(0, 10).forEach(aspect => {
                    // Dual-read for orb field
                    const orb = (Number.isFinite(aspect.orb) ? aspect.orb :
                                 Number.isFinite(aspect.orbit) ? aspect.orbit :
                                 Number.isFinite(aspect.diff) ? aspect.diff : null);
                    const p1 = aspect.p1_name || aspect.planet_a || aspect.transit_body || '—';
                    const p2 = aspect.p2_name || aspect.planet_b || aspect.natal_target || '—';
                    const asp = aspect.aspect || aspect.aspect_name || aspect.name || '—';
                    md += `- **${p1}** ${asp} **${p2}** (${orb !== null ? orb.toFixed(1) : '—'}° orb)\n`;
                });
                md += `\n`;
            }

            if (data.synastry?.aspects && data.synastry.aspects.length > 0) {
                md += `## Synastry Geometry\n\n`;
                md += `### Major Synastry Aspects\n\n`;
                data.synastry.aspects.slice(0, 15).forEach(aspect => {
                    md += `- **${aspect.p1_owner} ${aspect.p1_name}** ${aspect.aspect} **${aspect.p2_owner} ${aspect.p2_name}** (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                });
                md += `\n`;
            }

            // Handle composite data if present
            if (data.composite?.chart?.aspects && data.composite.chart.aspects.length > 0) {
                md += `## Composite Geometry\n\n`;
                md += `### Composite Chart Aspects\n\n`;
                data.composite.chart.aspects.slice(0, 15).forEach(aspect => {
                    md += `- **${aspect.p1_name}** ${aspect.aspect} **${aspect.p2_name}** (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                });
                md += `\n`;
            }

            // Process Transit Data (if mode includes transits)
            if (mode.includes('_transits')) {
                const transitStartDate = formData.transitParams?.startDate;
                const transitEndDate = formData.transitParams?.endDate;
                
                console.log('=== MARKDOWN TRANSIT DEBUG ===');
                console.log('Transit mode detected in markdown generation:', mode);
                console.log('Transit dates from form:', transitStartDate, 'to', transitEndDate);
                console.log('Data object keys:', Object.keys(data));
                console.log('Person A has transitsByDate?', !!data.person_a?.chart?.transitsByDate);
                console.log('Person B has transitsByDate?', !!data.person_b?.chart?.transitsByDate);
                
                if (data.person_a?.chart?.transitsByDate) {
                    console.log('Person A transit dates available:', Object.keys(data.person_a.chart.transitsByDate));
                }
                if (data.person_b?.chart?.transitsByDate) {
                    console.log('Person B transit dates available:', Object.keys(data.person_b.chart.transitsByDate));
                }
                
                md += `## Transit Analysis\n\n`;
                md += `**Period**: ${transitStartDate} to ${transitEndDate}\n\n`;

                                // --- New Unified Hook / Seismograph Renderer ---
                                const ui = window.WOVEN_UI_FILTERS || { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };
                
                                const NAME_MAP = { Medium_Coeli:'Midheaven (MC)', MC:'Midheaven (MC)', Mean_Node:'North Node', Mean_South_Node:'South Node', Mean_Lilith:'Lilith' };
                                const labelName = n => NAME_MAP[n] || n;
                                const aspectGlyph = a => ({conjunction:'☌', opposition:'☍', square:'□', trine:'△', sextile:'✧'})[a] || a;
                                                function hookLine(h){
                                                    const orbVal = h._orb??h.orb; const exact = (typeof orbVal==='number' && orbVal<=0.2) ? '★ ' : '';
                                                    const dir = h.approaching===true? '↓': (h.approaching===false? '↑': '');
                                                    return `${exact}${labelName(h.p1_display||h.p1_name)} ${aspectGlyph(h._aspect||h.aspect)} ${labelName(h.p2_display||h.p2_name)} (${(orbVal)?.toFixed ? orbVal.toFixed(1): '—'}°) ${(dir)}`.trim();
                                                }
                                function classifyClient(a){
                                    const cls = a._class || a.class || ''; // major, minor, harmonic
                                    if (cls==='major') return 'Major';
                                    if (cls==='minor') return 'Minor';
                                    if (cls==='harmonic') return 'Harmonic';
                                    return 'Other';
                                }
                                function passClientFilters(a){
                                    const orb = a._orb ?? a.orb;
                                    const tight = typeof orb==='number' && orb<=2;
                                    const cls = a._class;
                                    const isMinor = cls==='minor';
                                    const isHarm = cls==='harmonic';
                                    const isSelf = a.p1_name===a.p2_name;
                                    if (ui.tightOnly && !tight) return false;
                                    if (!ui.showMinor && isMinor) return false;
                                    if (!ui.showHarmonic && isHarm) return false;
                                    if (!ui.showSelf && isSelf) return false;
                                    return true;
                                }
                                                function deriveCounts(filteredList){
                                                    const counts = { majors_tight:0, majors_loose:0, minors:0, harmonics:0, self_aspects:0 };
                                                    filteredList.forEach(a=>{
                                                        const orb = a._orb??a.orb??99;
                                                        const isSelf = a.p1_name===a.p2_name;
                                                        if (isSelf) counts.self_aspects++;
                                                        if (a._class==='major') { if (orb<=2) counts.majors_tight++; else counts.majors_loose++; }
                                                        else if (a._class==='minor') counts.minors++; else if (a._class==='harmonic') counts.harmonics++;
                                                    });
                                                    return counts;
                                                }
                                                function buildDaySection(date, day){
                                                    if(!day) return '';
                                                    // Hooks sort tie-break by smaller orb
                                                    const hooks = (day.hooks?.slice()||[]).sort((a,b)=>{
                                                        const wDiff = (b._weight||0) - (a._weight||0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        const oa = a._orb??a.orb??99; const ob = b._orb??b.orb??99; return oa - ob;
                                                    });
                                                    const filteredAll = (day.filtered_aspects||[]).filter(passClientFilters);
                                                    const counts = deriveCounts(filteredAll);
                                                    // Invariant check (debug only)
                                                    if ((counts.majors_tight + counts.majors_loose + counts.minors + counts.harmonics + counts.self_aspects) !== filteredAll.length){
                                                        console.warn('Count invariant mismatch', date, counts, filteredAll.length);
                                                    }
                                                    let summaryLine = `${date} — Majors ${counts.majors_tight}/${counts.majors_loose} · Minors ${counts.minors} · Harmonics ${counts.harmonics}`;
                                                    let out = `<details><summary>${summaryLine}</summary>\n\n`;
                                                    out += `**Hooks**\n`;
                                                    hooks.forEach(h=> out += `- ${hookLine(h)}\n`);
                                                    if (!hooks.length) out += `- —\n`;
                                                    out += `\n**Filtered aspects (${filteredAll.length})**\n`;
                                                    filteredAll.forEach(a=>{
                                                        const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                        out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt}) — ${classifyClient(a)}\n`;
                                                    });
                                                    if (Array.isArray(day.aspects) && day.aspects.length){
                                                        out += `\n<details><summary>Full list (raw ${day.aspects.length})</summary>\n\n`;
                                                        day.aspects.slice(0,50).forEach(a=>{
                                                            const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                            out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt})\n`;
                                                        });
                                                        if (day.aspects.length>50) out += `... (${day.aspects.length-50} more)\n`;
                                                        out += `</details>\n`;
                                                    }
                                                    out += `\n</details>\n\n`;
                                                    return out;
                                                }
                                                function buildSummaryTable(title, dailyMap){
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    let out = `## ${title} — Weekly Seismograph\n\n| Date | Magnitude | Valence | Volatility | Top Hooks |\n|------|-----------:|--------:|-----------:|-----------|\n`;
                                                    dates.forEach(d=>{
                                                        const day = dailyMap[d];
                                                        // Limit to top 3 hooks by weight desc w/ tie-break
                                                        const hooks = (day.hooks||[]).slice().sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; const oa=a._orb??a.orb??99; const ob=b._orb??b.orb??99; return oa-ob; }).slice(0,3);
                                                        const peak = hooks.map(h=> hookLine(h)).join(', ');
                                                        out += `| ${d} | ${(day.seismograph?.magnitude??0).toFixed(2)} | ${(day.seismograph?.valence??0).toFixed(2)} | ${(day.seismograph?.volatility??0).toFixed(2)} | ${peak.replace(/\|/g,'\\|') || '—'} |\n`;
                                                    });
                                                    out += `\n`;
                                                    return out;
                                                }
                
                                md += `\n## Simple Mode — Hooks-First Geometry\n`;
                                if (data.person_a?.chart?.transitsByDate) md += buildSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Daily Hooks\n`;
                                if (data.person_a?.chart?.transitsByDate){
                                    Object.keys(data.person_a.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_a.chart.transitsByDate[d]); });
                                }
                                if (data.person_b?.chart?.transitsByDate){
                                    Object.keys(data.person_b.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_b.chart.transitsByDate[d]); });
                                }
                                if (data.composite?.transitsByDate){
                                    Object.keys(data.composite.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.composite.transitsByDate[d]); });
                                }
                
                console.log('=== END MARKDOWN TRANSIT DEBUG ===');

                // Synastry Transits (transits to synastry aspects)
                if (mode.includes('synastry') && data.synastry?.transitsByDate) {
                    md += `### Synastry Transit Activations\n\n`;
                    const synastryTransits = data.synastry.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(synastryTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = synastryTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_owner ? `${transit.p2_owner} ${transit.p2_name}` : (transit.p2_name ?? "?");
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant synastry transit activations in the specified date range.\n\n`;
                    }
                }

                // Composite Transits (for composite modes)
                if (mode.includes('composite') && data.composite?.transitsByDate) {
                    md += `### Composite Chart Transits\n\n`;
                    const compositeTransits = data.composite.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(compositeTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = compositeTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_name ?? "?";
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant composite transits in the specified date range.\n\n`;
                    }
                }
            }

            md += `---\n*Generated by Woven Map Math Brain - Pure Astrological Geometry*`;

            return md;
        }

                // Re-render hooks only (without round-trip) when filters change
                function rerenderHookMarkdownSection(){
                        if(!latestResultData) return;
                        try {
                            const full = generateMarkdownReport(latestResultData);
                            reportContent.textContent = full;
                        } catch(e){ console.warn('Re-render failed', e); }
                }

        function generateFilename(extension, data) {
            const formData = collectFormData();
            const personA = formData.personA.name.replace(/[^a-zA-Z0-9]/g, '');
            const personB = formData.personB?.name?.replace(/[^a-zA-Z0-9]/g, '') || '';
            const mode = formData.context.mode;
            const date = new Date().toISOString().split('T')[0];
            
            let filename = `WovenMap_${personA}`;
            if (personB) {
                filename += `_${personB}`;
            }
            filename += `_${mode}_${date}.${extension}`;
            
            return filename;
        }

        function parseCoordinates(coordString) {
            if (!coordString) return { latitude: undefined, longitude: undefined };
            
            coordString = coordString.trim();
            const decimalPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$/;
            const dmsPattern = /(\d+)[°\s]+(\d+)'?\s*([NS]),\s*(\d+)[°\s]+(\d+)'?\s*([EW])/i;

            console.log("Parsing coordinates:", coordString);

            if (decimalPattern.test(coordString)) {
                const [lat, lon] = coordString.split(',').map(s => parseFloat(s.trim()));
                console.log("Parsed decimal coordinates:", { latitude: lat, longitude: lon });
                return { latitude: lat, longitude: lon };
            }

            const dmsMatch = coordString.match(dmsPattern);
            if (dmsMatch) {
                let lat = parseFloat(dmsMatch[1]) + parseFloat(dmsMatch[2]) / 60;
                if (dmsMatch[3].toUpperCase() === 'S') lat = -lat;

                let lon = parseFloat(dmsMatch[4]) + parseFloat(dmsMatch[5]) / 60;
                if (dmsMatch[6].toUpperCase() === 'W') lon = -lon;
                
                console.log("Parsed DMS coordinates:", { latitude: lat, longitude: lon });
                return { latitude: parseFloat(lat.toFixed(4)), longitude: parseFloat(lon.toFixed(4)) };
            }
            
            console.error("Failed to parse coordinates:", coordString);
            // Return undefined if no pattern matches
            return { latitude: undefined, longitude: undefined };
        }

        // --- Form Logic ---

        function validateForm() {
            hideError();
            const mode = document.querySelector('input[name="contextMode"]:checked').value;

            // Validate Person A
            const nameA = document.getElementById('nameA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();

            if (!nameA || !dateA || !timeA || !astroA) {
                showError('Please fill in all required fields for Person A');
                return false;
            }
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateA)) {
                showError('Please enter Person A date in YYYY-MM-DD format');
                return false;
            }
            if (!/^\d{2}:\d{2}$/.test(timeA)) {
                showError('Please enter Person A time in HH:MM format (24-hour)');
                return false;
            }
            const coordsA = parseCoordinates(astroA);
            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                showError('Please enter Person A coordinates in a valid decimal (e.g., 40.01, -75.31) or DMS format (e.g., 40°1\'N, 75°18\'W)');
                return false;
            }

            // Validate Person B if required by mode
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                const nameB = document.getElementById('nameB').value.trim();
                const dateB = document.getElementById('birth_dateB').value.trim();
                const timeB = document.getElementById('birth_timeB').value.trim();
                const astroB = document.getElementById('astroB').value.trim();
                if (!nameB || !dateB || !timeB || !astroB) {
                    showError(`Please fill in all required fields for Person B for ${mode} analysis`);
                    return false;
                }
                if (!/^\d{4}-\d{2}-\d{2}$/.test(dateB)) {
                    showError('Please enter Person B date in YYYY-MM-DD format');
                    return false;
                }
                if (!/^\d{2}:\d{2}$/.test(timeB)) {
                    showError('Please enter Person B time in HH:MM format (24-hour)');
                    return false;
                }
                const coordsB = parseCoordinates(astroB);
                if (coordsB.latitude === undefined || coordsB.longitude === undefined) {
                    showError('Please enter Person B coordinates in a valid decimal or DMS format');
                    return false;
                }
            }

            // Validate transit dates if required by mode (ALL modes now require transits)
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits') {
                const start = transitStartDate.value;
                const end = transitEndDate.value;
                if (!start || !end) {
                    showError('Please enter both start and end dates for transit analysis');
                    return false;
                }
                if (end < start) {
                    showError('End date must be after or equal to start date');
                    return false;
                }
            }

            // Validate relocation coordinates if enabled
            if (relocationToggle.checked) {
                const relocationCoords = relocationCoordsInput.value.trim();
                if (!relocationCoords) {
                    showError('Please enter relocation coordinates when overlay is enabled');
                    return false;
                }
                const coordsR = parseCoordinates(relocationCoords);
                if (coordsR.latitude === undefined || coordsR.longitude === undefined) {
                    showError('Please enter valid relocation coordinates in decimal or DMS format');
                    return false;
                }
            }

            return true;
        }

        function collectFormData() {
            console.log("=== COLLECTING FORM DATA ===");
            
            // Person A - Get raw form values first
            const nameA = document.getElementById('nameA').value.trim();
            const cityA = document.getElementById('birth_cityA').value.trim();
            const stateA = document.getElementById('birth_stateA').value.trim();
            const countryA = document.getElementById('birth_countryA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();
            const zodiacA = document.getElementById('zodiacA').value;
            const timezoneA = document.getElementById('offsetA').value;

            console.log("Raw form values for Person A:");
            console.log("- Name:", nameA);
            console.log("- City:", cityA);
            console.log("- State:", stateA);
            console.log("- Country:", countryA);
            console.log("- Date:", dateA);
            console.log("- Time:", timeA);
            console.log("- Coordinates:", astroA);
            console.log("- Zodiac:", zodiacA);
            console.log("- Timezone:", timezoneA);

            // Parse date and time
            if (!dateA || !timeA) {
                console.error("Missing date or time for Person A");
                throw new Error("Date and time are required for Person A");
            }

            const [yearA, monthA, dayA] = dateA.split('-').map(Number);
            const [hourA, minuteA] = timeA.split(':').map(Number);

            console.log("Parsed date/time:", { yearA, monthA, dayA, hourA, minuteA });

            // Parse coordinates
            const coordsA = parseCoordinates(astroA);
            console.log("Parsed coordinates:", coordsA);

            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                console.error("Failed to parse coordinates for Person A");
                throw new Error("Valid coordinates are required for Person A");
            }

            const personA = {
                name: nameA || "Unknown",
                city: cityA || "Unknown",
                nation: countryA || "US",
                year: yearA,
                month: monthA, 
                day: dayA, 
                hour: hourA, 
                minute: minuteA,
                latitude: coordsA.latitude, 
                longitude: coordsA.longitude,
                zodiac_type: zodiacA || "Tropic",
                timezone: timezoneA || "America/New_York"
            };
            
            console.log("Final Person A data:", personA);
            
            // Validate all required fields are present and not undefined
            const requiredFields = ['year', 'month', 'day', 'hour', 'minute', 'name', 'city', 'nation', 'latitude', 'longitude', 'zodiac_type', 'timezone'];
            const missingFields = requiredFields.filter(field => {
                const value = personA[field];
                return value === undefined || value === null || value === "";
            });
            
            if (missingFields.length > 0) {
                console.error("Missing required fields for Person A:", missingFields);
                console.error("Current Person A object:", personA);
                throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
            }

            // Person B - only if fields are filled
            const dateB_val = document.getElementById('birth_dateB').value;
            const timeB_val = document.getElementById('birth_timeB').value.trim();
            const coordsB_val = document.getElementById('astroB').value.trim();
            let personB = null;

            if (dateB_val && timeB_val && coordsB_val) {
                console.log("Processing Person B data...");
                const coordsB = parseCoordinates(coordsB_val);
                if (coordsB.latitude !== undefined && coordsB.longitude !== undefined) {
                    const [yearB, monthB, dayB] = dateB_val.split('-').map(Number);
                    const [hourB, minuteB] = timeB_val.split(':').map(Number);
                    personB = {
                        name: document.getElementById('nameB').value.trim() || "Unknown",
                        city: document.getElementById('birth_cityB').value.trim() || "Unknown",
                        nation: document.getElementById('birth_countryB').value.trim() || "US",
                        year: yearB, 
                        month: monthB, 
                        day: dayB, 
                        hour: hourB, 
                        minute: minuteB,
                        latitude: coordsB.latitude,
                        longitude: coordsB.longitude,
                        zodiac_type: document.getElementById('zodiacB').value || "Tropic",
                        timezone: document.getElementById('offsetB').value || "America/New_York"
                    };
                    console.log("Person B data:", personB);
                }
            }

            const formData = {
                personA,
                personB: personB,
                context: {
                    mode: document.querySelector('input[name="contextMode"]:checked').value,
                    relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value,
                    intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value,
                    is_ex_relationship: exRelationshipCheckbox?.checked || false
                }
            };

            if (relocationToggle && relocationToggle.checked) {
                const relocationCoords = parseCoordinates(document.getElementById('relocationCoords').value.trim());
                formData.relocation = {
                    enabled: true,
                    city: document.getElementById('relocationCity').value.trim(),
                    state: document.getElementById('relocationState').value.trim(),
                    latitude: relocationCoords.latitude,
                    longitude: relocationCoords.longitude,
                    coordinates: document.getElementById('relocationCoords').value.trim(),
                    excludePersonB: excludePersonBFromRelocation?.checked || false
                };
            } else {
                formData.relocation = { enabled: false };
            }

            const mode = formData.context.mode;
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits') {
                const startDateElement = document.getElementById('transitStartDate');
                const endDateElement = document.getElementById('transitEndDate');
                const stepElement = document.getElementById('transitStep');
                
                console.log('=== FRONTEND TRANSIT DEBUG ===');
                console.log('Transit mode detected:', mode);
                console.log('Start date element:', startDateElement, 'Value:', startDateElement?.value);
                console.log('End date element:', endDateElement, 'Value:', endDateElement?.value);
                console.log('Step element:', stepElement, 'Value:', stepElement?.value);
                
                if (startDateElement && endDateElement && stepElement) {
                    formData.transitParams = {
                        startDate: startDateElement.value,
                        endDate: endDateElement.value,
                        step: stepElement.value
                    };
                    
                    console.log('Transit data added to form:', formData.transitParams);
                } else {
                    console.log('WARNING: Transit elements not found or missing values');
                }
                console.log('=== END FRONTEND TRANSIT DEBUG ===');
            }

            console.log("=== FINAL FORM DATA ===");
            console.log(JSON.stringify(formData, null, 2));
            return formData;
        }

        // --- API Call ---

        async function generateReport() {
            totalRowCount = 0; // Reset counter for each report
            WovenMapConfig.debugLog("Generate button clicked");
            
            if (!validateForm()) {
                return;
            }

            WovenMapConfig.debugLog("Form is valid, preparing API request");
            hideError();
            generateBtn.disabled = true;
            loadingIndicator.classList.remove('hidden');
            reportOutput.classList.add('hidden');

            try {
                const formData = collectFormData();
                
                // Log the complete data being sent to API
                console.log("=== SENDING TO API ===");
                console.log("Full form data:", JSON.stringify(formData, null, 2));
                console.log("PersonA structure:", JSON.stringify(formData.personA, null, 2));
                WovenMapConfig.debugLog("Sending data to API", formData);
                
                // Double-check required fields using configuration
                const requiredFields = WovenMapConfig.validation.requiredFields.person;
                const missingFields = requiredFields.filter(field => {
                    const value = formData.personA[field];
                    return value === undefined || value === null || value === "";
                });
                
                if (missingFields.length > 0) {
                    throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
                }
                
                const apiEndpoint = WovenMapConfig.getApiEndpoint('astrologyMathBrain');
                WovenMapConfig.debugLog(`Sending API request to ${apiEndpoint}`);
                
                // --- Robust fetch with AbortController (native fetch ignores custom timeout property) ---
                const timeoutMs = (WovenMapConfig?.api?.timeout && Number.isFinite(+WovenMapConfig.api.timeout)) ? +WovenMapConfig.api.timeout : 30000;
                const controller = new AbortController();
                const timeoutHandle = setTimeout(() => {
                    controller.abort();
                }, timeoutMs);

                let response;
                try {
                    response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(formData),
                        signal: controller.signal
                    });
                } catch (fetchErr) {
                    if (fetchErr.name === 'AbortError') {
                        throw new Error(`Request timed out after ${Math.round(timeoutMs/1000)}s (network slow or server overloaded)`);
                    }
                    throw fetchErr;
                } finally {
                    clearTimeout(timeoutHandle);
                }

                if (!response.ok) {
                    const errorBody = await response.text();
                    let errorMessage = `HTTP error! status: ${response.status}`;
                    try {
                        // Try to parse as JSON to get a more specific error message
                        const errorJson = JSON.parse(errorBody);
                        if (errorJson.error) {
                           errorMessage += ` - ${errorJson.error}`;
                           if(errorJson.missing) {
                             errorMessage += ` (Missing: ${errorJson.missing.join(', ')})`;
                           }
                        } else {
                           errorMessage += ` - ${errorBody}`;
                        }
                    } catch (e) {
                        // If not JSON, just use the text body
                        errorMessage += ` - ${errorBody}`;
                    }
                    throw new Error(errorMessage);
                }

                let result;
                try {
                    result = await response.json();
                } catch (parseErr) {
                    throw new Error('Failed to parse JSON response from server');
                }
                if (result.error) {
                    throw new Error(result.error);
                }

                // --- Shape Harmonization Shim ---
                (function harmonizeResultShape(r){
                    try {
                        // Synastry: ensure r.synastry.aspects present if nested chart form used
                        if (r.synastry && !r.synastry.aspects && r.synastry.chart?.aspects && Array.isArray(r.synastry.chart.aspects)) {
                            r.synastry.aspects = r.synastry.chart.aspects;
                        }
                        // Composite: some earlier frontend code expects composite.chart.* already; if only composite.aspects given, wrap
                        if (r.composite && !r.composite.chart && r.composite.aspects) {
                            r.composite.chart = { aspects: r.composite.aspects };
                        }
                        // Transit containers: normalize transitsByDate key if only transits present & shaped as date map
                        const maybePromote = (chartObj) => {
                            if (!chartObj || chartObj.transitsByDate) return;
                            if (chartObj.transits && !Array.isArray(chartObj.transits)) {
                                // Heuristic: if it's an object whose keys look like YYYY-MM-DD
                                const keys = Object.keys(chartObj.transits || {});
                                if (keys.length && keys.every(k => /^\d{4}-\d{2}-\d{2}$/.test(k))) {
                                    chartObj.transitsByDate = chartObj.transits; // promote
                                }
                            }
                        };
                        if (r.person_a?.chart) maybePromote(r.person_a.chart);
                        if (r.person_b?.chart) maybePromote(r.person_b.chart);
                        if (r.synastry) maybePromote(r.synastry); // in case synastry transits delivered similarly
                        if (r.composite) maybePromote(r.composite);
                    } catch (e) {
                        console.warn('Shape harmonization encountered an issue:', e);
                    }
                })(result);

                // Store result data for downloads
                latestResultData = result;

                // Generate human-readable Markdown report
                const report = generateMarkdownReport(result);
                
                // Debug: Log the actual data structure to understand transit availability
                console.log('=== DEBUGGING TRANSIT DATA ===');
                console.log('Full result structure:', Object.keys(result));
                if (result.person_a?.chart) {
                    console.log('Person A chart keys:', Object.keys(result.person_a.chart));
                    console.log('Person A has transits?', !!result.person_a.chart.transits);
                    console.log('Person A has transitsByDate?', !!result.person_a.chart.transitsByDate);
                    if (result.person_a.chart.transits) {
                        console.log('Person A transits sample:', result.person_a.chart.transits.slice(0, 2));
                    }
                }
                if (result.synastry) {
                    console.log('Synastry keys:', Object.keys(result.synastry));
                    console.log('Synastry has transits?', !!result.synastry.transits);
                    console.log('Synastry has transitsByDate?', !!result.synastry.transitsByDate);
                }
                console.log('=== END TRANSIT DEBUG ===');
                
                reportContent.textContent = report;
                reportOutput.classList.remove('hidden');

            } catch (error) {
                console.error('Error generating report:', error);
                showError(`Failed to generate report: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
                loadingIndicator.classList.add('hidden');
            }
        }

        // --- Event Listeners & UI Updates ---

        function setupEventListeners() {
            // Main button
            generateBtn.addEventListener('click', generateReport);

            // Modal
            mathBrainInfoBtn.addEventListener('click', () => mathBrainModal.classList.remove('hidden'));
            closeMathBrainModal.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            closeMathBrainModalBottom.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            mathBrainModal.addEventListener('click', (e) => {
                if (e.target === mathBrainModal) mathBrainModal.classList.add('hidden');
            });

            // Copy report
            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(reportContent.textContent);
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => { copyBtn.textContent = 'Copy Data'; }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            // Download Markdown
            downloadMarkdownBtn.addEventListener('click', () => {
                if (!latestResultData) {
                    showError('No data available for download. Please generate a report first.');
                    return;
                }
                try {
                    const markdownContent = generateMarkdownReport(latestResultData);
                    const filename = generateFilename('md', latestResultData);
                    downloadFile(markdownContent, filename, 'text/markdown');
                    
                    // Brief visual feedback
                    downloadMarkdownBtn.textContent = '✅ Downloaded!';
                    setTimeout(() => { downloadMarkdownBtn.textContent = '📄 Download MD'; }, 2000);
                } catch (error) {
                    console.error('Download error:', error);
                    showError('Failed to generate markdown download: ' + error.message);
                }
            });

            // Toggle mode help panel
            toggleModeHelp.addEventListener('click', () => {
                const isHidden = modeHelpPanel.classList.contains('hidden');
                modeHelpPanel.classList.toggle('hidden');
                toggleModeHelp.textContent = isHidden ? '🧭 Hide mode guide' : '🧭 What does each mode do?';
            });

            // Prefill today's date for transit dates
            prefillTodayBtn.addEventListener('click', prefillTodayDates);
                // Simple Mode: filter controls suppressed (defaults applied globally)

            // Toggle step size help panel
            stepSizeHelpBtn.addEventListener('click', () => {
                const isHidden = stepSizeHelpPanel.classList.contains('hidden');
                stepSizeHelpPanel.classList.toggle('hidden');
                stepSizeHelpBtn.textContent = isHidden ? '❓ Hide explanation' : '❓ What does this do?';
            });

            // Context mode switching
            document.querySelectorAll('input[name="contextMode"]').forEach(radio => {
                radio.addEventListener('change', updateFormUI);
            });

            // Relocation toggle
            relocationToggle.addEventListener('change', () => {
                relocationFields.classList.toggle('hidden', !relocationToggle.checked);
                updateRelocationPersonBOption();
            });

            // Relational context visibility
            const personBInputs = ['nameB', 'birth_cityB', 'birth_stateB', 'birth_dateB', 'birth_timeB', 'birth_countryB', 'astroB'];
            personBInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    const anyFilled = personBInputs.some(id => document.getElementById(id).value.trim() !== '');
                    relationalContextSection.classList.toggle('hidden', !anyFilled);
                });
            });
            
            // Intimacy tier visibility
            document.querySelectorAll('input[name="relationshipType"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    const isPartner = document.querySelector('input[name="relationshipType"]:checked')?.value === 'partner';
                    intimacyTierDropdown.classList.toggle('hidden', !isPartner);
                });
            });
        }

        function updateFormUI() {
            const mode = document.querySelector('input[name="contextMode"]:checked').value;

            const isNatal = mode === 'natal';
            const isSynastryTransits = mode === 'synastry_transits';
            const isCompositeTransits = mode === 'composite_transits';
            
            const showPersonB = !isNatal; // Person B needed for all relational modes
            personBCard.style.opacity = showPersonB ? '1' : '0.5';
            personBCard.style.pointerEvents = showPersonB ? 'auto' : 'none';

            const showTransitFields = true; // ALL modes now include transits
            transitDateFields.style.display = showTransitFields ? 'block' : 'none';

            // CRITICAL: Relocation overlay must be available whenever ANY chart data is entered
            // This includes Natal, Synastry, Composite, Transit, and Synastry+Transit modes
            // Protocol requirement: Location affects angle geometry regardless of context mode
            const showRelocation = true; // Always show relocation - it's a fundamental geometric option
            relocationSection.style.display = showRelocation ? 'block' : 'none';
            
            // Update Person B relocation option visibility
            updateRelocationPersonBOption();
            
            // Show/hide relational context section based on whether Person B is needed
            if (showPersonB) {
                relationalContextSection.classList.remove('hidden');
            } else {
                relationalContextSection.classList.add('hidden');
            }
        }
        
        function updateRelocationPersonBOption() {
            const mode = document.querySelector('input[name="contextMode"]:checked').value;
            const showPersonB = mode !== 'natal';
            const relocationEnabled = relocationToggle && relocationToggle.checked;
            
            // Show the Person B relocation option only if Person B is present and relocation is enabled
            if (relocationPersonBOption) {
                if (showPersonB && relocationEnabled) {
                    relocationPersonBOption.classList.remove('hidden');
                } else {
                    relocationPersonBOption.classList.add('hidden');
                }
            }
        }

        // Initial UI setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements assignment
            generateBtn = document.getElementById('generateReport');
            loadingIndicator = document.getElementById('loadingIndicator');
            errorDisplay = document.getElementById('errorDisplay');
            errorMessage = document.getElementById('errorMessage');
            reportOutput = document.getElementById('reportOutput');
            reportContent = document.getElementById('reportContent');
            copyBtn = document.getElementById('copyReport');
            downloadMarkdownBtn = document.getElementById('downloadMarkdown');
            mathBrainInfoBtn = document.getElementById('math-brain-info-btn');
            mathBrainModal = document.getElementById('math-brain-modal');
            closeMathBrainModal = document.getElementById('close-math-brain-modal');
            closeMathBrainModalBottom = document.getElementById('close-math-brain-modal-bottom');
            relocationToggle = document.getElementById('relocationToggle');
            relocationFields = document.getElementById('relocationFields');
            transitDateFields = document.getElementById('transit-date-range-fields');
            personBCard = document.getElementById('personB-card');
            relocationSection = document.getElementById('relocation-section');
            relationalContextSection = document.getElementById('relational-context-section');
            intimacyTierDropdown = document.getElementById('intimacy-tier-dropdown');
            exRelationshipCheckbox = document.getElementById('exRelationship');
            relocationPersonBOption = document.getElementById('relocationPersonBOption');
            excludePersonBFromRelocation = document.getElementById('excludePersonBFromRelocation');
            transitStartDate = document.getElementById('transitStartDate');
            transitEndDate = document.getElementById('transitEndDate');
            transitStep = document.getElementById('transitStep');
            relocationCoordsInput = document.getElementById('relocationCoords');
            toggleModeHelp = document.getElementById('toggle-mode-help');
            modeHelpPanel = document.getElementById('mode-help-panel');
            prefillTodayBtn = document.getElementById('prefillToday');
            stepSizeHelpBtn = document.getElementById('stepSizeHelp');
            stepSizeHelpPanel = document.getElementById('stepSizeHelpPanel');

            console.log("DOM elements assigned:", {
                generateBtn: !!generateBtn,
                loadingIndicator: !!loadingIndicator,
                errorDisplay: !!errorDisplay,
                transitStartDate: !!transitStartDate,
                transitEndDate: !!transitEndDate,
                transitStep: !!transitStep,
                relocationCoordsInput: !!relocationCoordsInput
            });

            setupEventListeners();
            updateFormUI();
            
            // Auto-prefill transit dates with today for convenience
            const todayStr = getTodayDateString();
            if (transitStartDate && transitEndDate) {
                transitStartDate.value = todayStr;
                transitEndDate.value = todayStr;
            }
            
            // Initial check for relational context section
            const personBInputs = ['nameB', 'birth_cityB', 'birth_stateB', 'birth_dateB', 'birth_timeB', 'birth_countryB', 'astroB'];
            const anyFilled = personBInputs.some(id => document.getElementById(id).value.trim() !== '');
            relationalContextSection.classList.toggle('hidden', !anyFilled);
            
            // Initial check for intimacy tier
            const isPartner = document.querySelector('input[name="relationshipType"]:checked')?.value === 'partner';
            intimacyTierDropdown.classList.toggle('hidden', !isPartner);
        });
    </script>
</body>
</html>
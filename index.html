<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Woven Map Report Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a202c;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
        .animate-fade-in-out {
            animation: fadeInOut 8s ease-in-out forwards;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateY(-20px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Woven Map Report Generator</h1>
            <p class="text-gray-400 mt-2">Math Brain</p>
        </header>

        <main>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div id="personA-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Person A / Natal Chart</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameA" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="DH Cross">
                            <input type="text" id="cityA" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="Bryn Mawr">
                             <input type="text" id="stateA" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="PA">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="dateA" placeholder="Date (MM-DD-YYYY)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="07-24-1973">
                            <input type="text" id="timeA" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="14:30">
                            <select id="offsetA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Chicago">Central (Chicago)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska (Anchorage)</option>
                                <option value="Pacific/Honolulu">Hawaii (Honolulu)</option>
                            </select>
                        </div>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="nationA" placeholder="Country" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="US">
                            <select id="zodiacA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-4 pt-2">
                           <label class="flex items-center"><input type="radio" name="coordModeA" value="combined" class="form-radio h-4 w-4 text-indigo-600" checked><span class="ml-2 text-gray-300">Combined</span></label>
                           <label class="flex items-center"><input type="radio" name="coordModeA" value="manual" class="form-radio h-4 w-4 text-indigo-600"><span class="ml-2 text-gray-300">Manual</span></label>
                        </div>
                        <div id="combinedCoordsA"><input type="text" id="astroA" placeholder="Birth Coordinates" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="40°1'N, 75°19'W"></div>
                        <div id="manualCoordsA" class="hidden grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="latA" placeholder="Latitude" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                            <input type="text" id="lonA" placeholder="Longitude" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                        </div>
                    </div>
                </div>

                <div id="personB-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Person B (Optional)</h2>
                    <div class="space-y-4">
                         <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameB" placeholder="Name" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <input type="text" id="cityB" placeholder="Birth City" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <input type="text" id="stateB" placeholder="Birth State/Prov" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="dateB" placeholder="Date (MM-DD-YYYY)" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <input type="text" id="timeB" placeholder="Time (24h HH:MM)" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                             <select id="offsetB" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Chicago">Central (Chicago)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska (Anchorage)</option>
                                <option value="Pacific/Honolulu">Hawaii (Honolulu)</option>
                            </select>
                        </div>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="nationB" placeholder="Country" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="">
                            <select id="zodiacB" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-4 pt-2">
                           <label class="flex items-center"><input type="radio" name="coordModeB" value="combined" class="form-radio h-4 w-4 text-indigo-600" checked><span class="ml-2 text-gray-300">Combined</span></label>
                           <label class="flex items-center"><input type="radio" name="coordModeB" value="manual" class="form-radio h-4 w-4 text-indigo-600"><span class="ml-2 text-gray-300">Manual</span></label>
                        </div>
                        <div id="combinedCoordsB"><input type="text" id="astroB" placeholder="Birth Coordinates" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value=""></div>
                        <div id="manualCoordsB" class="hidden grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="latB" placeholder="Latitude" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                            <input type="text" id="lonB" placeholder="Longitude" class="person-b-field w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                        </div>
                    </div>
                </div>
            </div>

            <div id="relational-context-stack" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 hidden border border-teal-500">
                <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Relational Context Query Stack</h2>
                <p class="text-gray-400 text-sm mb-4">Based on initial geometry, the Math Brain has detected the following potential dynamics:</p>
                <ul id="context-readout" class="list-disc list-inside space-y-2 mb-4 text-gray-300">
                    </ul>
                <div id="relationship-type-query">
                    <p class="text-lg font-medium text-white mb-2">How would you categorize this connection?</p>
                    <div class="flex flex-col space-y-2">
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="Partner" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Partner (romantic/undefined-intimate)</span></label>
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="Friend" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Friend or colleague</span></label>
                        <label class="flex items-center"><input type="radio" name="relationshipType" value="Family" class="form-radio h-4 w-4 text-teal-400"><span class="ml-2 text-gray-300">Family</span></label>
                    </div>
                </div>
            </div>

            <div class="mb-8">
                <label class="flex items-center">
                    <input type="checkbox" id="synastryToggle" class="form-checkbox h-5 w-5 text-teal-400" checked>
                    <span class="ml-3 text-white font-medium">Include Synastry Analysis</span>
                </label>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
                <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Step 1: Generate Natal & Transit Data</h2>
                <div>
                     <label class="text-lg text-gray-200">Date Range (Defaults to Today)</label>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                       <input type="text" id="startDate" placeholder="Start Date (MM-DD-YYYY)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                       <input type="text" id="endDate"   placeholder="End Date (optional)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                    </div>
                     <p class="text-gray-400 text-sm mt-2">Generates natal charts and transits for the date range, always calculated for the birth location.</p>
                     <div class="mt-4 bg-gray-700/50 p-4 rounded-md">
                        <label class="flex items-center">
                            <input type="checkbox" id="relocationToggle" class="form-checkbox h-5 w-5 text-teal-400">
                            <span class="ml-3 text-white font-medium">Add Relocation Overlay (Optional)</span>
                        </label>
                        <div id="relocationFields" class="hidden mt-3">
                            <p class="text-sm text-gray-400 mb-2">Enter coordinates (e.g., <b>30°10′N, 85°40′W</b>) to see a side-by-side comparison of how transits fall in the relocated house system.</p>
                            <input type="text"
                                   id="relocationCoords"
                                   placeholder="30°10′N, 85°40′W"
                                   class="w-full bg-gray-800 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-teal-500 focus:outline-none"
                                   value="30°10′N, 85°40′W">
                            <div id="relocationError" class="text-red-500 text-xs mt-1 hidden"></div>
                            <p class="text-xs text-gray-500 italic text-right pr-1 pt-1">
                                You can also paste decimal degrees (e.g., 30.1588, -85.6602).
                            </p>
                        </div>
                    </div>
                     <button id="generate-btn" class="mt-3 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:bg-indigo-400 disabled:cursor-not-allowed">
                        Generate Full Report
                    </button>
                </div>
            </div>
             <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
                 <h2 class="text-2xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Step 2 (Optional): Get Local Astrological Forecast</h2>
                 <p class="text-gray-400 text-sm mb-4 italic">This generates a standalone chart of the sky for a specific location and time, which can be used as a contextual overlay. For a full transit analysis, provide this data to your Poetic Brain along with the main report.</p>
                 <p class="text-gray-400 text-sm mb-4 italic font-semibold">Note: This app is built to generate input for astrology AI apps (GPTs). If you only generate the astrological weather (Step 2) without a natal chart, it won’t connect to personal dynamics and will be symbolically meaningless.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                        <label class="text-lg text-gray-200">Location</label>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                           <input type="text" id="weatherLat" placeholder="Latitude (e.g. 30.1588)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="30.1588">
                           <input type="text" id="weatherLon" placeholder="Longitude (e.g. -85.6602)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none" value="-85.6602">
                        </div>
                        <p class="text-xs text-gray-500 italic text-right pr-1 pt-1">Find coordinates with a web search, e.g., "coordinates for Panama City, FL".</p>
                    </div>
                    <div>
                        <label class="text-lg text-gray-200">Date Range (Defaults to Today)</label>
                         <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
                           <input type="text" id="weatherStartDate" placeholder="Start Date (MM-DD-YYYY)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                           <input type="text" id="weatherEndDate"   placeholder="End Date (optional)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                        </div>
                    </div>
                </div>
                <button id="getWeatherBtn" class="mt-4 w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Get Forecast
                </button>
            </div>


            <div id="output-section" class="bg-gray-800 p-6 rounded-lg shadow-lg hidden">
                 <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 id="report-title" class="text-2xl font-semibold text-white">Generated Report</h2>
                    <div class="flex space-x-2">
                        <button id="copy-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">Copy Markdown</button>
                        <button id="save-md-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">Save Markdown</button>
                        <button id="save-json-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">Save JSON</button>
                    </div>
                </div>
                <pre id="report-output" class="w-full h-96 bg-gray-900 text-gray-300 rounded-md p-4 overflow-auto font-mono text-sm whitespace-pre-wrap"></pre>
            </div>
             <div id="message-box" class="fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg hidden"></div>
        </main>
    </div>

    <script>
        // --- DOM Elements ---
        const generateBtn = document.getElementById('generate-btn');
        const getWeatherBtn = document.getElementById('getWeatherBtn');
        const outputSection = document.getElementById('output-section');
        const reportOutput = document.getElementById('report-output');
        const reportTitle = document.getElementById('report-title');
        const copyBtn = document.getElementById('copy-btn');
        const saveJsonBtn = document.getElementById('save-json-btn');
        const saveMdBtn = document.getElementById('save-md-btn');
        const messageBox = document.getElementById('message-box');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const weatherStartDateInput = document.getElementById('weatherStartDate');
        const weatherEndDateInput = document.getElementById('weatherEndDate');
        const relocationToggle = document.getElementById('relocationToggle');
        const relocationFields = document.getElementById('relocationFields');
        const relocationCoordsInput = document.getElementById('relocationCoords');
        const relocationError = document.getElementById('relocationError');
        const synastryToggle = document.getElementById('synastryToggle');
        const relationalContextStack = document.getElementById('relational-context-stack');
        const contextReadout = document.getElementById('context-readout');

        // --- Global State ---
        let fullReportData = {};
        let markdownReport = '';
        let contextCheckTimeout;

        // --- API & LOCAL ENGINE CONFIG ---
        const ORBS = { "conjunction": 8, "opposition": 8, "square": 5, "trine": 6, "sextile": 4 };
        const ASPECT_DEGREES = { "conjunction": 0, "opposition": 180, "square": 90, "trine": 120, "sextile": 60 };
        const HOUSE_NAMES = ["First_House", "Second_House", "Third_House", "Fourth_House", "Fifth_House", "Sixth_House", "Seventh_House", "Eighth_House", "Ninth_House", "Tenth_House", "Eleventh_House", "Twelfth_House"];
        const SYMBOLS = {"conjunction": "☌", "opposition": "☍", "square": "□", "trine": "△", "sextile": "✶"};

        // --- HELPER FUNCTIONS ---
        const showMessage = (message, type = 'error') => {
            messageBox.textContent = message;
            messageBox.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg ${type === 'error' ? 'bg-red-600' : 'bg-green-600'}`;
            messageBox.classList.remove('hidden');
            messageBox.classList.add('animate-fade-in-out');
            setTimeout(() => { messageBox.classList.add('hidden'); messageBox.classList.remove('animate-fade-in-out'); }, 7900);
        };

        const parseCoordinate = (input) => {
            let s = String(input).trim();
            if (!s) throw new Error("Coordinate input is empty.");
            let sign = /[SW]/i.test(s) ? -1 : 1;
            s = s.replace(/[NSEW]/ig, '');
            if (s.startsWith('-')) { sign = -1; s = s.slice(1); }
            s = s.replace(/[°º]/g, ' ').replace(/[\'′’]/g, ' ').replace(/[\"″]/g, ' ');
            const parts = s.trim().split(/\s+/).filter(Boolean);
            if (parts.length === 0) throw new Error(`Invalid coordinate format for "${input}".`);

            const deg = parseFloat(parts[0]);
            if (isNaN(deg)) throw new Error(`Invalid degrees in coordinate "${input}".`);
            const min = parts[1] ? parseFloat(parts[1]) : 0;
            const sec = parts[2] ? parseFloat(parts[2]) : 0;
            if ((parts[1] && isNaN(min)) || (parts[2] && isNaN(sec))) {
                throw new Error(`Invalid minutes or seconds in coordinate "${input}".`);
            }
            const val = Math.abs(deg) + (min / 60) + (sec / 3600);
            return sign * val;
        };

        const parseCombinedCoords = (txt) => {
            if (!txt) throw new Error("Coordinate input is empty.");
            let parts = txt.split(',');
            if (parts.length >= 2) {
                const latitude = parseCoordinate(parts[0]);
                const longitude = parseCoordinate(parts.slice(1).join(','));
                return { latitude, longitude };
            }
            const match = txt.match(/([\d°º'"′″\.\s+-]+[NS])[^\dA-Z+-]*([\d°º'"′″\.\s+-]+[EW])/i);
            if (match) return { latitude: parseCoordinate(match[1]), longitude: parseCoordinate(match[2]) };
            throw new Error('Invalid combined coordinate format.');
        };

        const getSubjectData = (personPrefix) => {
            const name = document.getElementById(`name${personPrefix}`).value;
            const city = document.getElementById(`city${personPrefix}`).value;
            const state = document.getElementById(`state${personPrefix}`).value;
            const date = document.getElementById(`date${personPrefix}`).value;
            const time = document.getElementById(`time${personPrefix}`).value;
            const timezone = document.getElementById(`offset${personPrefix}`).value;
            const nation = document.getElementById(`nation${personPrefix}`).value;
            const zodiac_type = document.getElementById(`zodiac${personPrefix}`).value;

            // Basic validation for required fields
            if (!name || !city || !state || !date || !time || !nation) {
                return null;
            }
            // Date and time format validation
            if (!/^\d{2}-\d{2}-\d{4}$/.test(date) || !/^\d{2}:\d{2}$/.test(time)) {
                return null;
            }

            let latitude, longitude;
            const coordMode = document.querySelector(`input[name="coordMode${personPrefix}"]:checked`).value;

            try {
                if (coordMode === 'combined') {
                    const astroValue = document.getElementById(`astro${personPrefix}`).value;
                    if (!astroValue) return null;
                    const coords = parseCombinedCoords(astroValue);
                    latitude = coords.latitude;
                    longitude = coords.longitude;
                } else {
                    const latValue = document.getElementById(`lat${personPrefix}`).value;
                    const lonValue = document.getElementById(`lon${personPrefix}`).value;
                    if (!latValue || !lonValue) return null;
                    latitude = parseCoordinate(latValue);
                    longitude = parseCoordinate(lonValue);
                }
                if (isNaN(latitude) || isNaN(longitude)) {
                   return null;
                }
            } catch (error) {
                // Don't show a popup for real-time validation, just return null
                return null;
            }

            const [month, day, year] = date.split('-').map(Number);
            const [hour, minute] = time.split(':').map(Number);

            return { name, city, state, date, time, timezone, latitude, longitude, year, month, day, hour, minute, nation, zodiac_type };
        };

        const getChartDataFromApi = async (payload) => {
            const res = await fetch('/.netlify/functions/astrology', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const text = await res.text();
            let responsePayload;

            try {
                responsePayload = JSON.parse(text);
            } catch {
                console.error('Non-JSON response from Netlify function:', text);
                throw new Error(`Server returned invalid data (status ${res.status}):\n` + text);
            }

            if (!res.ok) {
                throw new Error(responsePayload.error || 'An unknown server error occurred.');
            }

            return responsePayload;
        };

        const calculateAspects = (chartA, chartB, orbOverrides = {}) => {
            const aspects = [];
            const planetsA = chartA.planets_names_list.concat(chartA.axial_cusps_names_list);
            const planetsB = chartB.planets_names_list.concat(chartB.axial_cusps_names_list);

            for (const p1Name of planetsA) {
                const p1 = chartA[p1Name.toLowerCase()];
                if (!p1) continue;
                for (const p2Name of planetsB) {
                    const p2 = chartB[p2Name.toLowerCase()];
                    if (!p2) continue;
                    // Avoid self-aspects in natal calculations
                    if (chartA === chartB && p1.name === p2.name) continue;

                    const diff = Math.abs((p1.abs_pos - p2.abs_pos + 180) % 360 - 180);
                    for (const [aspectName, aspectDeg] of Object.entries(ASPECT_DEGREES)) {
                        const orbLimit = orbOverrides[aspectName] || ORBS[aspectName];
                        const orb = Math.abs(diff - aspectDeg);
                        if (orb < orbLimit) {
                            aspects.push({
                                p1_name: p1.name, p2_name: p2.name,
                                p1_pos: p1.position, p2_pos: p2.position,
                                aspect: aspectName, orb: parseFloat(orb.toFixed(2))
                            });
                        }
                    }
                }
            }
            return aspects;
        };

        const calculateHouseOverlays = (planetsChart, housesChart) => {
            const overlays = {};
            const houseCusps = HOUSE_NAMES.map(name => housesChart[name.toLowerCase()].abs_pos);

            for (const planetName of planetsChart.planets_names_list) {
                const planet = planetsChart[planetName.toLowerCase()];
                if (!planet) continue;

                for (let i = 0; i < 12; i++) {
                    const cuspStart = houseCusps[i];
                    const cuspEnd = houseCusps[(i + 1) % 12];

                    let inHouse = false;
                    if (cuspStart < cuspEnd) {
                        if (planet.abs_pos >= cuspStart && planet.abs_pos < cuspEnd) inHouse = true;
                    } else { // Wraps around 0° Aries
                        if (planet.abs_pos >= cuspStart || planet.abs_pos < cuspEnd) inHouse = true;
                    }

                    if (inHouse) {
                        overlays[planet.name] = HOUSE_NAMES[i];
                        break;
                    }
                }
            }
            return overlays;
        };
        
        // --- RELATIONAL CONTEXT STACK LOGIC ---
        async function updateRelationalContext() {
            const personAData = getSubjectData('A');
            const personBData = getSubjectData('B');

            if (!personAData || !personBData) {
                relationalContextStack.classList.add('hidden');
                return;
            }

            try {
                // Fetch both charts quietly for analysis
                const [chartA, chartB] = await Promise.all([
                    getChartDataFromApi({ subject: personAData }).then(r => r.data.subject),
                    getChartDataFromApi({ subject: personBData }).then(r => r.data.subject)
                ]);

                const synastryAspects = calculateAspects(chartA, chartB);
                const findings = [];

                // 1. shared_vector_presence
                if (synastryAspects.some(a => a.orb <= 2.0)) {
                    findings.push('<li>These two charts show active mutual resonance (aspects within 2° orb).</li>');
                }

                // 2. angle_contact_check
                const angles = ['Ascendant', 'Descendant', 'Medium_Coeli', 'Imum_Coeli'];
                if (synastryAspects.some(a => angles.includes(a.p1_name) || angles.includes(a.p2_name))) {
                    findings.push('<li>There’s at least one strong contact to an angular point.</li>');
                }

                // 3. 29°_crisis_flag
                if (synastryAspects.some(a => a.p1_pos >= 29 || a.p2_pos >= 29)) {
                    findings.push('<li>A 29° placement is involved in a tension aspect.</li>');
                }
                
                // 4. echo_loop_flag
                const tightAspects = synastryAspects.filter(a => a.orb < 1.0);
                const echoLoops = [];
                for(const aspect1 of tightAspects) {
                    for (const aspect2 of tightAspects) {
                        if(aspect1.p1_name === aspect2.p2_name && aspect1.p2_name === aspect2.p1_name) {
                             if (!echoLoops.find(p => p.includes(aspect1.p1_name) && p.includes(aspect1.p2_name))) {
                                echoLoops.push([aspect1.p1_name, aspect1.p2_name]);
                             }
                        }
                    }
                }
                if (echoLoops.length > 0) {
                     findings.push(`<li>At least one potential Echo Loop detected (${echoLoops.map(p => p.join('/')).join(', ')}).</li>`);
                }

                // 5. overlay_pressure_zone
                const overlaysA_in_B = calculateHouseOverlays(chartA, chartB);
                const overlaysB_in_A = calculateHouseOverlays(chartB, chartA);
                const pressureHouses = ['Fourth_House', 'Seventh_House', 'Twelfth_House'];
                const pressureOverlays = Object.values(overlaysA_in_B).some(h => pressureHouses.includes(h)) ||
                                        Object.values(overlaysB_in_A).some(h => pressureHouses.includes(h));
                if (pressureOverlays) {
                    findings.push('<li>A planet falls in a pressure zone (4th, 7th, or 12th house overlay).</li>');
                }

                if (findings.length > 0) {
                    contextReadout.innerHTML = findings.join('');
                    relationalContextStack.classList.remove('hidden');
                } else {
                    contextReadout.innerHTML = '<li>No significant geometric links detected based on the core flags.</li>';
                    relationalContextStack.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Context Stack Error:", error);
                relationalContextStack.classList.add('hidden');
            }
        }


        // --- MARKDOWN FORMATTING ENGINE ---
        const formatMdNatalChart = (personData) => {
            const { details, chart: apiResponse } = personData;
            // The API response for a natal call is nested under 'data', then 'subject'
            const chart = apiResponse.data.subject;
            const aspects = apiResponse.aspects;

            const degToDMS = (deg) => `${Math.floor(deg)}°${Math.round((deg % 1) * 60).toString().padStart(2, '0')}'`;

            let report = [`# ${details.name}`];
            report.push(`> Birth Location: ${details.city}, ${details.state} *(For reference only; uses coordinates below)*`);
            report.push(`> Birth Coordinates: ${details.latitude.toFixed(4)}, ${details.longitude.toFixed(4)}`);
            report.push(`> Birth Date: ${details.date}`);
            report.push(`> Birth Time: ${details.time} (Timezone: ${details.timezone})`);

            report.push(`\n## Natal Chart – ${chart.houses_system_name}`);
            let planetTable = '| Planet | AEL | Sign | Pos | 29° |\n|---|---|---|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p) planetTable += `| ${p.name} | ${p.abs_pos.toFixed(2)}° | ${p.sign} | ${degToDMS(p.position)} | ${p.position >= 29 ? '★' : ''} |\n`;
            });
            report.push(planetTable);

            report.push(`\n## Planet House Placements`);
             let placementTable = '| Planet | House |\n|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p && p.house) placementTable += `| ${p.name} | ${p.house} |\n`;
            });
            report.push(placementTable);

            report.push(`\n## Natal Aspects`);
            const aspectList = aspects.map(a => {
                const core = a.orbit <= 3 ? ' (Core Pressure Point)' : '';
                return `- ${a.p1_name} ${SYMBOLS[a.aspect.toLowerCase()]} ${a.p2_name} (${a.orbit.toFixed(1)}°)${core}`;
            }).join('\n');
            report.push(aspectList || '- None found.');

            return report.join('\n');
        };

        const formatMdTransit = (transitData, personData, isRelocated) => {
            const chart = transitData.chart.data.subject;
            const aspects = transitData.aspects;
            const degToDMS = (deg) => `${Math.floor(deg)}°${Math.round((deg % 1) * 60).toString().padStart(2, '0')}'`;

            let report = [];
            if (isRelocated) {
                report.push(`\n### Relocation Overlay for ${transitData.date}`);
                const lat = chart.lat;
                const lon = chart.lng;
                if (typeof lat === 'number' && typeof lon === 'number') {
                    report.push(`*Houses & Angles recalculated for ${lat.toFixed(4)}, ${lon.toFixed(4)}*`);
                }
            } else {
                report.push(`\n## Transits for ${transitData.date}`);
                report.push(`*Transits calculated for birth location: ${personData.details.city}.*`);
            }
            let planetTable = '| Planet | AEL | Sign | Pos | 29° |\n|---|---|---|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p) planetTable += `| ${p.name} | ${p.abs_pos.toFixed(2)}° | ${p.sign} | ${degToDMS(p.position)} | ${p.position >= 29 ? '★' : ''} |\n`;
            });
            report.push(planetTable);

            report.push(`\n### Transit → Natal Aspects (${personData.details.name})`);
            const aspectList = aspects.map(a => {
                 const core = a.orb <= 3 ? ' (Core Pressure Point)' : '';
                return `- Transiting ${a.p1_name} ${SYMBOLS[a.aspect.toLowerCase()]} Natal ${a.p2_name} (${a.orb.toFixed(1)}°)${core}`;
            }).join('\n');
            report.push(aspectList || '- None found.');

            return report.join('\n');
        };

        const formatMdWeather = (weatherData) => {
            const chart = weatherData.chart.data.subject;
            const degToDMS = (deg) => `${Math.floor(deg)}°${Math.round((deg % 1) * 60).toString().padStart(2, '0')}'`;

            let report = [`# Local Astrological Forecast for ${weatherData.date}`];
            report.push(`> This is a standalone chart of the sky for the specified date and location. It is not a transit report and does not contain aspects to a natal chart.`);

            let planetTable = '| Planet | AEL | Sign | Pos |\n|---|---|---|---|\n';
            chart.planets_names_list.forEach(pName => {
                const p = chart[pName.toLowerCase()];
                if(p) planetTable += `| ${p.name} | ${p.abs_pos.toFixed(2)}° | ${p.sign} | ${degToDMS(p.position)} |\n`;
            });
            report.push(planetTable);
            return report.join('\n\n');
        };

        const formatMdSynastry = (synData, personA, personB) => {
            const aspects = synData.aspects || [];
            // The synastry response directly contains the two subjects' data
            const chartA = synData.data.first_subject;
            const chartB = synData.data.second_subject;
            const aInB = calculateHouseOverlays(chartA, chartB);
            const bInA = calculateHouseOverlays(chartB, chartA);

            const clean = h => h.replace(/_/g, ' ');

            let report = [`## Synastry: ${personA.details.name} & ${personB.details.name}`];
            report.push('### Interplanetary Aspects');
            if (aspects.length) {
                aspects.forEach(a => {
                    const core = a.orb <= 3 ? ' (Core Pressure Point)' : '';
                    report.push(`- ${a.p1_name} ${SYMBOLS[a.aspect.toLowerCase()]} ${a.p2_name} (${a.orb.toFixed(1)}°)${core}`);
                });
            } else {
                report.push('- None found.');
            }

            report.push(`\n### ${personA.details.name}'s Planets in ${personB.details.name}'s Houses`);
            const aLines = Object.entries(aInB).map(([p, h]) => `- ${p} in ${clean(h)}`);
            report.push(aLines.join('\n') || '- None.');

            report.push(`\n### ${personB.details.name}'s Planets in ${personA.details.name}'s Houses`);
            const bLines = Object.entries(bInA).map(([p, h]) => `- ${p} in ${clean(h)}`);
            report.push(bLines.join('\n') || '- None.');

            return report.join('\n');
        };


        // --- MAIN REPORT GENERATION LOGIC (RESTRUCTURED) ---
        async function generateReport() {
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';
            outputSection.classList.add('hidden');

            try {
                const personAData = getSubjectData('A');
                if (!personAData) {
                    throw new Error("Person A's data is incomplete or invalid.");
                }

                const personBData = getSubjectData('B');
                const useSynastry = personBData && synastryToggle.checked;

                let markdownParts = [
                    `> ★ = Planet is within the last degree of a sign (the 29th degree).\n> **Aspect Symbols:** ☌ = Conjunction, ☍ = Opposition, □ = Square, △ = Trine, ✶ = Sextile\n> **"Core Pressure Point"** = aspect orb ≤ 3° (the strongest and most direct influences).`
                ];
                fullReportData = { schema: "WM-Chart-1.0" };

                if (useSynastry) {
                    // --- SYNASTRY REPORT ---
                    const payload = {
                        first_subject: personAData,
                        second_subject: personBData
                    };
                    const synastryResponse = await getChartDataFromApi(payload);

                    // We need the natal aspects, which aren't in the synastry call, so we fetch them separately.
                    const natalAFromSynastry = await getChartDataFromApi({ subject: personAData });
                    const natalBFromSynastry = await getChartDataFromApi({ subject: personBData });

                    fullReportData.person_a = { details: personAData, chart: natalAFromSynastry };
                    fullReportData.person_b = { details: personBData, chart: natalBFromSynastry };
                    fullReportData.synastry = synastryResponse;
                    
                    markdownParts.push(formatMdNatalChart(fullReportData.person_a));
                    markdownParts.push(formatMdNatalChart(fullReportData.person_b));
                    markdownParts.push(formatMdSynastry(synastryResponse, fullReportData.person_a, fullReportData.person_b));

                } else {
                    // --- NATAL-ONLY REPORT ---
                    const apiResponseA = await getChartDataFromApi({ subject: personAData });
                    fullReportData.person_a = { details: personAData, chart: apiResponseA };
                    markdownParts.push(formatMdNatalChart(fullReportData.person_a));

                    if (personBData) {
                        const apiResponseB = await getChartDataFromApi({ subject: personBData });
                        fullReportData.person_b = { details: personBData, chart: apiResponseB };
                        markdownParts.push(formatMdNatalChart(fullReportData.person_b));
                    }
                }

                // --- TRANSIT CALCULATIONS (COMMON LOGIC) ---
                let startStr = startDateInput.value;
                 if (!startStr) {
                    const today = new Date();
                    startStr = `${String(today.getMonth() + 1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}-${today.getFullYear()}`;
                }

                const [sm, sd, sy] = startStr.split('-').map(Number);
                const start = new Date(Date.UTC(sy, sm - 1, sd));
                let end = start;
                if (endDateInput.value) {
                    const [em, ed, ey] = endDateInput.value.split('-').map(Number);
                    end = new Date(Date.UTC(ey, em - 1, ed));
                }

                fullReportData.transits = [];
                const relocationChecked = relocationToggle.checked;
                let relocationCoords = getRelocationLatLonOrNull();
                if (relocationChecked && !relocationCoords) throw new Error("Relocation coordinates are invalid.");

                for (let d = new Date(start); d <= end; d.setUTCDate(d.getUTCDate() + 1)) {
                     const ds = (d.getUTCMonth()+1).toString().padStart(2,'0') + '-' +
                                 d.getUTCDate().toString().padStart(2,'0') + '-' +
                                 d.getUTCFullYear();

                    // Person A Transits
                    const transitSubjectA = { ...personAData, year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(), name: `Transit ${ds}` };
                    const transitApiResponseA = await getChartDataFromApi({ subject: transitSubjectA });
                    const chartA = fullReportData.person_a.chart.data.subject;
                    const entryA = { person: 'a', date: ds, chart: transitApiResponseA, aspects: calculateAspects(transitApiResponseA.data.subject, chartA), location_type: 'birth' };
                    fullReportData.transits.push(entryA);
                    markdownParts.push(formatMdTransit(entryA, fullReportData.person_a, false));

                    // Relocation for A
                    if (relocationChecked && relocationCoords) {
                         const relocationSubjectA = { ...transitSubjectA, latitude: relocationCoords.latitude, longitude: relocationCoords.longitude, city: 'Relocated', nation: '' };
                         const relocationApiResponseA = await getChartDataFromApi({ subject: relocationSubjectA });
                         const entryRelocA = { person: 'a', date: ds, chart: relocationApiResponseA, aspects: calculateAspects(relocationApiResponseA.data.subject, chartA), location_type: 'relocated' };
                         fullReportData.transits.push(entryRelocA);
                         markdownParts.push(formatMdTransit(entryRelocA, fullReportData.person_a, true));
                    }

                    // Person B Transits (if they exist)
                    if (fullReportData.person_b) {
                        const transitSubjectB = { ...personBData, year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(), name: `Transit ${ds}` };
                        const transitApiResponseB = await getChartDataFromApi({ subject: transitSubjectB });
                        const chartB = fullReportData.person_b.chart.data.subject;
                        const entryB = { person: 'b', date: ds, chart: transitApiResponseB, aspects: calculateAspects(transitApiResponseB.data.subject, chartB), location_type: 'birth' };
                        fullReportData.transits.push(entryB);
                        markdownParts.push(formatMdTransit(entryB, fullReportData.person_b, false));

                         // Relocation for B
                        if (relocationChecked && relocationCoords) {
                             const relocationSubjectB = { ...transitSubjectB, latitude: relocationCoords.latitude, longitude: relocationCoords.longitude, city: 'Relocated', nation: '' };
                             const relocationApiResponseB = await getChartDataFromApi({ subject: relocationSubjectB });
                             const entryRelocB = { person: 'b', date: ds, chart: relocationApiResponseB, aspects: calculateAspects(relocationApiResponseB.data.subject, chartB), location_type: 'relocated' };
                             fullReportData.transits.push(entryRelocB);
                             markdownParts.push(formatMdTransit(entryRelocB, fullReportData.person_b, true));
                        }
                    }
                }

                markdownReport = markdownParts.join('\n\n');
                reportTitle.textContent = "Generated Report";
                reportOutput.textContent = markdownReport;
                outputSection.classList.remove('hidden');

            } catch (error) {
                showMessage(error.message, 'error');
                console.error(error);
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Full Report';
            }
        }

        async function generateWeatherReport() {
            getWeatherBtn.disabled = true;
            getWeatherBtn.textContent = 'Fetching...';
            outputSection.classList.add('hidden');

            try {
                const lat = parseFloat(document.getElementById('weatherLat').value);
                const lon = parseFloat(document.getElementById('weatherLon').value);
                if (isNaN(lat) || isNaN(lon)) throw new Error("Latitude and Longitude are required for the forecast.");

                let startStr = weatherStartDateInput.value;
                if (!startStr) {
                    const today = new Date();
                    startStr = `${String(today.getMonth() + 1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}-${today.getFullYear()}`;
                }

                const [sm, sd, sy] = startStr.split('-').map(Number);
                const start = new Date(Date.UTC(sy, sm - 1, sd));
                let end = start;
                if (weatherEndDateInput.value) {
                    const [em, ed, ey] = weatherEndDateInput.value.split('-').map(Number);
                    end = new Date(Date.UTC(ey, em - 1, ed));
                }

                let markdownParts = [];
                fullReportData = { schema: "WM-Forecast-1.0", forecasts: [] };

                for (let d = new Date(start); d <= end; d.setUTCDate(d.getUTCDate() + 1)) {
                    const ds = (d.getUTCMonth()+1).toString().padStart(2,'0') + '-' +
                                 d.getUTCDate().toString().padStart(2,'0') + '-' +
                                 d.getUTCFullYear();

                    const weatherSubject = {
                        year: d.getUTCFullYear(), month: d.getUTCMonth() + 1, day: d.getUTCDate(),
                        hour: 12, minute: 0,
                        city: "Local Forecast",
                        name: `Forecast for ${ds}`,
                        latitude: lat, longitude: lon,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                        zodiac_type: 'Tropic'
                    };

                    const apiResponse = await getChartDataFromApi({ subject: weatherSubject });
                    const weatherEntry = { date: ds, chart: apiResponse };
                    fullReportData.forecasts.push(weatherEntry);
                    markdownParts.push(formatMdWeather(weatherEntry));
                }

                markdownReport = markdownParts.join('\n\n');
                reportTitle.textContent = `Local Astrological Forecast`;
                reportOutput.textContent = markdownReport;
                outputSection.classList.remove('hidden');

            } catch(error) {
                showMessage(error.message, 'error');
                console.error(error);
            } finally {
                getWeatherBtn.disabled = false;
                getWeatherBtn.textContent = 'Get Forecast';
            }
        }

        // --- EVENT LISTENERS ---
        generateBtn.addEventListener('click', generateReport);
        getWeatherBtn.addEventListener('click', generateWeatherReport);

        copyBtn.addEventListener('click', () => {
            const textarea = document.createElement('textarea');
            textarea.value = markdownReport;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('Copied to clipboard!', 'success');
                } else {
                    showMessage('Failed to copy.', 'error');
                }
            } catch (err) {
                showMessage('Failed to copy.', 'error');
                console.error('Clipboard copy failed:', err);
            }
            document.body.removeChild(textarea);
        });

        const downloadFile = (filename, content, contentType) => {
            const element = document.createElement('a');
            const blob = new Blob([content], { type: contentType });
            element.href = URL.createObjectURL(blob);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
            URL.revokeObjectURL(element.href);
        };

        const generateFilename = (extension) => {
            const nameA = document.getElementById('nameA').value.replace(/\s+/g, '_') || 'PersonA';
            const nameB = document.getElementById('nameB').value.replace(/\s+/g, '_');
            const finalName = nameB ? `${nameA}_and_${nameB}` : nameA;
            
            const startDateStr = startDateInput.value;
            const endDateStr = endDateInput.value;
            let datePart = `_on_${new Date().toISOString().split('T')[0]}`;

            if (startDateStr) {
                const reformatDate = (dateStr) => {
                    if (!/^\d{2}-\d{2}-\d{4}$/.test(dateStr)) return new Date().toISOString().split('T')[0];
                    const [m, d, y] = dateStr.split('-');
                    return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                }
                const formattedStart = reformatDate(startDateStr);
                if (endDateStr && endDateStr !== startDateStr) {
                    const formattedEnd = reformatDate(endDateStr);
                    datePart = `_from_${formattedStart}_to_${formattedEnd}`;
                } else {
                    datePart = `_on_${formattedStart}`;
                }
            }
            return `report_${finalName}${datePart}.${extension}`;
        };

        saveJsonBtn.addEventListener('click', () => {
            const filename = generateFilename('json');
            downloadFile(filename, JSON.stringify(fullReportData, null, 2), 'application/json');
        });

        saveMdBtn.addEventListener('click', () => {
            const filename = generateFilename('md');
            downloadFile(filename, markdownReport, 'text/markdown');
        });

        document.querySelectorAll('input[name^="coordMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const personPrefix = e.target.name.includes('A') ? 'A' : 'B';
                const isCombined = e.target.value === 'combined';
                document.getElementById(`combinedCoords${personPrefix}`).style.display = isCombined ? 'block' : 'none';
                document.getElementById(`manualCoords${personPrefix}`).style.display = isCombined ? 'none' : 'grid';
                if (personPrefix === 'B') triggerContextCheck();
            });
        });

        relocationToggle.addEventListener('change', () => {
            relocationFields.style.display = relocationToggle.checked ? 'block' : 'none';
        });

        relocationCoordsInput.addEventListener('input', () => {
            if (relocationToggle.checked) {
                getRelocationLatLonOrNull();
            }
        });

        function getRelocationLatLonOrNull() {
            if (!relocationToggle.checked) return null;
            try {
                const coords = parseCombinedCoords(relocationCoordsInput.value);
                relocationError.classList.add('hidden');
                return coords;
            } catch (e) {
                relocationError.textContent = e.message;
                relocationError.classList.remove('hidden');
                return null;
            }
        }
        
        // --- Trigger for the Relational Context Stack ---
        function triggerContextCheck() {
            clearTimeout(contextCheckTimeout);
            contextCheckTimeout = setTimeout(updateRelationalContext, 1000); // Debounce to avoid rapid firing
        }
        
        document.querySelectorAll('.person-b-field').forEach(field => {
            field.addEventListener('input', triggerContextCheck);
            field.addEventListener('change', triggerContextCheck); // For select dropdown
        });

    </script>
</body>
</html>
    <!DOCTYPE html>
    <!-- COPILOT_GUIDE: CLEAR MIRROR DOWNSTREAM ONLY
     - Math Brain payload is geometry-only. Do NOT generate narrative (Clear Mirror) here.
     - Never emit keys named field, voice, or map back to serverless layer.
     - Provide RAVEN_NUDGE + Mirror flags so downstream Poetic Brain (Raven Calder) can translate FIELD → MAP → VOICE.
     - Use hooks (≤2° preference), seismograph (magnitude, valence, volatility, scaling_strategy/confidence), retrograde flags, and True/Mean Node distinctions.
     - Timezone baseline preference: America/Chicago (Central). Emit TZ check hints; do not auto-correct silently.
     - Add Mini Glossary + Raven Checklist at footer for non-Raven consumers.
     - TODO[RAVEN]: Read seismograph scaling to nuance stability vs emergent signal.
     - TODO[RAVEN]: If multiple retrograde_involved hooks, surface a "revision/recursion" nuance.
  
        === STYLE NOTE: TERMINOLOGY LAYERING (Woven Map) ===
        Purpose: Prevent collapse into mechanistic language ("wiring"). Prefer mythic metaphors by layer:
            1. Natal / Personality Context → "Reveal the Weave" (structural identity, natal pattern coherence)
            2. Transit (daily / short-term) → "Trace the Threads" (live activations tugged or loosening)
            3. Transit Aggregation / Macro Patterns → "Currents" / "Seismograph" (field states, symbolic weather, volatility)
        Raven Calder (Poetic Brain) alone produces narrative/interpretation. Math Brain supplies geometry + nudges only.
        If NOT Raven Calder GPT:
            - Auto-append Mini Glossary footer.
            - Reinforce role distinction: "Math Brain finds the coordinates; Poetic Brain translates the weave."
        
    -->
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Woven Map Math Brain - Pure Astrological Geometry</title>
                <!-- Tailwind CSS (compiled) -->
                <link href="/dist/output.css" rel="stylesheet">
                <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
                <style>
            :root {
                /* Modern color palette */
                --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                --bg-dark: #0f0f14;
                --bg-card: rgba(255, 255, 255, 0.03);
                --bg-card-hover: rgba(255, 255, 255, 0.05);
                --border-subtle: rgba(255, 255, 255, 0.08);
                --border-active: rgba(102, 126, 234, 0.5);
                --text-primary: #f3f4f6;
                --text-secondary: #9ca3af;
                --text-muted: #6b7280;
                --accent-teal: #14b8a6;
                --accent-purple: #8b5cf6;
                --accent-blue: #3b82f6;
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
                background-color: var(--bg-dark);
                background: var(--bg-dark);
                color: var(--text-primary);
                line-height: 1.6;
                min-height: 100vh;
                position: relative;
                overflow-x: hidden;
            }

            /* Subtle background gradient */
            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at 20% 80%, rgba(102, 126, 234, 0.08) 0%, transparent 50%),
                            radial-gradient(circle at 40% 40%, rgba(20, 184, 166, 0.04) 0%, transparent 50%);
                pointer-events: none;
            }

            /* Modern container styling */
            .container {
                position: relative;
                z-index: 1;
            }

            /* Enhanced header styling */
            header h1 {
                background: var(--primary-gradient);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: -0.02em;
                line-height: 1.2;
            }

            /* Tab navigation with modern styling */
            .bg-gray-800 {
                background: var(--bg-card) !important;
                border: 1px solid var(--border-subtle);
                backdrop-filter: blur(10px);
            }

            /* Modern button styling */
            .bg-teal-600 {
                background: var(--primary-gradient) !important;
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            }

            .hover\:bg-teal-700:hover {
                transform: translateY(-1px);
                box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4) !important;
            }

            /* Form enhancements */
            .bg-gray-700 {
                background: var(--bg-card) !important;
                border: 1px solid var(--border-subtle);
                backdrop-filter: blur(10px);
            }

            .bg-gray-700:hover {
                background: var(--bg-card-hover) !important;
                border-color: rgba(255, 255, 255, 0.1);
            }

            /* Input field styling */
            input, select, textarea {
                background: rgba(255, 255, 255, 0.05) !important;
                border: 2px solid var(--border-subtle) !important;
                border-radius: 12px !important;
                color: var(--text-primary) !important;
                transition: all 0.3s ease;
            }

            input:focus, select:focus, textarea:focus {
                background: rgba(255, 255, 255, 0.08) !important;
                border-color: var(--border-active) !important;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1) !important;
                outline: none !important;
            }

            input:hover, select:hover, textarea:hover {
                border-color: rgba(255, 255, 255, 0.15) !important;
            }

            /* Enhanced radio button labels */
            label {
                background: var(--bg-card) !important;
                border: 2px solid var(--border-subtle) !important;
                border-radius: 12px !important;
                transition: all 0.3s ease !important;
                cursor: pointer !important;
                backdrop-filter: blur(10px) !important;
            }

            label:hover {
                background: var(--bg-card-hover) !important;
                border-color: var(--accent-teal) !important;
                transform: translateY(-1px) !important;
                box-shadow: 0 4px 12px rgba(20, 184, 166, 0.2) !important;
            }

            /* Card styling enhancements */
            .rounded-lg {
                border-radius: 16px !important;
            }

            .rounded {
                border-radius: 12px !important;
            }

            /* Smooth transitions for interactive elements */
            a, button, input, select, textarea, .clickable {
                transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* Button improvements */
            button:hover {
                transform: translateY(-1px);
            }

            button:active {
                transform: translateY(0);
            }

            /* Custom scrollbar */
            ::-webkit-scrollbar {
                width: 10px;
            }

            ::-webkit-scrollbar-track {
                background: var(--bg-dark);
            }

            ::-webkit-scrollbar-thumb {
                background: var(--border-subtle);
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: var(--border-active);
            }

            /* Animation utilities */
            .animate-fade-in-out {
                animation: fadeInOut 8s ease-in-out forwards;
            }

            @keyframes fadeInOut {
                0%, 100% { opacity: 0; transform: translateY(-20px); }
                10%, 90% { opacity: 1; transform: translateY(0); }
            }

            /* Loading states */
            .loading::after {
                content: '';
                width: 1rem;
                height: 1rem;
                border: 2px solid transparent;
                border-top-color: currentColor;
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
                display: inline-block;
                margin-left: 0.5rem;
            }

            @keyframes spin {
                to { transform: rotate(360deg); }
            }
        </style>
                <script>
                    // Warn if Tailwind didn’t load (class not applied within a tick)
                    window.addEventListener('DOMContentLoaded', function(){
                        const probe = document.createElement('div');
                        probe.className = 'hidden bg-gray-800';
                        document.body.appendChild(probe);
                        const style = window.getComputedStyle(probe);
                        const looksTailwind = style && style.backgroundColor && style.backgroundColor !== 'rgba(0, 0, 0, 0)';
                        if (!looksTailwind) {
                            console.warn('[Tailwind] Compiled CSS might not be loaded (check /dist/output.css 200).');
                        }
                        probe.remove();
                    });
                </script>
        

        <!-- Self-hosted Auth0 SDK - sequential load with readiness promise -->
                    <script>
                        (function(){
                            var resolveReady, rejectReady;
                            window.__auth0Ready = new Promise(function(res, rej){ resolveReady = res; rejectReady = rej; });
                            function injectScript(url){
                                return new Promise(function(res, rej){
                                    var s = document.createElement('script');
                                    s.src = url;
                                    s.onload = function(){
                                        // Check if Auth0 SDK is properly loaded and createAuth0Client is available
                                        console.log('[SDK Loader] Script loaded from', url);
                                        console.log('[SDK Loader] window.auth0:', typeof window.auth0);
                                        console.log('[SDK Loader] window.auth0?.createAuth0Client:', typeof window.auth0?.createAuth0Client);
                                        console.log('[SDK Loader] global createAuth0Client:', typeof createAuth0Client);
                                        
                                        if (typeof window.auth0 !== 'undefined' && typeof window.auth0.createAuth0Client === 'function') {
                                            console.info('[Auth0] SDK loaded from', url);
                                            res(true);
                                        } else {
                                            rej(new Error('SDK loaded but window.auth0.createAuth0Client missing'));
                                        }
                                    };
                                    s.onerror = function(e){ rej(new Error('Failed to load '+url)); };
                                    document.head.appendChild(s);
                                });
                            }
                            function fetchText(url){
                                return fetch(url, { method:'GET', cache:'no-store' })
                                    .then(function(res){ if(!res.ok) throw new Error('HTTP '+res.status+' for '+url); return res.text(); });
                            }
                            (async function(){
                                var paths = [
                                    '/public/vendor/auth0-spa-js.production.js',
                                    '/vendor/auth0-spa-js.production.js',
                                    'https://cdn.auth0.com/js/auth0-spa-js/2.1.3/auth0-spa-js.production.js'
                                ];
                                for (var i=0;i<paths.length;i++){
                                    var url = paths[i];
                                    try{
                                        // For cross-origin CDN, skip prefetch content check (CORS may block text())
                                        if (/^https?:\/\//.test(url)) {
                                            await injectScript(url);
                                        } else {
                                            var txt = await fetchText(url);
                                            var looksJS = /createAuth0Client\s*=/.test(txt) || txt.indexOf('Auth0Client') !== -1;
                                            if (!looksJS) { console.warn('[Auth0] Not JS at', url); continue; }
                                            await injectScript(url);
                                        }
                                        resolveReady(true);
                                        return;
                                    } catch(e){
                                        console.warn('[Auth0] Loader attempt failed for', url, e.message || e);
                                    }
                                }
                                console.error('[Auth0] Unable to load SDK from any known path');
                                rejectReady(new Error('Auth0 SDK not loaded'));
                                try { document.querySelectorAll('.auth-btn').forEach(function(btn){ if(btn){ btn.disabled=false; btn.addEventListener('click', function(){ alert('Auth is unavailable because the Auth0 SDK did not load. Verify /public/vendor path and _redirects.'); }); } }); } catch(_){ }
                            })();
                        })();
                    </script>
                <style>
                        /* Custom scrollbar */
            ::-webkit-scrollbar {
                width: 10px;
            }

            ::-webkit-scrollbar-track {
                background: var(--bg-dark);
            }

            ::-webkit-scrollbar-thumb {
                background: var(--border-subtle);
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: var(--border-active);
            }

            /* Range slider styling */
            input[type="range"] {
                height: 6px;
                background: var(--border-subtle);
                border-radius: 3px;
                outline: none;
            }

            input[type="range"]::-webkit-slider-thumb {
                appearance: none;
                width: 18px;
                height: 18px;
                background: var(--accent-blue);
                border-radius: 50%;
                cursor: pointer;
            }

            input[type="range"]::-moz-range-thumb {
                width: 18px;
                height: 18px;
                background: var(--accent-blue);
                border-radius: 50%;
                cursor: pointer;
                border: none;
            }

            /* Animation utilities */
            .animate-fade-in-out {
                animation: fadeInOut 8s ease-in-out forwards;
            }

            @keyframes fadeInOut {
                0%, 100% { opacity: 0; transform: translateY(-20px); }
                10%, 90% { opacity: 1; transform: translateY(0); }
            }

            /* Loading states */
            .loading::after {
                content: '';
                width: 1rem;
                height: 1rem;
                border: 2px solid transparent;
                border-top-color: currentColor;
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
                display: inline-block;
                margin-left: 0.5rem;
            }

            @keyframes spin {
                to { transform: rotate(360deg); }
            }

            /* Button improvements */
            button:hover {
                transform: translateY(-1px);
            }

            button:active {
                transform: translateY(0);
            }

            /* Smooth transitions for interactive elements */
            a, button, input, select, textarea, .clickable {
                transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), 
                            opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                            background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                            border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                            box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* Filter panel animations */
            #seismographFiltersPanel {
                transition: all 0.3s ease;
                max-height: 0;
                overflow: hidden;
            }

            #seismographFiltersPanel:not(.hidden) {
                max-height: 400px;
            }
            
            /* Seismograph chart responsiveness - prevent horizontal scrolling */
            .seismograph-content-area {
                overflow-x: auto;
                width: 100%;
            }
            
            .seismograph-content-area canvas {
                max-width: 100%;
                height: auto;
            }
            
            /* Ensure sticky controls work properly on all screen sizes */
            @media (max-width: 768px) {
                .sticky {
                    position: relative; /* Fall back to relative on very small screens */
                }
            }

            /* ---- Report Reading Surface Enhancements ---- */
            .report-surface { font-variant-ligatures:none; }
            .report-surface::-webkit-scrollbar { width:10px; }
            .report-surface::-webkit-scrollbar-track { background:rgba(31,41,55,.55); border-radius:6px; }
            .report-surface::-webkit-scrollbar-thumb { background:linear-gradient(to bottom,#0d9488,#0e7490); border-radius:6px; }
            .report-surface::-webkit-scrollbar-thumb:hover { background:linear-gradient(to bottom,#14b8a6,#06b6d4); }
            .report-surface h1, .report-surface h2, .report-surface h3 { font-family:'Inter',sans-serif; font-weight:600; letter-spacing:.5px; }
            .report-surface h1 { font-size:1.05rem; margin-top:.85rem; margin-bottom:.4rem; color:#5eead4; }
            .report-surface h2 { font-size:.95rem; margin-top:.75rem; margin-bottom:.35rem; color:#67e8f9; }
            .report-surface h3 { font-size:.85rem; margin-top:.65rem; margin-bottom:.3rem; color:#a5f3fc; }
            .report-surface code { background:#1e293b; padding:2px 4px; border-radius:4px; font-size:.9em; }
            .report-surface hr { border:0; border-top:1px solid rgba(148,163,184,.25); margin:.8rem 0; }
            .report-surface ul { list-style:disc; margin-left:1.1rem; margin-bottom:.4rem; }
            .report-surface table { border-collapse:collapse; width:100%; font-size:.72rem; margin:.6rem 0 .9rem; }
            .report-surface th, .report-surface td { border:1px solid rgba(71,85,105,.55); padding:4px 6px; }
            .report-surface th { background:#0f172a; font-weight:500; color:#7dd3fc; }
            .report-surface tr:nth-child(even){ background:rgba(30,41,59,.55); }
            .report-surface a { color:#38bdf8; text-decoration:underline; }
            .report-surface a:hover { color:#7dd3fc; }
            .report-surface .tag { display:inline-block; background:#164e63; color:#cffafe; padding:2px 6px; margin:1px 3px 1px 0; border-radius:4px; font-size:.55rem; letter-spacing:.5px; }
            .report-surface .faint { color:#64748b; }
            .report-surface .section-break { margin:1rem 0 .55rem; padding-top:.25rem; border-top:1px dashed rgba(94,234,212,.35); }
            /* Flash highlight for Show Wiring anchor scroll */
            .flash-wire { outline:3px solid currentColor; outline-offset:2px; animation:flashWire 900ms ease-in-out; }
            @media (prefers-contrast: more) { .flash-wire { outline-width:4px; } }
            @keyframes flashWire { 0%{filter:brightness(1.2);} 100%{filter:brightness(1);} }
            @media (min-width:1024px){ .report-surface { font-size:12px; } }
            
            /* Auth0 and Poetic Brain Styles */
            .auth-button {
                background-color: #4c51bf;
                color: white;
                padding: 0.5rem 1rem;
                border-radius: 0.375rem;
                font-weight: 600;
                cursor: pointer;
                border: none;
                transition: background-color 0.2s;
            }
            .auth-button:hover {
                background-color: #434190;
            }
            .auth-button[disabled]{opacity:.55;cursor:not-allowed;filter:grayscale(15%)}
            .auth-button[disabled]:hover{transform:none}
            .poetic-brain-section {
                display: none;
            }
            /* --- Minimal Utility Shim (when Tailwind is blocked) --- */
            .container{max-width:1200px;margin-left:auto;margin-right:auto}
            .mx-auto{margin-left:auto;margin-right:auto}
            .p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-8{padding:2rem}
            .px-4{padding-left:1rem;padding-right:1rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}
            .mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mb-8{margin-bottom:2rem}
            .mt-2{margin-top:.5rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}
            .text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-lg{font-size:1.125rem}
            .text-2xl{font-size:1.5rem}.text-4xl{font-size:2.25rem}
            .font-medium{font-weight:500}.font-semibold{font-weight:600}.font-bold{font-weight:700}
            .rounded{border-radius:.375rem}.rounded-md{border-radius:.375rem}.rounded-lg{border-radius:.75rem}
            .shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}
            .border{border:1px solid var(--border-subtle)}.border-b{border-bottom:1px solid var(--border-subtle)}
            .grid{display:grid}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}
            .gap-4{grid-gap:1rem}.gap-8{grid-gap:2rem}
            .flex{display:flex}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}
            .hidden{display:none}.inline-flex{display:inline-flex}
            @media(min-width:1024px){.lg\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}
            /* Color shims (already styled above, ensure presence) */
            .bg-gray-900{background-color:#111827}.bg-gray-800{background:var(--bg-card)}.bg-gray-700{background:var(--bg-card)}
            .text-white{color:#fff}.text-gray-200{color:#e5e7eb}.text-gray-300{color:#d1d5db}.text-gray-400{color:#9ca3af}
            .border-gray-600{border-color:var(--border-subtle)}.border-gray-700{border-color:var(--border-subtle)}
            .bg-teal-600{background:var(--primary-gradient)}.hover\:bg-teal-700:hover{filter:brightness(1.05)}
            .bg-indigo-600{background:#4f46e5}.hover\:bg-indigo-700:hover{filter:brightness(.9)}
            .bg-gray-500{background:#6b7280}.hover\:bg-gray-600:hover{filter:brightness(.9)}
            .bg-gray-600{background:#4b5563}.hover\:bg-gray-700:hover{filter:brightness(.9)}
            .text-teal-300{color:#5eead4}.text-teal-200{color:#99f6e4}
            .border-teal-500{border-color:rgba(20,184,166,.3)}
            .rounded-full{border-radius:9999px}
            .underline{text-decoration:underline}
            .transition-colors{transition:background-color .2s ease,color .2s ease}
            .space-y-1>*+*{margin-top:.25rem}.space-y-2>*+*{margin-top:.5rem}.space-y-3>*+*{margin-top:.75rem}.space-y-4>*+*{margin-top:1rem}.space-y-5>*+*{margin-top:1.25rem}
        </style>
        
        <!-- PDF Generation Library - Load early with fallback -->
        <script>
            // Enhanced PDF loading with multiple fallback strategies
            let pdfLibraryStatus = 'loading';
            let pdfLoadPromise = null;
            
            function createPDFLoadPromise() {
                if (pdfLoadPromise) return pdfLoadPromise;
                
                pdfLoadPromise = new Promise((resolve, reject) => {
                    // Check if already loaded
                    if (isPDFLibraryReady()) {
                        pdfLibraryStatus = 'ready';
                        resolve();
                        return;
                    }
                    
                    // Load from CDN
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js';
                    script.async = true;
                    script.defer = true;
                    
                    script.onload = () => {
                        // Give it a moment to initialize
                        setTimeout(() => {
                            if (isPDFLibraryReady()) {
                                pdfLibraryStatus = 'ready';
                                resolve();
                            } else {
                                pdfLibraryStatus = 'error';
                                reject(new Error('PDF library loaded but not functional'));
                            }
                        }, 500);
                    };
                    
                    script.onerror = () => {
                        pdfLibraryStatus = 'error';
                        reject(new Error('Failed to load PDF library from CDN'));
                    };
                    
                    document.head.appendChild(script);
                    
                    // Global timeout
                    setTimeout(() => {
                        if (pdfLibraryStatus === 'loading') {
                            pdfLibraryStatus = 'timeout';
                            reject(new Error('PDF library load timeout'));
                        }
                    }, 15000);
                });
                
                return pdfLoadPromise;
            }
            
            // Start loading immediately
            // Defer preload to idle so it never competes with auth/UI init
            try {
                const kickOffPreload = () => createPDFLoadPromise().catch(() => {
                    // Downgrade to debug to reduce console noise; we have robust fallbacks
                    console.debug('PDF library preload failed (non-blocking); will use fallback when needed');
                });
                if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
                    requestIdleCallback(() => kickOffPreload());
                } else {
                    setTimeout(() => kickOffPreload(), 2000);
                }
            } catch(_) { /* noop */ }
        </script>
        
        <!-- PDF Library Loading Verification -->
        <script>
            // Function to check if PDF library is ready
            function isPDFLibraryReady() {
                return typeof html2pdf !== 'undefined' && html2pdf && typeof html2pdf().from === 'function';
            }
            
            // Function to wait for PDF library to load
            function waitForPDFLibrary(maxWaitTime = 5000) {
                return new Promise((resolve, reject) => {
                    if (isPDFLibraryReady()) {
                        resolve(true);
                        return;
                    }
                    
                    // Try to use the preload promise first
                    if (pdfLoadPromise && pdfLibraryStatus === 'loading') {
                        pdfLoadPromise.then(resolve).catch(() => {
                            // If preload failed, try manual check
                            const startTime = Date.now();
                            const checkInterval = setInterval(() => {
                                if (isPDFLibraryReady()) {
                                    clearInterval(checkInterval);
                                    resolve(true);
                                } else if (Date.now() - startTime > maxWaitTime) {
                                    clearInterval(checkInterval);
                                    reject(new Error('PDF library failed to load within timeout'));
                                }
                            }, 200);
                        });
                        return;
                    }
                    
                    // Fallback to manual polling
                    const startTime = Date.now();
                    const checkInterval = setInterval(() => {
                        if (isPDFLibraryReady()) {
                            clearInterval(checkInterval);
                            resolve(true);
                        } else if (Date.now() - startTime > maxWaitTime) {
                            clearInterval(checkInterval);
                            reject(new Error('PDF library failed to load within timeout'));
                        }
                    }, 200);
                });
            }
            
            // Improved print-to-PDF fallback
            function printReportAsPDF(markdownReport, filename) {
                try {
                    const htmlContent = convertMarkdownToHTML(markdownReport);
                    const printWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');
                    
                    if (!printWindow) {
                        // Fallback: try to copy to clipboard
                        if (navigator.clipboard) {
                            navigator.clipboard.writeText(markdownReport).then(() => {
                                alert('Pop-up blocked. Report copied to clipboard - paste into a document and print.');
                            });
                        } else {
                            alert('Pop-up blocked and clipboard unavailable. Please enable pop-ups or use the Download JSON option.');
                        }
                        return;
                    }
                    
                    printWindow.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${filename || 'Report'}</title>
                            <style>
                                @media print {
                                    body { font-size: 11px; line-height: 1.4; margin: 0.5in; font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif; color: black; }
                                    h1, h2, h3 { break-after: avoid; margin-top: 1em; color: black; }
                                    table { break-inside: avoid; page-break-inside: avoid; width: 100%; border-collapse: collapse; margin: 1em 0; }
                                    th, td { border: 1px solid #333; padding: 4px 6px; text-align: left; }
                                    th { background-color: #f0f0f0; font-weight: bold; }
                                    tr { break-inside: avoid; page-break-inside: avoid; }
                                    .page-break { page-break-before: always; }
                                    * { color: black !important; }
                                }
                                @media screen {
                                    body { font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 20px; line-height: 1.5; }
                                    table { border-collapse: collapse; width: 100%; margin: 1em 0; }
                                    th, td { border: 1px solid #ddd; padding: 8px; }
                                    th { background-color: #f2f2f2; }
                                    .print-instructions { background: #e7f3ff; padding: 15px; margin: 20px 0; border-radius: 5px; }
                                }
                            </style>
                        </head>
                        <body>
                            <div class="print-instructions">
                                <strong>Print Instructions:</strong> Use your browser's Print function (Ctrl+P / Cmd+P) and select "Save as PDF" as the destination.
                            </div>
                            ${htmlContent}
                        </body>
                        </html>
                    `);
                    printWindow.document.close();
                    
                    printWindow.onload = () => {
                        setTimeout(() => {
                            printWindow.focus();
                            printWindow.print();
                        }, 800);
                    };
                    
                } catch (error) {
                    console.error('Print fallback failed:', error);
                    alert('Print fallback failed. Please use the Download JSON option instead.');
                }
            }
        </script>
    </head>
<body class="bg-gray-900 text-gray-200">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <div class="flex justify-between items-center mb-4">
                <div></div> <!-- Empty div for spacing -->
                <h1 class="text-4xl font-bold text-white">Woven Map Math Brain</h1>
                <div id="auth-debug-origin" class="hidden text-xs text-gray-400 ml-2 select-all" title="Current origin used as redirect_uri"></div>
                <div class="flex gap-2">
                    <button id="google-login-button" class="auth-button bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded text-sm font-semibold auth-btn" title="Sign in with Google" disabled>Continue with Google</button>
                    <button id="logout-button" class="auth-button bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded text-sm font-semibold auth-btn hidden" disabled>Log Out</button>
                </div>
            </div>
            <p class="text-gray-400 mt-2 flex items-center justify-center gap-2">Pure Astrological Geometry Computation
                <button id="math-brain-info-btn" class="ml-2 text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                    What is Math Brain? (Glossary)
                </button>
            </p>
            
            <!-- Weather Badge (shown when Planetary Weather is selected) -->
            <div id="weatherBadge" class="hidden mt-4 mb-2">
                <div class="inline-flex items-center gap-2 px-3 py-1 bg-gradient-to-r from-blue-600 to-purple-600 text-white text-sm font-medium rounded-full border border-blue-500/30">
                    <span class="text-lg">🌤️</span>
                    <span>Weather</span>
                </div>
            </div>
            
            <!-- Mirror/Seismograph/Balance Meter Tab Switch -->
            <div class="mt-6 mb-4">
                <div class="flex justify-center">
                    <div class="bg-gray-800 p-1 rounded-lg border border-gray-600 inline-flex" role="tablist" aria-label="Output Mode">
                        <button id="mirrorModeTab" type="button" role="tab" aria-selected="true" aria-controls="mirror-content" 
                                class="px-6 py-2 text-sm font-medium rounded-md bg-teal-600 text-white transition-colors duration-200" 
                                data-mode="mirror">
                            Mirror
                        </button>
                        <button id="balanceMeterModeTab" type="button" role="tab" aria-selected="false" aria-controls="balance-meter-content" 
                                class="px-6 py-2 text-sm font-medium rounded-md bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors duration-200" 
                                data-mode="balance_meter">
                            Balance Meter
                        </button>
                    </div>
                </div>
                <div class="mt-2 text-xs text-gray-400 text-center">
                    <span id="modeDescription">
                        <strong class="text-teal-300">Mirror:</strong> Geometry + reflection in one stream. Always includes the full skeletal ledger (angles, houses, hooks) plus the recognition layer. Seismograph trace auto-appends when transit hooks exist.
                    </span>
                </div>
            </div>
        </header>

                <!-- Glossary Modal -->
                <div id="math-brain-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 hidden" role="dialog" aria-modal="true" aria-labelledby="math-brain-modal-title">
                    <div id="math-brain-modal-content" class="bg-gray-900 rounded-lg shadow-xl max-w-lg w-full p-6 relative border border-teal-500" tabindex="-1">
            <button id="close-math-brain-modal" class="absolute top-2 right-2 text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
                        <h2 id="math-brain-modal-title" class="text-xl font-bold text-teal-300 mb-2">Math Brain & Poetic Brain: The Woven Map Framework</h2>
            <p class="text-sm text-gray-200 mb-3">
              <b>Math Brain</b>: computes planetary positions, aspects, house placements. Outputs geometry, no meaning.<br>
              <b>Poetic Brain</b>: translates geometry into felt/narrative language. Diagnostic, not predictive.<br>
              <b>TL;DR</b>: Math Brain finds the coordinates. Poetic Brain speaks the language you can feel.
            </p>
            <h3 class="text-teal-200 font-semibold mt-4 mb-1">Glossary</h3>
            <ul class="text-xs text-gray-300 space-y-1 max-h-48 overflow-y-auto pr-2">
              <li><b>FIELD → MAP → VOICE</b>: FIELD = energetic climate, MAP = geometry, VOICE = felt reflection.</li>
              <li><b>Recognition-First Principle</b>: Choose diagnostic mode based on real question, not technical curiosity.</li>
              <li><b>Context Modes</b>: Natal (single person), Synastry (interaction), Transit (current currents), Composite (relationship entity).</li>
              <li><b>Ping</b>: Recognized resonance between chart and experience.</li>
              <li><b>SST</b>: Falsifiability filter. WB = Within Boundary, ABE = At Boundary Edge, OSR = Outside Symbolic Range.</li>
              <li><b>Echo Loop</b>: Dyadic cycle under 1° orb.</li>
              <li><b>REF</b>: Relational Echo Field, macro-pattern resonance between two charts.</li>
              <li><b>Intimacy Tier</b>: P1 = Platonic, P2 = FWB, P3 = Romantic.</li>
              <li><b>Clear Mirror</b>: Testable, non-mystical phrasing.</li>
              <li><b>29° Crisis Node</b>: Planet at 29°, volatility.</li>
              <li><b>Symbolic Weather Overlay</b>: Current transits as energetic "weather".</li>
              <li><b>Paradox Line</b>: Internal contradiction.</li>
            </ul>
            <div class="mt-4 text-right">
              <button id="close-math-brain-modal-bottom" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-1 px-4 rounded">Close</button>
            </div>
          </div>
        </div>

        <main>
            <!-- Person A & B Cards -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div id="personA-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <div class="flex items-center justify-between mb-4 border-b border-gray-700 pb-2">
                        <h2 class="text-2xl font-semibold text-white">Person A / Natal Chart</h2>
                        <div class="flex items-center gap-2">
                            <button id="relocQuickBtn" type="button" aria-pressed="false" class="text-xs px-3 py-1 rounded-full border border-gray-600 text-gray-300 hover:bg-gray-700/20 transition-colors" title="Apply Panama City relocation overlay">Reloc: Panama City</button>
                        </div>
                    </div>
                    <div class="space-y-5">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameA" placeholder="Name" class="w-full bg-gray-700 text-white rounded-lg p-3 border-2 border-gray-600 focus:border-teal-500 focus:ring-2 focus:ring-teal-500/20 transition-all duration-200 hover:border-gray-500" value="DH Cross">
                            <input type="text" id="birth_cityA" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-lg p-3 border-2 border-gray-600 focus:border-teal-500 focus:ring-2 focus:ring-teal-500/20 transition-all duration-200 hover:border-gray-500" value="Bryn Mawr">
                            <input type="text" id="birth_stateA" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-lg p-3 border-2 border-gray-600 focus:border-teal-500 focus:ring-2 focus:ring-teal-500/20 transition-all duration-200 hover:border-gray-500" value="PA">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="date" id="birth_dateA" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-lg p-3 border-2 border-gray-600 focus:border-teal-500 focus:ring-2 focus:ring-teal-500/20 transition-all duration-200 hover:border-gray-500" value="1973-07-24">
                            <input type="text" id="birth_timeA" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-lg p-3 border-2 border-gray-600 focus:border-teal-500 focus:ring-2 focus:ring-teal-500/20 transition-all duration-200 hover:border-gray-500" value="14:30">
                            <select id="offsetA" class="w-full bg-gray-700 text-white rounded-lg p-3 border-2 border-gray-600 focus:border-teal-500 focus:ring-2 focus:ring-teal-500/20 transition-all duration-200 hover:border-gray-500">
                                <option value="America/Chicago" selected>Central (Chicago)</option>
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska</option>
                                <option value="Pacific/Honolulu">Hawaii</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="birth_countryA" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="US">
                            <select id="zodiacA" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div>
                            <label for="astroA" class="block mb-2 text-sm font-medium text-gray-300">Birth Coordinates</label>
                            <input type="text" id="astroA" placeholder="e.g., 40°1'N, 75°18'W or 40.01, -75.31" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="40°1'N, 75°18'W">
                        </div>
                    </div>
                </div>
                
                <!-- Person B Card with Progressive Disclosure -->
                <div id="personB-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <!-- Person B Toggle Header -->
                    <div id="personB-toggle" class="flex items-center justify-between mb-4 cursor-pointer hover:bg-gray-750 p-2 -m-2 rounded transition-colors" role="button" tabindex="0" aria-expanded="false" aria-controls="personB-details">
                        <h2 class="text-2xl font-semibold text-white border-b border-gray-700 pb-2 border-b-0 pb-0">Person B (Optional)</h2>
                        <svg id="personB-chevron" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    
                    <!-- Person B Details (collapsible) -->
                    <div id="personB-details" class="hidden">
                        <div class="border-b border-gray-700 mb-4"></div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <input type="text" id="nameB" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_cityB" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_stateB" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <input type="date" id="birth_dateB" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_timeB" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <select id="offsetB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                    <option value="America/New_York">Eastern (New York)</option>
                                    <option value="America/Chicago">Central (Chicago)</option>
                                    <option value="America/Denver">Mountain (Denver)</option>
                                    <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                    <option value="America/Anchorage">Alaska</option>
                                    <option value="Pacific/Honolulu">Hawaii</option>
                                </select>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <input type="text" id="birth_countryB" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <select id="zodiacB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                    <option value="Tropic">Tropic</option>
                                    <option value="Sidereal">Sidereal</option>
                                </select>
                            </div>
                            <div>
                               <label for="astroB" class="block mb-1 text-sm font-medium text-gray-300">Birth Coordinates</label>
                               <input type="text" id="astroB" placeholder="e.g., 30.16, -85.66" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            </div>
                            <button id="pasteAstroB" class="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded text-sm">
                              Paste AstroSeek Data
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Gate: Simplified Selection -->
            <div id="context-gate-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold text-white">What do you want to explore?</h2>
                    <button id="context-help-btn" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 Context Guide
                    </button>
                </div>
                
                <!-- Context Help Panel (initially hidden) -->
                <div id="context-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Context Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Solo →</span>
                            <div class="text-gray-300">
                                <div>Chart your inner landscape and its current activations. <em>"What patterns am I carrying, and how is today pressing on them?"</em></div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Relational →</span>
                            <div class="text-gray-300">
                                <div>Map how two charts weave together, plus the currents moving through that dynamic. <em>"What happens when our patterns touch?"</em></div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Weather →</span>
                            <div class="text-gray-300">
                                <div>Current planetary currents without personal chart context. <em>"What's the energetic weather right now?"</em></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity.
                        </p>
                    </div>
                    <!-- What's New (dismissible) -->
                    <div id="whats-new-2025-09-07" class="mt-4 p-3 bg-gray-800 rounded border border-amber-600 text-sm">
                        <div class="flex items-start justify-between gap-3">
                            <div>
                                <h4 class="text-amber-300 font-semibold mb-1">What’s new in Balance Meter Correlation</h4>
                                <ul class="list-disc list-inside text-gray-300 space-y-1">
                                    <li>Supplemental overlays: Magnitude↔RHR, Magnitude↔Active energy, Volatility↔Wrist temp Δ</li>
                                    <li>Per-window normalization; missing data excluded from similarity</li>
                                    <li>Tiny windows (≤3 days): shuffle p-value suppressed</li>
                                </ul>
                                <p class="mt-2 text-xs text-gray-400">These overlays don’t affect the core three-axis composite or significance; they add context only.</p>
                            </div>
                            <button id="dismiss-whats-new-2025-09-07" class="ml-2 text-xs bg-amber-700 hover:bg-amber-800 text-white px-2 py-1 rounded">Dismiss</button>
                        </div>
                    </div>
                </div>
                
                <div id="context-selection" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <label class="flex items-center p-4 border-2 border-gray-600 rounded-lg hover:border-teal-500 hover:bg-gray-700/30 transition-all duration-200 cursor-pointer bg-gray-800/50 backdrop-blur-sm">
                        <input type="radio" name="contextType" value="solo" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 focus:ring-2 border-gray-600 rounded bg-gray-700" checked>
                        <div>
                            <div class="text-white font-semibold text-base">Solo</div>
                            <div class="text-gray-300 text-sm mt-1">Chart your inner weave</div>
                        </div>
                    </label>
                    <label class="flex items-center p-4 border-2 border-gray-600 rounded-lg hover:border-teal-500 hover:bg-gray-700/30 transition-all duration-200 cursor-pointer bg-gray-800/50 backdrop-blur-sm">
                        <input type="radio" name="contextType" value="relational" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 focus:ring-2 border-gray-600 rounded bg-gray-700">
                        <div>
                            <div class="text-white font-semibold text-base">Relational</div>
                            <div class="text-gray-300 text-sm mt-1">Where two patterns touch</div>
                        </div>
                    </label>
                    <label class="flex items-center p-4 border-2 border-gray-600 rounded-lg hover:border-teal-500 hover:bg-gray-700/30 transition-all duration-200 cursor-pointer bg-gray-800/50 backdrop-blur-sm">
                        <input type="radio" name="contextType" value="weather" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 focus:ring-2 border-gray-600 rounded bg-gray-700">
                        <div>
                            <div class="text-white font-semibold text-base">Planetary Weather Only</div>
                            <div class="text-gray-300 text-sm mt-1">Sky patterns without personal charts</div>
                        </div>
                    </label>
                </div>
                
                <!-- Solo Subtype Selection (initially visible for solo mode) -->
                <div id="solo-subtypes" class="mt-4 p-4 bg-gray-800/60 rounded-lg border-2 border-gray-600 backdrop-blur-sm">
                    <h3 class="text-sm font-semibold text-white mb-3">What type of solo analysis?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label class="flex items-center p-3 border-2 border-gray-600 rounded-lg hover:border-teal-500 hover:bg-gray-700/30 transition-all duration-200 cursor-pointer bg-gray-700/20">
                            <input type="radio" name="soloSubtype" value="natal_only" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 focus:ring-2 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white text-sm font-medium">Chart Only</div>
                                <div class="text-gray-300 text-xs mt-1">Foundational natal architecture</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border-2 border-gray-600 rounded-lg hover:border-teal-500 hover:bg-gray-700/30 transition-all duration-200 cursor-pointer bg-gray-700/20">
                            <input type="radio" name="soloSubtype" value="natal_transits" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 focus:ring-2 border-gray-600 rounded bg-gray-700" checked>
                            <div>
                                <div class="text-white text-sm font-medium">Chart + Transits</div>
                                <div class="text-gray-300 text-xs mt-1">Your chart + current currents</div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <!-- Relational Subtype Selection (initially hidden) -->
                <div id="relational-subtypes" class="hidden mt-4 p-4 bg-gray-750 rounded-lg border border-gray-600">
                    <h3 class="text-sm font-medium text-white mb-3">What type of relational analysis?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationalSubtype" value="synastry" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white text-sm">Synastry + Transits</div>
                                <div class="text-gray-400 text-xs">Laying two old maps on top of each other—where rivers line up, where mountains clash</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationalSubtype" value="composite" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                            <div>
                                <div class="text-white text-sm">Composite + Transits</div>
                                <div class="text-gray-400 text-xs">Sketching a third map from the overlap—what country appears when you travel together</div>
                            </div>
                        </label>
                    </div>
                    
                    <!-- Relational Mode Explanation -->
                    <div class="mt-4 p-3 bg-gray-800 rounded-lg border border-gray-600">
                        <div class="text-xs text-gray-300 space-y-2">
                            <div>
                                <strong class="text-teal-300">Synastry</strong> is like laying two old maps on top of each other to see where the rivers line up and where the mountains clash. It shows where each of you naturally flows toward or grinds against the other.
                            </div>
                            <div>
                                <strong class="text-teal-300">Composite</strong> is more like sketching a third map out of the overlap—what kind of country appears when you travel together, even if only for a short spell. That land isn't yours alone or theirs alone; it only exists when the two maps are laid together.
                            </div>
                            <div class="text-gray-400 italic mt-2">
                                Remember: The mirror does not mean the journey is happening—only that, if the two paths touch, this is what the water would show.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Mode Section (legacy - will be hidden and auto-updated) -->
            <div id="context-mode-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500 hidden">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-semibold text-white">Context Mode</h2>
                    <button id="toggle-mode-help" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 What does each mode do?
                    </button>
                </div>
                
                <!-- Symbolic Purpose Guide (initially hidden) -->
                <div id="mode-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Mode Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Natal+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current planetary field on individual chart. <em>"How is today's current flowing through me?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: If a date range is added, the system checks for all periods of exact or near-exact resonance between those dates—not just today.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Comp+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current field on the shared connection. <em>"How is today's current flowing through our bond?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: Adding a date range means the system maps every significant current on the connection during that window. Results are limited to that span.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Syn+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current field on relational dynamics. <em>"How is today's current flowing through our interaction?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: With a date range, the system searches for all windows where relational tension or harmony becomes active during the specified time frame.</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity. 
                            Each mode serves a specific diagnostic purpose within the FIELD → MAP → VOICE framework.
                        </p>
                        <p class="text-xs text-gray-400 mt-2">
                            <strong class="text-teal-300">Date Range Effect:</strong> Adding a date range turns a "today" reading into a scan for all matching patterns over that period, revealing field windows and thresholds—not just a snapshot.
                        </p>
                    </div>
                </div>
                
                <!-- Context Mode Selection -->
                <div class="flex flex-wrap items-center gap-4 mb-4">
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_transits" class="mr-2" checked>
                        <span class="text-gray-300">Natal Chart + Transits</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="composite_transits" class="mr-2">
                        <span class="text-gray-300">Composite + Transits</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="contextMode" value="synastry_transits" class="mr-2">
                        <span class="text-gray-300">Synastry + Transits</span>
                    </label>
                </div>
                
            </div>
            
            <!-- Progressive Disclosure Sections -->
            
            <!-- Transit Date Range with Progressive Disclosure -->
            <div id="optional-details-section" class="space-y-6">
                
                <!-- Quick Transit Settings (Mirror Mode Default) -->
                <div id="quick-transit-section" class="bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold text-white">Date Range</h2>
                        <div class="flex items-center gap-4">
                            <button id="todayDefault" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded text-sm transition-colors">
                                📅 Use Today
                            </button>
                            <button id="expandTransitOptions" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                                ⚙️ More Options
                            </button>
                        </div>
                    </div>
                    
                    <!-- Simple Date Inputs -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="transitStartDate" class="block text-gray-300 font-medium mb-1">Start Date:</label>
                            <input type="date" id="transitStartDate" name="transitStartDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" required>
                        </div>
                        <div>
                            <label for="transitEndDate" class="block text-gray-300 font-medium mb-1">End Date:</label>
                            <input type="date" id="transitEndDate" name="transitEndDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" required>
                        </div>
                    </div>
                    
                    <!-- Advanced Transit Options (initially hidden) -->
                    <div id="advanced-transit-options" class="hidden mt-4 pt-4 border-t border-gray-700">
                        <div class="flex justify-between items-center mb-2">
                            <label for="transitStep" class="block text-gray-300 font-medium">Step Size:</label>
                            <button id="stepSizeHelp" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                                ❓ What does this do?
                            </button>
                        </div>
                        <select id="transitStep" name="transitStep" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <option value="1d">Daily (1 day intervals)</option>
                            <option value="7d">Weekly (7 day intervals)</option>
                            <option value="1m">Monthly (1 month intervals)</option>
                        </select>
                        <!-- Step Size Help Panel (initially hidden) -->
                        <div id="stepSizeHelpPanel" class="hidden mt-2 p-3 bg-gray-750 rounded-lg border border-teal-600 text-sm">
                            <h4 class="text-teal-300 font-semibold mb-2">📊 Step Size Explained</h4>
                            <p class="text-gray-200 mb-2">Step size controls how frequently transit calculations are performed within your date range:</p>
                            <ul class="text-gray-300 space-y-1 ml-4">
                                <li><b>Daily</b>: Calculate transits for every single day (most detailed, max 45 days)</li>
                                <li><b>Weekly</b>: Calculate transits every 7 days (good balance, max 6 months)</li>
                                <li><b>Monthly</b>: Calculate transits once per month (fastest, max 1 year)</li>
                            </ul>
                            <div class="mt-3 p-2 bg-gray-800 rounded border border-gray-600">
                                <p class="text-teal-300 text-xs font-medium mb-1">📏 Recommended Date Ranges (API-Optimized):</p>
                                <ul class="text-gray-400 text-xs space-y-1 ml-2">
                                    <li>• <strong>1-14 days:</strong> Use Daily for detailed analysis</li>
                                    <li>• <strong>2 weeks-3 months:</strong> Use Weekly for balance</li>
                                    <li>• <strong>3-6 months:</strong> Use Monthly for overview</li>
                                    <li>• <strong>Today only:</strong> Daily for current transits</li>
                                </ul>
                                <p class="text-yellow-200 mt-2 text-xs"><b>API Protection</b>: Conservative limits prevent excessive API usage. Daily=45 days max, Weekly=9 months max, Monthly=18 months max.</p>
                            </div>
                            <p class="text-yellow-200 mt-2 text-xs"><b>Performance Note</b>: Longer ranges with finer steps may take more time to process and generate larger datasets.</p>
                        </div>
                    </div>
                </div>

                <!-- Relocation Overlay with Progressive Disclosure -->
                <div id="relocation-section" class="bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500">
                    <div class="flex items-center justify-between cursor-pointer hover:bg-gray-750 p-2 -m-2 rounded transition-colors" 
                         id="relocation-toggle-header" role="button" tabindex="0" aria-expanded="false" aria-controls="relocation-details">
                        <div class="flex items-center">
                            <input type="checkbox" id="relocationToggle" class="mr-4 h-6 w-6 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <h3 class="text-lg font-medium text-white">Relocation Overlay</h3>
                                <p class="text-sm text-teal-300">Check this to compare how your chart shifts if you lived elsewhere</p>
                                <p class="text-xs text-gray-400">Same planets, different stage - where your patterns express in daily life</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button id="useDefaultRelocation" type="button" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">Use my default</button>
                            <svg id="relocation-chevron" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- Relocation Details (collapsible) -->
                    <div id="relocation-details" class="hidden">
                        <p id="relocation-default-note" class="mb-4 text-xs text-gray-500 italic">
                            Panama City, FL (30°10'N, 85°40'W) is pre-filled as a suggested relocation reference. It is NOT applied until you enable the checkbox.
                        </p>
                        <div class="mt-4 pt-4 border-t border-gray-700 space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label for="relocationCity" class="block mb-1 text-sm font-medium text-gray-300">Relocation City</label>
                                    <input type="text" id="relocationCity" placeholder="e.g., Panama City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="Panama City">
                                </div>
                                <div>
                                    <label for="relocationState" class="block mb-1 text-sm font-medium text-gray-300">State/Province</label>
                                    <input type="text" id="relocationState" placeholder="e.g., FL" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="FL">
                                </div>
                            </div>
                            
                            <div>
                                <label for="relocationCoords" class="block mb-1 text-sm font-medium text-gray-300">
                                    Relocation Coordinates
                                    <span class="text-xs text-gray-500">(Required for overlay calculations)</span>
                                </label>
                                <input type="text" id="relocationCoords" placeholder="e.g., 30°10'N, 85°40'W or 34.0522, -118.2437" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="30°10'N, 85°40'W">
                                <div class="mt-1 text-xs text-gray-500">
                                    <strong class="text-gray-400">Supported formats:</strong>
                                    <br>• <strong>Astroseek format:</strong> "30°10'N, 85°40'W" (degrees/minutes with direction)
                                    <br>• <strong>Decimal degrees:</strong> "40.7128, -74.0060" (positive = N/E, negative = S/W)
                                    <br>• Get coordinates from <a href="https://astroseek.com/astrology-birth-chart-calculator-map" target="_blank" class="text-teal-400 underline">Astroseek</a> or Google Maps
                                </div>
                                
                                <!-- Validation Error for Relocation Coords -->
                                <div id="relocationCoordsError" class="hidden mt-1 text-xs text-red-400">
                                    Please enter valid coordinates in format: latitude, longitude
                                </div>
                            </div>
                            
                            <div class="bg-gray-750 p-3 rounded border border-gray-600">
                                <h4 class="text-sm font-medium text-teal-300 mb-2">How Relocation Works:</h4>
                                <ul class="text-xs text-gray-400 space-y-1">
                                    <li>• <strong class="text-gray-300">Same birth chart, different stage set</strong> - planets and aspects unchanged</li>
                                    <li>• <strong class="text-gray-300">Houses and angles shift</strong> - where your patterns get expressed in daily life</li>
                                    <li>• <strong class="text-gray-300">Tectonic (where), not timing</strong> - foundational context shift; timing of the sky doesn't change</li>
                                    <li>• <strong class="text-gray-300">Diagnostic value</strong> - shows where natal currents plug into new ground</li>
                                </ul>
                                <div class="mt-2 p-2 bg-gray-800 rounded border border-gray-600">
                                    <p class="text-xs text-teal-300">
                                        <strong>Example:</strong> Sun in 12th (private) → Sun at Midheaven (public stage). 
                                        Same solar nature, different life domain where it gets expressed.
                                    </p>
                                </div>
                            </div>
                            
                            <!-- Person B Relocation Option (only visible when Person B is present) -->
                            <div id="relocationPersonBOption" class="hidden">
                                <div class="flex items-center p-3 bg-gray-750 rounded border border-gray-600">
                                    <input type="checkbox" id="includePersonBRelocation" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                                    <label for="includePersonBRelocation" class="text-gray-300 font-medium">
                                        Also relocate Person B to same location
                                        <span class="text-xs text-gray-500 block">
                                            <strong>Default:</strong> Only Person A gets relocated. <br>
                                            <strong>Check this if:</strong> Person B is also in the same relocation city. <br>
                                            <strong>Leave unchecked if:</strong> Person B remains in their birth location.
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Legacy hidden sections for compatibility -->
            <div class="hidden">
                <div id="context-toggle" class="flex items-center mb-4">
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_only" class="mr-2">
                        <span class="text-gray-300">Natal Chart Only</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_transits" class="mr-2" checked>
                        <span class="text-gray-300">Natal Chart + Transits</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="balance_meter" class="mr-2">
                        <span class="text-gray-300">Balance Meter (Health Data Comparison)</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="composite_transits" class="mr-2">
                        <span class="text-gray-300">Composite + Transits</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="contextMode" value="synastry_transits" class="mr-2">
                        <span class="text-gray-300">Synastry + Transits</span>
                    </label>
                </div>
                
                <!-- Legacy transit fields for compatibility -->
                <div id="transit-date-range-fields" class="mb-6 hidden">
                  <div class="flex justify-between items-center mb-2">
                    <label for="transitStartDate" class="block text-gray-300 font-medium">Transit Start Date (YYYY-MM-DD):</label>
                    <button id="prefillToday" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                        📅 Use Today for Quick Check
                    </button>
                  </div>
                </div>
            </div>
                
                <!-- Additional Context Options -->
                <div id="context-options" class="space-y-4">
                    <div class="bg-yellow-900 border border-yellow-700 text-yellow-100 px-4 py-3 rounded mb-4">
                        <div class="flex">
                            <div class="flex-shrink-0">
                                <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="ml-3">
                                <h3 class="text-sm font-medium">Math Brain Protocol Active</h3>
                                <div class="mt-2 text-sm">
                                    This panel computes geometry only. Interpretation lives in the Mirror.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            </div>

            <!-- Relational Context Section (conditional visibility) - moved from hidden context-mode-section -->
            <div id="relational-context-section" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500" role="region" aria-labelledby="relational-context-heading">
                <h2 id="relational-context-heading" class="text-xl font-semibold mb-4 text-white">Relational Context</h2>
                <p class="text-gray-400 text-sm mb-4">Detected potential dynamics:</p>
                <ul id="context-readout" class="list-disc list-inside space-y-2 mb-4 text-gray-300"></ul>
                <div id="relationship-type-query">
                    <p class="text-lg font-medium text-white mb-2">How would you categorize this connection?</p>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="partner" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Partner</div>
                                <div class="text-gray-400 text-xs">Romantic / undefined-intimate</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="friend" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Friend / Colleague</div>
                                <div class="text-gray-400 text-xs">Friend or colleague</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="family" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Family Member</div>
                                <div class="text-gray-400 text-xs">Family member</div>
                            </div>
                        </label>
                    </div>
                    <div id="exRelationshipRow" class="mt-4 pt-3 border-t border-gray-600">
                        <label class="flex items-center p-2 hover:bg-gray-750 rounded cursor-pointer">
                            <input type="checkbox" id="exRelationship" class="mr-3 h-4 w-4 text-red-400 focus:ring-red-500 border-gray-600 rounded bg-gray-700">
                            <span class="text-gray-300">Ex or Estranged</span>
                            <span class="text-xs text-gray-500 ml-2">(not valid for Friend/Colleague)</span>
                        </label>
                    </div>
                    <!-- Relationship Role (conditional) -->
                    <div id="relationship-role-block" class="mt-4 hidden" aria-live="polite">
                        <label for="relationshipRole" class="block text-sm font-medium text-gray-300">
                            Relationship Role 
                            <span class="text-xs text-gray-400">(Person B relative to A)</span>
                        </label>
                        <select id="relationshipRole" class="mt-1 w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-sm"></select>
                        <input id="relationshipRoleCustom" placeholder="Custom role (e.g., half-brother, stepmother)" class="mt-2 w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-sm hidden" />
                        <div class="mt-2">
                            <label for="relationshipNotes" class="block text-xs font-medium text-gray-400">Relationship Notes (optional)</label>
                            <textarea id="relationshipNotes" rows="2" class="w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-xs" placeholder="Any clarifying context (e.g., estranged, adopted)"></textarea>
                        </div>
                    </div>
                    <div id="intimacy-tier-dropdown" class="mt-4 hidden">
                        <p class="text-md font-medium text-white mb-2">Select intimacy tier (required for Partner):</p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P1" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P1 – Platonic</div>
                                    <div class="text-gray-400 text-xs">No sexual/romantic expectations</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P2" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P2 – FWB</div>
                                    <div class="text-gray-400 text-xs">Sexual, no romantic commitment</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P3" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P3 – Situationship</div>
                                    <div class="text-gray-400 text-xs">Fluid rules/expectations</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P4" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P4 – Low-commitment</div>
                                    <div class="text-gray-400 text-xs">Uneven investment, minimal care</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P5a" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P5a – Committed</div>
                                    <div class="text-gray-400 text-xs">Romantic + sexual</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P5b" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P5b – Committed</div>
                                    <div class="text-gray-400 text-xs">Romantic, no sexual</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Contact Channel Toggle -->
                    <div class="mt-6 p-4 bg-gray-750 rounded-lg border border-gray-600">
                        <p class="text-md font-medium text-white mb-3">Contact Channel:</p>
                        <p class="text-xs text-gray-400 mb-4">Is this an active relationship channel (currently exchanging), or a dormant one (not currently exchanging)?</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                                <input type="radio" name="contactChannel" value="live" class="mr-3 h-4 w-4 text-teal-400 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                                <div>
                                    <div class="text-white text-sm">🟢 Live</div>
                                    <div class="text-gray-400 text-xs">Currently in contact / active exchange</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                                <input type="radio" name="contactChannel" value="latent" class="mr-3 h-4 w-4 text-teal-400 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">⚫ Latent</div>
                                    <div class="text-gray-400 text-xs">Not currently in contact / no active exchange</div>
                                </div>
                            </label>
                        </div>
                        <div class="mt-3 p-2 bg-gray-800 rounded text-xs text-gray-300">
                            <strong class="text-teal-300">Live:</strong> Enables interaction overlays ("when A does this, B may respond...") <br>
                            <strong class="text-teal-300">Latent:</strong> Parallel weather only (side-by-side individual readings)
                        </div>
                    </div>
                </div>
            </div>

            <!-- Primary Action -->
            <div class="text-center mb-12">
                <button id="generateReport" class="bg-gradient-to-r from-teal-600 to-teal-700 hover:from-teal-700 hover:to-teal-800 text-white font-bold py-4 px-12 rounded-lg text-xl shadow-lg transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    ✨ Get My Mirror
                </button>
            </div>

            <!-- Secondary Actions - Core Workflow -->
            <div class="text-center mb-8">
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md mx-auto">
                    <h3 class="text-white font-medium mb-4">📋 Chart Management</h3>
                    <p class="text-xs text-gray-400 mb-4">Keep your current setup to reuse later</p>
                    <div class="flex justify-center gap-3">
                        <button id="saveDataBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                            💾 Save Setup
                        </button>
                        <button id="loadDataBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                            📂 Load Setup
                        </button>
                    </div>
                    <input type="file" id="loadDataInput" accept=".json" class="hidden">
                </div>
            </div>

            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center mb-8" role="status" aria-live="polite" aria-atomic="true" aria-busy="false">
                <div class="inline-flex items-center px-4 py-2 font-semibold leading-6 text-sm shadow rounded-md text-white bg-teal-600 transition ease-in-out duration-150">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="loadingText">Computing Astrological Geometry...</span>
                </div>
            </div>

            <!-- Poetic Brain Section (requires login) -->
            <div id="poetic-brain-section" class="poetic-brain-section max-w-4xl mx-auto mb-8 bg-gray-800 p-6 rounded-lg shadow-lg border-t-4 border-indigo-500">
                <h2 class="text-2xl font-semibold text-white mb-4">🐦‍⬛ Poetic Brain - Raven Calder</h2>
                <p class="text-gray-400 mb-4">Welcome. You have access to the Poetic Brain. Ask a question to receive a reflection from Raven Calder.</p>
                <div class="flex gap-4">
                    <input type="text" id="poetic-prompt" placeholder="What weighs on your soul?" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                    <button id="ask-poetic-brain" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">Ask</button>
                </div>
                <div id="poetic-response-container" class="mt-4 p-4 bg-gray-900 rounded-lg hidden">
                    <pre id="poetic-response" class="whitespace-pre-wrap font-mono text-sm text-gray-300"></pre>
                </div>
            </div>

            <!-- Optional Data Correlations (Advanced) -->
            <div class="max-w-4xl mx-auto mb-8">
                <div class="text-center mb-4">
                    <h3 class="text-lg font-medium text-gray-300 mb-2">📋 Optional Data Correlations</h3>
                    <p class="text-sm text-gray-400 max-w-2xl mx-auto">
                        These are <strong>completely optional</strong> advanced features. Upload data files to correlate external data with your astrological patterns. 
                        <br><span class="text-teal-400">Workflow: 1) Generate your base chart, 2) Optionally upload data for correlation analysis.</span>
                    </p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Health Data Overlay -->
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg border-t-4 border-purple-500">
                        <h3 class="text-white font-medium mb-2 flex items-center gap-2">
                            🏥 Health Data Overlay
                            <button id="healthDataHelpBtn" class="text-xs text-purple-300 hover:text-purple-400 focus:outline-none" title="How to setup Health Auto Export">
                                ❓
                            </button>
                        </h3>
                        <p class="text-xs text-gray-400 mb-2">Compare Apple Health metrics (sleep, HRV, mood) with astrological transits</p>
                        <p class="text-xs text-blue-300 mb-4"><strong>Produces:</strong> Correlation tables showing how your health patterns align with planetary movements</p>
                        <div class="space-y-2">
                            <button id="loadHealthDataBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                                📱 Upload Health Data (.json)
                            </button>
                            <button id="clearHealthDataBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden">
                                ✖️ Clear Health Data
                            </button>
                        </div>
                        <input type="file" id="healthDataInput" accept=".json,application/json" class="hidden">
                        <div id="healthDataStatus" class="text-xs text-green-400 hidden mt-2"></div>
                        <p class="text-xs text-purple-400 mt-2">Compatible with iOS "Health Auto Export" app (.json format)</p>
                    </div>

                    <!-- Symbolic Log Correlation -->
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg border-t-4 border-cyan-500">
                        <h3 class="text-white font-medium mb-2 flex items-center gap-2">
                            📊 Balance Meter Correlation
                            <button class="text-xs text-cyan-300 hover:text-cyan-400 focus:outline-none" title="Upload Balance Meter report (.json) to correlate with health data">
                                ❓
                            </button>
                        </h3>
                        <p class="text-xs text-gray-400 mb-2">Cross-correlate Balance Meter symbolic data with health metrics for pattern analysis</p>
                        <p class="text-xs text-cyan-300 mb-4"><strong>Produces:</strong> Three-axis overlay showing valence, magnitude, and volatility alignment with health patterns</p>
                        
                        <!-- Requirements Notice -->
                        <div class="mb-4 p-3 bg-gray-750 rounded border border-cyan-600">
                            <p class="text-gray-300 font-medium text-sm">
                                📋 Requirements (upload order doesn't matter):
                                <span class="text-xs text-gray-400 block mt-1">
                                    • Balance Meter report JSON (from Download JSON above)<br>
                                    • Health Auto Export JSON (from iOS Health app)<br>
                                    • Both files should cover overlapping date ranges for correlation
                                </span>
                            </p>
                        </div>
                        
                        <div class="space-y-2">
                            <button id="loadSeismoBtn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                                📄 Upload Balance Meter Report
                            </button>
                            <button id="clearSeismoBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden">
                                ✖️ Clear Balance Meter Data
                            </button>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <button id="genComparativeBtn" class="bg-amber-600 hover:bg-amber-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden" disabled>
                                    📝 Download Correlation (.md)
                                </button>
                                <button id="genComparativePdfBtn" class="bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden" disabled>
                                    📑 Download Correlation (.pdf)
                                </button>
                            </div>
                        </div>
                        <input type="file" id="seismoMdInput" accept=".json,application/json" class="hidden">
                        <div id="seismoDataStatus" class="text-xs text-gray-500 hidden mt-2"></div>
                        <p class="text-xs text-cyan-400 mt-2">Accepts Balance Meter JSON reports from this app</p>
                    </div>
                </div>
            </div>

            <!-- Health Data Help Modal -->
            <div id="healthDataHelpModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="health-data-help-title">
                <div id="healthDataHelpContent" class="bg-gray-800 p-6 rounded-lg max-w-2xl max-h-96 overflow-y-auto border border-purple-500" tabindex="-1">
                    <h3 id="health-data-help-title" class="text-lg font-semibold text-purple-300 mb-4">Health Auto Export Setup Guide</h3>
                    <div class="text-sm text-gray-300 space-y-3">
                        <p><strong class="text-white">Required App:</strong> "Health Auto Export" from iOS App Store</p>
                        <p><strong class="text-white">Recommended Settings:</strong></p>
                        <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Quick Export tab</li>
                            <li>Aggregation Interval: <span class="text-green-400">days</span></li>
                            <li>Aggregate Data: <span class="text-green-400">ON</span></li>
                        </ul>
                        <p><strong class="text-white">Include These Metrics:</strong></p>
                        <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Heart Rate Variability (HRV)</li>
                            <li>Resting Heart Rate</li>
                            <li>Sleep Sessions</li>
                            <li>State of Mind (optional - can use separate CSV)</li>
                        </ul>
                        <p class="text-yellow-300"><strong>Note:</strong> Other metrics (workouts, ECG, etc.) are safely ignored.</p>
                        <p class="text-blue-300"><strong>Privacy:</strong> Data stays in your browser - no server upload.</p>
                    </div>
                    <button id="closeHealthDataHelp" class="mt-4 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded text-sm">Close</button>
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorDisplay" class="hidden bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-8" role="alert" aria-live="assertive" aria-atomic="true" aria-describedby="errorMessage" tabindex="-1">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium">Error computing geometry</h3>
                        <div id="errorMessage" class="mt-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Report Output -->
            <div id="reportOutput" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg">
                <!-- Action Zones (Moved here to be globally visible for all tabs) -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- For Readers Zone -->
                    <div class="bg-gray-750 p-4 rounded-lg border border-emerald-600">
                        <h3 class="text-emerald-300 font-medium mb-3">📖 For Readers</h3>
                        <div class="space-y-2">
                            <button id="downloadReport" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-medium py-2 px-3 rounded text-sm transition-colors hidden">
                                📄 Download JSON
                                <span class="block text-xs opacity-80">Machine‑readable report for Raven</span>
                            </button>
                            <button id="downloadPDF" class="w-full bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-3 rounded text-sm transition-colors hidden">
                                📑 Download PDF
                                <span class="block text-xs opacity-80">Professional PDF report</span>
                            </button>
                            <div id="pdfOptions" class="text-xs text-gray-400 mt-1 hidden">
                                <label class="flex items-center gap-1">
                                    <input type="checkbox" id="autoDownloadPDF" checked class="w-3 h-3">
                                    <span>Auto-download (no filename prompt)</span>
                                </label>
                            </div>
                            <!-- Copy Report removed per product decision: JSON/PDF only -->
                             <!-- Reader Notes (exported in JSON balance_meter.notes) -->
                             <div class="mt-3">
                                 <label for="readerNotes" class="block text-xs font-medium text-gray-300">Reader Notes (optional, exported)</label>
                                 <textarea id="readerNotes" rows="2" class="w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-xs" placeholder="Jot quick context or reactions; saved into the JSON notes array."></textarea>
                             </div>
                        </div>
                    </div>
                </div>
                
                <!-- Tab Content Areas -->
                <div id="mirror-content" role="tabpanel" aria-labelledby="mirrorModeTab">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-semibold text-white">Pure Astrological Geometry</h2>
                        
                        <!-- Progressive Disclosure: Raw Data Toggle -->
                        <button id="toggleRawData" class="text-xs text-gray-400 underline hover:text-gray-300 focus:outline-none">
                            Show Raw Data
                        </button>
                    </div>

                    <!-- Orientation Banner -->
                    <div class="mb-6 p-4 bg-gray-750 rounded-lg border border-gray-600">
                        <p class="text-sm text-gray-300">
                            <strong>Complete Mirror Report:</strong> Math Brain geometry + Poetic Brain narrative elements. 
                            These files are structured for both humans and AI to read.
                        </p>
                    </div>

                    <!-- Mirror Report Display Area -->
                    <div id="mirrorReportDisplay" class="hidden">
                        <div class="bg-gray-900/80 backdrop-blur-sm p-4 rounded-lg border border-gray-700/70 mb-6">
                            <div id="mirrorReportContent" class="report-surface whitespace-pre-wrap font-mono text-[11px] leading-relaxed overflow-auto max-h-[34rem] shadow-inner selection:bg-teal-600/40 selection:text-teal-50">
                            </div>
                        </div>
                    </div>

                <!-- Progressive Disclosure: Raw Data Content -->
                <div id="rawDataSection" class="hidden">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-medium text-white">Raw Output Data</h3>
                        <button id="hideRawData" class="text-xs text-gray-400 underline hover:text-gray-300 focus:outline-none">
                            Hide Raw Data
                        </button>
                    </div>
                    <!-- Simple Mode: Hook / Aspect Filter Controls intentionally hidden (retained for future advanced mode) -->
                    <div id="hookFilters" class="hidden"></div>
                    <div id="reportContent" class="report-surface whitespace-pre-wrap font-mono text-[11px] leading-relaxed bg-gray-900/80 backdrop-blur-sm p-4 rounded-lg border border-gray-700/70 overflow-auto max-h-[34rem] shadow-inner selection:bg-teal-600/40 selection:text-teal-50">
                    </div>
                </div>
                
                <!-- Balance Meter Tab Content -->
                <div id="balance-meter-content" role="tabpanel" aria-labelledby="balanceMeterModeTab" class="hidden">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-semibold text-white">Balance Meter</h2>
                    </div>
                    <div id="balanceMeterTabContent" class="space-y-6">
                        <!-- Balance Meter content will be populated dynamically -->
                    </div>
                </div>
                
            </div>
        </main>

        <footer class="text-center text-gray-500 text-sm mt-12">
            <p>&copy; 2024 Woven Map Report Generator. Math Brain + Poetic Brain Framework.</p>
        </footer>
    </div>

    <script src="config.js"></script>
    <script src="src/parsers/seismograph-md.js"></script>
    <script src="src/reporters/comparative-report.js"></script>
    <script>
// --- Global row counter for report summary ---
let totalRowCount = 0;
// UI Filter State (persist across renders)
// Simple Mode defaults (no user toggles rendered)
window.WOVEN_UI_FILTERS = { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };
// ...existing code...
// ...existing code...
    // (Auth0 runtime removed here — consolidated below in initializeAuth0())

// Universal context reference for browser/server compatibility
const WOVEN_GLOBAL = (typeof globalThis !== 'undefined') ? globalThis : (typeof window !== 'undefined' ? window : {});

// Step-size limits (centralized + configurable)
// Defaults are intentionally conservative; warnings trigger at 80% of max.
const DEFAULT_STEP_LIMITS = {
    daily:  { max: 45,  warnRatio: 0.8, label: 'daily calculations' },
    weekly: { max: 270, warnRatio: 0.8, label: 'weekly calculations' },
    monthly:{ max: 550, warnRatio: 0.8, label: 'monthly calculations' }
};
function resolveStepLimits(){
    try {
        // Allow overrides via config.js if present
        const conf = (typeof WovenMapConfig !== 'undefined' && WovenMapConfig && WovenMapConfig.api && WovenMapConfig.api.limits && WovenMapConfig.api.limits.steps)
            ? WovenMapConfig.api.limits.steps : null;
        // Allow developer/browser overrides via localStorage
        const ls = localStorage.getItem('wm_step_limits_override');
        const lsParsed = ls ? JSON.parse(ls) : null;
        const merged = JSON.parse(JSON.stringify(DEFAULT_STEP_LIMITS));
        const apply = (src) => {
            if (!src) return;
            ['daily','weekly','monthly'].forEach(k => {
                if (src[k]) {
                    if (Number.isFinite(+src[k].max)) merged[k].max = +src[k].max;
                    if (Number.isFinite(+src[k].warnRatio)) merged[k].warnRatio = Math.max(0, Math.min(1, +src[k].warnRatio));
                    if (typeof src[k].label === 'string') merged[k].label = src[k].label;
                }
            });
        };
        apply(conf); apply(lsParsed);
        return merged;
    } catch(e){
        console.warn('Step limits override parse failed; using defaults', e);
        return DEFAULT_STEP_LIMITS;
    }
}
window.WOVEN_STEP_LIMITS = resolveStepLimits();

// --- Helper for lean/legacy aspect/transit row keys ---
function rowNamesAndOrb(r) {
    const transit = r.transit_body ?? r.p1_name ?? r.planet_a ?? '—';
    const natal   = r.natal_target ?? r.p2_name ?? r.planet_b ?? '—';
    const aspect  = r.aspect ?? r.aspect_name ?? r.name ?? '—';
    let orb = r.orb;
    if (!Number.isFinite(orb)) orb = Number(r.orbit);
    if (!Number.isFinite(orb)) orb = null;
    return { transit, natal, aspect, orb };
}
// --- Dual-read helpers for natal/synastry aspects ---
function nameA(r){ return r.p1_name ?? (legacyTouch('natal/synastry:p1_name'), r.planet_a) ?? r.transit_body ?? '—'; }
function nameB(r){ return r.p2_name ?? (legacyTouch('natal/synastry:p2_name'), r.planet_b) ?? r.natal_target ?? '—'; }
function aspectA(r){ return r.aspect ?? (legacyTouch('natal/synastry:aspect_name'), r.aspect_name) ?? '—'; }
function orbA(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('natal/synastry:orbit/diff'), (r.orbit ?? r.diff)); }

function formatAspectRow(r){
    const A = nameA(r), B = nameB(r), asp = aspectA(r);
    const o = orbA(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// --- Global legacy usage telemetry ---
window.WM_LEGACY_HITS = 0;
function legacyTouch(tag){ 
    window.WM_LEGACY_HITS++; 
    console.warn(`[LEGACY] used: ${tag}`); 
}

function nameT(r){ return r.transit_body ?? (legacyTouch('p1_name'), r.p1_name); }
function nameN(r){ return r.natal_target ?? (legacyTouch('p2_name'), r.p2_name); }
function aspectT(r){ return r.aspect ?? (legacyTouch('aspect_name'), r.aspect_name); }
function orbT(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('orbit/diff'), (r.orbit ?? r.diff)); }

function formatTransitRow(r){
    const A = nameT(r), B = nameN(r), asp = aspectT(r);
    const o = orbT(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// ---- aspect math (for fallback orb) ----
const ASPECTS = { conjunction:0, sextile:60, square:90, trine:120, opposition:180,
    quincunx:150, quintile:72, biquintile:144, 'semi-square':45, semisquare:45, sesquiquadrate:135 };
function degNorm(d){ let x=d%360; return x<0?x+360:x; }
function sep(a,b){ const d=Math.abs(degNorm(a)-degNorm(b)); return d>180?360-d:d; }
function computeOrbFromLongitudes(lon1, lon2, aspectName){
    if(!Number.isFinite(lon1) || !Number.isFinite(lon2)) return null;
    const exact = ASPECTS[(aspectName||'').toLowerCase()];
    if(!Number.isFinite(exact)) return null;
    return Math.abs(sep(lon1, lon2) - exact);
}
function bandOrb(orb){ if(!Number.isFinite(orb)) return 'wide';
    if(orb<=1) return 'tight'; if(orb<=3) return 'close'; if(orb<=6) return 'medium'; return 'wide';
}
function valenceHint(aspect){
    const a=(aspect||'').toLowerCase();
    if(['square','opposition','sesquiquadrate','semisquare','semi-square','quincunx'].includes(a)) return 'hot';
    if(['trine','sextile','quintile','biquintile'].includes(a)) return 'cool';
    return 'neutral_to_hot';
}

// ---- normalizers that accept any shape ----
function normalizeTransitRow(row){
    if (row && row.transit_body && row.natal_target) {
        const aspect = row.aspect || row.aspect_name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.transit_lon, row.natal_lon, aspect);
        return {
            transit_body: row.transit_body,
            natal_target: row.natal_target,
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.transit_lon ?? null,
            natal_lon: row.natal_lon ?? null,
            transit_house: row.transit_house ?? null,
            natal_house: row.natal_house ?? null,
            transit_is_retrograde: !!row.transit_is_retrograde,
            natal_is_retrograde: !!row.natal_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.planet_a || row.planet_b)) {
        const aspect = row.aspect_name || row.aspect || row.type || '';
        let orb = Number.isFinite(row.orbit) ? row.orbit
                        : Number.isFinite(row.orb) ? row.orb
                        : computeOrbFromLongitudes(row.abs_pos_a, row.abs_pos_b, aspect);
        return {
            transit_body: row.planet_a || '—',
            natal_target: row.planet_b || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.abs_pos_a ?? null,
            natal_lon: row.abs_pos_b ?? null,
            transit_house: row.p1_house ?? row.house1 ?? null,
            natal_house: row.p2_house ?? row.house2 ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.p1_name || row.p2_name)) {
        const aspect = row.aspect || row.name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.p1_abs_pos, row.p2_abs_pos, aspect);
        return {
            transit_body: row.p1_name || '—',
            natal_target: row.p2_name || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.p1_abs_pos ?? null,
            natal_lon: row.p2_abs_pos ?? null,
            transit_house: row.p1_house ?? null,
            natal_house: row.p2_house ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    return null;
}
function normalizeTransitBlock(block){
    if (Array.isArray(block)) {
        return block.map(normalizeTransitRow).filter(Boolean);
    }
    if (block && block.chart && Array.isArray(block.chart.aspects)) {
        return block.chart.aspects.map(normalizeTransitRow).filter(Boolean);
    }
    return [];
}
function renderTransitDay(dateStr, items){
    const rows = normalizeTransitBlock(items);
    if (!Array.isArray(rows) || rows.length === 0) return `<h4>${dateStr}</h4><p><em>No computed aspects.</em></p>`;
    const lines = rows.map(r => {
        const orbTxt = (r && typeof r.orb === 'number' && Number.isFinite(r.orb)) ? `${r.orb.toFixed(2)}°` : '—';
        return `• <strong>${r.transit_body}</strong> ${r.aspect} <strong>${r.natal_target}</strong> (${orbTxt}, ${r.orb_band}, ${r.valence_hint})`;
    });
    return `<h4>${dateStr}</h4><ul><li>${lines.join("</li><li>")}</li></ul>`;
}
        // Global UI element references
    let generateBtn, loadingIndicator, errorDisplay, errorMessage, reportOutput, reportContent, downloadReportBtn, mathBrainInfoBtn, mathBrainModal, closeMathBrainModal, closeMathBrainModalBottom, relocationToggle, relocationFields, transitDateFields, personBCard, relocationSection, relationalContextSection, intimacyTierDropdown, toggleModeHelp, modeHelpPanel, prefillTodayBtn, stepSizeHelpBtn, stepSizeHelpPanel, exRelationshipCheckbox, relocationPersonBOption, includePersonBRelocationEl, transitStartDate, transitEndDate, transitStep, relocationCoordsInput, loadHealthDataBtn, clearHealthDataBtn, healthDataInput, healthDataStatus, loadSeismoBtn, clearSeismoBtn, seismoMdInput, seismoDataStatus, genComparativeBtn, genComparativePdfBtn;

        // Store health data for correlation analysis
        let loadedHealthData = null;

        // Defensive check for window/globalThis
        if (typeof window === 'undefined') {
            console.warn('window is not defined; running in non-browser context');
        }

        // Store the latest result data for downloads
        let latestResultData = null;

        // --- Utility Functions ---

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
            reportOutput.classList.add('hidden');
            try { errorDisplay.focus({ preventScroll: true }); } catch(_){}
            // Hide report action buttons when showing error
            // Copy report removed
            document.getElementById('downloadReport').classList.add('hidden');
            document.getElementById('downloadPDF').classList.add('hidden');
            document.getElementById('pdfOptions').classList.add('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }
        
        function showBonusReportNotification(hasMirrorReport, hasBalanceMeterData, currentMode) {
            // Remove any existing notifications and tab indicators
            const existingNotifications = document.querySelectorAll('.bonus-report-notification');
            existingNotifications.forEach(n => n.remove());
            
            const existingIndicators = document.querySelectorAll('.bonus-indicator');
            existingIndicators.forEach(i => i.remove());
            
            let notificationMessage = '';
            let shouldShow = false;
            
            if (currentMode === 'mirror' && hasBalanceMeterData) {
                notificationMessage = '🎁 Bonus: Balance Meter analysis is also available! Check the Balance Meter tab.';
                shouldShow = true;
                
                // Add indicator to Balance Meter tab
                const balanceTab = document.getElementById('balanceMeterModeTab');
                if (balanceTab && !balanceTab.querySelector('.bonus-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'bonus-indicator bg-teal-500 text-white text-xs px-1.5 py-0.5 rounded-full ml-2';
                    indicator.textContent = 'NEW';
                    indicator.title = 'Bonus Balance Meter analysis available!';
                    balanceTab.appendChild(indicator);
                }
            }
            // Note: Mirror report cross-notification removed due to availability issues
            
            if (shouldShow) {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = 'bonus-report-notification bg-teal-900/50 border border-teal-500/30 text-teal-200 px-4 py-3 rounded mb-4 text-sm flex items-center gap-2';
                notification.innerHTML = `
                    <span class="flex-1">${notificationMessage}</span>
                    <button onclick="this.parentElement.remove()" class="text-teal-400 hover:text-teal-200 ml-2">✕</button>
                `;
                
                // Insert notification at the top of the report output area
                const reportOutput = document.getElementById('reportOutput');
                if (reportOutput) {
                    reportOutput.insertBefore(notification, reportOutput.firstChild);
                }
            }
        }

        // Non-destructive error notification for non-critical failures (like download issues)
        function showNotification(message, type = 'error') {
            // Create or reuse notification element
            let notification = document.getElementById('notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification';
                notification.className = 'fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-md transition-all duration-300 transform translate-x-full';
                document.body.appendChild(notification);
            }
            
            // Set content and styling based on type
            const bgColor = type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-blue-600';
            notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-md transition-all duration-300 transform ${bgColor} text-white`;
            notification.textContent = message;
            
            // Show notification
            notification.classList.remove('translate-x-full');
            notification.classList.add('translate-x-0');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (notification && notification.parentNode) {
                    notification.classList.remove('translate-x-0');
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (notification && notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Helper function to get opposite zodiac sign for South Node calculation
        function getOppositeSign(sign) {
            const opposites = {
                'Ari': 'Lib', 'Tau': 'Sco', 'Gem': 'Sag', 'Can': 'Cap',
                'Leo': 'Aqu', 'Vir': 'Pis', 'Lib': 'Ari', 'Sco': 'Tau',
                'Sag': 'Gem', 'Cap': 'Can', 'Aqu': 'Leo', 'Pis': 'Vir'
            };
            return opposites[sign] || sign;
        }

        // Helper function to check if any house cusps are available in chart data
        function hasAnyHouseCusps(chart) {
            const houseKeys = [
                'first_house', 'second_house', 'third_house', 'fourth_house',
                'fifth_house', 'sixth_house', 'seventh_house', 'eighth_house', 
                'ninth_house', 'tenth_house', 'eleventh_house', 'twelfth_house'
            ];
            return houseKeys.some(key => chart[key] && chart[key].sign && chart[key].position !== undefined);
        }

        // Reusable function to render natal chart data for any person
        function renderNatalChartData(chart, personName) {
            let md = '';
            
            try {
                // Chart Angles - only show if available
                if (chart.asc || chart.ascendant) {
                    md += `### Chart Angles\n\n`;
                    const asc = chart.asc || chart.ascendant;
                    const mc = chart.mc || chart.midheaven;
                    const dsc = chart.dsc || chart.descendant;
                    const ic = chart.ic || chart.imum_coeli;
                    
                    if (asc && asc.sign && asc.position !== undefined) {
                        md += `- **Ascendant (ASC)**: ${asc.sign} ${asc.position.toFixed(2)}°\n`;
                    }
                    if (mc && mc.sign && mc.position !== undefined) {
                        md += `- **Midheaven (MC)**: ${mc.sign} ${mc.position.toFixed(2)}°\n`;
                    }
                    if (dsc && dsc.sign && dsc.position !== undefined) {
                        md += `- **Descendant (DSC)**: ${dsc.sign} ${dsc.position.toFixed(2)}°\n`;
                    }
                    if (ic && ic.sign && ic.position !== undefined) {
                        md += `- **Imum Coeli (IC)**: ${ic.sign} ${ic.position.toFixed(2)}°\n`;
                    }
                    md += `\n`;
                }
                
                // Natal Planet Positions  
                md += `### Natal Planet Positions\n\n`;
                
                // Core planets in standard order
                const planets = [
                    { key: 'sun', name: 'Sun' },
                    { key: 'moon', name: 'Moon' },
                    { key: 'mercury', name: 'Mercury' },
                    { key: 'venus', name: 'Venus' },
                    { key: 'mars', name: 'Mars' },
                    { key: 'jupiter', name: 'Jupiter' },
                    { key: 'saturn', name: 'Saturn' },
                    { key: 'uranus', name: 'Uranus' },
                    { key: 'neptune', name: 'Neptune' },
                    { key: 'pluto', name: 'Pluto' },
                    { key: 'chiron', name: 'Chiron' }
                ];
                
                planets.forEach(planet => {
                    const planetData = chart[planet.key];
                    if (planetData && planetData.sign && planetData.position !== undefined) {
                        const house = planetData.house || 'Unknown';
                        const retrograde = planetData.retrograde ? ' ℞' : '';
                        md += `- **${planet.name}**: ${planetData.sign} ${planetData.position.toFixed(2)}° (House ${house})${retrograde}\n`;
                    }
                });
                
                // Lunar Nodes if available - prioritize true_node over mean_node for accuracy
                const northNode = chart.true_node || chart.mean_node || chart.north_node;
                if (northNode && northNode.sign && northNode.position !== undefined) {
                    md += `\n### Lunar Nodes\n\n`;
                    const house = northNode.house || 'Unknown';
                    const nodeType = chart.true_node ? 'True' : chart.mean_node ? 'Mean' : '';
                    md += `- **North Node${nodeType ? ` (${nodeType})` : ''}**: ${northNode.sign} ${northNode.position.toFixed(2)}° (House ${house})\n`;
                    
                    // South Node is opposite North Node
                    const southNodePos = (northNode.position + 180) % 360;
                    const southNodeSign = getOppositeSign(northNode.sign);
                    if (southNodeSign) {
                        md += `- **South Node${nodeType ? ` (${nodeType})` : ''}**: ${southNodeSign} ${southNodePos.toFixed(2)}°\n`;
                    }
                }
                
                // House Cusps if available - check all 12 houses
                if (hasAnyHouseCusps(chart)) {
                    md += `\n### House Cusps\n\n`;
                    const houses = [
                        { key: 'first_house', name: '1st House', description: 'Identity, Stance' },
                        { key: 'second_house', name: '2nd House', description: 'Resource, Security' },
                        { key: 'third_house', name: '3rd House', description: 'Exchange, Signals' },
                        { key: 'fourth_house', name: '4th House', description: 'Root, Anchor' },
                        { key: 'fifth_house', name: '5th House', description: 'Creative, Expression' },
                        { key: 'sixth_house', name: '6th House', description: 'Craft, Rhythm' },
                        { key: 'seventh_house', name: '7th House', description: 'Relational, Mirror' },
                        { key: 'eighth_house', name: '8th House', description: 'Depth, Crossing' },
                        { key: 'ninth_house', name: '9th House', description: 'Horizon, Philosophy' },
                        { key: 'tenth_house', name: '10th House', description: 'Apex, Projection' },
                        { key: 'eleventh_house', name: '11th House', description: 'Network, Belonging' },
                        { key: 'twelfth_house', name: '12th House', description: 'Dream, Spirit' }
                    ];
                    
                    houses.forEach(house => {
                        const houseData = chart[house.key];
                        if (houseData && houseData.sign && houseData.position !== undefined) {
                            md += `- **${house.name}**: ${houseData.sign} ${houseData.position.toFixed(2)}° (${house.description})\n`;
                        }
                    });
                }
                
                md += `\n`;
            } catch (error) {
                console.log(`Error rendering ${personName} natal chart data:`, error);
                md += `*Natal chart data available but could not be displayed due to formatting.*\n\n`;
            }
            
            return md;
        }

        // --- Date Utility Functions ---

        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function prefillTodayDates() {
            const todayStr = getTodayDateString();
            document.getElementById('transitStartDate').value = todayStr;
            document.getElementById('transitEndDate').value = todayStr;
            
            // Brief visual feedback (only if button exists)
            if (prefillTodayBtn) {
                prefillTodayBtn.textContent = '✅ Set to Today';
                setTimeout(() => { 
                    prefillTodayBtn.textContent = '📅 Use Today for Quick Check'; 
                }, 2000);
            }
        }

        // --- Download Functions ---

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        // Chunking functions for handling large date ranges
        function calculateDaySpan(transitParams) {
            if (!transitParams?.startDate || !transitParams?.endDate) return 0;
            const start = new Date(transitParams.startDate);
            const end = new Date(transitParams.endDate);
            return Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;
        }

        function createDateChunks(transitParams, chunkSize = 10) {
            const start = new Date(transitParams.startDate);
            const end = new Date(transitParams.endDate);
            const chunks = [];
            
            let currentStart = new Date(start);
            
            while (currentStart <= end) {
                let currentEnd = new Date(currentStart);
                currentEnd.setDate(currentEnd.getDate() + chunkSize - 1);
                
                if (currentEnd > end) {
                    currentEnd = new Date(end);
                }
                
                chunks.push({
                    startDate: currentStart.toISOString().split('T')[0],
                    endDate: currentEnd.toISOString().split('T')[0],
                    step: transitParams.step
                });
                
                // advance to the day after the currentEnd (robust across months/years)
                currentStart = new Date(currentEnd);
                currentStart.setDate(currentStart.getDate() + 1);
            }
            
            return chunks;
        }

        function mergeChunkedResults(results) {
            // Merge multiple chunked results into a single coherent result
            if (!results.length) return null;
            
            const merged = JSON.parse(JSON.stringify(results[0])); // Deep clone first result
            
            // Merge transitsByDate for each entity
            for (let i = 1; i < results.length; i++) {
                const result = results[i];
                
                // Merge Person A transits
                if (result.person_a?.chart?.transitsByDate && merged.person_a?.chart?.transitsByDate) {
                    Object.assign(merged.person_a.chart.transitsByDate, result.person_a.chart.transitsByDate);
                }
                
                // Merge Person B transits
                if (result.person_b?.chart?.transitsByDate && merged.person_b?.chart?.transitsByDate) {
                    Object.assign(merged.person_b.chart.transitsByDate, result.person_b.chart.transitsByDate);
                }
                
                // Merge Composite transits
                if (result.composite?.transitsByDate && merged.composite?.transitsByDate) {
                    Object.assign(merged.composite.transitsByDate, result.composite.transitsByDate);
                }
                
                // Merge Synastry transits
                if (result.synastry?.transitsByDate && merged.synastry?.transitsByDate) {
                    Object.assign(merged.synastry.transitsByDate, result.synastry.transitsByDate);
                }
            }
            
            return merged;
        }

        // Resilient API POST helper with fallback
        async function postMathBrain(payload, timeoutMs = 30000) {
            const primary = WovenMapConfig.getApiEndpoint('astrologyMathBrain'); // usually /api/astrology-mathbrain
            const fallback = '/.netlify/functions/astrology-mathbrain'; // direct function path
            const doFetch = async (url) => {
                const controller = new AbortController();
                const timeoutHandle = setTimeout(() => controller.abort(), timeoutMs);
                try {
                    return await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                } finally {
                    clearTimeout(timeoutHandle);
                }
            };

            let res = await doFetch(primary);
            if (res.status === 404) {
                // If 404 returns Netlify HTML, SPA route likely intercepted; retry direct function path
                const ct = (res.headers && res.headers.get && res.headers.get('content-type')) || '';
                let txt = '';
                try { txt = await res.clone().text(); } catch(_) {}
                const looksHtml404 = ct.includes('text/html') || (txt && /^<!DOCTYPE html>/i.test(txt.trim()));
                if (looksHtml404) {
                    console.warn('[API] /api route returned 404 HTML. Retrying direct function path.');
                    res = await doFetch(fallback);
                }
            }
            return res;
        }

        async function generateReportWithChunking(formData) {
            const startTime = Date.now();
            const daySpan = calculateDaySpan(formData.transitParams);
            const mode = formData.context.mode;
            
            // Initialize run statistics tracking
            window.lastRunStats = {
                api_calls: 0,
                calc_ms: 0,
                hooks_accepted: 0,
                hooks_rejected: 0,
                chunks_processed: 0
            };
            
            // Auto-chunk for ranges > 15 days to stay under 6MB limit
            // Include balance_meter since it relies on per-day transit calculations
            if (daySpan > 15 && (mode.includes('transits') || mode === 'balance_meter')) {
                console.log(`Auto-chunking ${daySpan}-day range into smaller segments`);
                
                // Determine optimal chunk size based on step size
                let chunkSize = 10; // Default: 10 days per chunk
                if (formData.transitParams.step === '7d' || formData.transitParams.step === 'weekly') {
                    chunkSize = 21; // 3 weeks per chunk for weekly data
                } else if (formData.transitParams.step === '1m' || formData.transitParams.step === 'monthly') {
                    chunkSize = 60; // 2 months per chunk for monthly data
                }
                
                const chunks = createDateChunks(formData.transitParams, chunkSize);
                const results = [];
                
                // Update loading indicator to show progress
                const loadingText = document.getElementById('loadingText');
                const originalText = loadingText?.textContent || 'Computing Astrological Geometry...';
                
                const failed = [];
                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    
                    // Create a new formData object with chunked transit parameters
                    // CRITICAL: Don't modify transitParams directly - create new payload per chunk
                    const chunkData = JSON.parse(JSON.stringify(formData)); // Deep clone
                    chunkData.transitParams = chunk;
                    
                    // Update progress
                    if (loadingText) {
                        loadingText.textContent = `Processing chunk ${i + 1} of ${chunks.length} (${chunk.startDate} to ${chunk.endDate})...`;
                    }
                    
                    console.log(`Processing chunk ${i + 1}/${chunks.length}: ${chunk.startDate} to ${chunk.endDate}`);
                    
                    try {
                        const timeoutMs = 60000; // Longer timeout for chunked requests
                        const response = await postMathBrain(chunkData, timeoutMs);
                        // Track API call
                        window.lastRunStats.api_calls++;

                        if (!response.ok) {
                            const errorBody = await response.text();
                            throw new Error(`Chunk ${i + 1} failed: HTTP ${response.status} - ${errorBody}`);
                        }

                        const result = await response.json().catch(jsonError => {
                            // Handle cases where response is not valid JSON
                            console.error(`Chunk ${i + 1} - Failed to parse API response as JSON:`, jsonError);
                            console.error(`Chunk ${i + 1} - Response status:`, response.status, response.statusText);
                            throw new Error(`Chunk ${i + 1} API returned non-JSON response. Status: ${response.status}`);
                        });
                        // Track chunk processing
                        window.lastRunStats.chunks_processed++;
                        
                        if (result.error) {
                            throw new Error(`Chunk ${i + 1} error: ${result.error}`);
                        }
                        
                        results.push(result);
                        
                        // Brief pause between chunks to avoid overwhelming the server
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        
                    } catch (error) {
                        console.error(`Chunk ${i + 1} failed:`, error);
                        failed.push({ index: i + 1, start: chunk.startDate, end: chunk.endDate, message: error.message });
                        // Continue to try remaining chunks (partial success strategy)
                    }
                }
                
                // Restore loading text
                if (loadingText) {
                    loadingText.textContent = 'Merging results...';
                    // restore shortly after to base message
                    setTimeout(()=>{ try{ loadingText.textContent = originalText; } catch(_){} }, 300);
                }
                
                console.log(`Processed ${chunks.length} chunks → success: ${results.length}, failed: ${failed.length}. Merging results...`);
                if (failed.length) {
                    console.warn('Chunk failures:', failed);
                }
                if (!results.length) {
                    throw new Error('All chunk requests failed; no data could be retrieved.');
                }
                return mergeChunkedResults(results);
            }
            
            // Single request for shorter ranges
            const timeoutMs = (WovenMapConfig?.api?.timeout && Number.isFinite(+WovenMapConfig.api.timeout)) ? +WovenMapConfig.api.timeout : 30000;
            const response = await postMathBrain(formData, timeoutMs);

            if (!response.ok) {
                const errorBody = await response.text();
                let errorMessage = `HTTP error! status: ${response.status}`;
                try {
                    const errorJson = JSON.parse(errorBody);
                    if (errorJson.error) {
                       errorMessage += ` - ${errorJson.error}`;
                    } else {
                       errorMessage += ` - ${errorBody}`;
                    }
                } catch (e) {
                    errorMessage += ` - ${errorBody}`;
                }
                throw new Error(errorMessage);
            }

            const result = await response.json().catch(jsonError => {
                // Handle cases where response is not valid JSON (e.g., "Method Not Allowed" text)
                console.error('Failed to parse API response as JSON:', jsonError);
                console.error('Response status:', response.status, response.statusText);
                throw new Error(`API returned non-JSON response. Status: ${response.status}, Status Text: ${response.statusText}`);
            });
            if (result.error) {
                throw new Error(result.error);
            }
            
            // Finalize run statistics for single request
            window.lastRunStats.calc_ms = Date.now() - startTime;
            
            return result;
        }

        // === EXECUTIVE SUMMARY AND JSON APPENDIX GENERATORS ===
        
        // Helper functions for executive summary
        function aspectSymbol(asp) {
            const symbols = { 
                opp: "☍", opposition: "☍",
                conj: "☌", conjunction: "☌", 
                trine: "△", sextile: "✧", 
                square: "□", quinc: "⚼", quincunx: "⚼"
            };
            return symbols[asp] || asp;
        }
        
        function formatDegree(n) { 
            return `${n.toFixed(1)}°`; 
        }
        
        function formatNumber(n) { 
            return (n ?? NaN).toFixed(2).replace(/NaN/, "—"); 
        }
        
        function generateExecutiveSummary(data, opts = {}) {
            const { includeHealthLine = true, includeProvenance = true } = opts;
            
            // Extract first day seismograph data
            const firstDayRaw = data.person_a?.chart?.transitsByDate ? 
                Object.values(data.person_a.chart.transitsByDate)[0] :
                data.sky_transits?.transitsByDate ? 
                Object.values(data.sky_transits.transitsByDate)[0] : null;
            
            const firstDayData = firstDayRaw ? normalizeEntry(firstDayRaw) : null;
            
            const formData = collectFormData();
            const mode = formData.context.mode;
            const currentDate = new Date().toISOString().split('T')[0];
            const personA = data.person_a?.details || formData.personA;
            
            // Extract top hooks
            const top = firstDayData?.hooks?.slice(0, 3) || [];
            const hooksStr = top
                .map(h => `${h.p1_display || h.p1_name}${aspectSymbol(h._aspect || h.aspect)}${h.p2_display || h.p2_name} (${formatDegree(h._orb || h.orb || 0)})`)
                .join(", ") || "—";
            
            // Health data
            const healthData = data.health_analysis;
            const health = healthData?.present ? 
                `present${healthData.fidelity_index ? ` | Fidelity ${healthData.fidelity_index.toFixed(1)}/5` : ""}` : 
                "absent";
            
            // Provenance
            const ephemerisSource = data.provenance?.ephemeris_source || "AstrologerAPI-v4";
            const ephemerisHash = data.provenance?.ephemeris_hash || "unknown";
            const prov = `${ephemerisSource} | hash ${ephemerisHash.slice(0, 8)}…`;
            
            // Clamp valence for headline; keep raw for debug transparency
            const rawVal = firstDayData?.seismograph?.valence ?? 0;
            const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
            const clampedVal = clamp(rawVal,-5,5);
            // Retrograde breakdown (transiting retro bodies vs retro-tagged aspects)
            let retroTransitPlanets = 0; let retroTaggedAspects = 0;
            if (firstDayData) {
                const retroBodies = new Set();
                (firstDayData.hooks||[]).forEach(h=>{ if(h.transit_is_retrograde) retroBodies.add(h.p1_name||h.p1_display); if(h.transit_is_retrograde||h.natal_is_retrograde) retroTaggedAspects++; });
                (firstDayData.filtered_aspects||[]).forEach(a=>{ if(a.transit_is_retrograde) retroBodies.add(a.p1_name||a.p1_display); if(a.transit_is_retrograde||a.natal_is_retrograde) retroTaggedAspects++; });
                retroTransitPlanets = retroBodies.size;
            }
            const lines = [
                `# Exec Summary (${data.provenance?.math_brain_version || '0.2.1'})`,
                `Date: ${currentDate}  TZ: ${personA?.timezone || 'UTC'}  Context: ${mode?.toUpperCase() || 'N/A'}`,
                `Triple Channel: ${firstDayData ? tripleChannelLine(firstDayData) : 'No data'}`,
                `Magnitude: ${formatNumber(firstDayData?.seismograph?.magnitude)} (${toMagnitudeTerm(firstDayData?.seismograph?.magnitude || 0)}) | Valence: ${getValenceEmoji(clampedVal)} ${formatNumber(clampedVal)} (${toValenceTerm(clampedVal)}) | Volatility: ${formatNumber(firstDayData?.seismograph?.volatility)}`,
                `Valence_raw (debug): ${formatNumber(rawVal)}`,
                `Top Hooks (orb-capped): ${hooksStr} • [Geometry](#geometry-skeleton)`,
                `Transiting ℞ planets: ${retroTransitPlanets}  ℞-tagged aspects: ${retroTaggedAspects}  OSR: ${(firstDayData?.osr_flags || []).length}`,
                includeHealthLine ? `Health Link: ${health}` : undefined,
                includeProvenance ? `Provenance: ${prov}` : undefined
            ].filter(Boolean);
            
            return lines.join("\n");
        }
        
        function generateJsonAppendix(data, runStats = {}) {
            const transitsByDate = data.person_a?.chart?.transitsByDate || data.sky_transits?.transitsByDate || {};
            const CALIBRATION_BOUNDARY = (data.provenance && data.provenance.calibration_boundary) || '2025-09-05';
            const engines = data.provenance?.engine_versions || { seismograph: 'v1.0', balance: 'v1.1', sfd: 'v1.2' };
            const reconstructed = Boolean(data.reconstructed || (Object.keys(transitsByDate).some(d => d < CALIBRATION_BOUNDARY)));

            const entries = Object.entries(transitsByDate).map(([date, day]) => {
                // Normalize nested/flat balance & sfd
                const balance = day.balance && typeof day.balance === 'object'
                    ? day.balance
                    : (Number.isFinite(day.balance) ? { magnitude: day.seismograph?.magnitude || 0, valence: day.balance, version: 'v1.1' } : undefined);
                const sfd = day.sfd && typeof day.sfd === 'object'
                    ? day.sfd
                    : (Number.isFinite(day.sfd) || Number.isFinite(day.splus) || Number.isFinite(day.sminus))
                        ? { sfd: day.sfd || 0, sPlus: day.splus || 0, sMinus: day.sminus || 0, version: 'v1.2' }
                        : undefined;

                return {
                    schema: 'WM-Chart-1.2',
                    date,
                    seismograph: {
                        magnitude: day.seismograph?.magnitude || 0,
                        valence: day.seismograph?.valence || 0,
                        version: 'v1.0'
                    },
                    ...(balance ? { balance } : {}),
                    ...(sfd ? { sfd } : {}),
                    meta: {
                        calibration_boundary: CALIBRATION_BOUNDARY,
                        engine_versions: engines,
                        reconstructed
                    }
                };
            });

            return entries;
        }
        
        function generateProvenance(data, runStats = {}) {
            const lines = [
                "## Provenance & Processing Metadata\n",
                `**Ephemeris Source**: ${data.provenance?.ephemeris_source || 'AstrologerAPI-v4'}`,
                `**Ephemeris Hash**: ${data.provenance?.ephemeris_hash || 'unknown'}`,
                `**Node Preference**: ${data.provenance?.node_preference || 'True Node (preferred)'}`,
                `**Orb Caps Applied**: Luminaries ${data.provenance?.orb_caps?.luminaries || 12}°, Planets ${data.provenance?.orb_caps?.planets || 8}°, Points ${data.provenance?.orb_caps?.points || 6}°`,
                `**Max Ephemeris Delta**: ±${data.provenance?.max_ephemeris_delta || 0.01}°`,
                `**Processing Stats**: ${runStats.api_calls || 0} API calls, ${runStats.calc_ms || 0}ms calculation time`,
                `**Hook Stats**: ${runStats.hooks_accepted || 0} accepted, ${runStats.hooks_rejected || 0} rejected`,
                `**Deterministic Seed**: ${data.provenance?.deterministic_seed || 'None'}`,
                `**Error Budget**: Max ephemeris variance within tolerance for geometric fidelity`
            ];
            
            return lines.join("\n");
        }
        
        function validateAppendix(payload) {
            // Simple validation - check required fields
            try {
                if (!payload || typeof payload !== 'object') {
                    return { ok: false, errors: ['Payload must be an object'] };
                }
                
                const errors = [];
                
                // Check meta section
                if (!payload.meta) errors.push('meta section missing');
                else {
                    if (!payload.meta.wm_schema) errors.push('meta.wm_schema missing');
                    if (!payload.meta.math_brain_version) errors.push('meta.math_brain_version missing');
                    if (!payload.meta.generated_utc) errors.push('meta.generated_utc missing');
                    if (!payload.meta.ephemeris) errors.push('meta.ephemeris missing');
                    if (!payload.meta.run_stats) errors.push('meta.run_stats missing');
                }
                
                // Check subject section
                if (!payload.subject) errors.push('subject section missing');
                else {
                    if (!payload.subject.name) errors.push('subject.name missing');
                    if (!payload.subject.dob) errors.push('subject.dob missing');
                    if (!payload.subject.tob) errors.push('subject.tob missing');
                    if (!payload.subject.loc) errors.push('subject.loc missing');
                }
                
                // Check seismograph section
                if (!payload.seismograph) errors.push('seismograph section missing');
                else if (!Array.isArray(payload.seismograph)) errors.push('seismograph must be an array');
                
                return errors.length === 0 ? { ok: true } : { ok: false, errors };
            } catch (e) {
                return { ok: false, errors: [`Validation error: ${e.message}`] };
            }
        }

        // === BALANCE METER / SFD HELPERS ===
        
        function sfdVerdict(sfd) {
            if (sfd == null) return null;
            if (sfd >= 0.75)  return "stabilizers prevail";
            if (sfd <= -0.75) return "stabilizers cut";
            return "stabilizers mixed";
        }
        
        function fmtSigned(n) {
            if (n == null || Number.isNaN(+n)) return "?";
            const x = +n;
            return `${x >= 0 ? "+" : ""}${x.toFixed(1)}`;
        }
        
        function tripleChannelLine({ seismograph, balance, sfd }) {
            const mag = seismograph?.magnitude;
            const magTxt = Number.isFinite(mag) ? mag.toFixed(1) : "?";
            const val = seismograph?.valence;
            const valEmoji = Number.isFinite(val) ? getValenceEmoji(Math.max(-5, Math.min(5, val))) : '';
            const parts = [`⚡ ${magTxt}`, `Val ${valEmoji} ${fmtSigned(val)}`];

            if (balance && Number.isFinite(balance.valence)) {
                const balEmoji = getValenceEmoji(Math.max(-5, Math.min(5, balance.valence)));
                parts.push(`Bal ${balEmoji} ${fmtSigned(balance.valence)}`);
            }

            if (sfd && Number.isFinite(sfd.sfd)) {
                const verdict = sfdVerdict(sfd.sfd);
                if (verdict) {
                    const sPlus = Number.isFinite(sfd.sPlus) ? sfd.sPlus.toFixed(1) : '?';
                    const sMinus = Number.isFinite(sfd.sMinus) ? sfd.sMinus.toFixed(1) : '?';
                    parts.push(`${verdict} (SFD ${fmtSigned(sfd.sfd)}; S+ ${sPlus}/S− ${sMinus})`);
                } else {
                    parts.push(`SFD ${fmtSigned(sfd.sfd)}`);
                }
            }

            return parts.join(" · ");
        }
        
        // === TRANSITS HELPERS (Standardized extractors to avoid scope errors) ===
        function resolveTransitsByDate(root){
            if (!root || typeof root !== 'object') return null;
            // Common shapes
            if (root.chart?.transitsByDate) return root.chart.transitsByDate;
            if (root.transitsByDate) return root.transitsByDate;
            if (root.person_a?.chart?.transitsByDate) return root.person_a.chart.transitsByDate;
            if (root.sky_transits?.transitsByDate) return root.sky_transits.transitsByDate;
            if (root.composite?.transitsByDate) return root.composite.transitsByDate;
            if (root.synastry?.transitsByDate) return root.synastry.transitsByDate;
            return null;
        }

        function getFirstDayData(root){
            const tbd = resolveTransitsByDate(root);
            if (!tbd) return { firstDate: null, firstDayData: null, transitsByDate: null };
            let firstDate = null;
            let raw = null;
            if (Array.isArray(tbd)){
                raw = tbd[0] ?? null;
            } else {
                const keys = Object.keys(tbd);
                firstDate = keys.length ? keys[0] : null;
                raw = firstDate ? tbd[firstDate] : null;
            }
            let firstDayData = raw;
            try {
                if (typeof normalizeEntry === 'function' && raw) firstDayData = normalizeEntry(raw);
            } catch(_e) { /* ignore */ }
            return { firstDate, firstDayData, transitsByDate: tbd };
        }

        function countAspectsForDay(day){
            if (!day) return 0;
            if (Array.isArray(day)) return day.length;
            const a = Array.isArray(day.aspects) ? day.aspects.length : 0;
            const f = Array.isArray(day.filtered_aspects) ? day.filtered_aspects.length : 0;
            const h = Array.isArray(day.hooks) ? day.hooks.length : 0;
            return a || (f + h);
        }

        // Normalize entry for consistent nested data structure
        function normalizeEntry(e) {
            const out = { ...e };
            out.seismograph = e.seismograph ?? { 
                magnitude: e.magnitude || 0, 
                valence: e.valence || 0, 
                volatility: e.volatility || 0,
                version: "v1.0" 
            };
            out.balance = e.balance ?? (
                Number.isFinite(e.balance_valence) ? { 
                    magnitude: out.seismograph.magnitude, 
                    valence: e.balance_valence, 
                    version: "v1.1" 
                } : undefined
            );
            out.sfd = e.sfd ?? (
                (e.sfd != null || e.splus != null || e.sminus != null)
                    ? { sfd: e.sfd || 0, sPlus: e.splus || 0, sMinus: e.sminus || 0, version: "v1.2" }
                    : undefined
            );
            return out;
        }

        // Generate simplified seismograph markdown section for auto-append to Mirror reports
        // Resilience & Depletion Layer Functions
        function calculateNatalResilienceProfile(natalChart) {
            if (!natalChart?.aspects) return { scaffoldingStrength: 3.0, recoveryRate: 0.85, volatilityProne: false };
            
            let stabilizerPoints = 0;
            let volatilityPoints = 0;
            let saturnIntegration = 0;
            let dominanceFactors = { uranus: 0, pluto: 0, mars: 0 };
            
            natalChart.aspects.forEach(aspect => {
                const aspectType = aspect.aspect || aspect.aspect_name || aspect.name || '';
                const orb = Math.abs(aspect.orb || aspect.orbit || aspect.diff || 0);
                const p1 = aspect.p1_name || aspect.planet_a || '';
                const p2 = aspect.p2_name || aspect.planet_b || '';
                
                // Skip if orb too wide (focus on tight aspects)
                if (orb > 8) return;
                
                // Weight by orb tightness (tighter = stronger influence)
                const orbWeight = Math.max(0.3, 1 - (orb / 8));
                
                // Stabilizer-friendly patterns (per Raven's criteria)
                if (aspectType.toLowerCase().includes('trine')) {
                    stabilizerPoints += 2.0 * orbWeight;
                }
                if (aspectType.toLowerCase().includes('sextile')) {
                    stabilizerPoints += 1.0 * orbWeight;
                }
                
                // Saturn integration assessment
                if (p1.toLowerCase().includes('saturn') || p2.toLowerCase().includes('saturn')) {
                    if (aspectType.toLowerCase().includes('trine') || aspectType.toLowerCase().includes('sextile')) {
                        saturnIntegration += 1.5 * orbWeight; // Well-integrated Saturn
                    } else if (aspectType.toLowerCase().includes('conjunction')) {
                        saturnIntegration += 1.0 * orbWeight; // Neutral Saturn
                    }
                    // Squares/oppositions to Saturn don't add integration points but aren't penalties either
                }
                
                // Volatility-prone patterns
                if (aspectType.toLowerCase().includes('opposition') || aspectType.toLowerCase().includes('square')) {
                    // Check if there are compensating stabilizer aspects
                    const hasStabilizerCompensation = stabilizerPoints >= 2.0;
                    if (!hasStabilizerCompensation) {
                        volatilityPoints += 1.5 * orbWeight;
                    } else {
                        volatilityPoints += 0.5 * orbWeight; // Reduced penalty with stabilizer compensation
                    }
                }
                
                // Uranus/Pluto dominance tracking
                if (p1.toLowerCase().includes('uranus') || p2.toLowerCase().includes('uranus')) {
                    dominanceFactors.uranus += orbWeight;
                }
                if (p1.toLowerCase().includes('pluto') || p2.toLowerCase().includes('pluto')) {
                    dominanceFactors.pluto += orbWeight;
                }
                if (p1.toLowerCase().includes('mars') || p2.toLowerCase().includes('mars')) {
                    dominanceFactors.mars += orbWeight;
                }
            });
            
            // Calculate scaffolding strength (1.0 - 5.0 scale)
            const baseScaffolding = 3.0;
            const stabilizerBonus = Math.min(2.0, stabilizerPoints * 0.3);
            const saturnBonus = Math.min(1.0, saturnIntegration * 0.4);
            const volatilityPenalty = Math.min(2.0, volatilityPoints * 0.25);
            
            const scaffoldingStrength = Math.max(1.0, Math.min(5.0, 
                baseScaffolding + stabilizerBonus + saturnBonus - volatilityPenalty
            ));
            
            // Recovery rate (0.6 to 0.95 range - higher = faster decay/recovery)
            const baseRecoveryRate = 0.85;
            const recoveryBonus = (scaffoldingStrength - 3.0) * 0.025; // ±0.05 range
            const recoveryRate = Math.max(0.6, Math.min(0.95, baseRecoveryRate + recoveryBonus));
            
            // Volatility proneness
            const uranusPlutoDominance = dominanceFactors.uranus + dominanceFactors.pluto;
            const volatilityProne = uranusPlutoDominance >= 3.0 || volatilityPoints >= 4.0;
            
            return {
                scaffoldingStrength: Math.round(scaffoldingStrength * 10) / 10,
                recoveryRate: Math.round(recoveryRate * 1000) / 1000,
                volatilityProne: volatilityProne,
                // Debug info
                _debug: {
                    stabilizerPoints: Math.round(stabilizerPoints * 10) / 10,
                    volatilityPoints: Math.round(volatilityPoints * 10) / 10,
                    saturnIntegration: Math.round(saturnIntegration * 10) / 10,
                    dominanceFactors: dominanceFactors
                }
            };
        }
        
        function calculateResilienceMetrics(balanceMeterData, sourceData = null) {
            if (!balanceMeterData?.daily_entries) return {};
            
            // Extract natal scaffolding profile
            const natalChart = sourceData?.person_a?.chart;
            const natalProfile = calculateNatalResilienceProfile(natalChart);
            
            const dates = Object.keys(balanceMeterData.daily_entries).sort();
            const resilience = {};
            let cumulativeLoad = 0;
            let resilienceBaseline = natalProfile.scaffoldingStrength; // Smoothed baseline
            let recoveryMomentum = 0; // Continuous recovery state
            
            dates.forEach((date, index) => {
                const day = normalizeEntry(balanceMeterData.daily_entries[date]);
                if (!day) return;
                
                // Extract metrics from day
                const magnitude = day.seismograph?.magnitude || 0;
                const valence = day.seismograph?.valence || 0;
                const balanceVal = day.balance?.valence || valence;
                const sfd = day.sfd?.sfd || 0;
                
                // 1. Stress Detection (high magnitude + negative valence)
                const stressLevel = magnitude * Math.max(0, -valence) / 5; // 0-5 scale
                
                // 2. SMOOTHED Load Accumulation (natal-modulated decay)
                cumulativeLoad = cumulativeLoad * natalProfile.recoveryRate + stressLevel;
                
                // 3. CONTINUOUS Recovery Signal (no binary threshold)
                const positiveSignals = Math.max(0, balanceVal) + Math.max(0, sfd);
                const stressWeight = Math.max(0.1, 1 - (stressLevel / 5)); // Less recovery during active stress
                const rawRecoverySignal = positiveSignals * stressWeight;
                
                // 4. SMOOTHED Recovery Momentum (natal-modulated decay curve)
                const recoveryDecay = natalProfile.volatilityProne ? 0.75 : 0.85; // Volatile charts lose momentum faster
                const recoveryGain = natalProfile.scaffoldingStrength / 3.0; // 0.33-1.67 multiplier
                recoveryMomentum = (recoveryMomentum * recoveryDecay) + (rawRecoverySignal * recoveryGain * 0.3);
                
                // 5. SMOOTHED Resilience Baseline (adaptive baseline with momentum)
                const baselineDecay = 0.95; // Very slow baseline changes
                const loadStress = Math.min(1.0, cumulativeLoad / 5.0); // 0-1 stress factor
                const targetBaseline = natalProfile.scaffoldingStrength * (1 - loadStress * 0.4); // Max 40% reduction
                resilienceBaseline = (resilienceBaseline * baselineDecay) + (targetBaseline * (1 - baselineDecay));
                
                // 6. CONTINUOUS Resilience Score (no step functions)
                const recoveryBonus = Math.min(1.5, recoveryMomentum * 0.6); // Capped momentum bonus
                const resilienceScore = Math.max(0.5, resilienceBaseline + recoveryBonus);
                
                // 7. SMOOTHED Depletion Risk (continuous curve)
                const depletionThreshold = natalProfile.volatilityProne ? 2.5 : 3.0;
                let depletionRisk = 0;
                if (cumulativeLoad > depletionThreshold) {
                    const excessLoad = cumulativeLoad - depletionThreshold;
                    const volatilityMultiplier = natalProfile.volatilityProne ? 1.4 : 1.0;
                    const recoveryProtection = Math.min(0.5, recoveryMomentum * 0.2); // Recovery reduces depletion
                    depletionRisk = Math.max(0, (excessLoad * 1.5 * volatilityMultiplier) - recoveryProtection);
                }
                
                // 8. SMOOTHED Narrative (based on continuous values, not thresholds)
                let narrative = "Stable";
                const normalizedResilience = resilienceScore / natalProfile.scaffoldingStrength;
                
                if (depletionRisk >= 2.5) {
                    narrative = natalProfile.volatilityProne ? "Deep depletion risk" : "Depletion risk";
                } else if (stressLevel >= 2.0) {
                    if (normalizedResilience >= 1.1 && recoveryMomentum >= 1.0) {
                        narrative = natalProfile.scaffoldingStrength >= 4.0 ? "Quick rebound" : "Stress with rebound";
                    } else {
                        narrative = natalProfile.volatilityProne ? "Intense stress" : "Active stress";
                    }
                } else if (recoveryMomentum >= 1.2) {
                    narrative = natalProfile.scaffoldingStrength >= 4.0 ? "Strong recovery" : "Recovery phase";
                } else if (normalizedResilience <= 0.8) {
                    narrative = natalProfile.volatilityProne ? "Load building" : "Load accumulating";
                } else if (recoveryMomentum >= 0.5) {
                    narrative = "Gentle recovery";
                }
                
                resilience[date] = {
                    recovery: Math.round(recoveryMomentum * 10) / 10,
                    resilience: Math.round(resilienceScore * 10) / 10,
                    depletionIndex: Math.round(depletionRisk * 10) / 10,
                    narrative: narrative,
                    // Debug info (not shown in report)
                    _debug: {
                        stressLevel: Math.round(stressLevel * 10) / 10,
                        cumulativeLoad: Math.round(cumulativeLoad * 10) / 10,
                        resilienceBaseline: Math.round(resilienceBaseline * 10) / 10,
                        recoveryMomentum: Math.round(recoveryMomentum * 10) / 10,
                        natalProfile: index === 0 ? natalProfile : undefined // Only show on first day
                    }
                };
            });
            
            return resilience;
        }

        function buildBalanceMeterReport(balanceMeterData, sourceData = null) {
            if (!balanceMeterData) return 'No Balance Meter data available.';

            let md = `# Balance Meter Report\n\n`;
            const personDetails = sourceData?.person_a?.details || null;
            const subjectName = balanceMeterData.person?.name || personDetails?.name || 'Unknown';
            md += `**Subject**: ${subjectName}\n`;
            // Always include birth identity info if available
            try {
                if (personDetails && typeof generateBirthLabel === 'function') {
                    md += `**Birth**: ${generateBirthLabel({
                        birthDate: personDetails.birthDate || `${personDetails.year}-${String(personDetails.month).padStart(2,'0')}-${String(personDetails.day).padStart(2,'0')}`,
                        birthTime: personDetails.birthTime || `${String(personDetails.hour||'00').padStart(2,'0')}:${String(personDetails.minute||'00').padStart(2,'0')}`,
                        birthCity: personDetails.birthCity || personDetails.city || 'Unknown City',
                        birthState: personDetails.birthState || personDetails.nation || 'Unknown'
                    })}\n`;
                }
            } catch(_) {}
            md += `**Period**: ${balanceMeterData.period?.start} to ${balanceMeterData.period?.end}\n`;
            md += `**Schema**: WM-Chart-${balanceMeterData.schema_version}\n\n`;

            md += `## Executive Summary\n\n`;
            
            const summary = balanceMeterData.channel_summary;
            if (summary) {
                const seisAvg = Number.isFinite(summary.seismograph_average) ? summary.seismograph_average : 0;
                const balAvg = Number.isFinite(summary.balance_average) ? summary.balance_average : 0;
                const seisEmoji = getValenceEmoji(Math.max(-5, Math.min(5, seisAvg)));
                const balEmoji = getValenceEmoji(Math.max(-5, Math.min(5, balAvg)));
                md += `**Triple Channel Averages**:\n`;
                md += `- Seismograph (valence): ${seisEmoji} ${seisAvg.toFixed(2)}\n`;
                md += `- Balance (valence): ${balEmoji} ${balAvg.toFixed(2)}\n`;
                md += `- SFD (support–friction): ${(Number.isFinite(summary.sfd_average) ? summary.sfd_average : 0).toFixed(2)}\n\n`;
                
                if (summary.dominant_channel) {
                    md += `**Dominant Channel**: ${summary.dominant_channel}\n`;
                }
                if (Number.isFinite(summary.volatility_index)) {
                    md += `**Volatility Index**: 🌪️ ${summary.volatility_index.toFixed(2)}\n`;
                }
                md += `\n`;
            }

            // Add resilience summary
            const resilienceMetrics = calculateResilienceMetrics(balanceMeterData, sourceData);
            if (Object.keys(resilienceMetrics).length > 0) {
                const resilienceValues = Object.values(resilienceMetrics);
                const avgResilience = resilienceValues.reduce((sum, r) => sum + r.resilience, 0) / resilienceValues.length;
                const maxDepletion = Math.max(...resilienceValues.map(r => r.depletionIndex));
                const depletionDays = resilienceValues.filter(r => r.depletionIndex >= 3.0).length;
                const stressDays = resilienceValues.filter(r => r.narrative.includes('stress')).length;
                const recoveryDays = resilienceValues.filter(r => r.narrative.includes('Recovery')).length;
                
                // Check if natal scaffolding was available
                const firstDayDebug = resilienceValues[0]?._debug?.natalProfile;
                const hasNatalScaffolding = Boolean(firstDayDebug);
                
                md += `**Resilience & Depletion Summary**${hasNatalScaffolding ? ' (Personalized)' : ' (Generic)'}:\n`;
                md += `- Average Resilience: ${avgResilience.toFixed(2)} (0-5 scale)\n`;
                md += `- Peak Depletion Risk: ${maxDepletion.toFixed(1)}\n`;
                md += `- Pattern Breakdown: ${stressDays} stress days, ${recoveryDays} recovery days, ${depletionDays} depletion risk days\n`;
                
                if (hasNatalScaffolding) {
                    md += `- Natal Scaffolding: ${firstDayDebug.scaffoldingStrength}/5.0 strength, ${firstDayDebug.volatilityProne ? 'volatility-prone' : 'stable'} profile\n`;
                }
                md += `\n`;
            }

            md += `## Daily Entries\n\n`;
            md += `| Date | Triple Channel | SFD Verdict | Recovery | Resilience | DepletionIndex | Narrative | Top Hooks |\n`;
            md += `|------|-----------------|-------------|----------|------------|----------------|-----------|----------|\n`;

            // Calculate resilience metrics for all days (reuse from summary)
            const dailyResilienceMetrics = resilienceMetrics || calculateResilienceMetrics(balanceMeterData);

            if (balanceMeterData.daily_entries) {
                const dates = Object.keys(balanceMeterData.daily_entries).sort();
                
                dates.forEach(date => {
                    const day = normalizeEntry(balanceMeterData.daily_entries[date]);
                    if (!day) return;
                    
                    // Generate triple channel display
                    const channelLine = tripleChannelLine({ 
                        seismograph: day.seismograph, 
                        balance: day.balance, 
                        sfd: day.sfd 
                    });
                    
                    // Get SFD verdict
                    const verdict = sfdVerdict(day.sfd || {});
                    
                    // Get resilience metrics for this day
                    const resilience = dailyResilienceMetrics[date];
                    const recovery = resilience ? resilience.recovery.toFixed(1) : '—';
                    const resilienceScore = resilience ? resilience.resilience.toFixed(1) : '—';
                    const depletionIndex = resilience ? resilience.depletionIndex.toFixed(1) : '—';
                    const narrative = resilience ? resilience.narrative : '—';
                    
                    // Get top hooks for this day
                    const hooks = (day.hooks || []).slice(0, 2);
                    const topHooks = hooks.map(h => {
                        const orb = Math.abs(h._orb || h.orb || 0).toFixed(1);
                        return `${h.p1_name} ${h._aspect || h.aspect} ${h.p2_name} (${orb}°)`;
                    }).join(', ') || '—';
                    
                    md += `| ${date} | ${channelLine.replace(/\|/g, '\\|')} | ${verdict} | ${recovery} | ${resilienceScore} | ${depletionIndex} | ${narrative} | ${topHooks.replace(/\|/g, '\\|')} |\n`;
                });
            }

            md += `\n## Methodology\n\n`;
            md += `This Balance Meter report integrates the **triple-channel architecture** with a **Resilience & Depletion Layer** for comprehensive health-oriented astrological analysis:\n\n`;
            md += `### Core Channels\n`;
            md += `1. **Seismograph v1.0**: Crisis-weighted transit intensity\n`;

            return md;
        }

        // --- Empty Template Generators (v1.4) ---
        function buildSoloMirrorEmptyTemplate(context) {
            const today = new Date().toISOString().split('T')[0];
            const personA = context?.personA || {};
            const birthLabel = (typeof generateBirthLabel === 'function' && personA?.birthDate)
                ? generateBirthLabel(personA)
                : '[date time place]';
            const relocationOn = context?.relocation?.enabled ? 'on' : 'off';
            const tz = personA?.timezone || 'America/Chicago';
            return (
`# Solo Mirror — Empty Template (v1.4)\n\n`+
`## Typological Profile (Constitutional Climate Layer)\n\n`+
`### Dominant Orientation\n\n`+
`[Function: Thinking/Feeling/Sensation/Intuition] organized by [major planets, signs, houses, aspects]. Often shows up as [concrete behavioral patterns: structuring/analyzing/attuning/perceiving].\n\n`+
`### Secondary Orientation\n\n`+
`A background current of [function] ([Moon, Venus, auxiliary aspects, daily rhythm houses]) that surfaces as [conditional behaviors, relational modes, imaginal flashes].\n\n`+
`### Shadow Orientation\n\n`+
`Constitutional friction concentrates around [function(s)] ([squares, oppositions, Saturn/Pluto/Neptune knots, retrogrades]). Often felt as [doubt, fog, overdrive, timing snags, vulnerability, paradox].\n\n`+
`### Constitutional Climate (Summary Hook)\n\n`+
`“A [metaphor for dominant] working alongside a [metaphor for secondary/shadow].”\n\n`+
`—\n\n`+
`## Recognition Hierarchy (based on Hook Stack)\n\n`+
`“[Polarity hook 1]” • “[Polarity hook 2]” • “[Polarity hook 3]”\n\n`+
`**Recognition Layer: Where Tension Is Felt (frontstage)**\n\n`+
`- [Paragraph 1: 2–4 sentences, conditional, lived friction + behavioral edge]\n`+
`- [Paragraph 2: 2–4 sentences]\n`+
`- [Paragraph 3: 2–4 sentences]\n\n`+
`## SST Clause (Falsifiability)\n\n`+
`- WB — [rationale/ping]\n`+
`- ABE — [inversion/tonal/directional note]\n`+
`- OSR — [null confirmation]\n\n`+
`SST prompt (frontstage): Did this land? Mark WB / ABE / OSR.\n\n`+
`## Balance Meter (Full Stack) in Plain-Weather\n\n`+
`### Today’s Reading\n\n`+
`- [Pressure band narrative, direction] ([high/medium/low], [supportive 🌞 / restrictive 🌑 / mixed 🌗])\n`+
`- [Support cut/holding/prevailing] ([scaffolding present/challenged/absent])\n`+
`- [Depleted/resilient/rebounding] ([reserves + recovery narrative])\n\n`+
`### Climate Line\n\n`+
`[How typological baseline responds to current transits — constitutional weather dance]\n\n`+
`## Relocation Context\n\n`+
`Mode: [none | A_local]\n`+
`Notes: [Angles/houses relocate; typology remains natal]\n`+
`House System: [WholeSign | Placidus]\n`+
`Birth Time Confidence: [exact | approximate | unknown]\n`+
`House Confidence: [high | medium | low]\n`+
`Lens Location: [City, Region] • Time Zone: ${tz}\n\n`+
`## Vector-Integrity Check (Mandatory if structurally qualified)\n\n`+
`- [Latent/Suppressed/Dormant]: [Vector name] — [structural presence; currently contained/waiting]\n`+
`- [Latent/Suppressed/Dormant]: [Vector name] — [compensated by X placements]\n`+
`- [Latent/Suppressed/Dormant]: [Vector name] — [awaits activation window (e.g., Saturn return)]\n\n`+
`## Polarity Cards (FIELD → MAP → VOICE)\n\n`+
`1) [Polarity A] ↔ [Polarity B]\n`+
`FIELD: [somatic/sensory texture]\n`+
`MAP (operator): [planets, aspect, sign/house; lens flag]\n`+
`VOICE: [conditional behavioral description with both poles]\n\n`+
`2) [Polarity A] ↔ [Polarity B]\n`+
`FIELD: [embodied feel]\n`+
`MAP (operator): [symbolic source]\n`+
`VOICE: [plain-language both-side rendering]\n\n`+
`3) [Polarity A] ↔ [Polarity B]\n`+
`FIELD: [felt tone]\n`+
`MAP (operator): [exact geometry]\n`+
`VOICE: [everyday surfacing description]\n\n`+
`## Mirror Voice (Stitched Reflection)\n\n`+
`[Constitutional climate ↔ current weather interplay]\n`+
`[Support vs. friction: SFD narrative]\n`+
`[Relocation one-liner if applicable]\n`+
`[Reframe tension as engine, not flaw]\n`+
`[Close with optional invitation that honors both poles]\n\n`+
`## Agency + Hygiene\n\n`+
`If this doesn’t land, it doesn’t count (OSR valid). Language stays conditional. SST classification depends on lived confirmation.\n\n`+
`## Context & Accessibility (frontstage metadata)\n\n`+
`Birth-time status: [exact | approximate | unknown → solar]\n`+
`Relocation: ${relocationOn}\n`+
`Emoji alts present: true\n\n`+
`## Frontstage Metadata (Version Control)\n\n`+
`Template Version: SoloMirror-v1.4.0 • Schema: mirror-draft-2025-09 • Emoji Lexicon: 1.0\n`+
`Build ID: ${today}_[hash]\n`+
`Parent Build ID: null\n`+
`Min Raven: ≥2025.09\n\n`+
`## Subject\n\n`+
`Name: ${personA?.name || '[Name]'}\n`+
`Birth: ${birthLabel}\n`);
        }

        function buildRelationalMirrorEmptyTemplate(context) {
            const today = new Date().toISOString().split('T')[0];
            const A = context?.personA || {};
            const B = context?.personB || {};
            const aLabel = (typeof generateBirthLabel === 'function' && A?.birthDate) ? generateBirthLabel(A) : '[date time place]';
            const bLabel = (typeof generateBirthLabel === 'function' && B?.birthDate) ? generateBirthLabel(B) : '[date time place]';
            return (
`# Relational Mirror — Empty Template (v1.4)\n\n`+
`## Relational Tier & Consent\n\n`+
`Tier: [partner | friend/colleague | family | acquaintance]\n`+
`Consent Status: [mutual | single-sided | anonymized]\n`+
`Cultural/Lens Calibration: [tropical | sidereal | animist | nondual] (function-first)\n\n`+
`## Dyadic Typological Snapshot (Constitutional)\n\n`+
`Person A: [Dominant/Secondary/Shadow summaries]\n`+
`Person B: [Dominant/Secondary/Shadow summaries]\n`+
`Polarity Hook (shared): "[A vs. B tension name]"\n\n`+
`## Recognition Layer — Where It’s Felt (A & B)\n\n`+
`[Short paragraph: daily friction zone that both notice]\n`+
`[Short paragraph: zone unique to A]\n`+
`[Short paragraph: zone unique to B]\n\n`+
`## Bidirectional Vector Mirrors (Mandatory A→B and B→A)\n\n`+
`Vector 1\n\n`+
`A → B (frontstage): [ ]\n`+
`B → A (frontstage): [ ]\n`+
`MAP (operator): [ ]\n`+
`SST: [WB/ABE/OSR for each direction + rationale]\n\n`+
`Vector 2\n\n`+
`A → B: [ ]\n`+
`B → A: [ ]\n`+
`MAP: [ ]\n`+
`SST: [ ]\n\n`+
`Vector 3\n\n`+
`A → B: [ ]\n`+
`B → A: [ ]\n`+
`MAP: [ ]\n`+
`SST: [ ]\n\n`+
`## Balance Meter (Relational Climate)\n\n`+
`### Today’s Dyadic Reading\n\n`+
`- [Pressure on the bond] ([high/medium/low], [supportive 🌞 / restrictive 🌑 / mixed 🌗])\n`+
`- [Shared Scaffolding] ([present/challenged/absent])\n`+
`- [Bond Resilience] ([resilient/depleted/rebounding])\n`+
`- [Volatility] ([steady / scattered / storm-class 🌪️])\n\n`+
`### Bond Climate Line\n\n`+
`[How A’s baseline meets B’s baseline under current sky; where ease vs. drag concentrates]\n\n`+
`## Relocation Context (Relational)\n\n`+
`Mode: [none | A_local | B_local | midpoint]\n`+
`Notes: [Angles/houses relocate; individual typologies remain natal]\n`+
`House System: [WholeSign | Placidus]\n`+
`Birth Time Confidence (A/B): [ ] / [ ]\n`+
`House Confidence (A/B): [ ] / [ ]\n`+
`Lens Location: [City choice + rationale]\n\n`+
`## Vector-Integrity Check (Latent/Suppressed)\n\n`+
`- [Latent]: [A→B vector name] — [structural, not yet behaviorally pinged]\n`+
`- [Suppressed]: [B→A vector name] — [compensated by X placements]\n\n`+
`## Polarity Cards (Shared FIELD → MAP → VOICE)\n\n`+
`[Polarity Name of the Bond]\n\n`+
`FIELD: [somatic tone between A & B]\n`+
`MAP (operator): [cross-chart geometry; lens flag]\n`+
`VOICE: [conditional mirror that honors both sides without advice]\n\n`+
`## Mirror Voice (Stitched Dyadic Reflection)\n\n`+
`[What the bond tends to amplify under this sky]\n`+
`[Where scaffolding holds vs. where friction cuts]\n`+
`[Relocation one-liner if used]\n`+
`[Close with non-prescriptive invitation that preserves agency on both sides]\n\n`+
`## Agency + Hygiene\n\n`+
`OSR is valid data. Conditional phrasing only. Bidirectional SST logging required for each named vector.\n\n`+
`## Frontstage Identity\n\n`+
`Person A: ${A?.name || '[Name]'} — ${aLabel}\n`+
`Person B: ${B?.name || '[Name]'} — ${bLabel}\n`);
        }

        function buildSoloBalanceEmptyTemplate(context) {
            const today = new Date().toISOString().split('T')[0];
            const A = context?.personA || {};
            const aLabel = (typeof generateBirthLabel === 'function' && A?.birthDate) ? generateBirthLabel(A) : '[date time place]';
            return (
`# Solo Balance Report — Empty Template (v1.4)\n\n`+
`## Balance Meter Frontstage (Plain-Weather Only)\n\n`+
`### Today’s Reading\n\n`+
`- Pressure: [high/medium/low] ([supportive 🌞 / restrictive 🌑 / mixed 🌗])\n`+
`- Support/Scaffolding: [present/challenged/absent]\n`+
`- Resilience: [resilient/depleted/rebounding]\n`+
`- Volatility: [steady / scattered / storm-class 🌪️]\n\n`+
`### Climate Line\n\n`+
`[Narrative of how pressure distributes; key cross-currents; where air clears]\n\n`+
`## Support–Friction Differential (SFD)\n\n`+
`[Where support outweighs friction / where friction outweighs support; one paragraph]\n\n`+
`## Vector Flags (If Any)\n\n`+
`- [Latent/Suppressed/Dormant]: [Vector name] — [note]\n\n`+
`## Relocation Note (If On)\n\n`+
`[City] — [one line disclosure]\n\n`+
`## Frontstage Metadata\n\n`+
`Template Version: SoloBalance-v1.4.0 • Schema: bm-plainweather-2025-09 • Build ID: ${today}_[id]\n\n`+
`## Subject\n\n`+
`Name: ${A?.name || '[Name]'}\n`+
`Birth: ${aLabel}\n`);
        }

        function buildRelationalBalanceEmptyTemplate(context) {
            const today = new Date().toISOString().split('T')[0];
            const A = context?.personA || {};
            const B = context?.personB || {};
            const aLabel = (typeof generateBirthLabel === 'function' && A?.birthDate) ? generateBirthLabel(A) : '[date time place]';
            const bLabel = (typeof generateBirthLabel === 'function' && B?.birthDate) ? generateBirthLabel(B) : '[date time place]';
            return (
`# Relational Balance Report — Empty Template (v1.4)\n\n`+
`## Dyadic Balance Meter (Plain-Weather)\n\n`+
`### Today’s Bond Reading\n\n`+
`- Pressure on the Bond: [high/medium/low] ([supportive 🌞 / restrictive 🌑 / mixed 🌗])\n`+
`- Shared Scaffolding: [present/challenged/absent]\n`+
`- Bond Resilience: [resilient/depleted/rebounding]\n`+
`- Volatility: [steady / scattered / storm-class 🌪️]\n\n`+
`### Bond Climate Line\n\n`+
`[Narrative: how A’s field meets B’s field today; where coupling adds lift vs. drag]\n\n`+
`## SFD for the Bond\n\n`+
`[Explain net balance between stabilizers and stressors across the connection]\n\n`+
`## Dyadic Vector Flags (If Any)\n\n`+
`- [Latent/Suppressed/Dormant]: [A→B vector] — [note]\n`+
`- [Latent/Suppressed/Dormant]: [B→A vector] — [note]\n\n`+
`## Relocation Note (If On)\n\n`+
`Mode: [A_local | B_local | midpoint] — [one-line disclosure]\n\n`+
`## Frontstage Metadata\n\n`+
`Template Version: RelationalBalance-v1.4.0 • Schema: bm-relational-2025-09 • Build ID: ${today}_[id]\n\n`+
`## Frontstage Identity\n\n`+
`Person A: ${A?.name || '[Name]'} — ${aLabel}\n`+
`Person B: ${B?.name || '[Name]'} — ${bLabel}\n`);
        }

        // NEW: Render Balance Meter data as styled HTML instead of markdown
        function renderBalanceMeterHTML(balanceMeterData, sourceData = null) {
            if (!balanceMeterData) return '<p class="text-gray-400 text-sm">No Balance Meter data available.</p>';

            let html = `<div class="space-y-6">`;
            
            // Header with enhanced visual design
            html += `<div class="bg-gradient-to-r from-teal-600 to-teal-700 p-6 rounded-xl shadow-lg">`;
            html += `<div class="flex items-center gap-3 mb-3">`;
            html += `<span class="text-4xl">⚖️</span>`;
            html += `<h1 class="text-3xl font-bold text-white">Balance Meter Report</h1>`;
            html += `</div>`;
            html += `<div class="text-teal-100 text-sm space-y-1 bg-teal-800/30 p-3 rounded-lg">`;
            html += `<p><strong>Subject:</strong> ${balanceMeterData.person?.name || 'Unknown'}</p>`;
            html += `<p><strong>Period:</strong> ${balanceMeterData.period?.start} to ${balanceMeterData.period?.end}</p>`;
            html += `<p><strong>Schema:</strong> WM-Chart-${balanceMeterData.schema_version}</p>`;
            html += `</div></div>`;

            // Raven Calder Emoji Legend
            html += `<div class="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-lg">`;
            html += `<div class="flex items-center gap-2 mb-4">`;
            html += `<span class="text-2xl">🗝️</span>`;
            html += `<h2 class="text-xl font-semibold text-purple-300">Raven Calder Emoji Reference</h2>`;
            html += `</div>`;
            html += `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">`;
            
            // Core Metrics
            html += `<div class="bg-gray-700/50 p-3 rounded-lg">`;
            html += `<h3 class="text-cyan-300 font-medium mb-2">Core Metrics</h3>`;
            html += `<div class="space-y-1 text-gray-200">`;
            html += `<div>⚡ <span class="text-gray-300">Magnitude (intensity)</span></div>`;
            html += `<div>🌪️ <span class="text-gray-300">Volatility (instability)</span></div>`;
            html += `<div>🌞 🌑 🌗 <span class="text-gray-300">Valence (positive/negative/mixed)</span></div>`;
            html += `</div></div>`;
            
            // Positive Valence Modes
            html += `<div class="bg-gray-700/50 p-3 rounded-lg">`;
            html += `<h3 class="text-green-300 font-medium mb-2">Positive Modes 🌞</h3>`;
            html += `<div class="space-y-1 text-gray-200 text-xs">`;
            html += `<div>🌱 Fertile Field</div>`;
            html += `<div>✨ Harmonic Resonance</div>`;
            html += `<div>💎 Expansion Lift</div>`;
            html += `<div>🔥 Combustion Clarity</div>`;
            html += `<div>🦋 Liberation/Release</div>`;
            html += `<div>⚖️ Integration</div>`;
            html += `<div>🌊 Flow Tide</div>`;
            html += `<div>🌈 Visionary Spark</div>`;
            html += `</div></div>`;
            
            // Negative Valence Modes
            html += `<div class="bg-gray-700/50 p-3 rounded-lg">`;
            html += `<h3 class="text-red-300 font-medium mb-2">Negative Modes 🌑</h3>`;
            html += `<div class="space-y-1 text-gray-200 text-xs">`;
            html += `<div>♾️ Recursion Pull</div>`;
            html += `<div>⚔️ Friction Clash</div>`;
            html += `<div>↔️ Cross Current</div>`;
            html += `<div>🌫️ Fog/Dissolution</div>`;
            html += `<div>🌋 Pressure/Eruption</div>`;
            html += `<div>⏳ Saturn Weight</div>`;
            html += `<div>🧩 Fragmentation</div>`;
            html += `<div>🕳️ Entropy Drift</div>`;
            html += `</div></div>`;
            
            html += `</div></div>`;

            // Executive Summary with enhanced color coding
            html += `<div class="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-lg">`;
            html += `<div class="flex items-center gap-2 mb-4">`;
            html += `<span class="text-2xl">📊</span>`;
            html += `<h2 class="text-2xl font-semibold text-cyan-300">Executive Summary</h2>`;
            html += `</div>`;
            
            const summary = balanceMeterData.channel_summary;
            if (summary) {
                const seisAvg = Number.isFinite(summary.seismograph_average) ? summary.seismograph_average : 0;
                const balAvg = Number.isFinite(summary.balance_average) ? summary.balance_average : 0;
                const sfdAvg = Number.isFinite(summary.sfd_average) ? summary.sfd_average : 0;
                const seisEmoji = getValenceEmoji(Math.max(-5, Math.min(5, seisAvg)));
                const balEmoji = getValenceEmoji(Math.max(-5, Math.min(5, balAvg)));
                
                html += `<div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">`;
                
                // Seismograph Average with enhanced styling
                html += `<div class="bg-gradient-to-br from-purple-900 to-purple-800 p-4 rounded-lg border-l-4 border-purple-400 shadow-inner">`;
                html += `<div class="flex items-center gap-2 mb-2">`;
                html += `<span class="text-lg">⚡</span>`;
                html += `<h4 class="text-purple-300 font-semibold">Seismograph Average</h4>`;
                html += `</div>`;
                html += `<p class="text-3xl font-bold text-white mb-1">${seisEmoji} ${seisAvg.toFixed(2)}</p>`;
                html += `<p class="text-xs text-purple-200">Crisis-weighted intensity</p>`;
                html += `</div>`;
                
                // Balance Average with enhanced styling
                html += `<div class="bg-gradient-to-br from-teal-900 to-teal-800 p-4 rounded-lg border-l-4 border-teal-400 shadow-inner">`;
                html += `<div class="flex items-center gap-2 mb-2">`;
                html += `<span class="text-lg">⚖️</span>`;
                html += `<h4 class="text-teal-300 font-semibold">Balance Average</h4>`;
                html += `</div>`;
                html += `<p class="text-3xl font-bold text-white mb-1">${balEmoji} ${balAvg.toFixed(2)}</p>`;
                html += `<p class="text-xs text-teal-200">Rebalanced perspective</p>`;
                html += `</div>`;
                
                // SFD Average with enhanced styling
                html += `<div class="bg-gradient-to-br from-amber-900 to-amber-800 p-4 rounded-lg border-l-4 border-amber-400 shadow-inner">`;
                html += `<div class="flex items-center gap-2 mb-2">`;
                html += `<span class="text-lg">🔄</span>`;
                html += `<h4 class="text-amber-300 font-semibold">SFD Average</h4>`;
                html += `</div>`;
                html += `<p class="text-3xl font-bold text-white mb-1">${sfdAvg.toFixed(2)}</p>`;
                html += `<p class="text-xs text-amber-200">Support-Friction Differential</p>`;
                html += `</div>`;
                
                html += `</div>`;
                
                // Additional summary info with better styling
                if (summary.dominant_channel || Number.isFinite(summary.volatility_index)) {
                    html += `<div class="bg-gray-700/50 p-4 rounded-lg border border-gray-600">`;
                    html += `<div class="flex flex-wrap gap-4 text-sm">`;
                    if (summary.dominant_channel) {
                        html += `<div class="flex items-center gap-2">`;
                        html += `<span class="w-3 h-3 bg-cyan-500 rounded-full"></span>`;
                        html += `<span class="text-gray-300"><strong class="text-cyan-300">Dominant Channel:</strong> ${summary.dominant_channel}</span>`;
                        html += `</div>`;
                    }
                    if (Number.isFinite(summary.volatility_index)) {
                        html += `<div class="flex items-center gap-2">`;
                        html += `<span class="text-lg">🌪️</span>`;
                        html += `<span class="text-gray-300"><strong class="text-yellow-300">Volatility Index:</strong> ${summary.volatility_index.toFixed(2)}</span>`;
                        html += `</div>`;
                    }
                    html += `</div></div>`;
                }
            }
            html += `</div>`;

            // Resilience Summary with enhanced visual appeal
            const resilienceMetrics = calculateResilienceMetrics(balanceMeterData, sourceData);
            if (Object.keys(resilienceMetrics).length > 0) {
                const resilienceValues = Object.values(resilienceMetrics);
                const avgResilience = resilienceValues.reduce((sum, r) => sum + r.resilience, 0) / resilienceValues.length;
                const maxDepletion = Math.max(...resilienceValues.map(r => r.depletionIndex));
                const depletionDays = resilienceValues.filter(r => r.depletionIndex >= 3.0).length;
                const stressDays = resilienceValues.filter(r => r.narrative.includes('stress')).length;
                const recoveryDays = resilienceValues.filter(r => r.narrative.includes('Recovery')).length;
                
                const firstDayDebug = resilienceValues[0]?._debug?.natalProfile;
                const hasNatalScaffolding = Boolean(firstDayDebug);
                
                html += `<div class="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-lg">`;
                html += `<div class="flex items-center gap-2 mb-4">`;
                html += `<span class="text-2xl">🛡️</span>`;
                html += `<h2 class="text-2xl font-semibold text-emerald-300">Resilience & Depletion Summary</h2>`;
                if (hasNatalScaffolding) {
                    html += `<span class="px-2 py-1 bg-emerald-900/30 text-emerald-300 text-xs rounded-full border border-emerald-600">Personalized</span>`;
                } else {
                    html += `<span class="px-2 py-1 bg-gray-700 text-gray-400 text-xs rounded-full border border-gray-600">Generic</span>`;
                }
                html += `</div>`;
                
                html += `<div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">`;
                // Resilience card
                html += `<div class="bg-emerald-900/30 p-3 rounded-lg text-center border border-emerald-600 hover:bg-emerald-900/50 transition-colors">`;
                html += `<div class="flex items-center justify-center gap-1 mb-1">`;
                html += `<span class="text-emerald-400">🛡️</span>`;
                html += `<p class="text-xs text-emerald-300 font-medium">Avg Resilience</p>`;
                html += `</div>`;
                html += `<p class="text-2xl font-bold text-white">${avgResilience.toFixed(2)}</p>`;
                html += `<p class="text-xs text-emerald-200">0-5 scale</p>`;
                html += `</div>`;
                
                // Depletion card
                html += `<div class="bg-red-900/30 p-3 rounded-lg text-center border border-red-500 hover:bg-red-900/50 transition-colors">`;
                html += `<div class="flex items-center justify-center gap-1 mb-1">`;
                html += `<span class="text-red-400">⚠️</span>`;
                html += `<p class="text-xs text-red-300 font-medium">Peak Depletion</p>`;
                html += `</div>`;
                html += `<p class="text-2xl font-bold text-white">${maxDepletion.toFixed(1)}</p>`;
                html += `<p class="text-xs text-red-200">${depletionDays} risk days</p>`;
                html += `</div>`;
                
                // Stress days card
                html += `<div class="bg-yellow-900/30 p-3 rounded-lg text-center border border-yellow-500 hover:bg-yellow-900/50 transition-colors">`;
                html += `<div class="flex items-center justify-center gap-1 mb-1">`;
                html += `<span class="text-yellow-400">⚡</span>`;
                html += `<p class="text-xs text-yellow-300 font-medium">Stress Days</p>`;
                html += `</div>`;
                html += `<p class="text-2xl font-bold text-white">${stressDays}</p>`;
                html += `<p class="text-xs text-yellow-200">Active stress</p>`;
                html += `</div>`;
                
                // Recovery days card
                html += `<div class="bg-green-900/30 p-3 rounded-lg text-center border border-green-500 hover:bg-green-900/50 transition-colors">`;
                html += `<div class="flex items-center justify-center gap-1 mb-1">`;
                html += `<span class="text-green-400">🌱</span>`;
                html += `<p class="text-xs text-green-300 font-medium">Recovery Days</p>`;
                html += `</div>`;
                html += `<p class="text-2xl font-bold text-white">${recoveryDays}</p>`;
                html += `<p class="text-xs text-green-200">Positive momentum</p>`;
                html += `</div>`;
                html += `</div>`;
                
                if (hasNatalScaffolding) {
                    html += `<div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">`;
                    html += `<p class="text-gray-200 text-sm"><strong class="text-cyan-300">Natal Scaffolding:</strong> ${firstDayDebug.scaffoldingStrength}/5.0 strength, ${firstDayDebug.volatilityProne ? '<span class="text-orange-300">volatility-prone</span>' : '<span class="text-green-300">stable</span>'} profile</p>`;
                    html += `</div>`;
                }
                html += `</div>`;
            }

            // Daily Entries Table with enhanced styling
            html += `<div class="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-lg">`;
            html += `<div class="flex items-center gap-2 mb-4">`;
            html += `<span class="text-2xl">📅</span>`;
            html += `<h2 class="text-2xl font-semibold text-blue-300">Daily Entries</h2>`;
            html += `</div>`;
            html += `<div class="overflow-x-auto bg-gray-900/50 rounded-lg border border-gray-600">`;
            html += `<table class="w-full text-sm border-collapse">`;
            html += `<thead class="bg-gradient-to-r from-gray-700 to-gray-600">`;
            html += `<tr class="text-gray-100">`;
            html += `<th class="border border-gray-500 px-3 py-2 text-left font-semibold">Date</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-left font-semibold">Triple Channel</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-left font-semibold">SFD Verdict</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-center font-semibold">Recovery</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-center font-semibold">Resilience</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-center font-semibold">Depletion</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-left font-semibold">Narrative</th>`;
            html += `<th class="border border-gray-500 px-3 py-2 text-left font-semibold">Top Hooks</th>`;
            html += `</tr></thead><tbody>`;

            const dailyResilienceMetrics = resilienceMetrics || calculateResilienceMetrics(balanceMeterData);

            if (balanceMeterData.daily_entries) {
                const dates = Object.keys(balanceMeterData.daily_entries).sort();
                
                dates.forEach((date, index) => {
                    const day = normalizeEntry(balanceMeterData.daily_entries[date]);
                    if (!day) return;
                    
                    const channelLine = tripleChannelLine({ 
                        seismograph: day.seismograph, 
                        balance: day.balance, 
                        sfd: day.sfd 
                    });
                    
                    const verdict = sfdVerdict(day.sfd || {}) || '—';
                    
                    const resilience = dailyResilienceMetrics[date];
                    const recovery = resilience ? resilience.recovery.toFixed(1) : '—';
                    const resilienceScore = resilience ? resilience.resilience.toFixed(1) : '—';
                    const depletionIndex = resilience ? resilience.depletionIndex.toFixed(1) : '—';
                    const narrative = resilience ? resilience.narrative : '—';
                    
                    const hooks = (day.hooks || []).slice(0, 2);
                    const topHooks = hooks.map(h => {
                        const orb = Math.abs(h._orb || h.orb || 0).toFixed(1);
                        return `${h.p1_name} ${h._aspect || h.aspect} ${h.p2_name} (${orb}°)`;
                    }).join(', ') || '—';
                    
                    const rowClass = index % 2 === 0 ? 'bg-gray-800/60 hover:bg-gray-700/60' : 'bg-gray-900/60 hover:bg-gray-800/60';
                    html += `<tr class="${rowClass} text-gray-200 transition-colors">`;
                    html += `<td class="border border-gray-600 px-3 py-2 font-medium text-cyan-300">${date}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-xs font-mono">${channelLine}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-xs">${verdict}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-center font-semibold">${recovery}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-center font-semibold">${resilienceScore}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-center font-semibold">${depletionIndex}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-xs">${narrative}</td>`;
                    html += `<td class="border border-gray-600 px-3 py-2 text-xs">${topHooks}</td>`;
                    html += `</tr>`;
                });
            }
            
            html += `</tbody></table></div></div>`;

            // Methodology with enhanced design
            html += `<div class="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-lg">`;
            html += `<div class="flex items-center gap-2 mb-4">`;
            html += `<span class="text-2xl">🔬</span>`;
            html += `<h2 class="text-2xl font-semibold text-indigo-300">Methodology</h2>`;
            html += `</div>`;
            html += `<p class="text-gray-200 mb-4 leading-relaxed">This Balance Meter report integrates the <strong class="text-cyan-300">triple-channel architecture</strong> with a <strong class="text-emerald-300">Resilience & Depletion Layer</strong> for comprehensive health-oriented astrological analysis.</p>`;
            html += `<div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">`;
            html += `<div class="bg-purple-900/20 p-4 rounded-lg border border-purple-500/30">`;
            html += `<h4 class="font-semibold text-purple-300 mb-2 flex items-center gap-2"><span>⚡</span> Seismograph v1.0</h4>`;
            html += `<p class="text-gray-300">Crisis-weighted transit intensity measurement</p>`;
            html += `</div>`;
            html += `<div class="bg-teal-900/20 p-4 rounded-lg border border-teal-500/30">`;
            html += `<h4 class="font-semibold text-teal-300 mb-2 flex items-center gap-2"><span>⚖️</span> Balance Channel v1.1</h4>`;
            html += `<p class="text-gray-300">Rebalanced perspective with gentler valence calculation</p>`;
            html += `</div>`;
            html += `<div class="bg-amber-900/20 p-4 rounded-lg border border-amber-500/30">`;
            html += `<h4 class="font-semibold text-amber-300 mb-2 flex items-center gap-2"><span>🔄</span> SFD v1.2</h4>`;
            html += `<p class="text-gray-300">Support-Friction Differential measuring stabilizer efficacy</p>`;
            html += `</div>`;
            html += `<div class="bg-emerald-900/20 p-4 rounded-lg border border-emerald-500/30">`;
            html += `<h4 class="font-semibold text-emerald-300 mb-2 flex items-center gap-2"><span>🛡️</span> Resilience Layer</h4>`;
            html += `<p class="text-gray-300">Personalized stress recovery patterns based on natal scaffolding</p>`;
            html += `</div>`;
            html += `</div></div>`;
            
            html += `</div>`;
            return html;
            md += `2. **Balance v1.1**: Rebalanced valence using planetary locality factors\n`;
            md += `3. **SFD v1.2**: Support-Friction Differential tracking supportive vs disruptive transits\n\n`;
            md += `### Resilience & Depletion Layer (Natal-Scaffolding Enhanced)\n`;
            md += `4. **Recovery**: Continuous momentum-based recovery signal with natal-modulated decay curves (0-5 scale)\n`;
            md += `5. **Resilience**: Adaptive capacity with smoothed baseline that responds gradually to load changes (0-5 scale)\n`;
            md += `6. **DepletionIndex**: Risk assessment using continuous curves with recovery protection factors (0-5 scale)\n`;
            md += `7. **Narrative**: Contextual state summary based on continuous thresholds, not binary switches\n\n`;
            md += `**Natal Scaffolding Analysis**: Recovery speed and resilience baseline determined by natal patterns:\n`;
            md += `- **Stabilizer-Friendly Charts** (strong trines, domicile planets, integrated Saturn): Faster momentum decay (0.85), higher baseline resilience\n`;
            md += `- **Volatility-Prone Charts** (oppositions/squares without stabilizers, Uranus/Pluto dominance): Slower momentum decay (0.75), extended vulnerability windows\n\n`;
            md += `**Continuous Channel Design**: Unlike binary rebound detection, the resilience system uses smoothed decay curves modulated by natal factors. This creates natural momentum and prevents step-function jumps, making the resilience score feel like a living biological system.\n\n`;
            md += `The **SFD Verdict** indicates whether supportive forces ("stabilizers prevail"), disruptive forces ("cuts"), or mixed patterns ("mixed") dominate each day.\n\n`;
            md += `**Resilience calculations** use precise natal chart geometry to personalize stress accumulation, recovery patterns, and depletion vulnerability. Two people experiencing identical transits will show different recovery arcs based on their natal wiring.\n\n`;
            md += `For correlation with health metrics, focus on SFD patterns, Balance Channel trends, and personalized Resilience/Depletion patterns.\n\n`;

            return md;
        }

        function buildSeismographMarkdownSection(data) {
            if (!data) return 'No seismograph data available.';

            let md = '## Seismograph Trace (Auto-Append)\n\n';
            md += '> **Protocol**: Seismograph always rides on the Mirror skeleton for falsifiability. Without geometry + hooks, the trace cannot be falsified.\n\n';

            // Process each dataset that has transit data
            const datasets = [];
            
            if (data.person_a?.chart?.transitsByDate) {
                datasets.push({ title: `${data.person_a.details?.name || 'Person A'} Transits`, data: data.person_a.chart.transitsByDate });
            }
            if (data.person_b?.chart?.transitsByDate) {
                datasets.push({ title: `${data.person_b.details?.name || 'Person B'} Transits`, data: data.person_b.chart.transitsByDate });
            }
            if (data.synastry?.transitsByDate) {
                datasets.push({ title: 'Synastry Transits', data: data.synastry.transitsByDate });
            }
            if (data.composite?.transitsByDate) {
                datasets.push({ title: 'Composite Transits', data: data.composite.transitsByDate });
            }
            
            // Generate tables for each dataset
            datasets.forEach(({ title, data: transitData }) => {
                const dates = Object.keys(transitData).sort();
                if (dates.length === 0) return;
                
                md += `### ${title}\n\n`;
                md += '| Date | Triple Channel | Top Hooks |\n';
                md += '|------|-----------------|----------|\n';
                
                dates.forEach(date => {
                    const day = normalizeEntry(transitData[date]);
                    if (!day) return;
                    
                    // Generate triple channel display
                    const channelLine = tripleChannelLine({ 
                        seismograph: day.seismograph, 
                        balance: day.balance, 
                        sfd: day.sfd 
                    });
                    
                    // Get top hooks for this day
                    const hooks = (day.hooks || []).slice(0, 2);
                    const topHooks = hooks.map(h => {
                        const orb = Math.abs(h._orb || h.orb || 0).toFixed(1);
                        return `${h.p1_name} ${h._aspect || h.aspect} ${h.p2_name} (${orb}°)`;
                    }).join(', ') || '—';
                    
                    md += `| ${date} | ${channelLine.replace(/\|/g, '\\|')} | ${topHooks.replace(/\|/g, '\\|')} |\n`;
                });
                
                md += '\n';
            });
            
            if (datasets.length === 0) {
                md += 'No transit hooks detected for this time window.\n\n';
            } else {
                md += '**Triple Channel Notes**: ⚡ = magnitude (0–5), Val = net seismograph valence (−5…+5), Bal = balance channel valence (−5…+5), SFD = Support–Friction Differential with verdict\n\n';
            }
            
            return md;
        }

        function generateClearMirrorReport(data, options = {}) {
            // RAVEN CALDER PAYLOAD GENERATOR — SOLO MIRROR SKELETON
            // Math Brain's job: provide clean structural containers + standardized tokens
            // Raven's job: weave into narrative via FIELD → MAP → VOICE
            
            const formData = collectFormData();
            const currentDate = new Date().toISOString().split('T')[0];
            const personA = (data.person_a && data.person_a.details) ? data.person_a.details : formData.personA;
            const personB = (data.person_b && data.person_b.details) ? data.person_b.details : formData.personB;
            const mode = formData.context.mode;
            const isRelational = personB && personB.name && personB.name.trim();
            const hasRelocation = formData.relocation && formData.relocation.enabled;
            
            let md = '';
            
            // Report Type Declaration
            md += `# ${isRelational ? 'Relational' : 'Solo'} Mirror — Raven Calder Payload\n\n`;
            md += `**Report_Type:** "${isRelational ? 'Relational_Mirror' : 'Solo_Mirror'}"\n`;
            md += `**Report_Date:** "${currentDate}"\n\n`;
            
            // Context (subject identity always; relational has both)
            if (isRelational) {
                md += `## Context\n\n`;
                md += `**Person_A:** {name: "${personA?.name || 'Unknown'}", birth_label: "${generateBirthLabel(personA)}"}\n`;
                md += `**Person_B:** {name: "${personB?.name || 'Unknown'}", birth_label: "${generateBirthLabel(personB)}"}\n`;
                md += `**Relational_Tier:** "[Partner | Family | Friend | Acquaintance]" // Math Brain cannot determine—requires user input\n\n`;
            } else {
                md += `## Context\n\n`;
                if (personA?.name) {
                    md += `**Subject:** {name: "${personA.name}", birth_label: "${generateBirthLabel(personA)}"}\n\n`;
                } else {
                    md += `**Subject:** {name: "Unknown", birth_label: "${generateBirthLabel(personA)}"}\n\n`;
                }
            }
            
            // Typological Profile (Constitutional Climate Layer)
            md += generateTypologicalProfile(data.person_a, personA);
            
            if (isRelational && data.person_b) {
                md += generateTypologicalProfile(data.person_b, personB, 'Person_B');
            }
            
            // Hook Stack (Recognition Hierarchy)
            md += generateHookStack(data, isRelational);
            
            // Balance Meter (Full Stack) in Plain-Weather
            md += generateBalanceMeterClimate(data, formData);
            
            // Relocation Context (if applicable)
            if (hasRelocation) {
                md += generateRelocationContext(formData);
            }
            
            // Vector-Integrity Check
            md += generateVectorIntegrityCheck(data);
            
            // Polarity Cards (FIELD → MAP → VOICE)
            md += generatePolarityCards(data, isRelational);
            
            // Mirror Voice Container (empty for Raven to fill)
            md += generateMirrorVoiceContainer(isRelational, data);
            
            // SST Clause (Falsifiability)
            md += generateSSTClause();
            
            // Agency + Hygiene
            md += generateAgencyHygiene();
            
            // Metadata (Version Control)
            md += generateMetadata();
            
            return md;
        }
        
        function generateBirthLabel(person) {
            if (!person) return "undefined undefined undefined, undefined";
            
            const birthDate = person.birthDate || person.birth_date || "undefined";
            const birthTime = person.birthTime || person.birth_time || "undefined";
            const birthCity = person.birthCity || person.city || "undefined";
            const birthState = person.birthState || person.state || person.nation || "undefined";
            
            return `${birthDate} ${birthTime} ${birthCity}, ${birthState}`;
        }
        
        function generateTypologicalProfile(personData, personDetails, label = 'Solo') {
            let md = '';
            
            if (label !== 'Solo') {
                md += `## Typological_Profile_${label}\n\n`;
            } else {
                md += `## Typological_Profile\n\n`;
            }
            
            // Extract chart data for typological analysis
            const chartData = extractChartDataForTypology(personData);
            const dominant = analyzeDominantOrientation(chartData);
            const secondary = analyzeSecondaryOrientation(chartData);
            const shadow = analyzeShadowOrientation(chartData);
            
            md += `**Dominant:** ${dominant.functionalEmphasis}: ${dominant.orientation} organized by ${dominant.rawPlacements}. Often shows up as ${generateBehavioralPatterns(dominant)}.\n\n`;
            
            md += `**Secondary:** A background current of ${secondary.functionalEmphasis} (${secondary.rawPlacements}) that surfaces as ${generateSecondaryPatterns(secondary)}.\n\n`;
            
            md += `**Shadow:** Constitutional friction concentrates around ${shadow.functionalEmphasis} (${shadow.rawPlacements}). Often felt as ${generateShadowPatterns(shadow)}.\n\n`;
            
            md += `**Constitutional_Climate:** A ${generateDominantMetaphor(dominant)} working alongside a ${generateSecondaryMetaphor(secondary, shadow)}.\n\n`;
            
            return md;
        }
        
        function generateHookStack(data, isRelational) {
            let md = `## Hook_Stack\n\n`;
            md += `**Order_Rule:** "${isRelational ? 'relational hooks then personal hooks' : 'personal-outer hard → angles → anaretic → anchors'}"\n\n`;
            
            const hooks = extractTopHooks(data, isRelational);
            md += `**Hooks:**\n`;
            hooks.forEach((hook, index) => {
                md += `  - ${hook.description}\n`;
            });
            md += `\n`;
            
            return md;
        }
        
        function generateBalanceMeterClimate(data, formData) {
            let md = `## Balance_Meter_Narrative\n\n`;

            // Extract Balance Meter data if available
            const balanceData = data.balance_meter || synthesizeBalanceMeterFromTransits(data);

            if (balanceData) {
                const climateReading = generateClimateReading(balanceData);
                const supportStatus = generateSupportStatus(balanceData);
                const systemEnergy = generateSystemEnergy(balanceData);
                const seismographTag = generateSeismographTag(balanceData);

                md += `**Climate_Line:** ${climateReading}\n`;
                md += `**Support_Status:** ${supportStatus}\n`;
                md += `**System_Energy:** ${systemEnergy}\n`;
                md += `**Seismograph_Tag:** ${seismographTag}\n`;
                md += `**Depletion_Note:** ${generateDepletionNote(balanceData)}\n\n`;
            } else {
                md += `**Climate_Line:** No transit data available for climate analysis\n`;
                md += `**Support_Status:** Unknown - no balance meter data\n`;
                md += `**System_Energy:** Unknown - no balance meter data\n`;
                md += `**Seismograph_Tag:** Unknown - no balance meter data\n`;
                md += `**Depletion_Note:** No data available for depletion analysis\n\n`;
            }

            return md;
        }
        
        function generateRelocationContext(formData) {
            let md = `## Relocation_Context\n\n`;
            
            const reloc = formData.relocation;
            md += `**Mode:** "${reloc.personA ? 'A_local' : 'none'}"\n`;
            md += `**Notes:** "Angles/houses relocate under this lens; typology remains natal."\n`;
            md += `**House_System:** "[${reloc.houseSystem || 'Placidus'}]"\n`;
            md += `**Birth_Time_Confidence:** "[${reloc.birthTimeConfidence || 'approximate'}]"\n`;
            md += `**House_Confidence:** "[${reloc.houseConfidence || 'medium'}]"\n\n`;
            
            if (reloc.personA) {
                md += `**Lens_Location:**\n`;
                md += `  - **Name:** "${reloc.city}, ${reloc.state}"\n`;
                md += `  - **Time_Zone:** "${reloc.timezone || 'Unknown'}"\n\n`;
            }
            
            return md;
        }
        
        function generateVectorIntegrityCheck(data) {
            let md = `## Vector_Integrity_Check\n\n`;
            
            // Check for latent/suppressed vectors
            const vectors = identifyLatentVectors(data);
            
            if (vectors.length > 0) {
                vectors.forEach(vector => {
                    md += `**[${vector.status}]: ${vector.name}** — "[${vector.description}]"\n`;
                });
            } else {
                md += `**[No latent vectors detected]**\n`;
            }
            md += `\n`;
            
            return md;
        }
        
        function generatePolarityCards(data, isRelational) {
            let md = `## Polarity_Cards\n\n`;

            const polarities = extractTopPolarities(data, isRelational);

            polarities.forEach((polarity, index) => {
                md += `### ${index + 1}) **${polarity.nameA}** ↔ **${polarity.nameB}**\n`;

                if (isRelational) {
                    md += `**FIELD:**\n`;
                    md += `  - **Person_A:** ${polarity.fieldA}\n`;
                    md += `  - **Person_B:** ${polarity.fieldB}\n`;
                    md += `**MAP:** [Operator only: ${polarity.map}]\n`;
                    md += `**VOICE:**\n`;
                    md += `  - **Person_A:** ${generatePolarityVoice(polarity, 'A')}\n`;
                    md += `  - **Person_B:** ${generatePolarityVoice(polarity, 'B')}\n\n`;
                } else {
                    md += `**FIELD:** ${polarity.field}\n`;
                    md += `**MAP:** [Operator only: ${polarity.map}]\n`;
                    md += `**VOICE:** ${generatePolarityVoice(polarity)}\n\n`;
                }
            });

            return md;
        }
        
        function generateMirrorVoiceContainer(isRelational, data) {
            let md = `## ${isRelational ? 'Relational_' : ''}Mirror_Voice\n\n`;

            // Extract data for synthesis
            const chartData = extractChartDataForTypology(data.person_a);
            const dominantOrientation = analyzeDominantOrientation(chartData);
            const secondaryOrientation = analyzeSecondaryOrientation(chartData);
            const balanceData = synthesizeBalanceMeterFromTransits(data);
            const polarityData = extractTopPolarities(data, isRelational);

            if (isRelational) {
                // Relational Mirror Voice - bidirectional synthesis
                const personAName = data.person_a?.details?.name || 'Person A';
                const personBName = data.person_b?.details?.name || 'Person B';

                md += `**FIELD**: Intersecting relational climate where ${personAName}'s ${dominantOrientation.functionalEmphasis} patterns meet ${personBName}'s patterns\n\n`;

                md += `**MAP**: ${polarityData.length > 0 ? polarityData.slice(0, 2).map(p => `${p.nameA}/${p.nameB} (${p.map})`).join('; ') : 'Cross-chart geometry connecting individual patterns'}\n\n`;

                md += `**VOICE**: "${generateRelationalMirrorVoice(data, { name: personAName }, { name: personBName }).voice}"\n\n`;
            } else {
                // Individual Mirror Voice - personal synthesis
                const personName = data.person_a?.details?.name || 'Subject';

                md += `**FIELD**: ${generateClimateReading(balanceData)} — ${dominantOrientation.functionalEmphasis} organizing current\n\n`;

                md += `**MAP**: ${polarityData.length > 0 ? polarityData.slice(0, 2).map(p => `${p.nameA}/${p.nameB} (${p.map})`).join('; ') : 'Personal geometry patterns'}\n\n`;

                md += `**VOICE**: "${generateMirrorVoiceForPerson(data.person_a, { name: personName }).voice}"\n\n`;
            }

            return md;
        }
        
        function generateSSTClause() {
            let md = `## SST_Clause\n\n`;
            md += `**Resonance_Rule:** "If it doesn't ping, it doesn't count (OSR valid)."\n`;
            md += `**SST_Prompt:** "Ask user: did this land? (WB / ABE / OSR)"\n`;
            md += `**Conditional_Language:** "All phrasing uses may / might / could."\n\n`;
            return md;
        }
        
        function generateAgencyHygiene() {
            let md = `## Agency_Hygiene\n\n`;
            md += `If this doesn't land, it doesn't count (OSR valid).\n`;
            md += `All phrasing remains conditional (may/might/could).\n`;
            md += `The SST classification depends entirely on your lived experience confirmation.\n\n`;
            return md;
        }
        
        function generateMetadata() {
            let md = `## Frontstage_Metadata\n\n`;
            md += `**Template_Version:** "SoloMirror-v1.4.0"\n`;
            md += `**Schema_Version:** "mirror-draft-2025-09"\n`;
            md += `**Render_Profile:** "woven-web-app-2025-09"\n`;
            md += `**Emoji_Lexicon_Version:** "1.0"\n`;
            md += `**Build_ID:** "${new Date().toISOString()}"\n`;
            md += `**Min_Raven_Version:** ">=2025.09"\n\n`;
            return md;
        }
        
        // STANDARDIZED TOKEN GENERATORS FOR CLEAN STRUCTURAL PAYLOAD
        // These functions provide approved descriptors, not improvised prose
        
        function generateBehavioralPatterns(dominant) {
            // Standardized behavioral pattern descriptors based on function + orientation
            const patterns = {
                'Thinking_Introverted': 'structuring, analyzing, systematizing',
                'Thinking_Extraverted': 'organizing, directing, implementing',
                'Feeling_Introverted': 'attuning, harmonizing, value-sensing',
                'Feeling_Extraverted': 'connecting, facilitating, group-harmonizing',
                'Sensation_Introverted': 'grounding, stabilizing, detail-tracking',
                'Sensation_Extraverted': 'engaging, experiencing, action-taking',
                'Intuition_Introverted': 'perceiving, visioning, pattern-sensing',
                'Intuition_Extraverted': 'exploring, possibility-generating, inspiring'
            };
            
            const key = `${dominant.functionalEmphasis}_${dominant.orientation}`;
            return patterns[key] || 'mixed functional patterns';
        }
        
        function generateSecondaryPatterns(secondary) {
            // Standardized secondary pattern descriptors
            const patterns = {
                'Feeling': 'conditional behaviors, relational modes, emotional rhythms',
                'Thinking': 'analytical flashes, cognitive structuring, logical checks',
                'Sensation': 'sensory awareness, grounding moments, practical adjustments',
                'Intuition': 'imaginal flashes, pattern recognition, possibility sensing'
            };
            
            return patterns[secondary.functionalEmphasis] || 'auxiliary patterns';
        }
        
        function generateShadowPatterns(shadow) {
            // Standardized shadow friction descriptors
            const patterns = {
                'Thinking': 'doubt, analysis paralysis, over-structuring',
                'Feeling': 'emotional overwhelm, boundary fog, value conflicts',
                'Sensation': 'sensory overload, grounding loss, detail fixation',
                'Intuition': 'vision scatter, timing snags, possibility overwhelm'
            };
            
            return patterns[shadow.functionalEmphasis] || 'constitutional friction points';
        }
        
        function generateDominantMetaphor(dominant) {
            // Clean metaphors for dominant orientation (no flourish words)
            const metaphors = {
                'Thinking_Introverted': 'architect',
                'Thinking_Extraverted': 'director',
                'Feeling_Introverted': 'tuning fork',
                'Feeling_Extraverted': 'bridge',
                'Sensation_Introverted': 'anchor',
                'Sensation_Extraverted': 'current',
                'Intuition_Introverted': 'lens',
                'Intuition_Extraverted': 'explorer'
            };
            
            const key = `${dominant.functionalEmphasis}_${dominant.orientation}`;
            return metaphors[key] || 'constitutional foundation';
        }
        
        function generateSecondaryMetaphor(secondary, shadow) {
            // Clean metaphors for secondary/shadow interaction
            const metaphors = {
                'Feeling': 'tide-puller',
                'Thinking': 'grid-keeper',
                'Sensation': 'ground-anchor',
                'Intuition': 'wind-reader'
            };
            
            return metaphors[secondary.functionalEmphasis] || 'background current';
        }
        
        function extractTopHooks(data, isRelational) {
            // Extract top 3 hooks using standardized recognition hierarchy
            const hooks = [];

            // Personal-outer hard aspects first
            const hardAspects = extractHardAspects(data);
            hardAspects.slice(0, 2).forEach(aspect => {
                hooks.push({
                    description: `${aspect.p1_name} ${aspect.aspect} ${aspect.p2_name} (${Math.abs(aspect.orb || 0).toFixed(1)}°)`
                });
            });

            // Angles if available
            const angleAspects = extractAngleAspects(data);
            if (angleAspects.length > 0 && hooks.length < 3) {
                hooks.push({
                    description: `${angleAspects[0].description} (angular)`
                });
            }

            // Fill to 3 hooks minimum with actual data extraction
            while (hooks.length < 3) {
                // Try to get more aspects from the data
                const allAspects = data.person_a?.aspects || [];
                const remainingAspects = allAspects.filter(aspect =>
                    !hooks.some(hook =>
                        hook.description.includes(aspect.p1_name) &&
                        hook.description.includes(aspect.p2_name)
                    )
                );

                if (remainingAspects.length > 0) {
                    const nextAspect = remainingAspects[0];
                    hooks.push({
                        description: `${nextAspect.p1_name} ${nextAspect.aspect} ${nextAspect.p2_name} (${Math.abs(nextAspect.orb || nextAspect.orbit || 0).toFixed(1)}°)`
                    });
                } else {
                    // Use generic fallback if no more aspects available
                    hooks.push({
                        description: `Chart emphasizes earlier listed patterns`
                    });
                }
            }

            return hooks.slice(0, 3);
        }
        
        function generateClimateReading(balanceData) {
            // Generate standardized climate reading using approved descriptors
            const summary = balanceData?.channel_summary;
            if (!summary) return "Transit patterns suggest internal recalibration";
            
            const magnitude = summary.seismograph_average || 0;
            const valence = summary.balance_average || 0;
            
            const magnitudeDesc = magnitude > 3 ? 'high pressure' : magnitude > 1.5 ? 'moderate pressure' : 'low pressure';
            const valenceEmoji = valence > 0 ? '🌞' : valence < 0 ? '🌑' : '🌗';
            const direction = valence > 0 ? 'supportive' : valence < 0 ? 'restrictive' : 'mixed';
            
            return `${magnitudeDesc} band, ${direction} ${valenceEmoji}`;
        }
        
        function generateSupportStatus(balanceData) {
            // Generate standardized support status using approved descriptors
            const sfdAvg = balanceData?.channel_summary?.sfd_average || 0;
            
            if (sfdAvg > 1) return "scaffolding prevailing";
            if (sfdAvg > -1) return "scaffolding holding";
            return "support cut";
        }
        
        function generateSystemEnergy(balanceData) {
            // Generate standardized system energy status
            const summary = balanceData?.channel_summary;
            if (!summary) return "energy status unknown";
            
            const resilience = summary.resilience_average || 0;
            const depletion = summary.depletion_average || 0;
            
            if (resilience > 3 && depletion < 2) return "resilient";
            if (depletion > 3) return "depleted";
            return "rebounding";
        }
        
        function generateSeismographTag(balanceData) {
            // Generate standardized seismograph tag
            const magnitude = balanceData?.channel_summary?.seismograph_average || 0;
            
            if (magnitude > 3.5) return "high";
            if (magnitude > 2) return "med";
            return "low";
        }
        
        function generateDepletionNote(balanceData) {
            // Generate standardized depletion note
            const summary = balanceData?.channel_summary;
            if (!summary) return "Depletion status unknown - no balance meter data available";
            
            const depletion = summary.depletion_average || 0;
            const resilience = summary.resilience_average || 0;
            
            if (depletion > 3) {
                return `High depletion detected (${depletion.toFixed(1)}) - focus on recovery and replenishment`;
            } else if (resilience > 3) {
                return `Strong resilience (${resilience.toFixed(1)}) supporting sustained activity`;
            } else {
                return `Balanced energy reserves - monitor for signs of depletion`;
            }
        }
        
        function generatePolarityVoice(polarity, person = null) {
            // Generate VOICE content for polarity cards using standardized patterns
            const aspectType = polarity.map?.split(',')[0]?.split(' ')[2]?.toLowerCase() || 'conjunction';
            
            const voiceTemplates = {
                'conjunction': 'These energies may blend together, sometimes harmoniously, sometimes creating intensity that needs conscious direction.',
                'opposition': 'These energies may pull in different directions, creating awareness through contrast and the need to find balance.',
                'square': 'These energies may create friction that generates movement - challenge that promotes growth when engaged consciously.',
                'trine': 'These energies may flow naturally together, creating ease and supporting natural expression.',
                'sextile': 'These energies may offer opportunities for integration through conscious engagement and effort.'
            };
            
            const baseVoice = voiceTemplates[aspectType] || 'These planetary energies may interact in ways that create opportunities for conscious awareness and growth.';
            
            if (person === 'A') {
                return `For Person A: ${baseVoice}`;
            } else if (person === 'B') {
                return `For Person B: ${baseVoice}`;
            } else {
                return baseVoice;
            }
        }
        
        function extractHardAspects(data) {
            // Extract hard aspects (squares, oppositions) from chart data
            const aspects = [];
            
            // Check person_a aspects (correct data path)
            if (data.person_a?.aspects) {
                data.person_a.aspects.forEach(aspect => {
                    if (['square', 'opposition', 'conjunction'].includes(aspect.aspect?.toLowerCase())) {
                        aspects.push(aspect);
                    }
                });
            }
            
            return aspects.sort((a, b) => Math.abs(a.orb || a.orbit || 0) - Math.abs(b.orb || b.orbit || 0));
        }
        
        function extractAngleAspects(data) {
            // Extract angular aspects (ASC, MC, DSC, IC)
            const angles = [];
            // Implementation depends on how angular data is stored in chart
            // TODO: Add implementation based on actual data structure
            return angles;
        }
        
        function identifyLatentVectors(data) {
            // Identify structurally present but behaviorally quiet vectors
            const vectors = [];
            
            // Check for strong aspects with wide orbs
            if (data.person_a?.aspects) {
                data.person_a.aspects.forEach(aspect => {
                    const orb = Math.abs(aspect.orb || aspect.orbit || 0);
                    if (orb > 4 && orb < 8) {  // Wide but within orb
                        vectors.push({
                            status: 'Latent',
                            name: `${aspect.p1_name} ${aspect.aspect} ${aspect.p2_name}`,
                            description: 'structural presence but contained/waiting'
                        });
                    }
                });
            }
            
            return vectors.slice(0, 3); // Maximum 3 vectors
        }
        
        function extractTopPolarities(data, isRelational) {
            // Extract top 3 polarities for FIELD → MAP → VOICE cards
            const polarities = [];

            if (data.person_a?.aspects) {
                data.person_a.aspects.slice(0, 3).forEach(aspect => {
                    polarities.push({
                        nameA: aspect.p1_name,
                        nameB: aspect.p2_name,
                        field: generatePolarityField(aspect),
                        map: `${aspect.p1_name} ${aspect.aspect} ${aspect.p2_name}, ${Math.abs(aspect.orb || aspect.orbit || 0).toFixed(1)}° orb`,
                        fieldA: isRelational ? generatePolarityField(aspect, 'A') : null,
                        fieldB: isRelational ? generatePolarityField(aspect, 'B') : null
                    });
                });
            }

            // Fill to 3 polarities with actual data if available
            while (polarities.length < 3) {
                // Try to get more aspects from the data
                const allAspects = data.person_a?.aspects || [];
                const remainingAspects = allAspects.filter(aspect =>
                    !polarities.some(polarity =>
                        polarity.nameA === aspect.p1_name &&
                        polarity.nameB === aspect.p2_name
                    )
                );

                if (remainingAspects.length > 0) {
                    const nextAspect = remainingAspects[0];
                    polarities.push({
                        nameA: nextAspect.p1_name,
                        nameB: nextAspect.p2_name,
                        field: generatePolarityField(nextAspect),
                        map: `${nextAspect.p1_name} ${nextAspect.aspect} ${nextAspect.p2_name}, ${Math.abs(nextAspect.orb || nextAspect.orbit || 0).toFixed(1)}° orb`,
                        fieldA: isRelational ? generatePolarityField(nextAspect, 'A') : null,
                        fieldB: isRelational ? generatePolarityField(nextAspect, 'B') : null
                    });
                } else {
                    // Use archetypal fallback if no more aspects available
                    polarities.push({
                        nameA: 'Individual',
                        nameB: 'Collective',
                        field: 'personal/transpersonal tension',
                        map: 'Fundamental human polarity patterns',
                        fieldA: isRelational ? 'Individual focus for A' : null,
                        fieldB: isRelational ? 'Individual focus for B' : null
                    });
                }
            }

            return polarities;
        }
        
        function generatePolarityField(aspect, person = null) {
            // Generate standardized FIELD descriptions (somatic/sensory texture)
            const aspectType = aspect.aspect?.toLowerCase();
            
            const fieldTextures = {
                'conjunction': 'fusion pressure, merging pull',
                'opposition': 'pull-apart tension, polarizing stretch',
                'square': 'friction heat, resistance pressure',
                'trine': 'flowing ease, supportive current',
                'sextile': 'opportunity spark, gentle activation'
            };
            
            return fieldTextures[aspectType] || 'energetic texture';
        }
        
        function synthesizeBalanceMeterFromTransits(data) {
            // Synthesize Balance Meter data from available transit information
            // Check multiple possible locations for transit data
            const transitsByDate = data.transitsByDate ||
                                   data.person_a?.chart?.transitsByDate ||
                                   data.balance_meter?.daily_entries ||
                                   null;

            if (!transitsByDate) return null;

            const dates = Object.keys(transitsByDate);
            if (dates.length === 0) return null;

            // Calculate basic averages from transit data
            let totalMagnitude = 0;
            let totalValence = 0;
            let totalSfd = 0;
            let totalResilience = 0;
            let totalDepletion = 0;
            let count = 0;

            dates.forEach(date => {
                const dayData = transitsByDate[date];
                if (dayData?.seismograph) {
                    totalMagnitude += dayData.seismograph.magnitude || 0;
                    totalValence += dayData.seismograph.valence || 0;
                    count++;
                }
                // Also check for balance meter data
                if (dayData?.balance) {
                    totalSfd += dayData.balance.sfd || 0;
                    totalResilience += dayData.balance.resilience || 0;
                    totalDepletion += dayData.balance.depletion || 0;
                } else if (dayData?.sfd) {
                    totalSfd += typeof dayData.sfd === 'object' ? dayData.sfd.sfd || 0 : dayData.sfd;
                }
            });

            if (count === 0) return null;

            // If we don't have balance data, provide reasonable defaults
            const avgSfd = totalSfd > 0 ? totalSfd / count : 0;
            const avgResilience = totalResilience > 0 ? totalResilience / count : 2.5;
            const avgDepletion = totalDepletion > 0 ? totalDepletion / count : 2.0;

            return {
                channel_summary: {
                    seismograph_average: totalMagnitude / count,
                    balance_average: totalValence / count,
                    sfd_average: avgSfd,
                    resilience_average: avgResilience,
                    depletion_average: avgDepletion
                }
            };
        }
        
        function extractChartDataForTypology(personData) {
            // Extract chart data needed for typological analysis
            if (!personData) return { planets: [], houses: [], signs: [], aspects: [] };
            
            return {
                planets: personData.chart?.planets || [],
                houses: personData.chart?.houses || [],
                signs: personData.chart?.signs || [],
                aspects: personData.aspects || []
            };
        }
        
        function analyzeDominantOrientation(chartData) {
            // Analyze dominant psychological orientation from chart data
            // Focus on Sun, Mercury, and Ascendant for dominant function
            const sun = chartData.sun;
            const mercury = chartData.mercury;
            const ascendant = chartData.ascendant;

            // Build raw placements description from actual data
            const rawPlacements = [
                sun ? `Sun in ${sun.sign || 'Unknown'} (${sun.house || 'Unknown'})` : 'Sun placement unavailable',
                mercury ? `Mercury in ${mercury.sign || 'Unknown'} (${mercury.house || 'Unknown'})${mercury.retrograde ? ' ℞' : ''}` : 'Mercury placement unavailable',
                ascendant ? `Ascendant in ${ascendant.sign || 'Unknown'}` : 'Ascendant unavailable'
            ].filter(Boolean).join(', ');

            // Determine functional emphasis based on actual placements
            const functionalEmphasis = determineFunctionalEmphasis(sun, mercury, ascendant);

            // Determine orientation (Introverted/Extraverted) based on actual data
            const orientation = determineOrientation(sun, mercury, ascendant);

            return {
                rawPlacements,
                functionalEmphasis,
                orientation
            };
        }
        
        function analyzeSecondaryOrientation(chartData) {
            const moon = chartData.moon;

            // Find auxiliary aspects to Moon from actual data
            const moonAspects = chartData.aspects ? chartData.aspects.filter(aspect =>
                aspect.p1_name === 'Moon' || aspect.p2_name === 'Moon'
            ).slice(0, 3) : [];

            const aspectsText = moonAspects.length > 0
                ? moonAspects.map(a => `${a.p1_name || ''} ${a.aspect || ''} ${a.p2_name || ''}`).join(', ')
                : 'No major aspects detected';

            const rawPlacements = moon
                ? `Moon in ${moon.sign || 'Unknown'} (${moon.house || 'Unknown'}), aspects: ${aspectsText}`
                : 'Moon placement unavailable';

            const functionalEmphasis = moon ? determineSecondaryFunction(moon) : 'Unknown';
            const orientationCue = moon ? determineSecondaryOrientation(moon) : 'Unknown';

            return {
                rawPlacements,
                functionalEmphasis,
                orientationCue
            };
        }
        
        function analyzeShadowOrientation(chartData) {
            // Focus on Mars, Saturn, Neptune, and outer planets for shadow/inferior
            const mars = chartData.mars;
            const saturn = chartData.saturn;
            const neptune = chartData.neptune;
            const uranus = chartData.uranus;
            const pluto = chartData.pluto;

            // Find challenging aspects from actual data
            const challengingAspects = chartData.aspects ? chartData.aspects.filter(aspect =>
                (aspect.aspect === 'square' || aspect.aspect === 'opposition' || aspect.aspect === 'quincunx') &&
                (aspect.p1_name === 'Mars' || aspect.p1_name === 'Saturn' || aspect.p1_name === 'Neptune' ||
                 aspect.p2_name === 'Mars' || aspect.p2_name === 'Saturn' || aspect.p2_name === 'Neptune')
            ).slice(0, 4) : [];

            const rawPlacements = [
                mars ? `Mars in ${mars.sign || 'Unknown'} (${mars.house || 'Unknown'})` : 'Mars placement unavailable',
                saturn ? `Saturn in ${saturn.sign || 'Unknown'} (${saturn.house || 'Unknown'})` : 'Saturn placement unavailable',
                neptune ? `Neptune in ${neptune.sign || 'Unknown'} (${neptune.house || 'Unknown'})` : 'Neptune placement unavailable'
            ].filter(Boolean).join(', ') +
            (challengingAspects.length > 0 ? '; Challenging aspects: ' +
                challengingAspects.map(a => `${a.p1_name} ${a.aspect} ${a.p2_name}`).join(', ') : '');

            const inferiorFunctions = determineInferiorFunctions(mars, saturn, neptune);
            const pressureDescription = generatePressureDescription(challengingAspects, mars, saturn, neptune);

            return {
                rawPlacements,
                inferiorFunctions,
                pressureDescription
            };
        }
        
        // Helper function to generate insights from aspects
        function generateInsightFromAspect(aspect) {
            if (!aspect) return "Transit patterns suggest a day of internal reflection and recalibration.";
            
            const p1 = aspect.p1_name || aspect.p1_display || "Planet";
            const p2 = aspect.p2_name || aspect.p2_display || "Planet";
            const aspectType = aspect.aspect || aspect._aspect || "conjunction";
            const orb = Math.abs(aspect.orbit || aspect._orb || 0);
            
            // Generate contextual insight based on aspect type and planets
            const tensionAspects = ['square', 'opposition', 'sesquiquadrate'];
            const supportiveAspects = ['trine', 'sextile', 'quintile'];
            
            if (tensionAspects.includes(aspectType)) {
                return `Today features ${orb < 2 ? 'precise' : 'building'} tension between ${p1.toLowerCase()} and ${p2.toLowerCase()}, creating dynamic pressure that can catalyze growth through conscious engagement.`;
            } else if (supportiveAspects.includes(aspectType)) {
                return `The day flows with ${orb < 2 ? 'exact' : 'approaching'} harmony between ${p1.toLowerCase()} and ${p2.toLowerCase()}, offering opportunities for integration and natural progress.`;
            } else {
                return `A ${orb < 2 ? 'precise' : 'developing'} ${aspectType} between ${p1.toLowerCase()} and ${p2.toLowerCase()} creates a potent field for transformation and new possibilities.`;
            }
        }

        function generatePersonClearMirror(personData, personDetails, label) {
            let md = `## ${label}: ${personDetails.name}\n\n`;
            
            // === 1. PERSONALITY PROFILE (What People Want First) ===
            md += `### Personality Profile\n\n`;
            
            const typologyProfile = generateTypologicalProfile(personData, personDetails);
            
            md += `**Your Constitutional Climate**\n\n`;
            md += `${typologyProfile.ravenTranslation.climate}\n\n`;
            
            md += `**Dominant Operating Style**\n\n`;
            md += `${typologyProfile.ravenTranslation.dominant}\n\n`;
            
            md += `**Secondary Support System**\n\n`;
            md += `${typologyProfile.ravenTranslation.secondary}\n\n`;
            
            md += `**Shadow Integration Work**\n\n`;
            md += `${typologyProfile.ravenTranslation.shadow}\n\n`;
            
            md += `*This profile describes your core psychological patterns and natural operating style, derived from your natal planetary positions.*\n\n`;
            
            md += `⸻\n\n`;
            
            // === 2. KEY PATTERNS IN PLAY (Transit Activations) ===
            md += `### Key Patterns in Play\n\n`;
            md += `*These are the most significant active energies for today.*\n\n`;
            
            // Get major aspects for Key Drivers (using top aspects or hooks if available)
            const aspects = getTopAspectsForPerson(personData);
            const keyDrivers = aspects.slice(0, 4); // Top 4 for Key Drivers
            
            keyDrivers.forEach((aspect, index) => {
                const driverType = index === 0 ? 'Primary Tension' : 
                                 index === 1 ? 'Helpful Insight' : 
                                 index === 2 ? 'Background Support' : 'Secondary Theme';
                
                const polarity = generatePolarityFromAspect(aspect, index + 1);
                md += `**${driverType}**: **${polarity.title}**\n\n`;
                md += `${polarity.voice}\n\n`;
            });
            
            // Add recursive pattern note if many retrograde aspects
            const firstDayData = personData?.chart?.transitsByDate ? 
                Object.values(personData.chart.transitsByDate)[0] : null;
                
            if (firstDayData) {
                const retroCount = (firstDayData.hooks || []).filter(h => 
                    h.transit_is_retrograde || h.natal_is_retrograde).length;
                if (retroCount > 3) {
                    md += `**Overarching Theme**: **Retrograde Recursion Pattern** (${retroCount} aspects detected)\n\n`;
                    md += `A significant emphasis on internal review, revision, and processing of past patterns. Energy is directed inward, not outward.\n\n`;
                }
            }
            
            md += `⸻\n\n`;
            
            // === 3. THE BOTTOM LINE (Executive Summary) ===
            md += `### The Bottom Line (Executive Summary)\n\n`;
            
            if (firstDayData) {
                const magnitude = firstDayData.seismograph?.magnitude || 0;
                const valence = firstDayData.seismograph?.valence || 0;
                const volatility = firstDayData.seismograph?.volatility || 0;
                
                const magnitudeTerm = toMagnitudeTerm(magnitude);
                const valenceTerm = toValenceTerm(valence);
                const valenceEmoji = getValenceEmoji(valence);
                
                md += `**Overall Intensity**: ${magnitude.toFixed(1)} / 5.0 (**${magnitudeTerm}**)\n\n`;
                md += `**Emotional Vibe**: ${valenceEmoji} ${valence.toFixed(1)} / 5.0 (**${valenceTerm}**)\n\n`;
                md += `**Energy State**: ${volatility > 3 ? 'High Volatility' : 'Focused Pressure'} (Volatility: ${volatility.toFixed(2)})\n\n`;
                
                // Generate key insight from top aspects
                const topAspects = getTopAspectsForPerson(personData).slice(0, 2);
                if (topAspects.length > 0) {
                    const primaryPattern = generateInsightFromAspect(topAspects[0]);
                    md += `**Key Insight**: ${primaryPattern}\n\n`;
                }
            } else {
                md += `**Today's Weather**: Transit data processing... check back for live insights.\n\n`;
            }
            
            md += `⸻\n\n`;
            
            // === 3. HOW TO READ THIS (Glossary & Method) ===
            md += `<details>\n`;
            md += `<summary><strong>How to Read This Report</strong></summary>\n\n`;
            md += `### Agency Statement\n\n`;
            md += `This analysis describes symbolic weather patterns, not deterministic outcomes. The map is a tool to support your agency; it never overrides it. You are the author of your choices.\n\n`;
            md += `### Key Terms\n\n`;
            md += `- **Magnitude**: Overall intensity level (0-5 scale)\n`;
            md += `- **Valence**: Emotional tone from challenging (-5) to supportive (+5)\n`;
            md += `- **Volatility**: How quickly energy shifts (higher = more unpredictable)\n`;
            md += `- **Aspects**: Geometric relationships between planets creating specific energies\n`;
            md += `- **Retrograde**: Apparent backward motion indicating internal/review themes\n\n`;
            md += `### System Notes\n\n`;
            md += `- **Math Brain**: Calculates precise planetary geometry (this report)\n`;
            md += `- **Raven Calder**: Translates geometry into felt language and poetry\n`;
            md += `- **Mirror Principle**: Reflects patterns for recognition, not prediction\n\n`;
            md += `</details>\n\n`;
            
            md += `⸻\n\n`;
            
            // === 4. THE BLUEPRINT (Reference Data) ===
            md += `<details>\n`;
            md += `<summary><strong>Technical Blueprint & Reference Data</strong></summary>\n\n`;
            
            md += `💡 **For Complete Balance Analysis**: This Clear Mirror report includes Balance Channel (v1.1) and Support–Friction Differential (v1.2) data in the Triple Channel metrics. For comprehensive Resilience & Depletion layer analysis, generate a dedicated report using **Balance Meter mode** in the app interface.\n\n`;
            
            // === RAVEN TRANSLATION LAYER ===
            md += `### 🎯 AI Poetic Brain Translation Layer\n\n`;
            md += `*Essential data feed for AI mirror writing (per Raven Calder guidance):*\n\n`;
            
            // Resolve first day using standardized helpers
            const { firstDate: tlFirstDate, firstDayData: tlFirstDay, transitsByDate: tlTbd } = getFirstDayData(personData);
            const firstDayTL = tlFirstDay || firstDayData || {};
            // Extract seismograph data
            const magnitude = firstDayTL.seismograph?.magnitude || 0;
            const valence = firstDayTL.seismograph?.valence || 0;
            const volatility = firstDayTL.seismograph?.volatility || 0;
            
            // Top Hooks (Essential)
            const topHooks = (firstDayTL.hooks || []).slice(0, 3);
            if (topHooks.length > 0) {
                const hooksText = topHooks.map(h => {
                    const p1 = h.p1_name || h.p1_display || 'Unknown';
                    const p2 = h.p2_name || h.p2_display || 'Unknown';
                    const aspect = aspectSymbol(h.aspect || h._aspect || 'conjunction');
                    return `${p1}${aspect}${p2}`;
                }).join(', ');
                md += `**Top Hooks (orb-capped)**: ${hooksText}\n\n`;
            }
            
            // Seismograph Triple Lens (Essential)
            md += `**Seismograph Triple Lens**: Magnitude ${magnitude.toFixed(2)}, Valence ${valence >= 0 ? '+' : ''}${valence.toFixed(2)}, Volatility ${volatility.toFixed(2)}\n\n`;
            
            // Balance Refinements (Essential)
            const sfdValue = (firstDayTL.sfd && typeof firstDayTL.sfd === 'object') 
                ? firstDayTL.sfd.sfd || 0 
                : (typeof firstDayTL.sfd === 'number' ? firstDayTL.sfd : 0);
            const sfdVerdict = sfdValue >= 0.75 ? "stabilizers prevail" : 
                              sfdValue <= -0.75 ? "stabilizers cut" : "stabilizers mixed";
            md += `**Balance Refinements**: SFD ${sfdValue >= 0 ? '+' : ''}${sfdValue.toFixed(1)}, "${sfdVerdict}"\n\n`;
            
            // Retrograde Recursion Flag (Essential)
            const totalAspects = countAspectsForDay(firstDayTL);
            md += `**Retrograde Recursion Flag**: ${totalAspects} aspects (${totalAspects > 50 ? 'heavy' : totalAspects > 25 ? 'moderate' : 'light'} day)\n\n`;
            
            // Natal Scaffolding (Essential) - Extract key planetary positions
            const chartDataTL = extractChartDataForTypology(personData);
            md += `**Natal Scaffolding**:\n`;
            md += `- **Asc**: ${chartDataTL.ascendant?.sign || 'Unknown'} ${(chartDataTL.ascendant?.position || 0).toFixed(1)}°\n`;
            md += `- **Sun**: ${chartDataTL.sun?.sign || 'Unknown'} ${(chartDataTL.sun?.position || 0).toFixed(1)}°\n`;
            md += `- **Moon**: ${chartDataTL.moon?.sign || 'Unknown'} ${(chartDataTL.moon?.position || 0).toFixed(1)}°\n`;
            md += `- **Mercury**: ${chartDataTL.mercury?.sign || 'Unknown'} ${(chartDataTL.mercury?.position || 0).toFixed(1)}°\n`;
            md += `- **Venus**: ${chartDataTL.venus?.sign || 'Unknown'} ${(chartDataTL.venus?.position || 0).toFixed(1)}°\n`;
            md += `- **Mars**: ${chartDataTL.mars?.sign || 'Unknown'} ${(chartDataTL.mars?.position || 0).toFixed(1)}°\n`;
            md += `- **Jupiter**: ${chartDataTL.jupiter?.sign || 'Unknown'} ${(chartDataTL.jupiter?.position || 0).toFixed(1)}°\n`;
            md += `- **Saturn**: ${chartDataTL.saturn?.sign || 'Unknown'} ${(chartDataTL.saturn?.position || 0).toFixed(1)}°\n`;
            md += `- **Uranus**: ${chartDataTL.uranus?.sign || 'Unknown'} ${(chartDataTL.uranus?.position || 0).toFixed(1)}°\n`;
            md += `- **Neptune**: ${chartDataTL.neptune?.sign || 'Unknown'} ${(chartDataTL.neptune?.position || 0).toFixed(1)}°\n`;
            md += `- **Pluto**: ${chartDataTL.pluto?.sign || 'Unknown'} ${(chartDataTL.pluto?.position || 0).toFixed(1)}°\n`;
            md += `- **True Node**: ${chartDataTL.true_node?.sign || 'Unknown'} ${(chartDataTL.true_node?.position || 0).toFixed(1)}°\n\n`;
            
            md += `*Everything below this point is engine room / audit data that AI translation can safely ignore.*\n\n`;
            
            // === NATAL CHART FOUNDATION ===
            md += `### Subject Details — Reveal the Weave\n\n`;
            
            md += `**Primary Subject**: ${personDetails.name}\n\n`;
            md += `- **Birth Date**: ${personDetails.year}-${String(personDetails.month).padStart(2, '0')}-${String(personDetails.day).padStart(2, '0')}\n`;
            md += `- **Birth Time**: ${String(personDetails.hour).padStart(2, '0')}:${String(personDetails.minute).padStart(2, '0')}\n`;
            md += `- **Location**: ${personDetails.city}, ${personDetails.nation}\n`;
            md += `- **Coordinates**: ${personDetails.lat}, ${personDetails.lng}\n`;
            md += `- **Timezone**: ${personDetails.timezone || 'UTC'}\n`;
            md += `- **Zodiac Type**: Tropic\n\n`;
            
            md += `### Geometry — The Skeleton of the Land\n\n`;
            
            // Extract natal chart data
            const chartData = extractChartDataForTypology(personData);
            
            md += `#### Chart Angles\n\n`;
            const asc = chartData.ascendant || {};
            const dsc = { sign: asc.sign === 'Vir' ? 'Pis' : 'Unknown', position: asc.position }; // Opposite sign logic would be more complex
            md += `- **Ascendant (ASC)**: ${asc.sign || 'Unknown'} ${(asc.position || 0).toFixed(2)}°\n`;
            md += `- **Descendant (DSC)**: ${dsc.sign} ${(dsc.position || 0).toFixed(2)}°\n`;
            md += `- **Midheaven (MC)**: ${(chartData.midheaven?.sign || 'Unknown')} ${(chartData.midheaven?.position || 0).toFixed(2)}°\n`;
            md += `- **Imum Coeli (IC)**: ${(chartData.midheaven?.sign || 'Unknown')} ${(chartData.midheaven?.position || 0).toFixed(2)}°\n\n`;
            
            md += `#### Natal Planet Positions\n\n`;
            const planets = [
                { key: 'sun', name: 'Sun' },
                { key: 'moon', name: 'Moon' },
                { key: 'mercury', name: 'Mercury' },
                { key: 'venus', name: 'Venus' },
                { key: 'mars', name: 'Mars' },
                { key: 'jupiter', name: 'Jupiter' },
                { key: 'saturn', name: 'Saturn' },
                { key: 'uranus', name: 'Uranus' },
                { key: 'neptune', name: 'Neptune' },
                { key: 'pluto', name: 'Pluto' }
            ];
            
            planets.forEach(planet => {
                const planetData = chartData[planet.key] || {};
                const sign = planetData.sign || 'Unknown';
                const position = (planetData.position || 0).toFixed(2);
                const house = planetData.house || 'Unknown';
                const retrograde = planetData.retrograde ? ' ℞' : '';
                
                md += `- **${planet.name}**: ${sign} ${position}° (House ${house})${retrograde}\n`;
            });
            
            md += `\n`;
            
            md += `#### House Cusps\n\n`;
            const houses = [
                { num: '1st', name: 'Identity, Stance' },
                { num: '2nd', name: 'Resource, Security' },
                { num: '3rd', name: 'Exchange, Signals' },
                { num: '4th', name: 'Root, Anchor' },
                { num: '5th', name: 'Creative, Expression' },
                { num: '6th', name: 'Craft, Rhythm' },
                { num: '7th', name: 'Relational, Mirror' },
                { num: '8th', name: 'Depth, Crossing' },
                { num: '9th', name: 'Horizon, Philosophy' },
                { num: '10th', name: 'Apex, Projection' },
                { num: '11th', name: 'Network, Belonging' },
                { num: '12th', name: 'Dream, Spirit' }
            ];
            
            houses.forEach(house => {
                // This would need actual house cusp data from API, using placeholder
                md += `- **${house.num} House**: Unknown Sign 0.00° (${house.name})\n`;
            });
            
            md += `\n`;
            
            // === DAILY TRANSIT ANALYSIS ===
            md += `### Daily Transit Analysis\n\n`;
            
            if (firstDayData) {
                md += `**Executive Summary (Math Brain Protocol)**\n\n`;
                const currentDate = new Date().toISOString().split('T')[0];
                md += `Date: ${currentDate} TZ: ${personDetails.timezone || 'UTC'} Context: NATAL_TRANSITS\n\n`;
                
                // Triple Channel breakdown
                const magnitude = firstDayData.seismograph?.magnitude || 0;
                const valence = firstDayData.seismograph?.valence || 0;
                const volatility = firstDayData.seismograph?.volatility || 0;
                const balance = (firstDayData.balance && typeof firstDayData.balance === 'object') 
                    ? firstDayData.balance.valence || 0 
                    : (typeof firstDayData.balance === 'number' ? firstDayData.balance : valence || 0);
                const sfd = (firstDayData.sfd && typeof firstDayData.sfd === 'object') 
                    ? firstDayData.sfd.sfd || 0 
                    : (typeof firstDayData.sfd === 'number' ? firstDayData.sfd : 0);
                
                const magnitudeEmoji = '⚡'; // Official Raven Calder magnitude emoji
                const valenceEmoji = getValenceEmoji(valence);
                const balanceEmoji = balance > 0 ? '🌞' : balance < 0 ? '🌑' : '🌗'; // Official valence emojis
                const volatilityEmoji = volatility > 7 ? ' 🌪️' : '';
                
                md += `Triple Channel: ${magnitudeEmoji} ${magnitude.toFixed(1)} · Val ${valenceEmoji} ${valence.toFixed(1)} · Bal ${balanceEmoji} ${balance.toFixed(1)}${volatilityEmoji} · stabilizers mixed (SFD ${sfd >= 0 ? '+' : ''}${sfd.toFixed(1)})\n\n`;
                
                md += `**Seismograph Metrics**\n\n`;
                md += `- **Magnitude**: ${magnitude.toFixed(2)} (${toMagnitudeTerm(magnitude)})\n`;
                md += `- **Valence**: ${valenceEmoji} ${valence.toFixed(2)} (${toValenceTerm(valence)})\n`;
                md += `- **Volatility**: ${volatility.toFixed(2)}\n`;
                md += `- **Valence_raw (debug)**: ${valence.toFixed(2)}\n\n`;
                
                // Top Hooks with precise formatting
                const topHooks = (firstDayData.hooks || []).slice(0, 3);
                if (topHooks.length > 0) {
                    const hooksText = topHooks.map(h => {
                        const p1 = h.p1_name || h.p1_display || 'Unknown';
                        const p2 = h.p2_name || h.p2_display || 'Unknown';
                        const aspect = aspectSymbol(h.aspect || h._aspect || 'conjunction');
                        const orb = (h.orbit || h._orb || 0).toFixed(1);
                        return `${p1}${aspect}${p2} (${orb < 0 ? '' : '+'}${orb}°)`;
                    }).join(', ');
                    md += `**Top Hooks (orb-capped)**: ${hooksText}\n\n`;
                }
                
                // Retrograde analysis
                const retroPlanets = [];
                const retroAspects = [];
                const osrFlags = firstDayData.osr_flags || [];
                
                (firstDayData.hooks || []).forEach(h => {
                    if (h.transit_is_retrograde) retroPlanets.push(h.p1_name || h.p1_display);
                    if (h.natal_is_retrograde || h.transit_is_retrograde) retroAspects.push(h);
                });
                
                md += `**Transit Status**\n\n`;
                md += `- **Transiting ℞ planets**: ${[...new Set(retroPlanets)].length}\n`;
                md += `- **℞-tagged aspects**: ${retroAspects.length}\n`;
                md += `- **OSR**: ${osrFlags.length}\n\n`;
                
                // Detailed aspect breakdown
                const allAspects = getTopAspectsForPerson(personData);
                if (allAspects.length > 0) {
                    md += `**Complete Aspect Analysis** (${allAspects.length} total)\n\n`;
                    md += `| Transit Planet | Aspect | Natal Planet | Orb | Type | Phase | Weight |\n`;
                    md += `|----------------|---------|--------------|-----|------|-------|--------|\n`;
                    
                    allAspects.slice(0, 20).forEach(aspect => {
                        const p1 = aspect.p1_name || aspect.p1_display || 'Unknown';
                        const p2 = aspect.p2_name || aspect.p2_display || 'Unknown';
                        const aspectType = aspect.aspect || aspect._aspect || 'conjunction';
                        const orb = (aspect.orbit || aspect._orb || 0).toFixed(1) + '°';
                        const classification = aspect.classification || 'major';
                        const phase = aspect.phase || (Math.abs(aspect.orbit || aspect._orb || 0) < 1 ? 'exact' : 'approaching');
                        const weight = aspect.weight ? `w=${aspect.weight.toFixed(2)}` : 'w=1.00';
                        const retroFlag = (aspect.transit_is_retrograde || aspect.natal_is_retrograde) ? ' ℞' : '';
                        
                        md += `| ${p1}${retroFlag} | ${aspectType} | ${p2} | ${orb} | ${classification} | ${phase} | ${weight} |\n`;
                    });
                    
                    if (allAspects.length > 20) {
                        md += `\n*...and ${allAspects.length - 20} additional aspects*\n`;
                    }
                }
                
                md += `\n`;
            }
            
            // === POETIC BRAIN TRANSLATION SCAFFOLDING ===
            md += `### Poetic Brain Translation Scaffolding\n\n`;
            
            // Mirror Voice Section (technical analysis)
            md += `**FIELD → MAP → VOICE Analysis**\n\n`;
            
            const mirrorVoice = generateMirrorVoiceForPerson(personData, personDetails);
            md += `**FIELD**: ${mirrorVoice.field}\n\n`;
            md += `**MAP**: ${mirrorVoice.map}\n\n`;
            md += `**VOICE**: ${mirrorVoice.voice}\n\n`;
            
            md += `*This technical scaffolding provides the raw material for The Poetic Brain to translate into felt language and meaningful narrative.*\n\n`;
            
            // === TYPOLOGICAL PROFILE COMPLETE ===
            md += `⸻\n\n`;
            md += `### Complete Typological Profile (Math Brain → Raven Calder)\n\n`;
            
            // Use the typologyProfile variable already declared at the top
            
            md += `**1. Dominant Orientation (Sun, Mercury, Ascendant drivers)**\n\n`;
            md += `Raw placements: ${typologyProfile.dominant.rawPlacements}\n\n`;
            md += `Functional emphasis: ${typologyProfile.dominant.functionalEmphasis}\n\n`;
            md += `Orientation: ${typologyProfile.dominant.orientation}\n\n`;
            
            md += `**2. Secondary Orientation (Moon + auxiliary aspects)**\n\n`;
            md += `Raw placements: ${typologyProfile.secondary.rawPlacements}\n\n`;
            md += `Functional emphasis: ${typologyProfile.secondary.functionalEmphasis}\n\n`;
            md += `Orientation cue: ${typologyProfile.secondary.orientationCue}\n\n`;
            
            md += `**3. Shadow / Inferior Orientation (Mars, Saturn, Neptune, outer-planet entanglements)**\n\n`;
            md += `Raw placements: ${typologyProfile.shadow.rawPlacements}\n\n`;
            md += `Inferior functions implicated: ${typologyProfile.shadow.inferiorFunctions}\n\n`;
            md += `Pressure description: ${typologyProfile.shadow.pressureDescription}\n\n`;
            
            md += `**4. Constitutional Climate Summary**\n\n`;
            md += `Math Brain notes: ${typologyProfile.climate.mathBrainNotes}\n\n`;
            md += `Climate tags: ${typologyProfile.climate.climateTags}\n\n`;
            
            md += `**Raven Translation Output (VOICE)**\n\n`;
            md += `**Typological Profile (Plain Language)**\n\n`;
            md += `Dominant orientation: ${typologyProfile.ravenTranslation.dominant}\n\n`;
            md += `Secondary orientation: ${typologyProfile.ravenTranslation.secondary}\n\n`;
            md += `Shadow orientation: ${typologyProfile.ravenTranslation.shadow}\n\n`;
            md += `Constitutional climate: ${typologyProfile.ravenTranslation.climate}\n\n`;
            
            // === SYNTHESIS DIRECTIVES FOR AI ===
            md += `⸻\n\n`;
            md += `### Synthesis Directives for AI Poetic Brain\n\n`;
            
            md += `**Translation Protocol**: Use the above geometric scaffolding to generate felt-sense language that honors both precision and poetry.\n\n`;
            
            md += `**Key Elements to Synthesize**:\n`;
            md += `- Combine seismograph metrics with typological climate for overall tone\n`;
            md += `- Weave natal foundations with daily transits for temporal context\n`;
            md += `- Transform aspect orbs and classifications into timing and intensity language\n`;
            md += `- Translate retrograde patterns into internal/external orientation guidance\n`;
            md += `- Honor the Mirror Principle: reflect for recognition, never predict or determine\n\n`;
            
            md += `**Agency Reinforcement**: All translations must support user agency and require verification through personal resonance testing.\n\n`;
            
            md += `</details>\n\n`;
            
            return md;
        }
        
        function generateRelationalMirror(data, personA, personB) {
            let md = `## Relational Mirror Synthesis\n\n`;
            
            // Relational Hook Stack
            md += `### Relational Hook Stack\n\n`;
            
            const relationalAspects = getTopRelationalAspects(data);
            const relationalHooks = relationalAspects.slice(0, 3);
            
            relationalHooks.forEach((aspect, index) => {
                const polarity = generateRelationalPolarityFromAspect(aspect, personA.name, personB.name);
                md += `**[${polarity.title}]**\n\n`;
                md += `FIELD (felt tone): ${polarity.field}\n\n`;
                md += `MAP (geometry): ${polarity.map}\n\n`;
                md += `VOICE (user-facing): ${polarity.voice}\n\n`;
                if (index < relationalHooks.length - 1) md += `⸻\n\n`;
            });
            
            md += `\n⸻\n\n`;
            
            // Relational Polarity Cards
            md += `### Relational Polarity Cards\n\n`;
            
            relationalAspects.slice(0, 3).forEach((aspect, index) => {
                const polarity = generateRelationalPolarityCard(aspect, personA.name, personB.name);
                md += `**[${polarity.nameA} / ${polarity.nameB}]**\n\n`;
                md += `FIELD: ${polarity.field}\n\n`;
                md += `MAP: ${polarity.map}\n\n`;
                md += `VOICE: ${polarity.voice}\n\n`;
                if (index < relationalAspects.slice(0, 3).length - 1) md += `\n`;
            });
            
            md += `\n⸻\n\n`;
            
            // Relational Mirror Voice
            md += `### Mirror Voice (Relational Synthesis)\n\n`;
            
            const relationalMirror = generateRelationalMirrorVoice(data, personA, personB);
            md += `FIELD: ${relationalMirror.field}\n\n`;
            md += `MAP: ${relationalMirror.map}\n\n`;
            md += `VOICE: ${relationalMirror.voice} *All requires The Poetic Brain to translate further and the user/client to verify if any of it resonates.*\n\n`;
            
            return md;
        }
        
        // Helper functions for Clear Mirror template generation
        
        function getTopAspectsForPerson(personData) {
            // Extract and prioritize aspects for this person
            const aspects = [];
            
            // Check for transit aspects first (if available)
            if (personData?.chart?.transitsByDate) {
                const firstDay = Object.values(personData.chart.transitsByDate)[0];
                if (firstDay?.hooks) {
                    aspects.push(...firstDay.hooks.map(h => ({...h, type: 'transit_hook'})));
                }
                if (firstDay?.filtered_aspects) {
                    aspects.push(...firstDay.filtered_aspects.map(a => ({...a, type: 'transit_aspect'})));
                }
            }
            
            // Add natal aspects if available
            if (personData?.chart?.aspects) {
                aspects.push(...personData.chart.aspects.map(a => ({...a, type: 'natal_aspect'})));
            }
            
            // Sort by orb (tighter aspects first)
            return aspects.sort((a, b) => {
                const orbA = Math.abs(a.orb || a.orbit || a.diff || 10);
                const orbB = Math.abs(b.orb || b.orbit || b.diff || 10);
                return orbA - orbB;
            });
        }
        
        function getTopRelationalAspects(data) {
            const aspects = [];
            
            // Synastry aspects
            if (data.synastry?.aspects) {
                aspects.push(...data.synastry.aspects.map(a => ({...a, type: 'synastry'})));
            }
            
            // Composite aspects
            if (data.composite?.chart?.aspects) {
                aspects.push(...data.composite.chart.aspects.map(a => ({...a, type: 'composite'})));
            }
            
            // Sort by orb (tighter aspects first)
            return aspects.sort((a, b) => {
                const orbA = Math.abs(a.orb || a.orbit || a.diff || 10);
                const orbB = Math.abs(b.orb || b.orbit || b.diff || 10);
                return orbA - orbB;
            });
        }
        
        function generatePolarityFromAspect(aspect, index) {
            const p1 = aspect.p1_name || aspect.planet_a || aspect.transit_body || 'Unknown';
            const p2 = aspect.p2_name || aspect.planet_b || aspect.natal_target || 'Unknown';
            const aspectName = aspect.aspect || aspect.aspect_name || aspect.name || 'conjunction';
            const orb = Math.abs(aspect.orb || aspect.orbit || aspect.diff || 0);
            
            // Generate polarity titles based on planets and aspect
            const title = generatePolarityTitle(p1, p2, aspectName);
            
            // Generate FIELD content (felt tone)
            const field = generateFieldContent(p1, p2, aspectName);
            
            // Generate MAP content (geometry)
            const map = `${p1} ${aspectName} ${p2} (${orb.toFixed(1)}° orb)`;
            
            // Generate VOICE content (user-facing description)
            const voice = generateVoiceContent(p1, p2, aspectName);
            
            return { title, field, map, voice };
        }
        
        function generatePolarityCardFromAspect(aspect) {
            const p1 = aspect.p1_name || aspect.planet_a || aspect.transit_body || 'Unknown';
            const p2 = aspect.p2_name || aspect.planet_b || aspect.natal_target || 'Unknown';
            const aspectName = aspect.aspect || aspect.aspect_name || aspect.name || 'conjunction';
            const orb = Math.abs(aspect.orb || aspect.orbit || aspect.diff || 0);
            
            // Generate polarity names
            const nameA = generatePolarityName(p1, aspectName, 'A');
            const nameB = generatePolarityName(p2, aspectName, 'B');
            
            // Generate content
            const field = generateCardFieldContent(p1, p2, aspectName);
            const map = `${p1} ${aspectName} ${p2} (${orb.toFixed(1)}° orb)`;
            const voice = generateCardVoiceContent(p1, p2, aspectName);
            
            return { nameA, nameB, field, map, voice };
        }
        
        function generateRelationalPolarityFromAspect(aspect, personAName, personBName) {
            const p1 = aspect.p1_name || aspect.planet_a || 'Unknown';
            const p2 = aspect.p2_name || aspect.planet_b || 'Unknown';
            const aspectName = aspect.aspect || aspect.aspect_name || 'conjunction';
            const orb = Math.abs(aspect.orb || aspect.orbit || 0);
            
            // Determine which person owns which planet
            const p1Owner = aspect.p1_owner || personAName;
            const p2Owner = aspect.p2_owner || personBName;
            
            const title = `${p1Owner}'s ${p1} ${aspectName} ${p2Owner}'s ${p2}`;
            const field = generateRelationalFieldContent(p1, p2, aspectName, p1Owner, p2Owner);
            const map = `${p1Owner} ${p1} ${aspectName} ${p2Owner} ${p2} (${orb.toFixed(1)}° orb)`;
            const voice = generateRelationalVoiceContent(p1, p2, aspectName, p1Owner, p2Owner);
            
            return { title, field, map, voice };
        }
        
        function generateRelationalPolarityCard(aspect, personAName, personBName) {
            const p1 = aspect.p1_name || aspect.planet_a || 'Unknown';
            const p2 = aspect.p2_name || aspect.planet_b || 'Unknown';
            const aspectName = aspect.aspect || aspect.aspect_name || 'conjunction';
            const orb = Math.abs(aspect.orb || aspect.orbit || 0);
            
            const p1Owner = aspect.p1_owner || personAName;
            const p2Owner = aspect.p2_owner || personBName;
            
            const nameA = `${p1Owner}'s ${p1}`;
            const nameB = `${p2Owner}'s ${p2}`;
            const field = generateRelationalCardFieldContent(p1, p2, aspectName, p1Owner, p2Owner);
            const map = `${p1Owner} ${p1} ${aspectName} ${p2Owner} ${p2} (${orb.toFixed(1)}° orb)`;
            const voice = generateRelationalCardVoiceContent(p1, p2, aspectName, p1Owner, p2Owner);
            
            return { nameA, nameB, field, map, voice };
        }
        
        function generateMirrorVoiceForPerson(personData, personDetails) {
            // Generate overall synthesis for individual
            const field = "Overall structural climate synthesizing multiple planetary tensions and supports";
            const map = "Connecting aspects forming the core personality framework";
            const voice = `${personDetails.name}'s chart reveals structural tension patterns that serve as growth edges rather than limitations. The geometry suggests areas where dialogue between opposing forces creates movement and development. This tension is structural, not a flaw.`;
            
            return { field, map, voice };
        }
        
        function generateRelationalMirrorVoice(data, personA, personB) {
            // Generate relational synthesis
            const field = "Combined relational climate showing where two systems intersect and create dynamic tension";
            const map = "Cross-chart aspects forming the relational geometry between both individuals";
            const voice = `The relationship between ${personA.name} and ${personB.name} creates a structural field where individual patterns interact. The tension points revealed here are not problems to solve but dynamics to navigate consciously. Growth often emerges from the dialogue between different approaches to the same universal themes.`;
            
            return { field, map, voice };
        }

        // Content generation helper functions
        
        function generatePolarityTitle(p1, p2, aspect) {
            const planetMeanings = {
                'Sun': 'Identity', 'Moon': 'Feeling', 'Mercury': 'Communication',
                'Venus': 'Values', 'Mars': 'Action', 'Jupiter': 'Expansion',
                'Saturn': 'Structure', 'Uranus': 'Innovation', 'Neptune': 'Intuition',
                'Pluto': 'Transformation'
            };
            
            const p1Meaning = planetMeanings[p1] || p1;
            const p2Meaning = planetMeanings[p2] || p2;
            
            return `${p1Meaning} / ${p2Meaning} Dynamic`;
        }
        
        function generateFieldContent(p1, p2, aspect) {
            // Generate felt sense descriptions based on planetary combinations
            const fieldTemplates = {
                'conjunction': 'Merging energies creating unified but potentially overwhelming sensation',
                'opposition': 'Pull between two directions creating productive tension',
                'square': 'Friction generating movement and growth through challenge',
                'trine': 'Natural flow creating ease and harmony',
                'sextile': 'Opportunity for integration through conscious effort'
            };
            
            return fieldTemplates[aspect] || 'Dynamic interaction between planetary energies';
        }
        
        function generateVoiceContent(p1, p2, aspect) {
            // Generate user-facing descriptions
            const aspectMeanings = {
                'conjunction': 'These energies blend together, sometimes harmoniously, sometimes creating intensity that needs conscious direction.',
                'opposition': 'These energies pull in different directions, creating awareness through contrast and the need to find balance.',
                'square': 'These energies create friction that generates movement - challenge that promotes growth when engaged consciously.',
                'trine': 'These energies flow naturally together, creating ease and supporting natural expression.',
                'sextile': 'These energies offer opportunities for integration through conscious engagement and effort.'
            };
            
            return aspectMeanings[aspect] || 'These planetary energies interact in ways that create opportunities for conscious awareness and growth.';
        }
        
        function generatePolarityName(planet, aspect, side) {
            const polarities = {
                'Sun': { A: 'Core Self', B: 'Expressed Identity' },
                'Moon': { A: 'Inner Feeling', B: 'Emotional Response' },
                'Mercury': { A: 'Mental Process', B: 'Communication Style' },
                'Venus': { A: 'Personal Values', B: 'Relational Expression' },
                'Mars': { A: 'Inner Drive', B: 'Outward Action' }
            };
            
            return polarities[planet]?.[side] || `${planet} ${side}`;
        }
        
        function generateCardFieldContent(p1, p2, aspect) {
            return `Felt experience of ${p1}-${p2} tension manifesting as bodily sensation or emotional climate`;
        }
        
        function generateCardVoiceContent(p1, p2, aspect) {
            return `How this ${p1}-${p2} dynamic usually expresses in daily life, and what helps balance or redirect the energy when it becomes overwhelming.`;
        }
        
        function generateRelationalFieldContent(p1, p2, aspect, owner1, owner2) {
            return `Interpersonal felt sense when ${owner1}'s ${p1} meets ${owner2}'s ${p2} energy`;
        }
        
        function generateRelationalVoiceContent(p1, p2, aspect, owner1, owner2) {
            return `How ${owner1}'s ${p1} and ${owner2}'s ${p2} interact in relationship, creating both connection points and areas where different approaches meet.`;
        }
        
        function generateRelationalCardFieldContent(p1, p2, aspect, owner1, owner2) {
            return `Relational climate created when these two planetary energies interact between ${owner1} and ${owner2}`;
        }
        
        function generateRelationalCardVoiceContent(p1, p2, aspect, owner1, owner2) {
            return `How this cross-chart connection typically plays out in the relationship, showing both the gifts and challenges of this particular energetic meeting point.`;
        }
        
        // Typological Profile Generation Functions
        
        function generateTypologicalProfile(personData, personDetails) {
            // Extract key chart data
            const chartData = extractChartDataForTypology(personData);
            
            // Analyze dominant orientation (Sun, Mercury, Ascendant)
            const dominant = analyzeDominantOrientation(chartData);
            
            // Analyze secondary orientation (Moon + auxiliary)
            const secondary = analyzeSecondaryOrientation(chartData);
            
            // Analyze shadow/inferior orientation (Mars, Saturn, Neptune, outer planets)
            const shadow = analyzeShadowOrientation(chartData);
            
            // Generate constitutional climate summary
            const climate = generateConstitutionalClimate(chartData);
            
            // Generate Raven translation (VOICE)
            const ravenTranslation = generateRavenTranslation(dominant, secondary, shadow, climate, personDetails);
            
            return {
                dominant,
                secondary,
                shadow,
                climate,
                ravenTranslation
            };
        }
        
        function extractChartDataForTypology(personData) {
            // The chart data structure from API: personData.chart contains the planetary data
            // and personData.aspects contains the aspects array
            const chart = personData?.chart || {};
            const aspects = personData?.aspects || [];
            
            return {
                sun: chart.sun || {},
                moon: chart.moon || {},
                mercury: chart.mercury || {},
                venus: chart.venus || {},
                mars: chart.mars || {},
                jupiter: chart.jupiter || {},
                saturn: chart.saturn || {},
                uranus: chart.uranus || {},
                neptune: chart.neptune || {},
                pluto: chart.pluto || {},
                ascendant: chart.asc || chart.ascendant || {},
                midheaven: chart.mc || chart.midheaven || {},
                aspects: aspects
            };
        }
        
        function analyzeDominantOrientation(chartData) {
            // Focus on Sun, Mercury, and Ascendant for dominant function
            const sun = chartData.sun;
            const mercury = chartData.mercury;
            const ascendant = chartData.ascendant;

            // Build raw placements description from actual data
            const rawPlacements = [
                sun ? `Sun in ${sun.sign || 'Unknown'} (${sun.house || 'Unknown'})` : 'Sun placement unavailable',
                mercury ? `Mercury in ${mercury.sign || 'Unknown'} (${mercury.house || 'Unknown'})${mercury.retrograde ? ' ℞' : ''}` : 'Mercury placement unavailable',
                ascendant ? `Ascendant in ${ascendant.sign || 'Unknown'}` : 'Ascendant unavailable'
            ].filter(Boolean).join(', ');

            // Determine functional emphasis based on actual placements
            const functionalEmphasis = determineFunctionalEmphasis(sun, mercury, ascendant);

            // Determine orientation (Introverted/Extraverted) based on actual data
            const orientation = determineOrientation(sun, mercury, ascendant);

            return {
                rawPlacements,
                functionalEmphasis,
                orientation
            };
        }
        
        function analyzeSecondaryOrientation(chartData) {
            const moon = chartData.moon;

            // Find auxiliary aspects to Moon from actual data
            const moonAspects = chartData.aspects ? chartData.aspects.filter(aspect =>
                aspect.p1_name === 'Moon' || aspect.p2_name === 'Moon'
            ).slice(0, 3) : [];

            const aspectsText = moonAspects.length > 0
                ? moonAspects.map(a => `${a.p1_name || ''} ${a.aspect || ''} ${a.p2_name || ''}`).join(', ')
                : 'No major aspects detected';

            const rawPlacements = moon
                ? `Moon in ${moon.sign || 'Unknown'} (${moon.house || 'Unknown'}), aspects: ${aspectsText}`
                : 'Moon placement unavailable';

            const functionalEmphasis = moon ? determineSecondaryFunction(moon) : 'Unknown';
            const orientationCue = moon ? determineSecondaryOrientation(moon) : 'Unknown';

            return {
                rawPlacements,
                functionalEmphasis,
                orientationCue
            };
        }
        
        function analyzeShadowOrientation(chartData) {
            // Focus on Mars, Saturn, Neptune, and outer planets for shadow/inferior
            const mars = chartData.mars;
            const saturn = chartData.saturn;
            const neptune = chartData.neptune;
            const uranus = chartData.uranus;
            const pluto = chartData.pluto;

            // Find challenging aspects from actual data
            const challengingAspects = chartData.aspects ? chartData.aspects.filter(aspect =>
                (aspect.aspect === 'square' || aspect.aspect === 'opposition' || aspect.aspect === 'quincunx') &&
                (aspect.p1_name === 'Mars' || aspect.p1_name === 'Saturn' || aspect.p1_name === 'Neptune' ||
                 aspect.p2_name === 'Mars' || aspect.p2_name === 'Saturn' || aspect.p2_name === 'Neptune')
            ).slice(0, 4) : [];

            const rawPlacements = [
                mars ? `Mars in ${mars.sign || 'Unknown'} (${mars.house || 'Unknown'})` : 'Mars placement unavailable',
                saturn ? `Saturn in ${saturn.sign || 'Unknown'} (${saturn.house || 'Unknown'})` : 'Saturn placement unavailable',
                neptune ? `Neptune in ${neptune.sign || 'Unknown'} (${neptune.house || 'Unknown'})` : 'Neptune placement unavailable'
            ].filter(Boolean).join(', ') +
            (challengingAspects.length > 0 ? '; Challenging aspects: ' +
                challengingAspects.map(a => `${a.p1_name} ${a.aspect} ${a.p2_name}`).join(', ') : '');

            const inferiorFunctions = determineInferiorFunctions(mars, saturn, neptune);
            const pressureDescription = generatePressureDescription(challengingAspects, mars, saturn, neptune);

            return {
                rawPlacements,
                inferiorFunctions,
                pressureDescription
            };
        }
        
        function generateConstitutionalClimate(chartData) {
            // Create shorthand geometric summary
            const mathBrainNotes = createMathBrainShorthand(chartData);
            
            // Generate climate tags
            const climateTags = generateClimateTags(chartData);
            
            return {
                mathBrainNotes,
                climateTags
            };
        }
        
        function generateRavenTranslation(dominant, secondary, shadow, climate, personDetails) {
            return {
                dominant: translateDominantOrientation(dominant),
                secondary: translateSecondaryOrientation(secondary),
                shadow: translateShadowOrientation(shadow),
                climate: translateConstitutionalClimate(climate, personDetails.name)
            };
        }
        
        // Helper functions for typological analysis
        
        function determineFunctionalEmphasis(sun, mercury, ascendant) {
            // Map signs to psychological functions - using API's abbreviated sign names
            const functionMap = {
                // Fire signs -> Intuition
                'Ari': 'Intuition', 'Leo': 'Intuition', 'Sag': 'Intuition',
                // Earth signs -> Sensation  
                'Tau': 'Sensation', 'Vir': 'Sensation', 'Cap': 'Sensation',
                // Air signs -> Thinking
                'Gem': 'Thinking', 'Lib': 'Thinking', 'Aqu': 'Thinking',
                // Water signs -> Feeling
                'Can': 'Feeling', 'Sco': 'Feeling', 'Pis': 'Feeling'
            };
            
            const sunFunction = functionMap[sun.sign] || 'Unknown';
            const mercuryFunction = functionMap[mercury.sign] || 'Unknown';
            const ascFunction = functionMap[ascendant.sign] || 'Unknown';
            
            // Primary emphasis based on Sun, modified by Mercury and Ascendant
            return `${sunFunction} (Sun), supported by ${mercuryFunction} (Mercury) and ${ascFunction} (Ascendant)`;
        }
        
        function determineOrientation(sun, mercury, ascendant) {
            // Convert house names to numbers: "First_House" -> 1, "Second_House" -> 2, etc.
            const houseNameToNumber = {
                'First_House': 1, 'Second_House': 2, 'Third_House': 3, 'Fourth_House': 4,
                'Fifth_House': 5, 'Sixth_House': 6, 'Seventh_House': 7, 'Eighth_House': 8,
                'Ninth_House': 9, 'Tenth_House': 10, 'Eleventh_House': 11, 'Twelfth_House': 12
            };
            
            const sunHouse = houseNameToNumber[sun.house] || parseInt(sun.house) || 1;
            const mercuryHouse = houseNameToNumber[mercury.house] || parseInt(mercury.house) || 1;
            const ascHouse = 1; // Ascendant is always 1st house
            
            // Simple heuristic: even houses = introverted, odd houses = extraverted
            const introvertedCount = [sunHouse, mercuryHouse, ascHouse].filter(h => h % 2 === 0).length;
            
            return introvertedCount >= 2 ? 'Introverted' : 'Extraverted';
        }
        
        function determineSecondaryFunction(moon) {
            const functionMap = {
                'Ari': 'Intuition', 'Leo': 'Intuition', 'Sag': 'Intuition',
                'Tau': 'Sensation', 'Vir': 'Sensation', 'Cap': 'Sensation',
                'Gem': 'Thinking', 'Lib': 'Thinking', 'Aqu': 'Thinking',
                'Can': 'Feeling', 'Sco': 'Feeling', 'Pis': 'Feeling'
            };
            
            return functionMap[moon.sign] || 'Unknown';
        }
        
        function determineSecondaryOrientation(moon) {
            const houseNameToNumber = {
                'First_House': 1, 'Second_House': 2, 'Third_House': 3, 'Fourth_House': 4,
                'Fifth_House': 5, 'Sixth_House': 6, 'Seventh_House': 7, 'Eighth_House': 8,
                'Ninth_House': 9, 'Tenth_House': 10, 'Eleventh_House': 11, 'Twelfth_House': 12
            };
            
            const moonHouse = houseNameToNumber[moon.house] || parseInt(moon.house) || 1;
            return moonHouse <= 6 ? 'inner/emotional' : 'outer/social';
        }
        
        function determineInferiorFunctions(mars, saturn, neptune) {
            // Inferior function is typically opposite to dominant
            const inferiorMap = {
                'Thinking': 'Feeling', 'Feeling': 'Thinking',
                'Sensation': 'Intuition', 'Intuition': 'Sensation'
            };
            
            return 'Usually opposite of dominant function (determined by pressure aspects)';
        }
        
        function generatePressureDescription(challengingAspects, mars, saturn, neptune) {
            if (challengingAspects.length === 0) {
                return 'Minimal pressure aspects detected';
            }
            
            const pressureTypes = [];
            challengingAspects.forEach(aspect => {
                if (aspect.p1_name === 'Saturn' || aspect.p2_name === 'Saturn') {
                    pressureTypes.push('constraint');
                }
                if (aspect.p1_name === 'Mars' || aspect.p2_name === 'Mars') {
                    pressureTypes.push('volatility');
                }
                if (aspect.p1_name === 'Neptune' || aspect.p2_name === 'Neptune') {
                    pressureTypes.push('dissolution');
                }
            });
            
            return pressureTypes.length > 0 ? pressureTypes.join(', ') : 'mixed pressure patterns';
        }
        
        function createMathBrainShorthand(chartData) {
            const sun = chartData.sun;
            const moon = chartData.moon;
            const mercury = chartData.mercury;
            
            return `${sun.sign || '?'} Sun (${sun.house || '?'}) + ${moon.sign || '?'} Moon (${moon.house || '?'}) + ${mercury.sign || '?'} Mercury (${mercury.house || '?'})`;
        }
        
        function generateClimateTags(chartData) {
            const tags = [];
            
            // Analyze elemental balance
            const elements = ['fire', 'earth', 'air', 'water'];
            const elementCounts = {};
            
            [chartData.sun, chartData.moon, chartData.mercury].forEach(planet => {
                const element = getElementForSign(planet.sign);
                elementCounts[element] = (elementCounts[element] || 0) + 1;
            });
            
            // Dominant element influences climate
            const dominantElement = Object.keys(elementCounts).reduce((a, b) => 
                elementCounts[a] > elementCounts[b] ? a : b
            );
            
            const climateMap = {
                'fire': 'dynamic',
                'earth': 'structured', 
                'air': 'fluid',
                'water': 'tidal'
            };
            
            tags.push(climateMap[dominantElement] || 'mixed');
            
            // Add complexity tags based on aspects
            if (chartData.aspects.length > 15) tags.push('complex');
            if (chartData.aspects.filter(a => a.aspect === 'opposition').length >= 2) tags.push('tension-rich');
            
            return tags.join(', ');
        }
        
        function getElementForSign(sign) {
            const elementMap = {
                'Aries': 'fire', 'Leo': 'fire', 'Sagittarius': 'fire',
                'Taurus': 'earth', 'Virgo': 'earth', 'Capricorn': 'earth',
                'Gemini': 'air', 'Libra': 'air', 'Aquarius': 'air',
                'Cancer': 'water', 'Scorpio': 'water', 'Pisces': 'water'
            };
            return elementMap[sign] || 'unknown';
        }
        
        function translateDominantOrientation(dominant) {
            return `Primary lens operates through ${dominant.functionalEmphasis.split(' ')[0].toLowerCase()} with ${dominant.orientation.toLowerCase()} attitude, creating the main perceptual climate.`;
        }
        
        function translateSecondaryOrientation(secondary) {
            return `Supporting current flows through ${secondary.functionalEmphasis.toLowerCase()} with ${secondary.orientationCue} emphasis, providing auxiliary navigation.`;
        }
        
        function translateShadowOrientation(shadow) {
            return `Pressure field involves ${shadow.pressureDescription}, activating inferior function dynamics that require conscious integration.`;
        }
        
        function translateConstitutionalClimate(climate, name) {
            return `${name}'s constitutional weather: ${climate.climateTags} — like ${generateWeatherMetaphor(climate.climateTags)}.`;
        }
        
        function generateWeatherMetaphor(climateTags) {
            const metaphors = {
                'structured': 'a well-built house with reliable heating',
                'dynamic': 'a crackling fire that needs tending',
                'fluid': 'changeable winds through an open landscape', 
                'tidal': 'rhythmic ocean currents with deep undercurrents',
                'complex': 'layered weather systems with multiple fronts',
                'tension-rich': 'atmospheric pressure creating dynamic weather patterns'
            };
            
            const primaryTag = climateTags.split(',')[0].trim();
            return metaphors[primaryTag] || 'unique weather patterns that require individual attention';
        }

        function generateMarkdownReport(data, options = {}) {
            // MATH BRAIN COMPLIANCE (PROTOCOL LAYER 1: GEOMETRY ONLY):
            // - Output pure astrological geometry with provenance tracking
            // - Include RAVEN_NUDGE for downstream Poetic Brain (Raven Calder) processing
            // - Layer separation: GEOMETRY ONLY → Clear Mirror → Poetic Codex
            // - NO narrative, interpretation, or advice generation here
            // - Protocol compliance: mirror_ready flags, rejections taxonomy, scaling confidence
            
            const {
                includeExecutiveSummary = false,
                includeJsonAppendix = false,
                includeProvenance = false
            } = options;
            
            const formData = collectFormData();
            const currentDate = new Date().toISOString().split('T')[0];
            // Prefer authoritative server-returned details if present (may include normalization/zodiac defaults)
            const personA = (data.person_a && data.person_a.details) ? data.person_a.details : formData.personA;
            const personB = (data.person_b && data.person_b.details) ? data.person_b.details : formData.personB;
            const mode = formData.context.mode;
            const isSky = mode === 'sky_transits';
            
            let md = '';
            
            // Executive Summary (optional, at top)
            if (includeExecutiveSummary) {
                md += generateExecutiveSummary(data, { includeHealthLine: true, includeProvenance: true });
                md += '\n\n---\n\n';
            }
            
            // Protocol Layer Headers
            md += `# Woven Map System Report\n\n`;
            md += `## Protocol Layer 1: Geometry Only\n\n`;
            md += `**Generated**: ${currentDate}\n`;
            md += `**Context Mode**: ${mode.replace(/_/g, ' ').toUpperCase()}\n`;
            md += `**Schema**: ${data.schema || 'WM-Chart-1.0'}\n`;
            md += `**Math Brain Version**: ${(data.provenance?.math_brain_version)||'0.x'}\n`;
            md += `**Ephemeris Source**: ${data.provenance?.ephemeris_source || 'AstrologerAPI-v4'}\n`;
            md += `**Mirror Status**: ${data.mirror_ready ? 'Ready for downstream processing' : 'Incomplete'}\n`;
            md += `**Contract**: ${data.contract || 'clear-mirror/1.2'}\n\n`;
            
            // Critical Protocol Reminder
            md += `> **Math Brain Role**: Symbolic scaffolding engine providing pure geometry.\n`;
            md += `> **Boundary**: No narrative, prediction, or interpretation. Mirror, not mandate.\n`;
            md += `> **Next Layer**: Clear Mirror translation via Poetic Brain (Raven Calder).\n\n`;
            
            // RAVEN_NUDGE Section (Protocol Requirement)
            md += `### RAVEN_NUDGE (Downstream Processing Guidance)\n\n`;
            md += `**Protocol Flow**: FIELD → MAP → VOICE translation required\n`;
            md += `**Sources Required**: Poetic Codex • FIELD_MAP_VOICE rules • Hook Stack • Seismograph Protocol\n`;
            md += `**Geometry Flags**: `;
            
            // Add specific flags based on data analysis
            const geometryFlags = [];
            let nodeTypes = new Set();
            let retrogradeCount = 0;
            let scaleConfidenceIssues = false;
            let hasDispersedInfluence = false;
            
            // Analyze the data for specific flags
            if (data.person_a?.chart?.transitsByDate) {
                const firstDay = Object.values(data.person_a.chart.transitsByDate)[0];
                if (firstDay?.retrograde_aspects?.length >= 2) {
                    geometryFlags.push('retrograde recursion');
                    retrogradeCount = firstDay.retrograde_aspects.length;
                }
                if (firstDay?.seismograph?.scaleConfidence < 0.7) {
                    geometryFlags.push('low scale confidence');
                    scaleConfidenceIssues = true;
                }
                if (firstDay?.hooks?.length === 0) {
                    geometryFlags.push('dispersed influence');
                    hasDispersedInfluence = true;
                }
                
                // Check for node types in hooks and aspects
                const allAspects = [...(firstDay.hooks || []), ...(firstDay.filtered_aspects || [])];
                allAspects.forEach(a => {
                    if (a.p1_name?.includes('True_Node') || a.p2_name?.includes('True_Node')) nodeTypes.add('True Node');
                    if (a.p1_name?.includes('Mean_Node') || a.p2_name?.includes('Mean_Node')) nodeTypes.add('Mean Node');
                });
            }
            
            // Check synastry/composite for additional patterns
            if (data.synastry?.aspects) {
                const tightAspects = data.synastry.aspects.filter(a => Math.abs(a.orbit) <= 1);
                if (tightAspects.length >= 2) geometryFlags.push('echo loop formation');
            }
            
            md += geometryFlags.length ? geometryFlags.join(' • ') : 'standard geometry';
            md += `\n`;
            
            md += `**Node Distinction**: `;
            if (nodeTypes.size > 0) {
                md += Array.from(nodeTypes).join(' and ') + ' present';
                if (nodeTypes.has('True Node') && nodeTypes.has('Mean Node')) {
                    md += ' — prefer True Node precision for tight orbs';
                }
            } else {
                md += 'Standard node handling (True Node preferred)';
            }
            md += `\n`;
            
            if (!isSky && personA && personA.timezone) {
                md += `**Timezone Check**: Target America/Chicago (Central) — Current: ${personA.timezone} ${personA.timezone === 'America/Chicago' ? '✓' : '⚠ Normalize required'}\n`;
            } else if (isSky) {
                md += `**Timezone Baseline**: America/Chicago (Central) — used for day-bucketing hints\n`;
            }
            md += `**Falsifiability**: All outputs must pass "Does this land?" test\n`;
            md += `**Agency Reinforcement**: Every output must preserve client autonomy\n`;
            
            // Add specific processing alerts
            if (retrogradeCount >= 2 || scaleConfidenceIssues || hasDispersedInfluence || nodeTypes.size > 1) {
                md += `**Processing Alerts**:\n`;
                if (retrogradeCount >= 2) md += `- ${retrogradeCount} retrograde aspects detected → internal revision themes likely\n`;
                if (scaleConfidenceIssues) md += `- Scale confidence below threshold → caution framing advised\n`;
                if (hasDispersedInfluence) md += `- No tight hooks → background stability or dispersed pattern\n`;
                if (nodeTypes.size > 1) md += `- Multiple node types present → ensure precision consistency\n`;
            }
            md += `\n`;
            
            // === RAVEN CALDER POETIC BRAIN INSTRUCTIONS ===
            md += `### INSTRUCTIONS FOR RAVEN CALDER POETIC BRAIN\n\n`;
            
            if (isSky) {
                md += `**WEATHER READING PROTOCOL:**\n`;
                md += `- **Subject**: Planetary weather only (no natal anchoring)\n`;
                md += `- **Mirror Focus**: Macro currents (magnitude/valence/volatility), hooks sampled without houses/angles\n`;
                md += `- **Scope**: Symbolic climate; use personal charts separately if attribution is needed\n`;
            } else if (personB && formData.context.relationship_type) {
                // Two-person relational reading instructions
                md += `**RELATIONAL READING PROTOCOL:**\n`;
                md += `- **Subject Clarity**: Always identify who is who (${personA.name} vs ${personB.name})\n`;
                md += `- **Bidirectional Analysis**: Address dynamics from both perspectives\n`;
                md += `- **Relationship Status**: ${formData.context.is_ex_relationship ? 'LATENT (ex-relationship - no active exchange)' : 'ACTIVE (ongoing relationship)'}\n`;
                
                if (formData.context.contact_channel) {
                    md += `- **Contact Channel**: ${formData.context.contact_channel === 'live' ? 'LIVE (regular contact/interaction)' : 'LATENT (minimal/dormant contact)'}\n`;
                }
                
                md += `- **Intimacy Context**: ${formData.context.intimacy_tier || 'unspecified'}\n`;
                md += `- **Mirror Focus**: Relational dynamics, shared field currents, echo patterns\n`;
                
                if (data.synastry?.aspects?.length > 0) {
                    md += `- **Synastry Available**: ${data.synastry.aspects.length} aspects - analyze interaction patterns\n`;
                }
                if (data.composite?.chart) {
                    md += `- **Composite Available**: Merged entity dynamics present\n`;
                }
                
                md += `\n**Required Elements in Response:**\n`;
                md += `1. Individual seismograph interpretation for both ${personA.name} AND ${personB.name}\n`;
                md += `2. Relational field analysis (how their patterns interact)\n`;
                md += `3. Clear attribution: "For ${personA.name}..." vs "For ${personB.name}..."\n`;
                md += `4. Bidirectional dynamics: How A affects B AND how B affects A\n`;
                
            } else if (personB) {
                // Two-person but no relationship context (comparison mode)
                md += `**COMPARATIVE READING PROTOCOL:**\n`;
                md += `- **Subject Clarity**: Always identify who is who (${personA.name} vs ${personB.name})\n`;
                md += `- **Individual Focus**: Analyze each person's geometry separately\n`;
                md += `- **No Relational Assumption**: Treat as independent charts unless synastry present\n`;
                md += `- **Mirror Focus**: Individual seismographs, separate hook stacks\n`;
                
            } else {
                // Single person reading instructions
                md += `**SOLO READING PROTOCOL:**\n`;
                md += `- **Subject**: ${personA.name} (single-person analysis)\n`;
                md += `- **Mirror Focus**: Individual seismograph, personal hook stack, internal currents\n`;
                md += `- **Temporal Context**: ${mode.includes('transit') ? 'Transits to natal geometry' : 'Natal geometry only'}\n`;
                
                if (mode.includes('transit') && formData.transitParams?.startDate) {
                    const daySpan = formData.transitParams.endDate ? 
                        Math.ceil((new Date(formData.transitParams.endDate) - new Date(formData.transitParams.startDate)) / (1000 * 60 * 60 * 24)) : 1;
                    
                    if (daySpan === 1) {
                        md += `- **Single Day Focus**: Deep-dive into specific day's current patterns\n`;
                        md += `- **Barometer Emphasis**: Detailed single-day barometric reading\n`;
                    } else {
                        md += `- **Time Range**: ${daySpan}-day span - analyze macro patterns and trends\n`;
                        md += `- **Seismograph Emphasis**: Pattern detection across time range\n`;
                    }
                }
            }
            
            md += `\n**Universal Requirements:**\n`;
            md += `- **Falsifiability**: Every statement must be testable against lived experience\n`;
            md += `- **Agency Preservation**: No deterministic claims - mirror, not mandate\n`;
            md += `- **Geometry First**: Build from math brain data, add poetic voice layer\n`;
            md += `- **Landing Test**: Does this resonate with actual lived experience?\n`;
            
            if (geometryFlags.includes('low scale confidence') || scaleConfidenceIssues) {
                md += `- **Caution Flag**: Scale confidence issues detected - frame interpretations tentatively\n`;
            }
            
            if (hasDispersedInfluence) {
                md += `- **Pattern Note**: No tight hooks detected - background stability or dispersed influence\n`;
            }
            
            md += `\n---\n\n`;
            
            // Range and Context
            if (formData.transitParams?.startDate && formData.transitParams?.endDate) {
                const stepMap = { '1d':'Daily', 'daily':'Daily', '7d':'Weekly', 'weekly':'Weekly', '1m':'Monthly', '1mo':'Monthly', 'monthly':'Monthly' };
                const rawStep = formData.transitParams.step || 'daily';
                const stepHuman = stepMap[rawStep] || rawStep;
                const startDate = new Date(formData.transitParams.startDate);
                const endDate = new Date(formData.transitParams.endDate);
                const daySpan = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                
                md += `**Temporal Scope**: ${formData.transitParams.startDate} → ${formData.transitParams.endDate}\n`;
                md += `**Step Resolution**: ${stepHuman} (${daySpan} day span)\n`;
                const stepKey = (rawStep === '7d' || rawStep === 'weekly') ? 'weekly' : ((rawStep === '1m' || rawStep === '1mo' || rawStep === 'monthly') ? 'monthly' : 'daily');
                const limit = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]?.max) || 45;
                md += `**Protocol Check**: ${daySpan <= limit ? '✓ Within safety limit' : '⚠ Exceeds recommended span'}\n\n`;
            }

            if (!isSky && personA) {
                // Subject Details (FIELD Layer)
                md += `## Subject Details — Reveal the Weave\n\n`;
                md += `### Primary Subject: ${personA.name}\n\n`;
                md += `- **Birth Date**: ${personA.year}-${String(personA.month).padStart(2, '0')}-${String(personA.day).padStart(2, '0')}\n`;
                md += `- **Birth Time**: ${String(personA.hour).padStart(2, '0')}:${String(personA.minute).padStart(2, '0')}\n`;
                md += `- **Location**: ${personA.city}, ${personA.nation}\n`;
                md += `- **Coordinates**: ${personA.latitude}, ${personA.longitude}\n`;
                md += `- **Timezone**: ${personA.timezone}\n`;
                md += `- **Zodiac Type**: ${personA.zodiac_type}\n\n`;
                md += `**TZ Check (Person A)**: expected \`America/Chicago\` (Central).\n`;
                md += `**Observed**: \`${personA.timezone}\` → ${personA.timezone === 'America/Chicago' ? 'OK' : '⚠ Normalize before mirroring'}\n\n`;
            }

            // Secondary Subject Details (if present)
                        if (personB) {
                md += `### Secondary Subject: ${personB.name}\n\n`;
                md += `- **Birth Date**: ${personB.year}-${String(personB.month).padStart(2, '0')}-${String(personB.day).padStart(2, '0')}\n`;
                md += `- **Birth Time**: ${String(personB.hour).padStart(2, '0')}:${String(personB.minute).padStart(2, '0')}\n`;
                md += `- **Location**: ${personB.city}, ${personB.nation}\n`;
                md += `- **Coordinates**: ${personB.latitude}, ${personB.longitude}\n`;
                md += `- **Timezone**: ${personB.timezone}\n`;
                md += `- **Zodiac Type**: ${personB.zodiac_type}\n\n`;

                                const relRole = formData.context.relationship_role;
                                const relNotes = formData.context.relationship_notes;
                                if (relRole || relNotes) {
                                    md += `- **Relationship Role**: ${relRole || 'unspecified'}${relNotes? ` — ${relNotes}`:''}\n\n`;
                                }

                // Relationship Context (if present)
                if (formData.context.relationship_type) {
                    md += `## Relationship Context\n\n`;
                    md += `- **Type**: ${formData.context.relationship_type}`;
                    if (formData.context.is_ex_relationship) {
                        md += ` (ex - no longer active)`;
                    }
                    md += `\n`;
                    if (formData.context.intimacy_tier) {
                        md += `- **Intimacy Tier**: ${formData.context.intimacy_tier}\n`;
                    }
                    if (formData.context.contact_channel) {
                        md += `- **Contact Channel**: ${formData.context.contact_channel === 'live' ? '🟢 Live (active exchange)' : '⚫ Latent (dormant channel)'}\n`;
                    }
                    md += `\n`;
                }
            }

            // Relocation (if present)
            if (data.relocation_a && data.relocation_a.status === 'OK') {
                md += `## Relocation Overlay\n\n`;
                md += `- **Location**: ${formData.relocation?.city || 'Unknown'}\n`;
                md += `- **Coordinates**: ${formData.relocation?.latitude}, ${formData.relocation?.longitude}\n`;
                
                if (data.relocation_b && data.relocation_b.status === 'OK') {
                    md += `- **Scope**: Both Person A and Person B relocated\n`;
                } else if (formData.relocation?.excludePersonB) {
                    md += `- **Scope**: Only Person A relocated (Person B excluded)\n`;
                } else {
                    md += `- **Scope**: Person A relocated\n`;
                }
                md += `\n`;
            }

            // Unified Geometry Skeleton (always present in Mirror output)
            md += `## Geometry — The Skeleton of the Land <a id="geometry-skeleton"></a>\n\n`;
            if (data.person_a?.chart && (data.person_a.chart.status === 'OK' || data.person_a.chart.sun)) {
                md += `### ${personA.name} Natal Angles & Planet Positions\n\n`;
                const chartA = data.person_a.chart.data || data.person_a.chart;
                md += renderNatalChartData(chartA, personA.name);
            }
            if (data.person_b?.chart && (data.person_b.chart.status === 'OK' || data.person_b.chart.sun)) {
                md += `### ${personB.name} Natal Angles & Planet Positions\n\n`;
                const chartB = data.person_b.chart.data || data.person_b.chart;
                md += renderNatalChartData(chartB, personB.name);
            }

            // Relocation Chart Summaries (if present)
            if (data.relocation_a?.status === 'OK') {
                md += `## ${personA.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_a.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            if (data.relocation_b?.status === 'OK') {
                md += `## ${personB.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_b.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Composite Chart Summary (if present)
            if (data.composite?.chart?.status === 'OK') {
                md += `## Composite Chart Summary\n\n`;
                const chart = data.composite.chart.data.subject;
                md += `- **Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Aspects Summary
            if (data.person_a?.chart?.aspects && data.person_a.chart.aspects.length > 0) {
                md += `## Person A Major Aspects\n\n`;
                data.person_a.chart.aspects.slice(0, 10).forEach(aspect => {
                    // Dual-read for orb field
                    const orb = (Number.isFinite(aspect.orb) ? aspect.orb :
                                 Number.isFinite(aspect.orbit) ? aspect.orbit :
                                 Number.isFinite(aspect.diff) ? aspect.diff : null);
                    const p1 = aspect.p1_name || aspect.planet_a || aspect.transit_body || '—';
                    const p2 = aspect.p2_name || aspect.planet_b || aspect.natal_target || '—';
                    const asp = aspect.aspect || aspect.aspect_name || aspect.name || '—';
                    md += `- **${p1}** ${asp} **${p2}** (${orb !== null ? orb.toFixed(1) : '—'}° orb)\n`;
                });
                md += `\n`;
            }

            if (data.synastry?.aspects && data.synastry.aspects.length > 0) {
                md += `## Relational Echo Field Analysis\n\n`;
                md += `### Bidirectional Aspect Inventory\n\n`;
                md += `> **Protocol**: Each aspect rendered from both A→B and B→A perspectives for narrative reflection generation\n`;
                md += `> **Echo Loop Detection**: Aspects within ±3° orb creating self-reinforcing dynamics\n`;
                md += `> **Attribution Rule**: PersonA vs PersonB explicit — no generic "they" or "both" until confirmed\n\n`;
                
                // Group aspects by orb ranges for Echo Loop analysis
                const tight = data.synastry.aspects.filter(a => Math.abs(a.orbit) <= 1);
                const echoRange = data.synastry.aspects.filter(a => Math.abs(a.orbit) > 1 && Math.abs(a.orbit) <= 3);
                const background = data.synastry.aspects.filter(a => Math.abs(a.orbit) > 3 && Math.abs(a.orbit) <= 6);
                
                if (tight.length > 0) {
                    md += `**Echo Loops (≤1° orb) — ${tight.length} aspects:**\n\n`;
                    tight.forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        const aspectCode = `EL-${String(index + 1).padStart(2, '0')}`;
                        md += `- **${aspectCode}**: ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                        md += `  - **Direction**: ${aspect.p1_name} (${initiator}) → ${aspect.p2_name} (${receiver})\n`;
                        md += `  - **Reciprocal**: ${aspect.p2_name} (${receiver}) ← ${aspect.p1_name} (${initiator})\n`;
                    });
                    md += `\n`;
                }
                
                if (echoRange.length > 0) {
                    md += `**Relational Echo Field (1-3° orb) — ${echoRange.length} aspects:**\n\n`;
                    echoRange.forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        const aspectCode = `REF-${String(index + 1).padStart(2, '0')}`;
                        md += `- **${aspectCode}**: ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                    });
                    md += `\n`;
                }
                
                if (background.length > 0) {
                    md += `**Background Geometry (3-6° orb) — ${background.length} aspects:**\n\n`;
                    background.slice(0, 10).forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        md += `- ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                    });
                    if (background.length > 10) md += `... (${background.length - 10} additional background aspects)\n`;
                    md += `\n`;
                }
                
                // REF Detection and Polarity Code Assignment
                if (tight.length >= 2 || (tight.length >= 1 && echoRange.length >= 1)) {
                    md += `**REF Macro Structure Detection**:\n`;
                    md += `- **Echo Loop Count**: ${tight.length}\n`;
                    md += `- **Echo Field Count**: ${echoRange.length}\n`;
                    md += `- **Convergence Threshold**: ${tight.length >= 2 ? 'Met' : 'Partial'}\n`;
                    
                    // Generate provisional polarity codes based on aspect types
                    const aspectTypes = [...tight, ...echoRange.slice(0, 2)].map(a => a.aspect.toLowerCase());
                    const hasHard = aspectTypes.some(a => ['square', 'opposition'].includes(a));
                    const hasSoft = aspectTypes.some(a => ['trine', 'sextile'].includes(a));
                    const hasConjunction = aspectTypes.some(a => a === 'conjunction');
                    
                    let polarityHint = '';
                    if (hasHard && hasConjunction) polarityHint = 'F21 (Frictional Attraction)';
                    else if (hasHard && hasSoft) polarityHint = 'M15 (Mixed Tension)';
                    else if (hasConjunction && hasSoft) polarityHint = 'H12 (Harmonic Blend)';
                    else if (hasHard) polarityHint = 'C18 (Challenge Dynamic)';
                    else if (hasSoft) polarityHint = 'E09 (Ease Flow)';
                    else polarityHint = 'TBD (Complex Pattern)';
                    
                    md += `- **Provisional Polarity Code**: ${polarityHint} — requires MAP layer confirmation\n`;
                    md += `- **Attribution**: ${personA.name} ↔ ${personB.name} (bidirectional analysis required)\n\n`;
                }
            }

            // Composite Field Dynamics (if present)
            if (data.composite?.chart?.aspects && data.composite.chart.aspects.length > 0) {
                md += `## Composite Field Dynamics — Shared Structural Patterns\n\n`;
                md += `### Composite Chart Aspects\n\n`;
                md += `> **Protocol**: Composite represents shared field dynamics, not individual attribution\n\n`;
                data.composite.chart.aspects.slice(0, 15).forEach(aspect => {
                    md += `- **${aspect.p1_name}** ${aspect.aspect} **${aspect.p2_name}** (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                });
                md += `\n`;
            }

            // Protocol Compliance Reminder
            md += `## Protocol Compliance Check\n\n`;
            md += `> **Geometry Layer Complete**: Calculations and aspect patterns documented\n`;
            md += `> **Boundary Maintained**: No narrative, prediction, or interpretation included\n`;
            md += `> **Next Required**: Clear Mirror translation via Poetic Brain (Raven Calder)\n`;
            md += `> **Contract**: mirror-ready geometry with appropriate nudges provided\n\n`;

            // Transit Analysis (if mode includes transits and is not natal_only)
            if (mode.includes('_transits') && mode !== 'natal_only') {
                const transitStartDate = formData.transitParams?.startDate;
                const transitEndDate = formData.transitParams?.endDate;
                
                console.log('=== MARKDOWN TRANSIT DEBUG ===');
                console.log('Transit mode detected in markdown generation:', mode);
                console.log('Transit dates from form:', transitStartDate, 'to', transitEndDate);
                console.log('Data object keys:', Object.keys(data));
                console.log('Person A has transitsByDate?', !!data.person_a?.chart?.transitsByDate);
                console.log('Person B has transitsByDate?', !!data.person_b?.chart?.transitsByDate);
                
                if (data.person_a?.chart?.transitsByDate) {
                    console.log('Person A transit dates available:', Object.keys(data.person_a.chart.transitsByDate));
                }
                if (data.person_b?.chart?.transitsByDate) {
                    console.log('Person B transit dates available:', Object.keys(data.person_b.chart.transitsByDate));
                }
                
                md += `## Protocol Layer 2: Live Activations — Trace the Threads\n\n`;
                md += `**Temporal Scope**: ${transitStartDate} to ${transitEndDate}\n`;
                md += `**Purpose**: Identify active tugging patterns and symbolic weather overlays\n`;
                md += `**Processing**: Seismograph aggregation with magnitude, valence, volatility metrics\n\n`;

                                // --- New Unified Hook / Seismograph Renderer ---
                                const ui = window.WOVEN_UI_FILTERS || { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };
                
                                const NAME_MAP = { Medium_Coeli:'Midheaven (MC)', MC:'Midheaven (MC)', Mean_Node:'North Node', Mean_South_Node:'South Node', Mean_Lilith:'Lilith' };
                                const labelName = n => NAME_MAP[n] || n;
                                const aspectGlyph = a => ({conjunction:'☌', opposition:'☍', square:'□', trine:'△', sextile:'✧'})[a] || a;
                                                function hookLine(h){
                                                    let orbVal = h._orb??h.orb; 
                                                    const sign = (typeof orbVal==='number' && orbVal<0)? -1:1;
                                                    const absOrb = (typeof orbVal==='number')? Math.abs(orbVal): orbVal;
                                                    const exact = (typeof absOrb==='number' && absOrb<=0.2) ? '★ ' : '';
                                                    // Phase arrow: if approaching flag supplied else derive from sign (negative = separating) fallback
                                                    let phaseArrow = '';
                                                    if (h.approaching === true) phaseArrow = '↑'; else if (h.approaching === false) phaseArrow = '↓'; else phaseArrow = (sign>0? '↑':'↓');
                                                    return `${exact}${labelName(h.p1_display||h.p1_name)} ${aspectGlyph(h._aspect||h.aspect)} ${labelName(h.p2_display||h.p2_name)} — ${(absOrb)?.toFixed ? absOrb.toFixed(1): '—'}° ${phaseArrow}`.trim();
                                                }
                                function classifyClient(a){
                                    const cls = a._class || a.class || ''; // major, minor, harmonic
                                    if (cls==='major') return 'Major';
                                    if (cls==='minor') return 'Minor';
                                    if (cls==='harmonic') return 'Harmonic';
                                    return 'Other';
                                }
                                function passClientFilters(a){
                                    const orb = a._orb ?? a.orb;
                                    const tight = typeof orb==='number' && orb<=2;
                                    const cls = a._class;
                                    const isMinor = cls==='minor';
                                    const isHarm = cls==='harmonic';
                                    const isSelf = a.p1_name===a.p2_name;
                                    if (ui.tightOnly && !tight) return false;
                                    if (!ui.showMinor && isMinor) return false;
                                    if (!ui.showHarmonic && isHarm) return false;
                                    if (!ui.showSelf && isSelf) return false;
                                    return true;
                                }
                                                function deriveCounts(filteredList){
                                                    const counts = { majors_tight:0, majors_loose:0, minors:0, harmonics:0, self_aspects:0 };
                                                    filteredList.forEach(a=>{
                                                        const orb = a._orb??a.orb??99;
                                                        const isSelf = a.p1_name===a.p2_name;
                                                        if (isSelf) counts.self_aspects++;
                                                        if (a._class==='major') { if (orb<=2) counts.majors_tight++; else counts.majors_loose++; }
                                                        else if (a._class==='minor') counts.minors++; else if (a._class==='harmonic') counts.harmonics++;
                                                    });
                                                    return counts;
                                                }
                                                // Hook pruning utilities
                                                function pruneHooks(list){
                                                    if(!Array.isArray(list)) return [];
                                                    const ORB_CAPS = { luminary:6, planet:4, point:3 }; // tightened hook layer caps
                                                    function bodyClass(n){
                                                        const name = (n||'').toLowerCase();
                                                        if (['sun','moon'].includes(name)) return 'luminary';
                                                        if (['ascendant','midheaven','mc','ic','north node','south node','node','lilith','chiron'].includes(name)) return 'point';
                                                        return 'planet';
                                                    }
                                                    // Filter by orb caps
                                                    const capped = list.filter(a=>{
                                                        const orb = Math.abs(a._orb??a.orb??99);
                                                        const aClass = bodyClass(a.p1_name);
                                                        const bClass = bodyClass(a.p2_name);
                                                        const cap = Math.min( ORB_CAPS[aClass]||5, ORB_CAPS[bClass]||5 );
                                                        return orb <= cap;
                                                    });
                                                    // Diversity: limit max 2 entries per symbolic point (Node/Lilith/Chiron) and 2 per identical pair signature
                                                    const pointNames = new Set(['north node','south node','node','lilith','chiron']);
                                                    const pointCounts = {}; const pairCounts = {};
                                                    const diversified = [];
                                                    for (const h of capped.sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; return (Math.abs(a._orb??a.orb??99)) - (Math.abs(b._orb??b.orb??99)); })) {
                                                        const aName=(h.p1_name||'').toLowerCase();
                                                        const bName=(h.p2_name||'').toLowerCase();
                                                        const pairKey = [aName,bName].sort().join('_');
                                                        const involvesPoint = pointNames.has(aName)||pointNames.has(bName);
                                                        if (involvesPoint){
                                                            pointCounts[aName] = pointCounts[aName]||0;
                                                            pointCounts[bName] = pointCounts[bName]||0;
                                                        }
                                                        pairCounts[pairKey] = pairCounts[pairKey]||0;
                                                        if (involvesPoint){
                                                            const totalPointHits = (pointCounts[aName]||0)+(pointCounts[bName]||0);
                                                            if (totalPointHits >=4) continue; // roughly 2 each combined ceiling
                                                        }
                                                        if (pairCounts[pairKey] >=2) continue;
                                                        // accept
                                                        diversified.push(h);
                                                        if (pointNames.has(aName)) pointCounts[aName]++;
                                                        if (pointNames.has(bName)) pointCounts[bName]++;
                                                        pairCounts[pairKey]++;
                                                        if (diversified.length>=8) break; // cap hooks shown
                                                    }
                                                    return diversified;
                                                }
                                                function buildDaySection(date, day){
                                                    if(!day) return '';
                                                    // Hooks sort tie-break by smaller orb
                                                    const rawHooksSorted = (day.hooks?.slice()||[]).sort((a,b)=>{
                                                        const wDiff = (b._weight||0) - (a._weight||0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        const oa = Math.abs(a._orb??a.orb??99); const ob = Math.abs(b._orb??b.orb??99); return oa - ob;
                                                    });
                                                    const hooks = pruneHooks(rawHooksSorted);
                                                    const filteredAll = (day.filtered_aspects||[]).filter(passClientFilters);
                                                    const counts = deriveCounts(filteredAll);
                                                    // Invariant check (debug only)
                                                    if ((counts.majors_tight + counts.majors_loose + counts.minors + counts.harmonics + counts.self_aspects) !== filteredAll.length){
                                                        console.warn('Count invariant mismatch', date, counts, filteredAll.length);
                                                    }
                                                    let summaryLine = `${date} — Majors: ${counts.majors_tight + counts.majors_loose} (tight ${counts.majors_tight}, loose ${counts.majors_loose}) · Minors: ${counts.minors} · Harmonics: ${counts.harmonics}`;
                                                    let out = `<details><summary>${summaryLine}</summary>\n\n`;
                                                    const suppressed = rawHooksSorted.length - hooks.length;
                                                    out += `**Hooks** (orb caps applied; diversity filtered${suppressed>0?`, ${suppressed} suppressed`:''})\n`;
                                                    hooks.forEach(h=> out += `- ${hookLine(h)}\n`);
                                                    if (suppressed>0){
                                                        // Provide extended weighted influences list (may exceed caps)
                                                        out += `\n**Top Weighted Influences (may exceed caps)**\n`;
                                                        rawHooksSorted.slice(0,8).forEach(h=>{ if(!hooks.includes(h)) out += `- ${hookLine(h)}\n`; });
                                                    }
                                                    if (!hooks.length) out += `- —\n`;
                                                    out += `\n**Filtered aspects (${filteredAll.length})**  *Loose majors (>6°) omitted from hooks*\n`;
                                                    filteredAll.forEach(a=>{
                                                        const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                        out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt}) — ${classifyClient(a)}\n`;
                                                    });
                                                    if (Array.isArray(day.aspects) && day.aspects.length){
                                                        out += `\n<details><summary>Full list (raw ${day.aspects.length})</summary>\n\n`;
                                                        day.aspects.slice(0,40).forEach(a=>{
                                                            const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                            out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt})\n`;
                                                        });
                                                        if (day.aspects.length>40) out += `... (${day.aspects.length-40} more)\n`;
                                                        out += `</details>\n`;
                                                    }
                                                    out += `\n</details>\n\n`;
                                                    return out;
                                                }

                                                // REMOVED: FIELD/MAP/VOICE Translation Bridge
                                                // Math Brain Compliance: This function violated protocol by generating interpretive content.
                                                // FIELD → MAP → VOICE translation is exclusively handled by downstream Poetic Brain (Raven Calder).
                                                // Math Brain outputs geometry only with appropriate nudges for downstream processing.
                                                
                                                // Enhanced buildSummaryTable with three-tier protocol structure
                                                function buildEnhancedSummaryTable(title, dailyMap) {
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    
                                                    // Determine context layer based on title content for proper mythic metaphors
                                                    let contextLayer = 'Trace the Threads'; // Default for transits
                                                    if (title.toLowerCase().includes('composite')) {
                                                        contextLayer = 'Currents + Seismograph';
                                                    }
                                                    
                                                    let out = `## ${title} — ${contextLayer}\n\n`;
                                                    out += `> **Math Brain Protocol**: Geometry Only • Mirror-ready for downstream Poetic Brain (Raven Calder)\n`;
                                                    out += `> **Layer**: Symbolic scaffolding for MAP → VOICE translation\n\n`;
                                                    
                                                    dates.forEach(d => {
                                                        const day = dailyMap[d];
                                                        const mag = (day.seismograph?.magnitude || 0).toFixed(2);
                                                        const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(2);
                                                        const vol = (day.seismograph?.volatility || 0).toFixed(2);
                                                        const trend = day.valence_trend || 0;
                                                        const trendArrow = trend > 0.5 ? ' ↗' : trend < -0.5 ? ' ↘' : '';
                                                        const scaleConf = day.seismograph?.scaleConfidence?.toFixed(3) || '—';
                                                        
                                                        // 1. Seismograph Readout (pure geometry)
                                                        out += `### ${d} — Seismograph Readout\n`;
                                                        out += `**Magnitude:** ${mag} • **Valence:** ${val}${trendArrow} • **Volatility:** ${vol} • **Scale Confidence:** ${scaleConf}\n\n`;
                                                        
                                                        // 2. Top Hooks (geometry with retrograde flags)
                                                        const filteredHooks = applyStrictOrbCaps(day.hooks || []);
                                                        const topHooks = filteredHooks.slice(0, 5);
                                                        
                                                        out += `**Geometry Hooks** _(orb caps applied)_:\n`;
                                                        if (topHooks.length === 0) {
                                                            out += `- No hooks within protocol orb caps\n`;
                                                        } else {
                                                            topHooks.forEach(h => {
                                                                const retroSymbol = (h.p1_retrograde ? '℞' : '') + (h.p2_retrograde ? '℞' : '');
                                                                const weightFlag = h._weight >= 0.8 ? ' ●' : h._weight >= 0.5 ? ' ◐' : '';
                                                                out += `- ${hookLine(h)}${retroSymbol ? ' ' + retroSymbol : ''}${weightFlag}\n`;
                                                            });
                                                        }
                                                        
                                                        // 3. Retrograde Recursion Band (if ≥2 retrograde aspects per protocol)
                                                        const retrogradeAspects = day.retrograde_aspects || [];
                                                        if (retrogradeAspects.length >= 2) {
                                                            out += `\n**Retrograde Recursion Pattern** _(${retrogradeAspects.length} aspects)_:\n`;
                                                            retrogradeAspects.slice(0, 4).forEach(a => {
                                                                const orb = Math.abs(a._orb || a.orb || 0).toFixed(1);
                                                                const body1 = (a.p1_retrograde ? '℞' : '') + labelName(a.p1_name);
                                                                const body2 = (a.p2_retrograde ? '℞' : '') + labelName(a.p2_name);
                                                                out += `- ${body1} ${aspectGlyph(a._aspect)} ${body2} (${orb}°)\n`;
                                                            });
                                                            if (retrogradeAspects.length > 4) out += `- ... (${retrogradeAspects.length - 4} more)\n`;
                                                        }
                                                        
                                                        // 4. Protocol Nudges for Downstream Processing
                                                            const includePoetic = (typeof document !== 'undefined' && document.getElementById('poeticFlagsToggle')?.checked);
                                                            if (includePoetic) {
                                                                const realMag = parseFloat(mag);
                                                                const realVal = parseFloat(val);
                                                                out += `\n**Poetic Prep Flags (optional; interpretive – not geometry):**\n`;
                                                                if (realMag >= 6 && parseFloat(vol) >= 3) {
                                                                    out += `- Current cluster: high magnitude + volatility (mirror before narrative)\n`;
                                                                }
                                                                if (Math.abs(realVal) >= 3) {
                                                                    out += `- Valence extreme (${val}) – directional tension needs framing\n`;
                                                                }
                                                                if (retrogradeAspects.length >= 2) {
                                                                    out += `- Retrograde recursion band (${retrogradeAspects.length}) – internal revision motif\n`;
                                                                }
                                                                if (scaleConf !== '—' && parseFloat(scaleConf) < 0.7) {
                                                                    out += `- Low scale confidence (${scaleConf}) – treat as provisional signal\n`;
                                                                }
                                                                if (topHooks.length === 0) {
                                                                    out += `- Sparse hook density – diffuse / background state\n`;
                                                                }
                                                                if (realMag < 2 && Math.abs(realVal) < 0.5) {
                                                                    out += `- Low activation baseline – avoid over-interpretation\n`;
                                                                }
                                                            } else {
                                                                out += `\n<details><summary><em>Enable Poetic Prep Flags (interpretive layer)</em></summary>Activate the toggle in Seismograph filters to surface optional salience prompts. Math Brain keeps geometry neutral by default.</details>\n`;
                                                            }
                                                        
                                                        // 5. Raw Aspect Inventory with Rejection Taxonomy (collapsible)
                                                        const allAspects = day.filtered_aspects || [];
                                                        const rejections = day.rejections || [];
                                                        
                                                        if (allAspects.length > 0 || rejections.length > 0) {
                                                            out += `\n<details><summary>Aspect Processing Summary — ${allAspects.length} accepted, ${rejections.length} rejected</summary>\n\n`;
                                                            
                                                            if (allAspects.length > 0) {
                                                                out += `**Accepted Aspects (${allAspects.length}):**\n`;
                                                                allAspects.forEach(a => {
                                                                    const orb = Math.abs(a._orb || a.orb || 0).toFixed(1);
                                                                    const retroFlag = (a.p1_retrograde || a.p2_retrograde) ? ' ℞' : '';
                                                                    const classFlag = a._class ? ` [${a._class}]` : '';
                                                                    const weightFlag = a._weight ? ` w=${a._weight.toFixed(2)}` : '';
                                                                    out += `- ${labelName(a.p1_name)} ${aspectGlyph(a._aspect)} ${labelName(a.p2_name)} (${orb}°)${retroFlag}${classFlag}${weightFlag}\n`;
                                                                });
                                                            }
                                                            
                                                            if (rejections.length > 0) {
                                                                out += `\n**Rejection Taxonomy (${rejections.length}):**\n`;
                                                                const rejectionGroups = {};
                                                                rejections.forEach(r => {
                                                                    if (!rejectionGroups[r.reason]) rejectionGroups[r.reason] = [];
                                                                    rejectionGroups[r.reason].push(r);
                                                                });
                                                                
                                                                Object.entries(rejectionGroups).forEach(([reason, items]) => {
                                                                    out += `- **${reason}** (${items.length}): `;
                                                                    const samples = items.slice(0, 3).map(r => `${r.aspect} (${Math.abs(r.orb || 0).toFixed(1)}°)`);
                                                                    out += samples.join(', ');
                                                                    if (items.length > 3) out += `, +${items.length - 3} more`;
                                                                    out += `\n`;
                                                                });
                                                            }
                                                            
                                                            out += `\n</details>\n\n`;
                                                        }
                                                        
                                                        out += `---\n\n`;
                                                    });
                                                    
                                                    // Add scaling strategy summary
                                                    const sampleDay = Object.values(dailyMap)[0];
                                                    if (sampleDay?.seismograph?.scalingStrategy) {
                                                        out += `**Scaling Protocol**: ${sampleDay.seismograph.scalingStrategy}`;
                                                        if (sampleDay.seismograph.scaleConfidence !== undefined) {
                                                            const confidence = sampleDay.seismograph.scaleConfidence;
                                                            const n = Math.round(confidence * 14);
                                                            out += ` (${n}/14 day window, confidence=${confidence.toFixed(3)})`;
                                                        }
                                                        out += `\n\n`;
                                                    }
                                                    
                                                    return out;
                                                }
                                                
                                                // Apply strict orb caps for Top Hooks
                                                function applyStrictOrbCaps(hooks) {
                                                    const ORB_CAPS = { luminary: 6, planet: 4, point: 3 };
                                                    
                                                    function getBodyType(name) {
                                                        const n = (name || '').toLowerCase();
                                                        if (['sun', 'moon'].includes(n)) return 'luminary';
                                                        if (['ascendant', 'midheaven', 'mc', 'ic', 'north node', 'south node', 'lilith', 'chiron'].includes(n)) return 'point';
                                                        return 'planet';
                                                    }
                                                    
                                                    return hooks.filter(h => {
                                                        const orb = Math.abs(h._orb || h.orb || 99);
                                                        const type1 = getBodyType(h.p1_name);
                                                        const type2 = getBodyType(h.p2_name);
                                                        const cap = Math.min(ORB_CAPS[type1] || 5, ORB_CAPS[type2] || 5);
                                                        return orb <= cap;
                                                    }).sort((a, b) => {
                                                        // Sort by weight, then by orb tightness
                                                        const wDiff = (b._weight || 0) - (a._weight || 0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        return Math.abs(a._orb || a.orb || 99) - Math.abs(b._orb || b.orb || 99);
                                                    });
                                                }

                                                function buildSummaryTable(title, dailyMap){
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    const single = dates.length===1;
                                                    let out = `## ${title} — Seismograph ${single?'(Daily Range)':'(Range)'}\n\n| Date | Magnitude | Valence | Volatility | Top Hooks |\n|------|-----------:|--------:|-----------:|-----------|\n`;
                                                    dates.forEach(d=>{
                                                        const day = dailyMap[d];
                                                        // Limit to top 3 hooks by weight desc w/ tie-break
                                                        const hooks = (day.hooks||[]).slice().sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; const oa=a._orb??a.orb??99; const ob=b._orb??b.orb??99; return oa-ob; }).slice(0,3);
                                                        const peak = hooks.map(h=> hookLine(h)).join(', ');
                                                        const rawVal = (day.seismograph?.valence??0);
                                                        const clampedVal = Math.max(-5, Math.min(5, rawVal));
                                                        out += `| ${d} | ${(day.seismograph?.magnitude??0).toFixed(2)} | ${clampedVal.toFixed(2)} | ${(day.seismograph?.volatility??0).toFixed(2)} | ${peak.replace(/\|/g,'\\|') || '—'} |\n`;
                                                    });
                                                    out += `\nMagnitude=aggregate charge (0–10 est), Valence=net tension (−=friction, +=ease), Volatility=dispersion of charge.\n`;
                                                    out += `_Valence emoji: 🌑 (negative), 🌗 (neutral), 🌞 (positive). Examples → negative: 🌋/⚔️/♻️/↔️/🌫️/⏳/🧩/🕳️; positive: 🌱/⚖️/🌊/✨/🌈/🔥/🦋/💎._\n`;
                                                    
                                                    // Add confidence scaling information if available
                                                    const sampleDay = Object.values(dailyMap)[0];
                                                    if (sampleDay?.seismograph?.scaleConfidence !== undefined) {
                                                        const confidence = sampleDay.seismograph.scaleConfidence;
                                                        const n = Math.round(confidence * 14);
                                                        out += `Scaling: blended (n=${n}, confidence=${confidence})\n`;
                                                    }
                                                    
                                                    out += `\n`;
                                                    return out;
                                                }
                
                                md += `### Daily Seismograph Readouts\n\n`;
                                // Sky dataset (weather-only)
                                if (isSky && (data.sky?.transitsByDate || data.transitsByDate)) {
                                    const skyMap = data.sky?.transitsByDate || data.transitsByDate;
                                    md += buildEnhancedSummaryTable(`Planetary Weather`, skyMap);
                                }
                                if (data.person_a?.chart?.transitsByDate && personA?.name) md += buildEnhancedSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildEnhancedSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildEnhancedSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Legacy Table View\n`;
                                if (isSky && (data.sky?.transitsByDate || data.transitsByDate)) {
                                    const skyMap = data.sky?.transitsByDate || data.transitsByDate;
                                    md += buildSummaryTable(`Planetary Weather`, skyMap);
                                }
                                if (data.person_a?.chart?.transitsByDate && personA?.name) md += buildSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Daily Hooks\n\n_Orb shows absolute degrees. Phase: ↑ applying (tightening) · ↓ separating (widening). Hook layer caps: ≤6° luminaries, ≤4° planets, ≤3° points; broader orbs remain in Raw._\n`;
                                if (data.person_a?.chart?.transitsByDate){
                                    Object.keys(data.person_a.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_a.chart.transitsByDate[d]); });
                                }
                                if (data.person_b?.chart?.transitsByDate){
                                    Object.keys(data.person_b.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_b.chart.transitsByDate[d]); });
                                }
                                if (data.composite?.transitsByDate){
                                    Object.keys(data.composite.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.composite.transitsByDate[d]); });
                                }
                
                console.log('=== END MARKDOWN TRANSIT DEBUG ===');

                // Synastry Transits (transits to synastry aspects)
                if (mode.includes('synastry') && data.synastry?.transitsByDate) {
                    md += `### Synastry Transit Activations\n\n`;
                    const synastryTransits = data.synastry.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(synastryTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = synastryTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_owner ? `${transit.p2_owner} ${transit.p2_name}` : (transit.p2_name ?? "?");
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant synastry transit activations in the specified date range.\n\n`;
                    }
                }

                // Composite Transits (for composite modes)
                if (mode.includes('composite') && data.composite?.transitsByDate) {
                    md += `### Composite Chart Transits\n\n`;
                    const compositeTransits = data.composite.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(compositeTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = compositeTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_name ?? "?";
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant composite transits in the specified date range.\n\n`;
                    }
                }
            }

            // Footer: Protocol Compliance & Safety Requirements
            const isRavenConsumer = data.raven_consumer === 'RAVEN_CALDER_GPT';
            
            md += `## Safety & Hygiene Protocol\n\n`;
            
            // Agency Clause (Required by Protocol)
            md += `### Agency Reinforcement (Required)\n\n`;
            md += `**Agency Statement**: This geometric analysis provides symbolic weather patterns, not deterministic outcomes. `;
            md += `You remain the author of your choices and the validator of any resonance. `;
            md += `The map supports your agency—it never overrides it. If something doesn't land, it doesn't count.\n\n`;
            
            // Temporal and Rate Limits
            md += `### Protocol Limits\n\n`;
            const dMax = (window.WOVEN_STEP_LIMITS?.daily?.max)||45;
            const wMaxM = Math.round(((window.WOVEN_STEP_LIMITS?.weekly?.max)||270)/30);
            const mMaxM = Math.round(((window.WOVEN_STEP_LIMITS?.monthly?.max)||550)/30);
            md += `- **Max Date Span**: Daily up to ${dMax} days; Weekly up to ${wMaxM} months; Monthly up to ${mMaxM} months (current: ${formData.transitParams ? Math.ceil((new Date(formData.transitParams.endDate) - new Date(formData.transitParams.startDate)) / (1000 * 60 * 60 * 24)) : 'N/A'} days)\n`;
            md += `- **Rate Limits**: 50 transit requests per day per user\n`;
            md += `- **Narrative Hygiene**: No deterministic or fatalistic language permitted\n`;
            md += `- **Falsifiability**: All outputs subject to "Does this land?" validation\n\n`;
            
            // Glossary for non-Raven consumers
            if (!isRavenConsumer) {
                md += `## Symbolic Glossary (for Non-Raven GPT Consumers)\n\n`;
                md += `| Term | Definition |\n`;
                md += `|------|------------|\n`;
                md += `| **Weave** | Structural identity patterns revealed through natal geometry |\n`;
                md += `| **Threads** | Live activation patterns through transiting aspects |\n`;
                md += `| **Currents** | Macro field states from seismograph aggregation |\n`;
                md += `| **Seismograph** | Two-axis symbolic measurement: Magnitude (X), Valence (Y), Volatility Index |\n`;
                md += `| **Echo Loop** | Bidirectional aspect within ±3° orb creating reinforcing relational dynamic |\n`;
                md += `| **REF** | Relational Echo Field — macro structure from converging Echo Loops |\n`;
                md += `| **Hook** | Salient daily aspect for focused attention (strict orb caps applied) |\n`;
                md += `| **Recursion Band** | Retrograde aspect pattern indicating internal revision themes |\n\n`;
                
                md += `### System Role Clarity\n\n`;
                md += `- **Math Brain**: Finds coordinates, measures angles, provides geometric scaffolding\n`;
                md += `- **Poetic Brain (Raven Calder)**: Translates geometry into felt language and mirrors\n`;
                md += `- **User**: Validates resonance, maintains agency, decides what lands\n\n`;
            }
            
            // Raven Processing Checklist
            md += `### Raven Calder Processing Checklist\n\n`;
            md += `**Required Sources**: `;
            md += `☐ Poetic Codex • ☐ FIELD_MAP_VOICE rules • ☐ Hook Stack protocols • ☐ Seismograph guidelines\n\n`;
            md += `**Geometry Verification**: `;
            md += `☐ Retrograde flags applied • ☐ True/Mean Node distinctions noted • ☐ Coordinates normalized • ☐ Timezone validated\n\n`;
            md += `**Protocol Compliance**: `;
            md += `☐ Recognition-first approach • ☐ SST taxonomy respected • ☐ Falsifiability maintained • ☐ Agency preserved\n\n`;
            md += `**Output Standards**: `;
            md += `☐ Mirror not mandate • ☐ No prediction claims • ☐ Testable reflections • ☐ Clear boundary maintenance\n\n`;
            
            md += `---\n\n`;
            md += `*Generated by Woven Map Math Brain — Pure Geometric Scaffolding Engine*\n`;
            md += `*Contract: clear-mirror/1.2 • Protocol: FIELD → MAP → VOICE • Version: ${(data.provenance?.math_brain_version)||'0.x'}*`;

            // Optional: Append Health Correlation if health data is present and we have Person A transits
            try {
                if (typeof loadedHealthData === 'object' && loadedHealthData && data.person_a?.chart?.transitsByDate) {
                    const correlations = correlateHealthWithSeismograph(loadedHealthData, data.person_a.chart.transitsByDate);
                    if (correlations && correlations.length) {
                        md += `\n---\n\n`;
                        md += generateHealthCorrelationTable(correlations);
                    }
                }
            } catch (e) {
                console.warn('Health correlation append skipped:', e);
            }
            
            // Add Provenance & Processing Metadata section
            if (includeProvenance) {
                md += '\n\n' + generateProvenance(data, window.lastRunStats || {});
            }
            
            // Add JSON Appendix
            if (includeJsonAppendix) {
                const jsonAppendix = generateJsonAppendix(data, window.lastRunStats || {});
                md += '\n\n---\n\n## Machine-Readable Appendix (JSON)\n\n';
                md += '```json\n';
                md += JSON.stringify(jsonAppendix, null, 2);
                md += '\n```\n';
            }

            return md;
        }

        // Build Raven-style JSON wrapper for main download
    function buildRavenJsonReport(data){
            try {
                const form = collectFormData();
                const mode = form?.context?.mode || data?.mode || '';
                const report_date = new Date().toISOString().split('T')[0];

                // Context block
                const context = {};
                const solo = !form?.personB?.name && !data?.person_b?.details;
                if (solo) {
                    context.type = 'solo';
                    const p = data?.person_a?.details || form?.personA || {};
                    context.natal = {
                        name: p.name || 'Unknown',
                        birth_date: p.year && p.month && p.day ? `${p.year}-${String(p.month).padStart(2,'0')}-${String(p.day).padStart(2,'0')}` : (p.birth_date || ''),
                        birth_time: p.hour!=null && p.minute!=null ? `${String(p.hour).padStart(2,'0')}:${String(p.minute).padStart(2,'0')}` : (p.birth_time || ''),
                        birth_place: [p.city, p.state || p.region, p.nation || p.country].filter(Boolean).join(', ')
                    };
                    // Translocation
                    const reloc = data?.relocation_a;
                    context.translocation = {
                        applies: reloc?.status === 'OK',
                        current_location: form?.relocation?.city ? `${form.relocation.city}, ${form.relocation.state || ''}`.trim() : undefined
                    };
                } else {
                    context.type = 'relational';
                    const a = data?.person_a?.details || form?.personA || {};
                    const b = data?.person_b?.details || form?.personB || {};
                    context.natal_A = {
                        name: a.name || 'A',
                        birth_date: a.year && a.month && a.day ? `${a.year}-${String(a.month).padStart(2,'0')}-${String(a.day).padStart(2,'0')}` : (a.birth_date || ''),
                        birth_time: a.hour!=null && a.minute!=null ? `${String(a.hour).padStart(2,'0')}:${String(a.minute).padStart(2,'0')}` : (a.birth_time || ''),
                        birth_place: [a.city, a.state || a.region, a.nation || a.country].filter(Boolean).join(', ')
                    };
                    context.natal_B = {
                        name: b.name || 'B',
                        birth_date: b.year && b.month && b.day ? `${b.year}-${String(b.month).padStart(2,'0')}-${String(b.day).padStart(2,'0')}` : (b.birth_date || ''),
                        birth_time: b.hour!=null && b.minute!=null ? `${String(b.hour).padStart(2,'0')}:${String(b.minute).padStart(2,'0')}` : (b.birth_time || ''),
                        birth_place: [b.city, b.state || b.region, b.nation || b.country].filter(Boolean).join(', ')
                    };
                    context.translocation = {
                        applies: (data?.relocation_a?.status === 'OK') || (data?.relocation_b?.status === 'OK'),
                        current_location_A: form?.relocation?.city || undefined,
                        current_location_B: undefined
                    };
                }

                // Helper: triad builder for a given root
                const buildTriad = (root) => {
                    const { firstDayData } = getFirstDayData(root);
                    const mag = Number(firstDayData?.seismograph?.magnitude) || 0;
                    const val = Number(firstDayData?.seismograph?.valence) || 0;
                    const vol = Number(firstDayData?.seismograph?.volatility) || 0;
                    const valEmoji = getValenceEmoji(Math.max(-5, Math.min(5, val)));
                    const confidence = typeof firstDayData?.seismograph?.scaleConfidence === 'number'
                        ? firstDayData.seismograph.scaleConfidence
                        : (typeof data?.provenance?.scale_confidence === 'number' ? data.provenance.scale_confidence : 0.9);
                    const glyphs = [];
                    if (Math.abs(val) >= 3) glyphs.push('⚡');
                    const anyHard = (firstDayData?.hooks || []).some(h => {
                        const a = (h._aspect || h.aspect || '').toLowerCase();
                        return a === 'opposition' || a === 'square';
                    });
                    if (anyHard && val < 0) glyphs.push('☍');
                    const quadrant = `${mag >= 3 ? 'High' : 'Low'} Mag / ${val < 0 ? '-' : '+'} Val`;
                    return {
                        magnitude: { value: mag, term: toMagnitudeTerm(mag) },
                        valence: { value: val, term: toValenceTerm(val), emoji: valEmoji },
                        volatility: { value: vol, term: vol>=4? 'Very high turbulence' : vol>=3? 'High turbulence' : vol>=2? 'Variable' : vol>=1? 'Settling' : 'Stable' },
                        confidence,
                        glyphs,
                        quadrant,
                        notes: window.userNotesForDay || []
                    };
                };

                // Build balance meter: solo vs relational (shared + per-party)
                let balance_meter;
                if (context.type === 'relational') {
                    const sharedRoot = data.composite || data.synastry || (data.person_a || {}); // prefer composite, else synastry
                    balance_meter = {
                        shared: buildTriad(sharedRoot),
                        party_A: buildTriad(data.person_a || data),
                        party_B: buildTriad(data.person_b || data)
                    };
                } else {
                    balance_meter = buildTriad(data.person_a || data);
                }

                // Macro and micro views (lightweight heuristics)
                const tbd = resolveTransitsByDate(data.person_a || data) || {};
                const dates = Array.isArray(tbd) ? [] : Object.keys(tbd).sort();
                let activation_curve = undefined, valence_drift = undefined, volatility_pattern = undefined;
                if (dates.length >= 2) {
                    const first = tbd[dates[0]]?.seismograph || {};
                    const last = tbd[dates[dates.length-1]]?.seismograph || {};
                    const magFrom = Number(first.magnitude)||0, magTo = Number(last.magnitude)||0;
                    activation_curve = `Magnitude trending ${magFrom.toFixed(1)} → ${magTo.toFixed(1)} (${toMagnitudeTerm(magFrom).split(' / ')[0]} → ${toMagnitudeTerm(magTo).split(' / ')[0]})`;
                    const valFrom = Number(first.valence)||0, valTo = Number(last.valence)||0;
                    const driftFrom = getValenceEmoji(Math.max(-5,Math.min(5,valFrom)));
                    const driftTo = getValenceEmoji(Math.max(-5,Math.min(5,valTo)));
                    const driftLabelFrom = toValenceTerm(valFrom);
                    const driftLabelTo = toValenceTerm(valTo);
                    valence_drift = `${driftLabelFrom} ${driftFrom} → ${driftLabelTo} ${driftTo}`;
                    const volFrom = Number(first.volatility)||0, volTo = Number(last.volatility)||0;
                    volatility_pattern = volTo>volFrom? 'Spiking later' : volTo<volFrom? 'Settling later' : 'Stable band';
                }

                // Micro view: allow per-party when relational
                let micro_view;
                if (context.type === 'relational') {
                    const triA = balance_meter.party_A;
                    const triB = balance_meter.party_B;
                    const heurA = generateBarometerHeuristics(triA.magnitude.value, triA.valence.value, triA.volatility.value, {});
                    const heurB = generateBarometerHeuristics(triB.magnitude.value, triB.valence.value, triB.volatility.value, {});
                    micro_view = {
                        daily_bar_pulse: { shared: balance_meter.shared.magnitude.value, party_A: triA.magnitude.value, party_B: triB.magnitude.value },
                        valence_annotation: { shared: balance_meter.shared.valence.value, party_A: triA.valence.value, party_B: triB.valence.value },
                        semantic_snapshot: { title: 'Shared field snapshot', glyphs: balance_meter.shared.glyphs, annotation: '' },
                        party_A_snapshot: { title: heurA.title, glyphs: heurA.glyphs? heurA.glyphs.split('') : triA.glyphs, annotation: heurA.annotation },
                        party_B_snapshot: { title: heurB.title, glyphs: heurB.glyphs? heurB.glyphs.split('') : triB.glyphs, annotation: heurB.annotation }
                    };
                } else {
                    const tri = balance_meter;
                    const heur = generateBarometerHeuristics(tri.magnitude.value, tri.valence.value, tri.volatility.value, {});
                    micro_view = {
                        daily_bar_pulse: tri.magnitude.value,
                        valence_annotation: tri.valence.value,
                        semantic_snapshot: { title: heur.title, glyphs: heur.glyphs? heur.glyphs.split('') : tri.glyphs, annotation: heur.annotation }
                    };
                }

                const macro_view = {
                    activation_curve,
                    valence_drift,
                    volatility_pattern
                };

                // Extract daily seismograph map for Person A (if present)
                let seismograph_by_date = undefined;
                try {
                    const tbd = resolveTransitsByDate(data.person_a || data) || {};
                    if (tbd && typeof tbd === 'object' && !Array.isArray(tbd)) {
                        const map = {};
                        Object.keys(tbd).forEach(d => {
                            const s = tbd[d]?.seismograph;
                            if (s && typeof s === 'object') {
                                map[d] = {
                                    magnitude: Number(s.magnitude) || 0,
                                    valence: Number(s.valence) || 0,
                                    volatility: Number(s.volatility) || 0
                                };
                            }
                        });
                        if (Object.keys(map).length) seismograph_by_date = map;
                    }
                } catch(e) { /* noop */ }

                // Attach any prebuilt reports/templates if present
                const reports = {};
                try {
                    if (data?.reports?.mirror_report) reports.mirror_report = data.reports.mirror_report;
                    if (data?.reports?.balance_meter_report) reports.balance_meter_report = data.reports.balance_meter_report;
                    if (data?.reports?.templates) reports.templates = data.reports.templates;
                } catch(_){}

                return {
                    report_date,
                    context,
                    balance_meter,
                    macro_view,
                    micro_view,
                    seismograph_by_date,
                    reports: Object.keys(reports).length ? reports : undefined
                };
            } catch (e) {
                console.warn('Raven JSON build failed, falling back to minimal shell', e);
                return { report_date: new Date().toISOString().split('T')[0], context: { type: 'solo' } };
            }
        }

        
        // SEISMOGRAPH FUNCTIONS
        // =============================================================================

    function buildSeismographDisplay(data) {
            if (!data) return '<p>No data available for seismograph analysis.</p>';
            
            // Store data globally for CSV export and filtering
            window.seismographData = data;
            window.seismographFilters = {
                minMagnitude: 0,
                minValence: -5,
                maxValence: 5,
                minVolatility: 0,
                showPatterns: true
            };
            
            let html = `
                <div class="space-y-6">
                    <!-- Fixed Control Header - Always visible and not scrollable -->
                    <div class="sticky top-0 z-10 bg-gray-800 p-4 rounded-lg border border-teal-500 shadow-lg">
                        <h3 class="text-lg font-semibold text-teal-300 mb-3">Seismograph Overview</h3>
                        ${loadedHealthData ? `<div class="bg-purple-900 p-2 rounded mb-3 text-sm">
                            <span class="text-purple-300">🏥 Health Data Loaded:</span> 
                            <span class="text-white">${Object.keys(loadedHealthData).length} metrics available for correlation analysis</span>
                        </div>` : `<div class="bg-gray-700 p-2 rounded mb-3 text-sm">
                            <span class="text-gray-300">💡 Tip:</span> 
                            <span class="text-white">Upload Health Auto Export JSON above for correlation analysis</span>
                        </div>`}
                        <!-- Control Buttons - Sticky and always visible -->
                        <div class="flex flex-wrap gap-2 mb-4" aria-label="Seismograph controls">
                            <button id="toggleSeismographView" aria-live="polite" class="px-3 py-1 bg-teal-600 text-white rounded text-sm hover:bg-teal-700" title="Cycle: Table → Arc → Barometer → Mobile">
                                🔄 View: Table
                            </button>
                            <button id="downloadAllSeismographCSV" class="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700" title="Download CSV per dataset">
                                📁 Download All CSV
                            </button>
                            <button id="toggleSeismographFilters" class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700" title="Show/Hide Filters">
                                🔍 Filters
                            </button>
                            <button id="queueSeismographAnalysis" class="px-3 py-1 bg-purple-600 text-white rounded text-sm hover:bg-purple-700" title="Queue pattern & cycle analysis (runs asynchronously)">
                                📦 Queue Analysis
                            </button>
                            <button id="toggleGlossary" class="px-3 py-1 bg-indigo-600 text-white rounded text-sm hover:bg-indigo-700" title="Open Seismograph Glossary">
                                📖 Glossary
                            </button>
                        </div>
                        <p class="text-sm text-gray-300 mb-3 leading-relaxed">
                            <strong>Macro (Seismograph Arc):</strong> Normalized activation curve (Magnitude scaled to 0–5) with valence drift path.<br>
                            <strong>Micro (Barometer):</strong> Daily bar pulses (Magnitude 0–5) with textual valence annotations (V:+/-x.x) and volatility shading.<br>
                            <strong>Scales:</strong> Magnitude 0–5 (normalized), Valence -5..+5 (annotation only), Volatility 0–5. Raw source magnitude (0–10) preserved in tables.
                        </p>
                        ${buildSeismographFilters()}
                        <div class="mt-4 text-xs text-gray-400 border-t border-gray-700 pt-3">
                            Normalization happens only in visual arc/barometer layers. Tables retain raw magnitude (0–10) for auditability.
                        </div>
                    </div>
                    
                    <!-- Scrollable Content Area -->
                    <div class="seismograph-content-area">`;
            
            // Pattern detection results
            html += '<div id="seismographPatterns"></div>';
            // Raven Voice panel container (hidden until analysis queued)
            html += '<div id="ravenVoicePanel" class="hidden mt-4 bg-gray-800 p-4 rounded border border-teal-600"><h4 class="text-teal-300 font-semibold mb-2">🗣️ Raven Voice</h4><div class="text-sm text-gray-200" id="ravenVoiceContent">Queue an analysis or hover (future) elements for contextual synthesis. FIELD → MAP remain primary; this is optional VOICE.</div></div>';
            // Global tooltip element (created once)
            if(!document.getElementById('globalHoverTooltip')){
                setTimeout(()=>{const t=document.createElement('div'); t.id='globalHoverTooltip'; t.className='pointer-events-none fixed z-50 px-2 py-1 rounded bg-gray-900/90 text-[11px] text-gray-100 border border-teal-500 shadow'; t.style.display='none'; document.body.appendChild(t);},0);
            }
            

            // Glossary Modal (fixed overlay - outside scrollable content)

            // View toggle container
            html += '<div id="seismographViewContainer">';
            
            // Glossary Modal - Expanded with Valence Maps

            html += `
                <div id="seismographGlossaryModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 p-4" aria-labelledby="glossary-title" role="dialog" aria-modal="true">
                    <div class="bg-gray-900 rounded-lg shadow-xl max-w-4xl w-full p-6 relative border border-indigo-500 overflow-y-auto max-h-[90vh]">
                        <button id="closeGlossary" class="absolute top-3 right-3 text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                        <h2 id="glossary-title" class="text-2xl font-bold text-indigo-300 mb-4">🌌 Woven Map Glossary (Balance Meter)</h2>
                        
                        <div class="space-y-6">
                            <!-- Core Dimensions -->
                            <div>
                                <h3 class="text-lg font-semibold text-white mb-3 border-b border-gray-700 pb-2">Core Dimensions</h3>
                                <ul class="space-y-3 text-sm">
                    <li><strong>Magnitude ⚡ (0–5)</strong> — <span class="text-gray-300">Size of symbolic pressure. Neutral in tone (how much, not which way); ceiling scale ensures comparability.</span></li>
                    <li><strong>Valence 🌞🌑🌗</strong> — <span class="text-gray-300">Directional tilt of pressure (supportive / restrictive / mixed).</span>
                                        <ul class="ml-4 mt-2 space-y-1 text-xs text-gray-400">
                        <li><strong>🌞 Positive:</strong> harmonizes, stabilizes, opens pathways.</li>
                        <li><strong>🌑 Negative:</strong> constrains, destabilizes, blocks.</li>
                        <li><strong>🌗 Mixed:</strong> simultaneous support and strain.</li>
                                        </ul>
                    </li>
                    <li><strong>Volatility 🌪️</strong> — <span class="text-gray-300">Distribution of pressure (low = concentrated; high = scattered/stormy).</span></li>
                    <li><strong>SFD (Support–Friction Differential)</strong> — <span class="text-gray-300">Splits S+ vs S−, nets the differential.</span></li>
                                </ul>
                            </div>

                            <!-- Negative Valence Types -->
                            <div>
                                <h3 class="text-lg font-semibold text-rose-300 mb-3 border-b border-gray-700 pb-2">🌑 Map of Negative Valence Types</h3>
                                <p class="text-xs text-gray-400 mb-3 italic">When energy pulls down, contracts, destabilizes</p>
                                <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3 text-sm">
                                    <li>♾️ <strong>Recursion Pull</strong> — <span class="text-gray-300">Old cycles resurface; déjà vu gravity.</span></li>
                                    <li>⚔️ <strong>Friction Clash</strong> — <span class="text-gray-300">Mars-style conflict, arguments, accidents, heat.</span></li>
                                    <li>↔️ <strong>Cross Current</strong> — <span class="text-gray-300">Competing priorities, mixed flows, confusion.</span></li>
                                    <li>🌫️ <strong>Fog / Dissolution</strong> — <span class="text-gray-300">Blurred boundaries, scattered signal.</span></li>
                                    <li>🌋 <strong>Pressure / Eruption</strong> — <span class="text-gray-300">Compression that forces release.</span></li>
                                    <li>⏳ <strong>Saturn Weight</strong> — <span class="text-gray-300">Heaviness, delay, endurance tests.</span></li>
                                    <li>🧩 <strong>Fragmentation</strong> — <span class="text-gray-300">Fractured focus, scatter.</span></li>
                                    <li>🕳️ <strong>Entropy Drift</strong> — <span class="text-gray-300">Inertia, slow leak of momentum.</span></li>
                                </ul>
                            </div>

                            <!-- Positive Valence Types -->
                            <div>
                                <h3 class="text-lg font-semibold text-emerald-300 mb-3 border-b border-gray-700 pb-2">🌞 Map of Positive Valence Types</h3>
                                <p class="text-xs text-gray-400 mb-3 italic">When energy uplifts, harmonizes, expands</p>
                                <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3 text-sm">
                                    <li>🌱 <strong>Fertile Field</strong> — <span class="text-gray-300">Growth, new opportunities, creativity sprouts.</span></li>
                                    <li>✨ <strong>Harmonic Resonance</strong> — <span class="text-gray-300">Trines/sextiles, things click, natural flow.</span></li>
                                    <li>💎 <strong>Expansion Lift</strong> — <span class="text-gray-300">Jupiter blessing, confidence, abundance.</span></li>
                                    <li>🔥 <strong>Combustion Clarity</strong> — <span class="text-gray-300">Pressure breaks but reveals hidden truth, sudden insight.</span></li>
                                    <li>🦋 <strong>Liberation / Release</strong> — <span class="text-gray-300">Uranian breakthroughs, freedom, change feels fresh.</span></li>
                                    <li>⚖️ <strong>Integration</strong> — <span class="text-gray-300">Opposites reconcile; balance returns.</span></li>
                                    <li>🌊 <strong>Flow Tide</strong> — <span class="text-gray-300">Ease, adaptability, emotions moving freely.</span></li>
                                    <li>🌈 <strong>Visionary Spark</strong> — <span class="text-gray-300">Inspiration, Neptune dream turned into art, spiritual elevation.</span></li>
                                </ul>
                            </div>

                            <div>
                                <h3 class="text-lg font-semibold text-amber-300 mb-3 border-b border-gray-700 pb-2">Sources of Force</h3>
                                <ul class="space-y-2 text-sm">
                                    <li><strong>Orb (🎯)</strong> → <span class="text-gray-300">Closer = stronger.</span></li>
                                    <li><strong>Aspect Type (🌀)</strong> → <span class="text-gray-300">Major = thunder, Minor = whispers.</span></li>
                                    <li><strong>Planetary Potency (🪐)</strong> → <span class="text-gray-300">Fast planets = sparks, slow planets = tectonic.</span></li>
                                    <li><strong>Natal Resonance (📡)</strong> → <span class="text-gray-300">Hits angles, luminaries, nodes = amplified.</span></li>
                                    <li><strong>Recursion (♾️)</strong> → <span class="text-gray-300">Overlapping themes echo louder.</span></li>
                                </ul>
                            </div>

                            <div>
                                <h3 class="text-lg font-semibold text-cyan-300 mb-3 border-b border-gray-700 pb-2">Quick Navigation</h3>
                                <ol class="space-y-2 text-sm">
                                    <li><strong>1. Valence</strong> = Is it 🌞 lifting, 🌑 pressing, or 🌗 neutral?</li>
                                    <li><strong>2. Type</strong> = Which "weather flavor" (🌪️ Recursion, 🌱 Fertility, etc.)?</li>
                                    <li><strong>3. Magnitude</strong> ⚡ = How loud is it?</li>
                                    <li><strong>4. Volatility</strong> 🌪️ = Is it steady or stormy?</li>
                                </ol>
                            </div>

                            <div class="bg-gray-800 p-4 rounded border border-gray-600">
                                <p class="text-sm text-gray-300">
                                    👉 So negative valence isn't just "bad vibes" — it could be <strong>weight (Saturn), fog (Neptune), eruption (Pluto), or clash (Mars)</strong>.<br>
                                    And positive valence isn't just "good vibes" — it could be <strong>growth (Jupiter), clarity (Sun), flow (Moon), or liberation (Uranus)</strong>.
                                </p>
                            </div>
                            
                            <div class="text-center pt-4 border-t border-gray-700">
                                <button id="glossary-close-secondary" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded text-sm">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // View toggle container - inside scrollable content area
            html += '<div id="seismographViewContainer">';

            // Build tables for sky/person/composite
            if (data.sky?.transitsByDate) {
                html += buildSeismographTable('Planetary Weather', data.sky.transitsByDate);
            } else if (data.transitsByDate) {
                html += buildSeismographTable('Planetary Weather', data.transitsByDate);
            }
            if (data.person_a?.chart?.transitsByDate) {
                const personAName = data.person_a?.info?.name || 'Person A';
                html += buildSeismographTable(personAName, data.person_a.chart.transitsByDate);
            }
            
            if (data.person_b?.chart?.transitsByDate) {
                const personBName = data.person_b?.info?.name || 'Person B';
                html += buildSeismographTable(personBName, data.person_b.chart.transitsByDate);
            }
            
            if (data.composite?.transitsByDate) {
                html += buildSeismographTable('Composite', data.composite.transitsByDate);
            }
            
            if (data.synastry?.transitsByDate) {
                html += buildSeismographTable('Synastry Transits', data.synastry.transitsByDate);
            }
            
            // Mobile cards view (hidden by default)
            html += '<div id="seismographMobileView" class="hidden">';
            if (data.sky?.transitsByDate || data.transitsByDate) {
                const map = data.sky?.transitsByDate || data.transitsByDate;
                html += buildMobileSeismographCards('Planetary Weather', map);
            }
            if (data.person_a?.chart?.transitsByDate) {
                const personAName = data.person_a?.info?.name || 'Person A';
                html += buildMobileSeismographCards(personAName, data.person_a.chart.transitsByDate);
            }
            if (data.person_b?.chart?.transitsByDate) {
                const personBName = data.person_b?.info?.name || 'Person B';
                html += buildMobileSeismographCards(personBName, data.person_b.chart.transitsByDate);
            }
            if (data.composite?.transitsByDate) {
                html += buildMobileSeismographCards('Composite', data.composite.transitsByDate);
            }
            if (data.synastry?.transitsByDate) {
                html += buildMobileSeismographCards('Synastry Transits', data.synastry.transitsByDate);
            }
            html += '</div>';
            
            html += '</div>'; // Close seismographViewContainer
            html += '</div>'; // Close seismograph-content-area
            html += '</div>'; // Close space-y-6
            return html;
        }

        function buildSeismographFilters() {
            return `
                <div id="seismographFiltersPanel" class="hidden mt-4 p-4 bg-gray-700 rounded border">
                    <h4 class="text-sm font-semibold text-blue-300 mb-3">Filter Thresholds</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-xs">
                        <div>
                            <label class="block text-gray-300 mb-1">Min Magnitude</label>
                            <input type="range" id="filterMinMagnitude" min="0" max="10" step="0.1" value="0" 
                                   class="w-full accent-blue-500">
                            <span id="filterMinMagnitudeValue" class="text-blue-300">0.0</span>
                        </div>
                        <div>
                            <label class="block text-gray-300 mb-1">Min Valence</label>
                            <input type="range" id="filterMinValence" min="-5" max="5" step="0.1" value="-5" 
                                   class="w-full accent-blue-500">
                            <span id="filterMinValenceValue" class="text-blue-300">-5.0</span>
                        </div>
                        <div>
                            <label class="block text-gray-300 mb-1">Max Valence</label>
                            <input type="range" id="filterMaxValence" min="-5" max="5" step="0.1" value="5" 
                                   class="w-full accent-blue-500">
                            <span id="filterMaxValenceValue" class="text-blue-300">5.0</span>
                        </div>
                        <div>
                            <label class="block text-gray-300 mb-1">Min Volatility</label>
                            <input type="range" id="filterMinVolatility" min="0" max="5" step="0.1" value="0" 
                                   class="w-full accent-blue-500">
                            <span id="filterMinVolatilityValue" class="text-blue-300">0.0</span>
                        </div>
                        <div class="md:col-span-4 mt-1">
                            <label class="inline-flex items-center gap-2 text-[11px] font-medium text-gray-300 select-none">
                                <input id="poeticFlagsToggle" type="checkbox" class="rounded border-gray-600 bg-gray-800 text-teal-500 focus:ring-teal-500">
                                <span>Include <span class="text-teal-300 font-semibold">Poetic Prep Flags</span> (salience prompts – not geometry)</span>
                            </label>
                            <p class="text-[10px] text-gray-400 mt-1 leading-snug">Filtering adjusts interpretation scope. Math Brain mirrors raw geometry; enabling flags adds optional prompts for the downstream Poetic Brain without altering calculations.</p>
                        </div>
                    </div>
                    <div class="mt-3 flex gap-2">
                        <button id="applySeismographFilters" class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
                            Apply Filters
                        </button>
                        <button id="resetSeismographFilters" class="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700">
                            Reset
                        </button>
                    </div>
                </div>`;
        }

        function buildSeismographTable(title, dailyMap) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) {
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title}</h4>
                    <p class="text-gray-400">No transit data available for this period.</p>
                </div>`;
            }
            
            const dates = Object.keys(dailyMap).sort();
            
            let html = `
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-lg font-semibold text-yellow-300">${title}</h4>
                        <button onclick="downloadSeismographCSV('${title}', window.seismographData)" 
                                class="px-2 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700">
                            📄 CSV
                        </button>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm border border-gray-600 rounded seismograph-table">
                            <thead class="bg-gray-700">
                                <tr class="text-[11px] uppercase tracking-wide">
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Date</th>
                                    <th class="px-3 py-2 text-right text-teal-300 border-b border-gray-600 align-bottom">Magnitude<br><span class="text-[10px] normal-case font-normal text-gray-400">Field Intensity</span></th>
                                    <th colspan="2" class="px-3 py-1 text-center text-amber-300 border-b border-gray-600 align-bottom">Modifiers<br><span class="text-[10px] normal-case font-normal text-gray-400">Tone & Turbulence (independent)</span></th>
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Top Hooks</th>
                                </tr>
                                <tr class="text-[11px] tracking-wide bg-gray-700/80">
                                    <th></th>
                                    <th class="text-right text-gray-400 font-normal">⚡ Mag</th>
                                    <th class="text-right text-gray-400 font-normal">↗︎ Val</th>
                                    <th class="text-right text-gray-400 font-normal">📊 Vol</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>`;
            
            // Shape normalizer so UI accepts either flat or nested channel payloads
            function normalizeEntry(e){
                const seismograph = e.seismograph ?? { magnitude: e.magnitude, valence: e.valence, version: 'v1.0' };
                const balance = e.balance ?? (
                    (Number.isFinite(e.balance_valence) || Number.isFinite(e.balanceMagnitude))
                        ? { magnitude: e.balanceMagnitude ?? seismograph.magnitude, valence: e.balance_valence, version: 'v1.1' }
                        : undefined
                );
                const sfd = e.sfd ?? (
                    (Number.isFinite(e.sfd_value) || Number.isFinite(e.splus) || Number.isFinite(e.sminus) || Number.isFinite(e.sfd))
                        ? { sfd: e.sfd ?? e.sfd_value, sPlus: e.splus ?? e.Splus, sMinus: e.sminus ?? e.Sminus, version: 'v1.2' }
                        : undefined
                );
                return { ...e, seismograph, balance, sfd };
            }

            const healthByDate = (typeof window !== 'undefined' && window.WM_HEALTH_BY_DATE) ? window.WM_HEALTH_BY_DATE : null;
            dates.forEach(date => {
                const dayRaw = dailyMap[date];
                if (!dayRaw) return;
                const day = normalizeEntry(dayRaw);
                
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                // Compact summary line with optional Balance/SFD
                const fmtSigned = (n)=>`${n>=0?'+':''}${n.toFixed(1)}`;
                let summary = `Mag ${mag} · Val ${fmtSigned(parseFloat(val))}`;
                if (day.balance && Number.isFinite(day.balance.valence)) summary += ` | Bal ${fmtSigned(day.balance.valence)}`;
                if (day.sfd && Number.isFinite(day.sfd.sfd)) {
                    const sp = Number.isFinite(day.sfd.sPlus) ? day.sfd.sPlus.toFixed(1) : '0.0';
                    const sm = Number.isFinite(day.sfd.sMinus) ? day.sfd.sMinus.toFixed(1) : '0.0';
                    summary += ` | SFD ${fmtSigned(day.sfd.sfd)} (S+${sp}/S−${sm})`;
                }
                
                // Get top 3 hooks
                const hooks = (day.hooks || []).slice(0, 3);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || h.p1_display || '?'} ${h.aspect || h._aspect || '?'} ${h.p2_name || h.p2_display || '?'}`).join(', ')
                    : '—';
                
                // Optional correlation score (raw data only - no salience labels)
                let badge = '';
                if (healthByDate) {
                    const hb = healthByDate[date];
                    if (hb) {
                        const sObj = { magnitude: parseFloat(mag), valence: parseFloat(val), volatility: parseFloat(vol) };
                        try {
                            const score = calculateCorrelationScore(sObj, hb);
                            // Show correlation score without automatic salience interpretation
                            // User must determine if correlation reflects lived experience
                            if (score >= 0.45) {
                                const detail = Object.keys(hb).map(k=>`${k}:${hb[k]}`).join(', ');
                                badge = `<span class="ml-2 text-[10px] px-1.5 py-0.5 rounded bg-gray-600 text-gray-300" title="health: ${detail}; correlation=${score.toFixed(3)}">r=${score.toFixed(2)}</span>`;
                            }
                        } catch(_){}
                    }
                }

                // Reduced semantic coloring – keep magnitude emphasis only (valence annotation neutral)
                const magColor = parseFloat(mag) > 7 ? 'text-red-400' : parseFloat(mag) > 5 ? 'text-yellow-400' : 'text-teal-300';
                const valColor = 'text-gray-300';
                const volColor = 'text-gray-300';
                
                // Enhanced valence display with emoji
                const valenceEmoji = getValenceEmoji(parseFloat(val));
                const valenceDisplay = `${valenceEmoji} ${val}`;
                
                html += `
                    <tr class="hover:bg-gray-700 transition-colors">
                        <td class="px-3 py-2 border-b border-gray-700 text-teal-300 whitespace-nowrap">${date} ${badge}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${magColor}" title="Symbolic field scalar (independent)">${mag}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${valColor}" title="Directional tone: ${getValenceType(parseFloat(val))}">${valenceDisplay}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${volColor}" title="Turbulence / spread of activation">${vol}<br><span class="text-[10px] text-gray-400">${summary}</span></td>
                        <td class="px-3 py-2 border-b border-gray-700 text-gray-300 text-xs" title="${hookText}">${hookText.length > 50 ? hookText.substring(0, 50) + '...' : hookText}</td>
                    </tr>`;
            });
            
            html += `
                            </tbody>
                        </table>
                        <div class="mt-2 text-[10px] text-gray-400 flex flex-col gap-1 leading-snug">
                            <div><span class="text-teal-300 font-semibold">Magnitude</span> = field intensity (hook density + weighted alignment). Not computed from Valence or Volatility.</div>
                            <div><span class="text-amber-300 font-semibold">Valence</span> = net directional tone. <span class="text-amber-300 font-semibold">Volatility</span> = turbulence / variance. Both modify lived experience of the field but do not derive it.</div>
                            <div>Three independent dials → mirror first, interpret later. <span class="text-gray-300">Mirror, not mandate.</span></div>
                        </div>
                    </div>
                </div>`;
            
            return html;
        }

        function buildSeismographTableFiltered(title, dailyMap, filters) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) {
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title}</h4>
                    <p class="text-gray-400">No transit data available for this period.</p>
                </div>`;
            }
            
            const dates = Object.keys(dailyMap).sort();
            
            // Filter dates based on seismograph values
            const filteredDates = dates.filter(date => {
                const day = dailyMap[date];
                if (!day || !day.seismograph) return false;
                
                const mag = day.seismograph.magnitude || 0;
                const val = day.seismograph.valence || 0;
                const vol = day.seismograph.volatility || 0;
                
                return mag >= filters.minMagnitude &&
                       val >= filters.minValence &&
                       val <= filters.maxValence &&
                       vol >= filters.minVolatility;
            });
            
            let html = `
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-lg font-semibold text-yellow-300">${title}</h4>
                        <div class="flex gap-2 items-center">
                            <span class="text-xs text-blue-400">Filtered: ${filteredDates.length}/${dates.length}</span>
                            <button onclick="downloadSeismographCSV('${title}', window.seismographData)" 
                                    class="px-2 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700">
                                📄 CSV
                            </button>
                        </div>
                    </div>`;
                    
            if (filteredDates.length === 0) {
                html += `<p class="text-orange-400 text-sm">No dates match current filter criteria.</p></div>`;
                return html;
            }
            
            html += `
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm border border-gray-600 rounded seismograph-table">
                            <thead class="bg-gray-700">
                                <tr class="text-[11px] uppercase tracking-wide">
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Date</th>
                                    <th class="px-3 py-2 text-right text-teal-300 border-b border-gray-600 align-bottom">Magnitude<br><span class="text-[10px] normal-case font-normal text-gray-400">Field Intensity</span></th>
                                    <th colspan="2" class="px-3 py-1 text-center text-amber-300 border-b border-gray-600 align-bottom">Modifiers<br><span class="text-[10px] normal-case font-normal text-gray-400">Tone & Turbulence (independent)</span></th>
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Top Hooks</th>
                                </tr>
                                <tr class="text-[11px] tracking-wide bg-gray-700/80">
                                    <th></th>
                                    <th class="text-right text-gray-400 font-normal">⚡ Mag</th>
                                    <th class="text-right text-gray-400 font-normal">↗︎ Val</th>
                                    <th class="text-right text-gray-400 font-normal">📊 Vol</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>`;
            
            const healthByDate = (typeof window !== 'undefined' && window.WM_HEALTH_BY_DATE) ? window.WM_HEALTH_BY_DATE : null;
            filteredDates.forEach(date => {
                const day = dailyMap[date];
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                const hooks = (day.hooks || []).slice(0, 3);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || h.p1_display || '?'} ${h.aspect || h._aspect || '?'} ${h.p2_name || h.p2_display || '?'}`).join(', ')
                    : '—';
                
                // Optional correlation score (raw data only - no salience labels)
                let badge = '';
                if (healthByDate) {
                    const hb = healthByDate[date];
                    if (hb) {
                        try {
                            const sObj = { magnitude: parseFloat(mag), valence: parseFloat(val), volatility: parseFloat(vol) };
                            const score = calculateCorrelationScore(sObj, hb);
                            // Show correlation score without automatic salience interpretation
                            // User must determine if correlation reflects lived experience
                            if (score >= 0.45) {
                                badge = `<span class="ml-2 text-[10px] px-1.5 py-0.5 rounded bg-gray-600 text-gray-300" title="correlation=${score.toFixed(3)}">r=${score.toFixed(2)}</span>`;
                            }
                        } catch(_){}
                    }
                }

                // Reduced semantic coloring – magnitude only
                const magColor = parseFloat(mag) > 7 ? 'text-red-300 font-bold' : parseFloat(mag) > 5 ? 'text-yellow-400' : 'text-teal-300';
                const valColor = 'text-gray-300';
                const volColor = 'text-gray-300';
                
                // Enhanced valence display with emoji
                const valenceEmoji = getValenceEmoji(parseFloat(val));
                const valenceDisplay = `${valenceEmoji} ${val}`;
                
                html += `
                    <tr class="hover:bg-gray-700 transition-colors">
                        <td class="px-3 py-2 border-b border-gray-700 text-teal-300 whitespace-nowrap">${date} ${badge}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${magColor}" title="Symbolic field scalar (independent)">${mag}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${valColor}" title="Directional tone: ${getValenceType(parseFloat(val))}">${valenceDisplay}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${volColor}" title="Turbulence / spread of activation">${vol}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-gray-300 text-xs" title="${hookText}">${hookText.length > 50 ? hookText.substring(0, 50) + '...' : hookText}</td>
                    </tr>`;
            });
            
            html += `
                            </tbody>
                        </table>
                        <div class="mt-2 text-[10px] text-gray-400 flex flex-col gap-1 leading-snug">
                            <div><span class="text-teal-300 font-semibold">Magnitude</span> = field intensity (hook density + weighted alignment). Independent axis.</div>
                            <div><span class="text-amber-300 font-semibold">Valence</span> = directional tone; <span class="text-amber-300 font-semibold">Volatility</span> = turbulence. Modify experience, not source magnitude.</div>
                            <div>Three dials; no derivation chain. <span class="text-gray-300">Mirror first → interpret later.</span></div>
                        </div>
                    </div>
                </div>`;
            
            return html;
        }

        function buildMobileSeismographCardsFiltered(title, dailyMap, filters) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) return '';
            
            const dates = Object.keys(dailyMap).sort();
            
            // Filter dates
            const filteredDates = dates.filter(date => {
                const day = dailyMap[date];
                if (!day || !day.seismograph) return false;

                const mag = day.seismograph.magnitude || 0;
                const val = day.seismograph.valence || 0;
                const vol = day.seismograph.volatility || 0;

                return mag >= filters.minMagnitude &&
                       val >= filters.minValence &&
                       val <= filters.maxValence &&
                       vol >= filters.minVolatility;
            });
            
            if (filteredDates.length === 0) {
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} - Mobile View</h4>
                    <p class="text-orange-400 text-sm">No dates match current filter criteria.</p>
                </div>`;
            }
            
            let html = `<div class="mb-6">
                <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} - Mobile View (${filteredDates.length}/${dates.length})</h4>
                <div class="space-y-3">`;

            filteredDates.forEach(date => {
                const rawDay = dailyMap[date];
                if (!rawDay) return;
                
                const day = normalizeEntry(rawDay);
                const channelLine = tripleChannelLine({ 
                    seismograph: day.seismograph, 
                    balance: day.balance, 
                    sfd: day.sfd 
                });
                
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                const hooks = (day.hooks || []).slice(0, 2);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || '?'} ${h.aspect || '?'} ${h.p2_name || '?'}`).join('<br>')
                    : 'No significant hooks';
                
                // Color coding for cards
                const cardClass = parseFloat(mag) > 7 ? 'border-red-500' : parseFloat(mag) > 5 ? 'border-yellow-500' : 'border-teal-500';
                
                html += `
                    <div class="bg-gray-700 p-3 rounded border-l-4 ${cardClass} swipeable-card">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-teal-300 font-semibold">${date}</span>
                            <div class="text-xs text-gray-400">
                                M:${mag} V:${val} Vol:${vol}
                            </div>
                        </div>
                        <div class="text-[10px] text-gray-300 mt-1" title="Triple Channel Summary">${channelLine}</div>
                        <div class="text-sm text-gray-300">${hookText}</div>
                    </div>`;
            });
            
            html += `</div></div>`;
            return html;
        }

        function buildMobileSeismographCards(title, dailyMap) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) return '';
            
            const dates = Object.keys(dailyMap).sort();
            
            let html = `<div class="mb-6">
                <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} - Mobile View</h4>
                <div class="space-y-3">`;
            
            dates.forEach(date => {
                const rawDay = dailyMap[date];
                if (!rawDay) return;
                
                const day = normalizeEntry(rawDay);
                const channelLine = tripleChannelLine({ 
                    seismograph: day.seismograph, 
                    balance: day.balance, 
                    sfd: day.sfd 
                });
                
                // Shorter version for mobile
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                const hooks = (day.hooks || []).slice(0, 2);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || '?'} ${h.aspect || '?'} ${h.p2_name || '?'}`).join('<br>')
                    : 'No significant hooks';
                
                html += `
                    <div class="bg-gray-700 p-3 rounded border-l-4 border-teal-500 swipeable-card">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-teal-300 font-semibold">${date}</span>
                            <div class="text-xs text-gray-400">
                                M:${mag} V:${val} Vol:${vol}
                            </div>
                        </div>
                        <div class="text-[10px] text-gray-300 mt-1" title="Triple Channel Summary">${channelLine}</div>
                        <div class="text-sm text-gray-300">${hookText}</div>
                    </div>`;
            });
            
            html += `</div></div>`;
            return html;
        }

        function downloadSeismographCSV(title, data) {
            const dailyMap = title === 'Person A' ? data?.person_a?.chart?.transitsByDate :
                           title === 'Person B' ? data?.person_b?.chart?.transitsByDate :
                           title === 'Composite' ? data?.composite?.transitsByDate :
                           title === 'Synastry Transits' ? data?.synastry?.transitsByDate : null;
            
            if (!dailyMap) {
                console.warn('No data available for CSV export:', title);
                return;
            }
            
            const dates = Object.keys(dailyMap).sort();
            let csv = 'Date,mag_v1_0,val_v1_0,vol,scale_confidence,bal_val_v1_1,sfd_v1_2,splus_v1_2,sminus_v1_2,calibration_boundary,reconstructed,engine_versions,Top_Hooks\n';
            
            const boundary = (window.seismographData && window.seismographData.provenance && window.seismographData.provenance.calibration_boundary) || '';
            const reconstructed = (window.seismographData && window.seismographData.reconstructed) ? 'true' : '';
            const engines = (window.seismographData && window.seismographData.provenance && window.seismographData.provenance.engine_versions) || null;
            const enginesJson = engines ? JSON.stringify(engines).replace(/"/g, '""') : '';

            dates.forEach(date => {
                const rawDay = dailyMap[date];
                if (!rawDay) return;
                
                const day = normalizeEntry(rawDay);
                const mag = (day.seismograph?.magnitude ?? '').toString();
                const val = (day.seismograph?.valence ?? '').toString();
                const vol = (day.seismograph?.volatility ?? '').toString();
                const conf = (day.seismograph?.scaleConfidence ?? '').toString();
                const bal = (day.balance && Number.isFinite(day.balance.valence)) ? day.balance.valence.toString() : '';
                const sfd = (day.sfd && Number.isFinite(day.sfd.sfd)) ? day.sfd.sfd.toString() : '';
                const splus = (day.sfd && Number.isFinite(day.sfd.sPlus)) ? day.sfd.sPlus.toString() : '';
                const sminus = (day.sfd && Number.isFinite(day.sfd.sMinus)) ? day.sfd.sMinus.toString() : '';

                const hooks = (day.hooks || []).slice(0, 3);
                const hookText = hooks.map(h => `${h.p1_name || '?'} ${h.aspect || '?'} ${h.p2_name || '?'}`).join('; ');
                const hookEsc = `"${hookText.replace(/"/g,'""')}"`;

                csv += `${date},${mag},${val},${vol},${conf},${bal},${sfd},${splus},${sminus},${boundary},${reconstructed},"${enginesJson}",${hookEsc}\n`;
            });
            
            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `seismograph_${title.replace(/\s+/g, '_')}_${timestamp}.csv`;
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadAllSeismographData() {
            if (!window.seismographData) {
                console.warn('No seismograph data available for export');
                return;
            }
            
            const data = window.seismographData;
            const timestamp = new Date().toISOString().slice(0, 10);
            
            // Download individual CSVs
            if (data.person_a?.chart?.transitsByDate) {
                downloadSeismographCSV('Person A', data);
            }
            if (data.person_b?.chart?.transitsByDate) {
                downloadSeismographCSV('Person B', data);
            }
            if (data.composite?.transitsByDate) {
                downloadSeismographCSV('Composite', data);
            }
            if (data.synastry?.transitsByDate) {
                downloadSeismographCSV('Synastry Transits', data);
            }
        }

        // --- Seismograph Analysis Queue & Voice Synthesis Layer ---
        let seismographAnalysisQueue = [];
        let seismographAnalysisRunning = false;
        function queueSeismographAnalysis(){
            seismographAnalysisQueue.push(Date.now());
            const btn = document.getElementById('queueSeismographAnalysis');
            if(btn){
                const original = btn.dataset.labelOriginal || btn.textContent.trim();
                btn.dataset.labelOriginal = original;
                btn.textContent = '⏳ Queued…';
                btn.disabled = true;
                btn.classList.add('opacity-70','cursor-wait');
            }
            processSeismographAnalysisQueue();
        }
        function processSeismographAnalysisQueue(){
            if(seismographAnalysisRunning) return;
            if(!seismographAnalysisQueue.length) return;
            seismographAnalysisRunning = true;
            seismographAnalysisQueue.shift();
            setTimeout(()=>{ // simulate async batch
                detectSeismographPatterns();
                seismographAnalysisRunning = false;
                const btn = document.getElementById('queueSeismographAnalysis');
                if(btn){
                    btn.textContent = '✅ Analysis Complete';
                    setTimeout(()=>{
                        btn.textContent = '📦 Queue Analysis';
                        btn.disabled = false;
                        btn.classList.remove('opacity-70','cursor-wait');
                    },1400);
                }
                synthesizeRavenVoiceFromPatterns();
                if(seismographAnalysisQueue.length) processSeismographAnalysisQueue();
            }, 60);
        }
        function synthesizeRavenVoiceFromPatterns(){
            const panel = document.getElementById('ravenVoicePanel');
            const content = document.getElementById('ravenVoiceContent');
            if(!panel||!content) return;
            const patterns = window.latestSeismographPatterns || [];
            if(!patterns.length){
                panel.classList.remove('hidden');
                content.innerHTML = 'No significant macro pattern clusters. Geometry baseline steady; micro hooks carry modulation.';
                return;
            }
            const top = patterns.slice(0,3).map(p=>`<span class=\"text-teal-300\">${p.subject}</span>: ${p.description}`).join('<br>');
            content.innerHTML = `<div class=\"space-y-2\">${top}<div class=\"text-[10px] text-gray-400 pt-1 border-t border-gray-700\">VOICE = optional synthesis. FIELD/MAP (tables & charts) remain falsifiable core.</div></div>`;
            panel.classList.remove('hidden');
        }
        // Tooltip helpers (foundation for future richer contextual hovers)
        function attachSeismographTooltip(el,text){ if(!el) return; el.addEventListener('mouseenter',e=>showGlobalTooltip(e,text)); el.addEventListener('mouseleave', hideGlobalTooltip); el.addEventListener('mousemove', moveGlobalTooltip); }
        function showGlobalTooltip(e,text){ const t=document.getElementById('globalHoverTooltip'); if(!t) return; t.innerHTML=text; t.style.display='block'; moveGlobalTooltip(e);} 
        function moveGlobalTooltip(e){ const t=document.getElementById('globalHoverTooltip'); if(!t) return; const pad=12; t.style.left=(e.clientX+pad)+'px'; t.style.top=(e.clientY+pad)+'px'; }
        function hideGlobalTooltip(){ const t=document.getElementById('globalHoverTooltip'); if(t) t.style.display='none'; }

        function detectSeismographPatterns(data) {
            if (!data) data = window.seismographData;
            if (!data) return;
            
            let patterns = [];
            
            // Analyze each dataset
            ['person_a', 'person_b', 'composite'].forEach(key => {
                const dailyMap = data[key]?.chart?.transitsByDate;
                if (!dailyMap) return;
                
                const name = key === 'person_a' ? 'Person A' : 
                           key === 'person_b' ? 'Person B' : 'Composite';
                
                const dates = Object.keys(dailyMap).sort();
                const values = dates.map(date => ({
                    date,
                    magnitude: dailyMap[date].seismograph?.magnitude || 0,
                    valence: dailyMap[date].seismograph?.valence || 0,
                    volatility: dailyMap[date].seismograph?.volatility || 0
                }));
                
                if (values.length < 3) return; // Need at least 3 days for meaningful analysis
                
                // 1. Detect valence trends (more sensitive threshold)
                const valenceTrend = detectTrend(values.map(v => v.valence));
                if (Math.abs(valenceTrend) > 0.05) { // Lowered from 0.1 to catch subtler trends
                    const strength = Math.abs(valenceTrend);
                    const direction = valenceTrend > 0 ? 'Increasing ease/flow' : 'Increasing tension/friction';
                    patterns.push({
                        type: 'valence_trend',
                        subject: name,
                        description: `${direction} (${strength.toFixed(3)} units/day)`,
                        strength: strength,
                        priority: strength > 0.2 ? 'high' : strength > 0.1 ? 'medium' : 'low'
                    });
                }
                
                // 2. Detect magnitude trends
                const magnitudeTrend = detectTrend(values.map(v => v.magnitude));
                if (Math.abs(magnitudeTrend) > 0.1) { // Magnitude trends need to be more significant
                    const direction = magnitudeTrend > 0 ? 'Intensifying' : 'Subsiding';
                    patterns.push({
                        type: 'magnitude_trend',
                        subject: name,
                        description: `${direction} activation levels (${Math.abs(magnitudeTrend).toFixed(3)} units/day)`,
                        strength: Math.abs(magnitudeTrend),
                        priority: Math.abs(magnitudeTrend) > 0.3 ? 'high' : 'medium'
                    });
                }
                
                // 3. Detect volatility spikes (high volatility periods)
                const highVolatilityDays = values.filter(v => v.volatility > 3.5).length;
                if (highVolatilityDays > Math.max(2, dates.length * 0.2)) {
                    patterns.push({
                        type: 'volatility_spike',
                        subject: name,
                        description: `High volatility period (${highVolatilityDays}/${dates.length} days above 3.5)`,
                        intensity: highVolatilityDays / dates.length,
                        priority: highVolatilityDays > dates.length * 0.5 ? 'high' : 'medium'
                    });
                }
                
                // 4. Detect sustained high magnitude
                const highMagCount = values.filter(v => v.magnitude > 5.5).length; // Lowered from 6.0
                if (highMagCount > Math.max(2, dates.length * 0.25)) {
                    patterns.push({
                        type: 'sustained_pressure',
                        subject: name,
                        description: `Sustained high activation (${highMagCount}/${dates.length} days above 5.5)`,
                        intensity: highMagCount / dates.length,
                        priority: highMagCount > dates.length * 0.5 ? 'high' : 'medium'
                    });
                }
                
                // 5. Detect sustained low activity (potential stagnation)
                const lowMagCount = values.filter(v => v.magnitude < 1.5).length;
                if (lowMagCount > Math.max(3, dates.length * 0.4)) {
                    patterns.push({
                        type: 'low_activity',
                        subject: name,
                        description: `Extended quiet period (${lowMagCount}/${dates.length} days below 1.5)`,
                        intensity: lowMagCount / dates.length,
                        priority: 'low'
                    });
                }
                
                // 6. Detect extreme valence periods
                const extremePositiveCount = values.filter(v => v.valence > 3.0).length;
                const extremeNegativeCount = values.filter(v => v.valence < -3.0).length;
                
                if (extremePositiveCount > Math.max(2, dates.length * 0.2)) {
                    patterns.push({
                        type: 'extreme_ease',
                        subject: name,
                        description: `Extended ease period (${extremePositiveCount}/${dates.length} days above +3.0 valence)`,
                        intensity: extremePositiveCount / dates.length,
                        priority: 'medium'
                    });
                }
                
                if (extremeNegativeCount > Math.max(2, dates.length * 0.2)) {
                    patterns.push({
                        type: 'extreme_tension',
                        subject: name,
                        description: `Extended friction period (${extremeNegativeCount}/${dates.length} days below -3.0 valence)`,
                        intensity: extremeNegativeCount / dates.length,
                        priority: extremeNegativeCount > dates.length * 0.4 ? 'high' : 'medium'
                    });
                }
                
                // 7. Detect cycles (improved algorithm)
                const magnitudeCycle = detectCyclePeriod(values.map(v => v.magnitude));
                if (magnitudeCycle > 0 && magnitudeCycle <= dates.length / 2) {
                    patterns.push({
                        type: 'magnitude_cycle',
                        subject: name,
                        description: `${magnitudeCycle}-day activation cycle detected`,
                        period: magnitudeCycle,
                        priority: magnitudeCycle >= 7 && magnitudeCycle <= 14 ? 'high' : 'medium' // Weekly/bi-weekly cycles are significant
                    });
                }
                
                // 8. Detect volatility stability
                const avgVolatility = values.reduce((sum, v) => sum + v.volatility, 0) / values.length;
                const volatilityStdDev = Math.sqrt(values.reduce((sum, v) => sum + Math.pow(v.volatility - avgVolatility, 2), 0) / values.length);
                
                if (volatilityStdDev < 0.5 && avgVolatility < 2.0) {
                    patterns.push({
                        type: 'stable_period',
                        subject: name,
                        description: `Stable energy pattern (low volatility variation: ${volatilityStdDev.toFixed(2)})`,
                        stability: 1 - volatilityStdDev,
                        priority: 'low'
                    });
                }
            });
            
            // Sort patterns by priority and strength
            patterns.sort((a, b) => {
                const priorityOrder = { high: 3, medium: 2, low: 1 };
                const aPriority = priorityOrder[a.priority] || 1;
                const bPriority = priorityOrder[b.priority] || 1;
                
                if (aPriority !== bPriority) return bPriority - aPriority;
                
                // Secondary sort by strength/intensity
                const aStrength = a.strength || a.intensity || 0;
                const bStrength = b.strength || b.intensity || 0;
                return bStrength - aStrength;
            });
            
            displaySeismographPatterns(patterns);
            window.latestSeismographPatterns = patterns;
        }

        function detectTrend(values) {
            if (values.length < 3) return 0;
            
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            
            values.forEach((y, x) => {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            });
            
            const n = values.length;
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            return slope;
        }

        function detectCyclePeriod(values) {
            if (values.length < 6) return 0;
            
            // Simple autocorrelation to detect cycles
            let bestPeriod = 0;
            let bestCorrelation = 0;
            
            for (let period = 2; period <= Math.floor(values.length / 2); period++) {
                let correlation = 0;
                let count = 0;
                
                for (let i = 0; i < values.length - period; i++) {
                    correlation += values[i] * values[i + period];
                    count++;
                }
                
                correlation /= count;
                
                if (correlation > bestCorrelation) {
                    bestCorrelation = correlation;
                    bestPeriod = period;
                }
            }
            
            return bestCorrelation > 0.5 ? bestPeriod : 0;
        }

        function displaySeismographPatterns(patterns) {
            const container = document.getElementById('seismographPatterns');
            if (!container) return;
            
            if (patterns.length === 0) {
                container.innerHTML = `
                    <div class="bg-gray-800 p-4 rounded border border-gray-600 mb-4">
                        <h4 class="text-purple-300 font-semibold mb-2">Pattern Analysis</h4>
                        <p class="text-gray-400">No significant patterns detected in current data.</p>
                    </div>`;
                return;
            }
            
            // Group patterns by priority
            const groupedPatterns = {
                high: patterns.filter(p => p.priority === 'high'),
                medium: patterns.filter(p => p.priority === 'medium'),
                low: patterns.filter(p => p.priority === 'low')
            };
            
            let html = `
                <div class="bg-gray-800 p-4 rounded border border-purple-500 mb-4">
                    <h4 class="text-purple-300 font-semibold mb-3">🔮 Pattern Detection Results (${patterns.length} patterns found)</h4>`;
            
            // High priority patterns
            if (groupedPatterns.high.length > 0) {
                html += `
                    <div class="mb-4">
                        <h5 class="text-red-300 font-semibold mb-2 flex items-center">
                            🚨 High Priority Patterns (${groupedPatterns.high.length})
                        </h5>
                        <div class="space-y-2">`;
                
                groupedPatterns.high.forEach(pattern => {
                    const typeColor = getPatternTypeColor(pattern.type);
                    const typeIcon = getPatternTypeIcon(pattern.type);
                    
                    html += `
                        <div class="bg-red-900/20 border border-red-500/30 p-3 rounded pattern-card">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold ${typeColor}">${typeIcon} ${pattern.subject}</span>
                                <span class="text-xs text-red-300 bg-red-800/50 px-2 py-1 rounded">${pattern.type.replace(/_/g, ' ')}</span>
                            </div>
                            <p class="text-sm text-gray-200 mt-1">${pattern.description}</p>
                        </div>`;
                });
                
                html += `</div></div>`;
            }
            
            // Medium priority patterns
            if (groupedPatterns.medium.length > 0) {
                html += `
                    <div class="mb-4">
                        <h5 class="text-yellow-300 font-semibold mb-2 flex items-center">
                            ⚠️ Medium Priority Patterns (${groupedPatterns.medium.length})
                        </h5>
                        <div class="space-y-2">`;
                
                groupedPatterns.medium.forEach(pattern => {
                    const typeColor = getPatternTypeColor(pattern.type);
                    const typeIcon = getPatternTypeIcon(pattern.type);
                    
                    html += `
                        <div class="bg-yellow-900/20 border border-yellow-500/30 p-3 rounded pattern-card">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold ${typeColor}">${typeIcon} ${pattern.subject}</span>
                                <span class="text-xs text-yellow-300 bg-yellow-800/50 px-2 py-1 rounded">${pattern.type.replace(/_/g, ' ')}</span>
                            </div>
                            <p class="text-sm text-gray-200 mt-1">${pattern.description}</p>
                        </div>`;
                });
                
                html += `</div></div>`;
            }
            
            // Low priority patterns (collapsible)
            if (groupedPatterns.low.length > 0) {
                html += `
                    <div class="mb-4">
                        <h5 class="text-gray-300 font-semibold mb-2 flex items-center cursor-pointer" onclick="toggleLowPriorityPatterns()">
                            <span id="lowPriorityToggle">▶</span> Low Priority Patterns (${groupedPatterns.low.length})
                        </h5>
                        <div id="lowPriorityPatterns" class="hidden space-y-2">`;
                
                groupedPatterns.low.forEach(pattern => {
                    const typeColor = getPatternTypeColor(pattern.type);
                    const typeIcon = getPatternTypeIcon(pattern.type);
                    
                    html += `
                        <div class="bg-gray-700/50 border border-gray-500/30 p-3 rounded pattern-card">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold ${typeColor}">${typeIcon} ${pattern.subject}</span>
                                <span class="text-xs text-gray-400 bg-gray-600/50 px-2 py-1 rounded">${pattern.type.replace(/_/g, ' ')}</span>
                            </div>
                            <p class="text-sm text-gray-300 mt-1">${pattern.description}</p>
                        </div>`;
                });
                
                html += `</div></div>`;
            }
            
            html += `</div>`;
            container.innerHTML = html;
        }

        function getPatternTypeColor(type) {
            const colors = {
                valence_trend: 'text-blue-400',
                magnitude_trend: 'text-red-400',
                volatility_spike: 'text-orange-400',
                sustained_pressure: 'text-red-300',
                low_activity: 'text-gray-400',
                extreme_ease: 'text-green-400',
                extreme_tension: 'text-red-400',
                magnitude_cycle: 'text-purple-400',
                stable_period: 'text-teal-400'
            };
            return colors[type] || 'text-gray-300';
        }

        function getPatternTypeIcon(type) {
            const icons = {
                valence_trend: '📈',
                magnitude_trend: '⚡',
                volatility_spike: '📊',
                sustained_pressure: '🔥',
                low_activity: '😴',
                extreme_ease: '🌟',
                extreme_tension: '⚠️',
                magnitude_cycle: '🔄',
                stable_period: '🧘'
            };
            return icons[type] || '📊';
        }

        function toggleLowPriorityPatterns() {
            const container = document.getElementById('lowPriorityPatterns');
            const toggle = document.getElementById('lowPriorityToggle');
            
            if (container && toggle) {
                const isHidden = container.classList.contains('hidden');
                
                if (isHidden) {
                    container.classList.remove('hidden');
                    toggle.textContent = '▼';
                } else {
                    container.classList.add('hidden');
                    toggle.textContent = '▶';
                }
            }
        }

        function setupSeismographEventListeners() {
            // Toggle filters
            const toggleFilters = document.getElementById('toggleSeismographFilters');
            const filtersPanel = document.getElementById('seismographFiltersPanel');
            if (toggleFilters && filtersPanel) {
                toggleFilters.addEventListener('click', () => {
                    filtersPanel.classList.toggle('hidden');
                });
            }
            
            // Download all CSV
            const downloadAllBtn = document.getElementById('downloadAllSeismographCSV');
            if (downloadAllBtn) {
                downloadAllBtn.addEventListener('click', downloadAllSeismographData);
            }
            
            // Queue analysis (replaces direct pattern detection trigger)
            const queueBtn = document.getElementById('queueSeismographAnalysis');
            if (queueBtn) {
                queueBtn.addEventListener('click', () => queueSeismographAnalysis());
            }
            
            // Filter controls
            ['MinMagnitude', 'MinValence', 'MaxValence', 'MinVolatility'].forEach(name => {
                const slider = document.getElementById(`filter${name}`);
                const display = document.getElementById(`filter${name}Value`);
                if (slider && display) {
                    slider.addEventListener('input', () => {
                        display.textContent = parseFloat(slider.value).toFixed(1);
                    });
                }
            });
            
            // Apply filters button
            const applyBtn = document.getElementById('applySeismographFilters');
            if (applyBtn) {
                applyBtn.addEventListener('click', applySeismographFilters);
            }
            
            // Reset filters button
            const resetBtn = document.getElementById('resetSeismographFilters');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetSeismographFilters);
            }
            
            // Glossary modal
            const glossaryModal = document.getElementById('seismographGlossaryModal');
            const toggleGlossaryBtn = document.getElementById('toggleGlossary');
            const closeGlossaryBtn = document.getElementById('closeGlossary');
            const closeGlossarySecondaryBtn = document.getElementById('glossary-close-secondary');

            const openGlossary = () => glossaryModal.classList.remove('hidden');
            const closeGlossary = () => glossaryModal.classList.add('hidden');

            if (toggleGlossaryBtn) toggleGlossaryBtn.addEventListener('click', openGlossary);
            if (closeGlossaryBtn) closeGlossaryBtn.addEventListener('click', closeGlossary);
            if (closeGlossarySecondaryBtn) closeGlossarySecondaryBtn.addEventListener('click', closeGlossary);
            if (glossaryModal) glossaryModal.addEventListener('click', (e) => {
                if (e.target === glossaryModal) closeGlossary();
            });

            // Toggle view (chart/table)
            const toggleView = document.getElementById('toggleSeismographView');
            if (toggleView) {
                toggleView.addEventListener('click', toggleSeismographViewMode);
            }
        }

        function applySeismographFilters() {
            if (!window.seismographData) {
                console.warn('No seismograph data available for filtering');
                return;
            }
            
            // Get filter values
            const filters = {
                minMagnitude: parseFloat(document.getElementById('filterMinMagnitude').value),
                minValence: parseFloat(document.getElementById('filterMinValence').value),
                maxValence: parseFloat(document.getElementById('filterMaxValence').value),
                minVolatility: parseFloat(document.getElementById('filterMinVolatility').value)
            };
            
            // Update global filters
            window.seismographFilters = { ...window.seismographFilters, ...filters };
            
            // Re-render tables with filtered data
            const container = document.getElementById('seismographViewContainer');
            if (!container) return;
            
            let html = '';
            
            // Rebuild each table with filtered data
            if (window.seismographData.person_a?.chart?.transitsByDate) {
                const personAName = window.seismographData.person_a?.info?.name || 'Person A';
                html += buildSeismographTableFiltered(personAName, window.seismographData.person_a.chart.transitsByDate, filters);
            }
            
            if (window.seismographData.person_b?.chart?.transitsByDate) {
                const personBName = window.seismographData.person_b?.info?.name || 'Person B';
                html += buildSeismographTableFiltered(personBName, window.seismographData.person_b.chart.transitsByDate, filters);
            }
            
            if (window.seismographData.composite?.transitsByDate) {
                html += buildSeismographTableFiltered('Composite', window.seismographData.composite.transitsByDate, filters);
            }
            
            if (window.seismographData.synastry?.transitsByDate) {
                html += buildSeismographTableFiltered('Synastry Transits', window.seismographData.synastry.transitsByDate, filters);
            }
            
            container.innerHTML = html;
            
            // Also update mobile view
            const mobileContainer = document.getElementById('seismographMobileView');
            if (mobileContainer) {
                let mobileHtml = '';
                
                if (window.seismographData.person_a?.chart?.transitsByDate) {
                    const personAName = window.seismographData.person_a?.info?.name || 'Person A';
                    mobileHtml += buildMobileSeismographCardsFiltered(personAName, window.seismographData.person_a.chart.transitsByDate, filters);
                }
                
                if (window.seismographData.person_b?.chart?.transitsByDate) {
                    const personBName = window.seismographData.person_b?.info?.name || 'Person B';
                    mobileHtml += buildMobileSeismographCardsFiltered(personBName, window.seismographData.person_b.chart.transitsByDate, filters);
                }
                
                if (window.seismographData.composite?.transitsByDate) {
                    mobileHtml += buildMobileSeismographCardsFiltered('Composite', window.seismographData.composite.transitsByDate, filters);
                }
                
                if (window.seismographData.synastry?.transitsByDate) {
                    mobileHtml += buildMobileSeismographCardsFiltered('Synastry Transits', window.seismographData.synastry.transitsByDate, filters);
                }
                
                mobileContainer.innerHTML = mobileHtml;
            }
            
            // Show feedback
            const applyBtn = document.getElementById('applySeismographFilters');
            if (applyBtn) {
                const originalText = applyBtn.textContent;
                applyBtn.textContent = '✅ Applied';
                applyBtn.classList.add('bg-green-600');
                applyBtn.classList.remove('bg-blue-600');
                
                setTimeout(() => {
                    applyBtn.textContent = originalText;
                    applyBtn.classList.remove('bg-green-600');
                    applyBtn.classList.add('bg-blue-600');
                }, 2000);
            }
        }

        function resetSeismographFilters() {
            document.getElementById('filterMinMagnitude').value = 0;
            document.getElementById('filterMinValence').value = -5;
            document.getElementById('filterMaxValence').value = 5;
            document.getElementById('filterMinVolatility').value = 0;
            
            // Update displays
            document.getElementById('filterMinMagnitudeValue').textContent = '0.0';
            document.getElementById('filterMinValenceValue').textContent = '-5.0';
            document.getElementById('filterMaxValenceValue').textContent = '5.0';
            document.getElementById('filterMinVolatilityValue').textContent = '0.0';
        }

        // New dual visualization & render mode cycle =======================================
        function toggleSeismographViewMode() {
            const button = document.getElementById('toggleSeismographView');
            const tableView = document.getElementById('seismographViewContainer');
            const mobileView = document.getElementById('seismographMobileView');
            let chartContainer = document.getElementById('seismographChartContainer');
            if (!button || !tableView || !mobileView) return;
            if (!chartContainer) {
                chartContainer = document.createElement('div');
                chartContainer.id = 'seismographChartContainer';
                chartContainer.className = 'mb-6';
                tableView.parentNode.insertBefore(chartContainer, tableView);
            }
            // Modes: table -> arc -> barometer -> mobile -> table
            const mode = button.getAttribute('data-mode') || 'table';
            const next = mode === 'table' ? 'arc' : mode === 'arc' ? 'barometer' : mode === 'barometer' ? 'mobile' : 'table';
            // Reset visibility
            tableView.classList.add('hidden');
            mobileView.classList.add('hidden');
            chartContainer.classList.add('hidden');
            if (next === 'table') {
                tableView.classList.remove('hidden');
                button.textContent = '🔄 View: Table';
            } else if (next === 'arc') {
                chartContainer.innerHTML = renderSeismographArcCharts();
                chartContainer.classList.remove('hidden');
                button.textContent = '🔄 View: Arc';
            } else if (next === 'barometer') {
                chartContainer.innerHTML = renderBarometerCharts();
                chartContainer.classList.remove('hidden');
                button.textContent = '🔄 View: Barometer';
            } else if (next === 'mobile') {
                mobileView.classList.remove('hidden');
                button.textContent = '🔄 View: Mobile';
            }
            button.setAttribute('data-mode', next);
        }

        function renderSeismographArcCharts() {
            if (!window.seismographData) return '<p>No data.</p>';
            let html = '<div class="space-y-6">';
            if (window.seismographData.person_a?.chart?.transitsByDate) {
                const nm = window.seismographData.person_a?.info?.name || 'Person A';
                html += renderArcChart(nm, window.seismographData.person_a.chart.transitsByDate);
            }
            if (window.seismographData.person_b?.chart?.transitsByDate) {
                const nm = window.seismographData.person_b?.info?.name || 'Person B';
                html += renderArcChart(nm, window.seismographData.person_b.chart.transitsByDate);
            }
            if (window.seismographData.composite?.transitsByDate) {
                html += renderArcChart('Composite', window.seismographData.composite.transitsByDate);
            }
            if (window.seismographData.synastry?.transitsByDate) {
                html += renderArcChart('Synastry Transits', window.seismographData.synastry.transitsByDate);
            }
            html += '</div>';
            return html;
        }

        function renderBarometerCharts() {
            if (!window.seismographData) return '<p>No data.</p>';
            let html = '<div class="space-y-6">';
            if (window.seismographData.person_a?.chart?.transitsByDate) {
                const nm = window.seismographData.person_a?.info?.name || 'Person A';
                html += renderBarometerChart(nm, window.seismographData.person_a.chart.transitsByDate);
            }
            if (window.seismographData.person_b?.chart?.transitsByDate) {
                const nm = window.seismographData.person_b?.info?.name || 'Person B';
                html += renderBarometerChart(nm, window.seismographData.person_b.chart.transitsByDate);
            }
            if (window.seismographData.composite?.transitsByDate) {
                html += renderBarometerChart('Composite', window.seismographData.composite.transitsByDate);
            }
            if (window.seismographData.synastry?.transitsByDate) {
                html += renderBarometerChart('Synastry Transits', window.seismographData.synastry.transitsByDate);
            }
            html += '</div>';
            return html;
        }

        function renderArcChart(title, dailyMap) {
            const dates = Object.keys(dailyMap || {}).sort();
            if (!dates.length) return '';
            const canvasId = `arc-${title.replace(/\s+/g,'-').toLowerCase()}`;
            const html = `<div class="mb-6"><h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} – Macro Arc</h4><div class="bg-gray-800 p-4 rounded border border-gray-600 overflow-x-auto"><canvas id="${canvasId}" width="900" height="260" class="bg-gray-900 rounded" style="min-width: 600px; max-width: 100%;"></canvas></div></div>`;
            setTimeout(()=>drawSeismographArc(canvasId, dailyMap, dates),5);
            return html;
        }

        function renderBarometerChart(title, dailyMap) {
            const dates = Object.keys(dailyMap || {}).sort();
            if (!dates.length) return '';
            // If only a single day, render enriched semantic snapshot instead of generic canvas
            if (dates.length === 1) {
                const d = dates[0];
                const day = dailyMap[d] || {};
                const seismo = day.seismograph || {};
                const magRaw = Number(seismo.magnitude)||0; // original 0..10 scale? earlier we divide by 2 to normalize
                const mag = +(magRaw/2).toFixed(2); // normalized 0..5
                const val = Math.max(-5, Math.min(5, Number(seismo.valence)||0));
                const vol = +(Number(seismo.volatility)||0).toFixed(2);
                const heur = generateBarometerHeuristics(mag, val, vol, day);
                // Color logic based on valence & magnitude
                const color = barometerColorForValence(val, mag);
                // Enhanced gradient with volatility texture
                let gradient;
                if (vol >= 4) {
                    // High volatility: complex scattered gradient 
                    gradient = `radial-gradient(ellipse at 30% 20%, ${color.start} 0%, ${color.end} 45%), linear-gradient(135deg, ${color.start} 0%, ${color.end} 70%, ${color.cap} 100%)`;
                } else if (vol >= 3) {
                    // Medium-high volatility: angular gradient with stops
                    gradient = `linear-gradient(125deg, ${color.start} 0%, ${color.end} 35%, ${color.start} 55%, ${color.end} 70%)`;
                } else if (vol >= 2) {
                    // Variable: enhanced linear with cap
                    gradient = `linear-gradient(135deg, ${color.start} 0%, ${color.end} 60%, ${color.cap} 85%)`;
                } else {
                    // Low volatility: clean linear
                    gradient = `linear-gradient(135deg, ${color.start} 0%, ${color.end} 70%)`;
                }
                const glyphs = heur.glyphs ? `<div class="text-2xl tracking-tight">${heur.glyphs}</div>` : '';
                const annotation = heur.annotation ? `<p class="text-sm italic text-gray-200 mt-2">“${heur.annotation}”</p>` : '';
                const hooks = (day.hooks && Array.isArray(day.hooks) && day.hooks.length) ?
                    `<div class="mt-3 text-xs text-teal-200"><span class="font-semibold text-teal-300">Hook Signature:</span> ${day.hooks.slice(0,5).map(h=>h.label||h.name||h.aspect||'').filter(Boolean).join(' · ')}</div>` : '';
                const scaleConf = (seismo.scaleConfidence!=null) ? `<span class="ml-2 text-[10px] text-gray-400">scale conf ${(+seismo.scaleConfidence).toFixed(2)}</span>` : '';
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} – Daily Barometer</h4>
                    <div class="rounded border border-gray-600 overflow-hidden bg-gray-900">
                        <div class="p-4" style="background:${gradient};">
                            <div class="flex flex-col md:flex-row md:items-start gap-4">
                                <div class="flex-1 min-w-[240px]">
                                    <div class="text-xs uppercase tracking-wide text-gray-300 mb-1">${d}</div>
                                    <h5 class="text-xl font-semibold text-gray-50">${heur.title || 'Pattern Snapshot'}${scaleConf}</h5>
                                    ${annotation}
                                    ${glyphs}
                                </div>
                                <div class="grid grid-cols-2 sm:grid-cols-4 gap-3 text-sm flex-none">
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Magnitude</div>
                                        <div class="font-semibold text-gray-100">${mag.toFixed(2)}<span class="text-[11px] text-gray-400"> / 5</span></div>
                                        <div class="text-[10px] text-gray-300">${heur.magnitudeLabel}</div>
                                    </div>
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Valence</div>
                                        <div class="font-semibold ${val<0?'text-rose-300':'text-emerald-300'}">${val.toFixed(2)}</div>
                                        <div class="text-[10px] text-gray-300">${heur.valenceLabel}</div>
                                    </div>
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Volatility</div>
                                        <div class="font-semibold ${vol>3?'text-amber-300':'text-gray-200'}">${vol.toFixed(2)}</div>
                                        <div class="text-[10px] text-gray-300">${heur.volatilityLabel}</div>
                                    </div>
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Signal Tags</div>
                                        <div class="font-semibold text-gray-100">${heur.signalTags || '—'}</div>
                                        <div class="text-[10px] text-gray-300">${heur.signalLabel}</div>
                                    </div>
                                </div>
                            </div>
                            ${hooks}
                            <div class="mt-4 text-[10px] text-gray-300 uppercase tracking-wide">Signal descriptors (geometry-sourced; not narrative)</div>
                        </div>
                    </div>
                </div>`;
            }
            // Multi-day fallback: existing canvas bar chart
            const canvasId = `bar-${title.replace(/\s+/g,'-').toLowerCase()}`;
            const legend = `<div class=\"mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2 text-[10px] text-gray-300\">
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-teal-300 font-semibold\">Magnitude</span><br><span class=\"text-gray-400\">Activation load 0–5</span></div>
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-amber-300 font-semibold\">Valence</span><br><span class=\"text-gray-400\">Ease ↔ Friction -5..+5</span></div>
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-pink-300 font-semibold\">Volatility</span><br><span class=\"text-gray-400\">Stability ↔ Spiking</span></div>
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-gray-200 font-semibold\">Hooks</span><br><span class=\"text-gray-400\">Aspect signatures</span></div>
            </div>`;
            const html = `<div class="mb-6"><h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} – Daily Barometer</h4><div class="bg-gray-800 p-4 rounded border border-gray-600 overflow-x-auto"><canvas id="${canvasId}" width="900" height="260" class="bg-gray-900 rounded" style="min-width: 600px; max-width: 100%;"></canvas>${legend}</div></div>`;
            setTimeout(()=>drawBarometerChart(canvasId, dailyMap, dates),5);
            return html;
        }

        function drawSeismographArc(canvasId, dailyMap, dates){
            const canvas = document.getElementById(canvasId); if(!canvas) return; const ctx = canvas.getContext('2d');
            const W=canvas.width, H=canvas.height; ctx.fillStyle='#111827'; ctx.fillRect(0,0,W,H);
            if(!dates.length) return; const margin={top:20,left:50,right:30,bottom:30};
            const cw=W-margin.left-margin.right, ch=H-margin.top-margin.bottom;
            const points = dates.map(d=>{const day=dailyMap[d]; const raw=day?.seismograph?.magnitude||0; const mag=raw/2; // normalize 0-5
                const val=Math.max(-5,Math.min(5,day?.seismograph?.valence||0)); return {d, mag, val};});
            // Scales
            const xStep = cw/(points.length-1);
            // Background grid (magnitude bands)
            ctx.strokeStyle='#374151'; ctx.lineWidth=1; for(let i=0;i<=5;i++){const y=margin.top+ch-(ch*i/5); ctx.beginPath(); ctx.moveTo(margin.left,y); ctx.lineTo(margin.left+cw,y); ctx.stroke(); ctx.fillStyle='#6b7280'; ctx.font='10px Inter'; ctx.fillText(i.toString(), margin.left-20, y+3); }
            // Valence midline
            const midY = margin.top + ch/2; ctx.strokeStyle='#4b5563'; ctx.beginPath(); ctx.moveTo(margin.left, midY); ctx.lineTo(margin.left+cw, midY); ctx.stroke();
            // Magnitude arc (smoothed line)
            ctx.strokeStyle='#14b8a6'; ctx.lineWidth=2; ctx.beginPath();
            points.forEach((p,i)=>{const x=margin.left+i*xStep; const y=margin.top+ch-(p.mag/5)*ch; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);}); ctx.stroke();
            // Valence drift (overlay thin line)
            ctx.strokeStyle='#fbbf24'; ctx.lineWidth=1.5; ctx.beginPath(); points.forEach((p,i)=>{const x=margin.left+i*xStep; const y=midY-(p.val/5)*(ch/2); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);}); ctx.stroke();
            // Points with annotations
            ctx.font='10px Inter'; points.forEach((p,i)=>{const x=margin.left+i*xStep; const y=margin.top+ch-(p.mag/5)*ch; ctx.fillStyle='#0d9488'; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); if(i%Math.ceil(points.length/12)===0||i===points.length-1){ctx.fillStyle='#94a3b8'; ctx.fillText(p.d, x-20, H-8);} // date labels sparse
                // Valence annotation
                ctx.fillStyle='#fbbf24'; ctx.fillText('V:'+(p.val>=0?'+':'')+p.val.toFixed(1), x-14, y-10); });
            // Legend
            ctx.fillStyle='#14b8a6'; ctx.fillRect(margin.left,5,8,8); ctx.fillStyle='#e5e7eb'; ctx.font='11px Inter'; ctx.fillText('Magnitude (0–5)', margin.left+12,13);
            ctx.fillStyle='#fbbf24'; ctx.fillRect(margin.left+140,5,8,8); ctx.fillStyle='#e5e7eb'; ctx.fillText('Valence Path (-5..+5)', margin.left+154,13);
        }

        function drawBarometerChart(canvasId,dailyMap,dates){
            const canvas=document.getElementById(canvasId); if(!canvas) return; const ctx=canvas.getContext('2d');
            const W=canvas.width,H=canvas.height; ctx.fillStyle='#111827'; ctx.fillRect(0,0,W,H); if(!dates.length) return; const margin={top:15,left:50,right:20,bottom:45};
            const cw=W-margin.left-margin.right, ch=H-margin.top-margin.bottom; const barW=Math.max(4, cw/dates.length - 2);
            const points=dates.map(d=>{const day=dailyMap[d]; const raw=day?.seismograph?.magnitude||0; const mag=raw/2; const val=Math.max(-5,Math.min(5,day?.seismograph?.valence||0)); const vol=day?.seismograph?.volatility||0; return {d,mag,val,vol};});
            // Grid
            ctx.strokeStyle='#374151'; ctx.lineWidth=1; for(let i=0;i<=5;i++){const y=margin.top+ch-(ch*i/5); ctx.beginPath(); ctx.moveTo(margin.left,y); ctx.lineTo(margin.left+cw,y); ctx.stroke(); ctx.fillStyle='#6b7280'; ctx.font='10px Inter'; ctx.fillText(i.toString(), margin.left-18, y+3);} // bars
            // Bars
            points.forEach((p,i)=>{const x=margin.left+i*(barW+2); const h=(p.mag/5)*ch; const y=margin.top+ch-h; // volatility shading (higher vol => pattern)
                const col = barometerColorForValence(p.val, p.mag);
                // base fill gradient
                const g=ctx.createLinearGradient(x,y,x,y+h); g.addColorStop(0,col.start); g.addColorStop(1,col.end); ctx.fillStyle=g; ctx.fillRect(x,y,barW,h);
                // volatility overlay stripes
                if(p.vol>2){ const stripeCount = Math.min(12, 4 + Math.floor(p.vol*2)); ctx.save(); ctx.beginPath(); ctx.rect(x,y,barW,h); ctx.clip(); ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; for(let s=0;s<stripeCount;s++){const sy=y + (h/stripeCount)*s; ctx.beginPath(); ctx.moveTo(x, sy); ctx.lineTo(x+barW, sy + 4); ctx.stroke(); } ctx.restore(); }
                // top cap
                ctx.fillStyle=col.cap; ctx.fillRect(x,y,barW,2);
                if(i%Math.ceil(points.length/10)===0||i===points.length-1){ctx.fillStyle='#94a3b8'; ctx.save(); ctx.translate(x+barW/2, H-8); ctx.rotate(-Math.PI/4); ctx.fillText(p.d, -20,0); ctx.restore();}
                // Valence annotation above bar
                ctx.fillStyle=p.val<0? '#f87171':'#fbbf24'; ctx.font='9px Inter'; ctx.fillText('V:'+(p.val>=0?'+':'')+p.val.toFixed(1), x-2, y-4); });
            // Axes labels
            ctx.fillStyle='#e5e7eb'; ctx.font='11px Inter'; ctx.fillText('Magnitude 0–5 (normalized)', margin.left, 12); ctx.fillText('Valence annotated per bar', margin.left+220, 12);
        }

        // --- Barometer Heuristics & Color Helpers (single-day + multi-day styling) ---
        function barometerColorForValence(val, mag){
            // Returns {start,end,cap} with enhanced emotional shading
            // Extreme negative valence: deep storm/friction colors
            if(val <= -4) return {start:'#4c1d15', end:'#991b1b', cap:'#dc2626'}; // deeper storm-gray to red
            if(val <= -3) return {start:'#581c1c', end:'#b91c1c', cap:'#dc2626'}; // original dark red
            if(val < -1) return {start:'#4c1d1d', end:'#7f1d1d', cap:'#991b1b'};
            if(val > 3) return {start:'#064e3b', end:'#059669', cap:'#10b981'};
            if(val > 1) return {start:'#0f766e', end:'#14b8a6', cap:'#0d9488'};
            return {start:'#334155', end:'#475569', cap:'#64748b'}; // neutral
        }

        // =============================================================================
        // SAFE LEXICON MAPPING FUNCTIONS
        // =============================================================================
        
        // Canonical magnitude vocabulary (neutral intensity only) — Balance Meter
        const MAGNITUDE_TERMS = [
            "Dormant / Baseline",
            "Murmur / Whisper",
            "Pulse / Stirring",
            "Surge / Activation",
            "Convergence / Compression",
            "Maximum Threshold / Structural Overload"
        ];
        
        // Canonical valence vocabulary (directional charge with clear positive/negative distinction)
        const VALENCE_TERMS = ["Collapse", "Grind", "Friction", "Contraction", "Drag", "Neutral", "Lift", "Flow", "Harmony", "Expansion", "Liberation"];
        
        function toMagnitudeTerm(mag) {
            // Assumes magnitude normalized to 0–5 for descriptors
            if (mag < 0.5) return "Dormant / Baseline";           // 0
            if (mag < 1.5) return "Murmur / Whisper";             // 1
            if (mag < 2.5) return "Pulse / Stirring";             // 2
            if (mag < 3.5) return "Surge / Activation";           // 3
            if (mag < 4.5) return "Convergence / Compression";    // 4
            return "Maximum Threshold / Structural Overload";     // 5
        }
        
        function toValenceTerm(val) {
            if (val <= -4.5) return "Collapse";
            if (val <= -3.5) return "Grind";
            if (val <= -2.5) return "Friction";
            if (val <= -1.5) return "Contraction";
            if (val < -0.5) return "Drag";
            if (val < 0.5) return "Neutral";
            if (val < 1.5) return "Lift";
            if (val < 2.5) return "Flow";
            if (val < 3.5) return "Harmony";
            if (val < 4.5) return "Expansion";
            return "Liberation";
        }
        
        // Migration function for legacy terms
        function migrateMagnitudeTerm(term) {
            // Map legacy terms to closest new descriptors
            if (/^Field$/i.test(term)) return "Maximum Threshold / Structural Overload";
            if (/^Quake$/i.test(term)) return "Convergence / Compression";
            // Log migration for provenance tracking
            if (window.lastRunStats) {
                window.lastRunStats.legacy_migrations = window.lastRunStats.legacy_migrations || [];
                window.lastRunStats.legacy_migrations.push({term, migrated_to: /^Field$/i.test(term) ? "Maximum Threshold / Structural Overload" : "Convergence / Compression"});
            }
            return term;
        }
        
        // Safety validation - ban unsafe metaphors in magnitude contexts
        function assertSafeMagnitudePhrase(text) {
            const BANNED_IN_MAG = /\b(storm|quake|disaster|tsunami|crash|catastrophe|earthquake)\b/i;
            if (BANNED_IN_MAG.test(text)) {
                console.error("Unsafe metaphor detected in magnitude context:", text);
                throw new Error("Unsafe metaphor in magnitude context: " + text);
            }
        }
        
        // Validation function to ensure safe lexicon is working correctly
        function validateSafeLexicon() {
            try {
                // Test magnitude terms are all safe
                for (let i = 0; i <= 5; i += 0.5) {
                    const term = toMagnitudeTerm(i);
                    assertSafeMagnitudePhrase(term);
                    if (!MAGNITUDE_TERMS.includes(term)) {
                        throw new Error(`Invalid magnitude term: ${term}`);
                    }
                }
                
                // Test valence terms are properly mapped
                for (let i = -5; i <= 5; i += 0.5) {
                    const term = toValenceTerm(i);
                    if (!VALENCE_TERMS.includes(term)) {
                        throw new Error(`Invalid valence term: ${term}`);
                    }
                }
                
                // Test emoji mapping consistency
                for (let i = -5; i <= 5; i += 0.25) {
                    const emoji = getValenceEmoji(i);
                    const type = getValenceType(i);
                    if (!emoji || !type) {
                        throw new Error(`Missing emoji or type for valence: ${i}`);
                    }
                }
                
                console.log("✅ Safe lexicon validation passed - all terms and emojis mapped correctly");
                return true;
            } catch (error) {
                console.error("❌ Safe lexicon validation failed:", error);
                return false;
            }
        }

        // =============================================================================
        // EMOJI VALENCE LEXICON (Directional charge: positive ↗ / negative ↘)
        // =============================================================================
        
        function getValenceEmoji(val, includeAccessibility = false) {
            const clampedVal = Math.max(-5, Math.min(5, val)); // Always clamp to ±5
            let emoji, label;

            // 🌑 Negative Valence Types (↘)
            if (clampedVal <= -4.5) { emoji = '🌋'; label = 'Pressure / Eruption'; }
            else if (clampedVal <= -3.5) { emoji = '⚔️'; label = 'Friction Clash'; }
            else if (clampedVal <= -2.8) { emoji = '♾️'; label = 'Recursion Pull'; }
            else if (clampedVal <= -2.1) { emoji = '↔️'; label = 'Cross Current'; }
            else if (clampedVal <= -1.6) { emoji = '🧩'; label = 'Fragmentation'; }
            else if (clampedVal <= -1.0) { emoji = '🌫️'; label = 'Fog / Dissolution'; }
            else if (clampedVal <= -0.5) { emoji = '🕳️'; label = 'Entropy Drift'; }
            else if (clampedVal < -0.2)  { emoji = '⏳'; label = 'Saturn Weight'; }
            // 🌗 Neutral range
            else if (clampedVal >= -0.2 && clampedVal <= 0.2) { emoji = '🌗'; label = 'Neutral Field'; }
            // 🌞 Positive Valence Types (↗)
            else if (clampedVal <= 0.8) { emoji = '🌱'; label = 'Fertile Field'; }
            else if (clampedVal <= 1.5) { emoji = '⚖️'; label = 'Integration'; }
            else if (clampedVal <= 2.3) { emoji = '🌊'; label = 'Flow Tide'; }
            else if (clampedVal <= 3.1) { emoji = '✨'; label = 'Harmonic Resonance'; }
            else if (clampedVal <= 3.8) { emoji = '🌈'; label = 'Visionary Spark'; }
            else if (clampedVal <= 4.6) { emoji = '🔥'; label = 'Combustion Clarity'; }
            else if (clampedVal <= 4.9) { emoji = '🦋'; label = 'Liberation / Release'; }
            else { emoji = '💎'; label = 'Expansion Lift'; }

            return includeAccessibility ?
                `<span class="valence-emoji" role="img" aria-label="${label}">${emoji}</span>` :
                emoji;
        }

        function getValenceType(val) {
            const v = Math.max(-5, Math.min(5, val));
            // 🌑 Negative Valence Types
            if (v <= -4.5) return 'Pressure / Eruption';
            if (v <= -3.5) return 'Friction Clash';
            if (v <= -2.8) return 'Recursion Pull';
            if (v <= -2.1) return 'Cross Current';
            if (v <= -1.6) return 'Fragmentation';
            if (v <= -1.0) return 'Fog / Dissolution';
            if (v <= -0.5) return 'Entropy Drift';
            if (v <  -0.2) return 'Saturn Weight';

            // 🌗 Neutral range
            if (v >= -0.2 && v <= 0.2) return 'Neutral Field';

            // 🌞 Positive Valence Types
            if (v <= 0.8) return 'Fertile Field';
            if (v <= 1.5) return 'Integration';
            if (v <= 2.3) return 'Flow Tide';
            if (v <= 3.1) return 'Harmonic Resonance';
            if (v <= 3.8) return 'Visionary Spark';
            if (v <= 4.6) return 'Combustion Clarity';
            if (v <= 4.9) return 'Liberation / Release';
            return 'Expansion Lift';
        }

        // =============================================================================
        // BAROMETER HEURISTICS (Updated with Safe Lexicon)
        // =============================================================================

        function generateBarometerHeuristics(mag,val,vol, day){
            // Magnitude label - using safe lexicon (neutral intensity only)
            let magnitudeLabel = toMagnitudeTerm(mag).toLowerCase();
            assertSafeMagnitudePhrase(magnitudeLabel); // Safety validation
            
            // Valence label - enhanced emoji lexicon with directional charge types
            const valenceEmoji = getValenceEmoji(val);
            const valenceType = getValenceType(val);
            let valenceLabel = `${valenceEmoji} ${valenceType}`;
            
            // Volatility label
            let volatilityLabel = vol>=4? 'scattered / spiking' : vol>=3? 'unstable oscillation' : vol>=2? 'variable' : vol>=1? 'settling' : 'steady';
            // Signal tags & glyphs
            const tags=[]; const glyphs=[];
            if(vol>=3) { tags.push('⚡'); glyphs.push('⚡'); }
            if(val<=-3) { tags.push('☍'); if(!glyphs.includes('☍')) glyphs.push('☍'); }
            if(vol>=3 && val<0) { tags.push('⧖'); if(!glyphs.includes('⧖')) glyphs.push('⧖'); }
            const signalTags = tags.join('');
            // Title heuristics - geometric descriptors only (Math Brain compliance)
            let title;
            if(val<=-4.5 && vol>=3) title='High Volatility Negative Valence';
            else if(val<=-4.5) title='Extreme Negative Valence';
            else if(mag>=4 && val<=-3) title='High Magnitude Negative Pattern';
            else if(val<=-4) title='Strong Negative Valence';
            else if(vol>=4 && val<0) title='High Volatility Negative';
            else if(mag<2 && Math.abs(val)<0.5) title='Low Signal Pattern';
            else if(mag>=3 && val>2) title='High Magnitude Positive';
            else title='Standard Pattern';
            // Annotation (geometric descriptors only; no narrative interpretation)
            let annotation;
            if(title==='High Volatility Negative Valence') annotation='Valence ≤-4.5, Volatility ≥3.0';
            else if(title==='Extreme Negative Valence') annotation='Valence ≤-4.5, Standard volatility';
            else if(title==='High Magnitude Negative Pattern') annotation='Magnitude ≥4.0, Valence ≤-3.0';
            else if(title==='Strong Negative Valence') annotation='Valence ≤-4.0';
            else if(title==='High Volatility Negative') annotation='Volatility ≥4.0, Negative valence';
            else if(title==='High Magnitude Positive') annotation='Magnitude ≥3.0, Valence >2.0';
            else if(title==='Low Signal Pattern') annotation='Magnitude <2.0, |Valence| <0.5';
            else annotation='Standard geometric pattern';
            return {title, annotation, glyphs: glyphs.join(''), magnitudeLabel, valenceLabel, volatilityLabel, signalTags, signalLabel:'composite flags'};
        }

        // =============================================================================
        // END SEISMOGRAPH FUNCTIONS
        // =============================================================================

                // Re-render hooks only (without round-trip) when filters change
                function rerenderHookMarkdownSection(){
                        if(!latestResultData) return;
                        try {
                            const full = generateMarkdownReport(latestResultData);
                            reportContent.textContent = full;
                        } catch(e){ console.warn('Re-render failed', e); }
                }

        function generateFilename(extension, data) {
            const formData = collectFormData();
            const personA = formData.personA.name.replace(/[^a-zA-Z0-9]/g, '') || 'PersonA';
            const personB = formData.personB?.name?.replace(/[^a-zA-Z0-9]/g, '') || '';
            const mode = formData.context.mode;
            const today = new Date().toISOString().split('T')[0];
            
            let filename = `WovenMap_${personA}`;
            if (personB) filename += `_${personB}`;
            
            // Include date range for transit modes
            if (mode.includes('transits')) {
                const start = formData.transitParams?.startDate || today;
                const end = formData.transitParams?.endDate || start;
                if (start === end) {
                    filename += `_${mode}_${start}`;
                } else {
                    filename += `_${mode}_${start}_to_${end}`;
                }
            } else {
                filename += `_${mode}_${today}`;
            }
            
            return `${filename}.${extension}`;
        }

        function parseCoordinates(coordString) {
            if (!coordString) return { latitude: undefined, longitude: undefined };
            
            coordString = coordString.trim();
            
            console.log("Parsing coordinates:", coordString);

            // Try decimal format first (e.g., "30.1667, -85.6667")
            const decimalPattern = /^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/;
            const decimalMatch = coordString.match(decimalPattern);
            if (decimalMatch) {
                const lat = parseFloat(decimalMatch[1]);
                const lon = parseFloat(decimalMatch[2]);
                if (isFinite(lat) && isFinite(lon) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {
                    console.log("Parsed decimal coordinates:", { latitude: lat, longitude: lon });
                    return { latitude: lat, longitude: lon };
                }
            }

            // Try DMS format with flexible patterns
            // Handles: "30°10'N, 85°40'W", "30° 10' N, 85° 40' W", etc.
            const dmsPattern = /^\s*(\d{1,3})(?:°\s*(\d{1,2}))?(?:'\s*([\d.]+))?\s*([NS])\s*,\s*(\d{1,3})(?:°\s*(\d{1,2}))?(?:'\s*([\d.]+))?\s*([EW])\s*$/i;
            
            // Clean up coordinate string for better matching
            const cleaned = coordString.replace(/º/g, '°'); // Replace alternative degree symbol
            const dmsMatch = cleaned.match(dmsPattern);
            
            if (dmsMatch) {
                // Parse latitude: degrees + minutes/60 + seconds/3600
                const latDeg = parseInt(dmsMatch[1], 10);
                const latMin = parseInt(dmsMatch[2] || '0', 10);
                const latSec = parseFloat(dmsMatch[3] || '0');
                const latDir = dmsMatch[4].toUpperCase();
                
                // Parse longitude: degrees + minutes/60 + seconds/3600
                const lonDeg = parseInt(dmsMatch[5], 10);
                const lonMin = parseInt(dmsMatch[6] || '0', 10);
                const lonSec = parseFloat(dmsMatch[7] || '0');
                const lonDir = dmsMatch[8].toUpperCase();
                
                // Convert to decimal
                let lat = latDeg + latMin / 60 + latSec / 3600;
                let lon = lonDeg + lonMin / 60 + lonSec / 3600;
                
                // Apply hemisphere signs
                if (latDir === 'S') lat = -lat;
                if (lonDir === 'W') lon = -lon;
                
                // Validate bounds
                if (isFinite(lat) && isFinite(lon) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {
                    console.log("Parsed DMS coordinates:", { latitude: lat, longitude: lon });
                    return { 
                        latitude: parseFloat(lat.toFixed(6)), 
                        longitude: parseFloat(lon.toFixed(6)) 
                    };
                }
            }
            
            console.error("Failed to parse coordinates - no pattern matched:", coordString);
            return { latitude: undefined, longitude: undefined };
        }

        // --- Form Logic ---

        function validateForm() {
            hideError();
            
            // Mobile debugging - log form data collection
            console.log('=== FORM VALIDATION START ===');
            console.log('User agent:', navigator.userAgent);
            console.log('Screen dimensions:', window.screen.width, 'x', window.screen.height);
            console.log('Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
            
            const modeSel = document.querySelector('input[name="contextMode"]:checked');
            const mode = modeSel ? modeSel.value : (currentContextType === 'weather' ? 'sky_transits' : 'natal_transits');
            const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value;
            const intimacyTier = document.querySelector('input[name="intimacyTier"]:checked')?.value;
            const roleSel = document.getElementById('relationshipRole');
            const roleCustomInput = document.getElementById('relationshipRoleCustom');
            const roleValueRaw = roleSel ? roleSel.value : '';

            // Weather-only: skip personal validation; validate only date range
            if (currentContextType === 'weather') {
                // Validate transit dates only
                const start = transitStartDate.value;
                const end = transitEndDate.value;
                if (!start || !end) {
                    showError('Please enter both start and end dates for planetary weather analysis');
                    return false;
                }
                if (end < start) {
                    showError('End date must be after or equal to start date');
                    return false;
                }
                // Date range + step limits as usual
                const startDate = new Date(start);
                const endDate = new Date(end);
                const daySpan = Math.max(1, Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
                const stepSize = transitStep.value || '1d';
                const stepKey = (stepSize === '7d' || stepSize === 'weekly') ? 'weekly'
                                 : (stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly') ? 'monthly'
                                 : 'daily';
                const limits = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]) || { max: 45, warnRatio: 0.8, label: 'calculations' };
                if (daySpan > limits.max) {
                    const limitsMsg = `Daily=${(window.WOVEN_STEP_LIMITS?.daily?.max)||45} days max, Weekly=${Math.round(((window.WOVEN_STEP_LIMITS?.weekly?.max)||270)/30)} months max, Monthly=${Math.round(((window.WOVEN_STEP_LIMITS?.monthly?.max)||550)/30)} months max`;
                    showError(`Date range of ${daySpan} days exceeds the ${limits.max}-day limit for ${limits.label}. Please shorten the range or use weekly/monthly.`);
                    return false;
                }
                const warningDays = Math.floor(limits.max * (limits.warnRatio || 0.8));
                if (daySpan > warningDays) {
                    const actualSteps = stepSize === '7d' || stepSize === 'weekly' ? Math.ceil(daySpan / 7)
                                       : stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? Math.ceil(daySpan / 30)
                                       : daySpan;
                    const proceed = confirm(`Date range is ${daySpan} days (~${actualSteps} ${limits.label}). This may be slower. Continue?`);
                    if (!proceed) return false;
                }
                return true;
            }

            // Validate Person A
            const nameA = document.getElementById('nameA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();

            // Mobile debugging - log raw values
            console.log('Person A form values:');
            console.log('- Name:', nameA);
            console.log('- Date (raw):', dateA);
            console.log('- Time (raw):', timeA);
            console.log('- Coordinates (raw):', astroA);
            console.log('- Date field type:', document.getElementById('birth_dateA').type);
            console.log('- Date field value:', document.getElementById('birth_dateA').value);

            if (!nameA || !dateA || !timeA || !astroA) {
                console.error('Missing required fields:', { nameA: !!nameA, dateA: !!dateA, timeA: !!timeA, astroA: !!astroA });
                showError('Please fill in all required fields for Person A');
                return false;
            }
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateA)) {
                console.error('Date format validation failed. Expected YYYY-MM-DD, got:', dateA);
                showError('Please enter Person A date in YYYY-MM-DD format');
                return false;
            }
            if (!/^\d{2}:\d{2}$/.test(timeA)) {
                showError('Please enter Person A time in HH:MM format (24-hour)');
                return false;
            }
            const coordsA = parseCoordinates(astroA);
            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                showError('Please enter Person A coordinates in a valid decimal (e.g., 40.01, -75.31) or DMS format (e.g., 40°1\'N, 75°18\'W)');
                return false;
            }

            // Validate Person B if required by mode
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                const nameB = document.getElementById('nameB').value.trim();
                const dateB = document.getElementById('birth_dateB').value.trim();
                const timeB = document.getElementById('birth_timeB').value.trim();
                const astroB = document.getElementById('astroB').value.trim();
                if (!nameB || !dateB || !timeB || !astroB) {
                    showError(`Please fill in all required fields for Person B for ${mode} analysis`);
                    return false;
                }
                if (!/^\d{4}-\d{2}-\d{2}$/.test(dateB)) {
                    showError('Please enter Person B date in YYYY-MM-DD format');
                    return false;
                }
                if (!/^\d{2}:\d{2}$/.test(timeB)) {
                    showError('Please enter Person B time in HH:MM format (24-hour)');
                    return false;
                }
                const coordsB = parseCoordinates(astroB);
                if (coordsB.latitude === undefined || coordsB.longitude === undefined) {
                    showError('Please enter Person B coordinates in a valid decimal or DMS format');
                    return false;
                }
            }

            // Validate transit dates if required by mode (skip for natal_only)
        if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits' || mode === 'balance_meter') {
                const start = transitStartDate.value;
                const end = transitEndDate.value;
                if (!start || !end) {
                    showError('Please enter both start and end dates for transit analysis');
                    return false;
                }
                if (end < start) {
                    showError('End date must be after or equal to start date');
                    return false;
                }

                // Date range validation with step size awareness
                const startDate = new Date(start);
                const endDate = new Date(end);
                const daySpan = Math.max(1, Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
                const stepSize = transitStep.value || '1d';
                
                // Define maximum ranges based on centralized limits (configurable)
                let maxDays, warningDays, stepDescription;
                const stepKey = (stepSize === '7d' || stepSize === 'weekly') ? 'weekly'
                                 : (stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly') ? 'monthly'
                                 : 'daily';
                const limits = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]) || { max: 45, warnRatio: 0.8, label: 'calculations' };
                maxDays = limits.max;
                warningDays = Math.floor(limits.max * (limits.warnRatio || 0.8));
                stepDescription = limits.label || 'calculations';

                // Hard limit validation
                if (daySpan > maxDays) {
                    const limitsMsg = `Daily=${(window.WOVEN_STEP_LIMITS?.daily?.max)||45} days max, Weekly=${Math.round(((window.WOVEN_STEP_LIMITS?.weekly?.max)||270)/30)} months max, Monthly=${Math.round(((window.WOVEN_STEP_LIMITS?.monthly?.max)||550)/30)} months max`;
                    showError(`Date range of ${daySpan} days exceeds the ${maxDays}-day limit for ${stepDescription}. Please use a shorter range or change the step size to weekly/monthly for longer periods. (API Protection: ${limitsMsg})`);
                    return false;
                }

                // Warning for longer ranges that might be slow
                if (daySpan > warningDays) {
                    const actualSteps = stepSize === '7d' || stepSize === 'weekly' ? Math.ceil(daySpan / 7) :
                                       stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? Math.ceil(daySpan / 30) :
                                       daySpan;
                    
                    const proceed = confirm(
                        `Date range is ${daySpan} days (approximately ${actualSteps} ${stepDescription}).\n\n` +
                        `This may take longer to process and generate a large amount of data.\n\n` +
                        `Consider using:\n` +
                        `• Weekly step size for longer ranges\n` +
                        `• Monthly step size for ranges over 6 months\n\n` +
                        `Continue with current settings?`
                    );
                    if (!proceed) return false;
                }

                // Helpful suggestion for very short ranges with loose step sizes
                if (daySpan <= 7 && (stepSize === '7d' || stepSize === 'weekly')) {
                    const useDailyInstead = confirm(
                        `Your date range is only ${daySpan} days, but you've selected weekly calculations.\n\n` +
                        `For better detail in short ranges, would you like to switch to daily calculations instead?`
                    );
                    if (useDailyInstead) {
                        transitStep.value = '1d';
                    }
                }
            }

            // Validate relocation coordinates if enabled
            if (relocationToggle.checked) {
                const relocationCoords = relocationCoordsInput.value.trim();
                if (!relocationCoords) {
                    showError('Please enter relocation coordinates when overlay is enabled');
                    return false;
                }
                const coordsR = parseCoordinates(relocationCoords);
                if (coordsR.latitude === undefined || coordsR.longitude === undefined) {
                    showError('Please enter valid relocation coordinates in decimal or DMS format');
                    return false;
                }
            }

            // Relationship context validation for synastry/composite modes
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                if (!relationshipType) {
                    showError('Please specify the relationship type for synastry/composite analysis');
                    return false;
                }
                
                // Partner requires intimacy tier
                if (relationshipType === 'partner') {
                    if (!intimacyTier) {
                        showError('Please select an intimacy tier for partner relationships');
                        return false;
                    }
                }
                
                // Family requires role
                if (relationshipType === 'family') {
                    if (!roleValueRaw) {
                        showError('Please specify the family role for family relationships');
                        return false;
                    }
                    if (roleValueRaw === 'other') {
                        const customVal = roleCustomInput?.value?.trim();
                        if (!customVal) {
                            showError('Please provide a custom family role description');
                            return false;
                        }
                    }
                }
                
                // Friend allows optional role but validates if provided
                if (relationshipType === 'friend' && roleValueRaw === 'other') {
                    const customVal = roleCustomInput?.value?.trim();
                    if (!customVal) {
                        showError('Please provide a custom friend role description or select "Other"');
                        return false;
                    }
                }
            }

            // Legacy relationship validation (for existing patterns)
            if (relationshipType === 'partner') {
                if (!intimacyTier) {
                    showError('Select an intimacy tier for partner relationships');
                    return false;
                }
            }
            if (relationshipType && relationshipType !== 'partner') {
                if (roleSel && roleValueRaw === 'other') {
                    const customVal = roleCustomInput?.value?.trim();
                    if (!customVal) {
                        showError('Provide a custom role description');
                        return false;
                    }
                }
            }
            if (relationshipType === 'partner' && roleSel && roleValueRaw) {
                console.warn('Role value ignored for partner type');
            }
            return true;
        }

        // Helper function to determine mode based on active tab
        function getCurrentActiveTabMode() {
            // Check which tab is currently active
            const mirrorTab = document.getElementById('mirrorModeTab');
            const balanceMeterTab = document.getElementById('balanceMeterModeTab');
            
            const mirrorSelected = mirrorTab?.getAttribute('aria-selected');
            const balanceSelected = balanceMeterTab?.getAttribute('aria-selected');
            
            console.log('Tab states - Mirror:', mirrorSelected, 'Balance:', balanceSelected);
            
            // Check aria-selected attribute to determine active tab
            if (balanceMeterTab?.getAttribute('aria-selected') === 'true') {
                console.log('getCurrentActiveTabMode returning: balance_meter');
                return 'balance_meter';
            }
            
            // Default to checking context mode radios for relational modes
            const contextModeChecked = document.querySelector('input[name="contextMode"]:checked');
            const result = contextModeChecked?.value || 'natal_transits';
            console.log('getCurrentActiveTabMode returning:', result);
            return result;
        }

        function collectFormData() {
            console.log("=== COLLECTING FORM DATA ===");

            // Sky-only: build minimal payload (no natal, no houses/angles)
            if (currentContextType === 'weather') {
                const startDateElement = document.getElementById('transitStartDate');
                const endDateElement = document.getElementById('transitEndDate');
                const stepElement = document.getElementById('transitStep');
                const transitParams = (startDateElement && endDateElement && stepElement) ? {
                    startDate: startDateElement.value,
                    endDate: endDateElement.value,
                    step: stepElement.value || '1d'
                } : null;
                const formData = {
                    context: { mode: 'sky_transits' }
                };
                if (transitParams) formData.transitParams = transitParams;
                console.log('Sky-only payload:', JSON.stringify(formData));
                return formData;
            }
            
            // Person A - Get raw form values first
            const nameA = document.getElementById('nameA').value.trim();
            const cityA = document.getElementById('birth_cityA').value.trim();
            const stateA = document.getElementById('birth_stateA').value.trim();
            const countryA = document.getElementById('birth_countryA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();
            const zodiacA = document.getElementById('zodiacA').value;
            const timezoneA = document.getElementById('offsetA').value;

            console.log("Raw form values for Person A:");
            console.log("- Name:", nameA);
            console.log("- City:", cityA);
            console.log("- State:", stateA);
            console.log("- Country:", countryA);
            console.log("- Date:", dateA);
            console.log("- Time:", timeA);
            console.log("- Coordinates:", astroA);
            console.log("- Zodiac:", zodiacA);
            console.log("- Timezone:", timezoneA);

            // Parse date and time
            if (!dateA || !timeA) {
                console.error("Missing date or time for Person A");
                throw new Error("Date and time are required for Person A");
            }

            const [yearA, monthA, dayA] = dateA.split('-').map(Number);
            const [hourA, minuteA] = timeA.split(':').map(Number);

            console.log("Parsed date/time:", { yearA, monthA, dayA, hourA, minuteA });

            // Parse coordinates
            const coordsA = parseCoordinates(astroA);
            console.log("Parsed coordinates:", coordsA);

            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                console.error("Failed to parse coordinates for Person A");
                throw new Error("Valid coordinates are required for Person A");
            }

            const personA = {
                name: nameA || "Unknown",
                city: cityA || "Unknown",
                nation: countryA || "US",
                year: yearA,
                month: monthA, 
                day: dayA, 
                hour: hourA, 
                minute: minuteA,
                latitude: coordsA.latitude, 
                longitude: coordsA.longitude,
                zodiac_type: zodiacA || "Tropic",
                timezone: timezoneA || "America/New_York"
            };
            
            console.log("Final Person A data:", personA);
            
            // Validate all required fields are present and not undefined
            const requiredFields = ['year', 'month', 'day', 'hour', 'minute', 'name', 'city', 'nation', 'latitude', 'longitude', 'zodiac_type', 'timezone'];
            const missingFields = requiredFields.filter(field => {
                const value = personA[field];
                return value === undefined || value === null || value === "";
            });
            
            if (missingFields.length > 0) {
                console.error("Missing required fields for Person A:", missingFields);
                console.error("Current Person A object:", personA);
                throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
            }

            // Person B - only if fields are filled
            const dateB_val = document.getElementById('birth_dateB').value;
            const timeB_val = document.getElementById('birth_timeB').value.trim();
            const coordsB_val = document.getElementById('astroB').value.trim();
            let personB = null;

            if (dateB_val && timeB_val && coordsB_val) {
                console.log("Processing Person B data...");
                const coordsB = parseCoordinates(coordsB_val);
                if (coordsB.latitude !== undefined && coordsB.longitude !== undefined) {
                    const [yearB, monthB, dayB] = dateB_val.split('-').map(Number);
                    const [hourB, minuteB] = timeB_val.split(':').map(Number);
                    personB = {
                        name: document.getElementById('nameB').value.trim() || "Unknown",
                        city: document.getElementById('birth_cityB').value.trim() || "Unknown",
                        nation: document.getElementById('birth_countryB').value.trim() || "US",
                        year: yearB, 
                        month: monthB, 
                        day: dayB, 
                        hour: hourB, 
                        minute: minuteB,
                        latitude: coordsB.latitude,
                        longitude: coordsB.longitude,
                        zodiac_type: document.getElementById('zodiacB').value || "Tropic",
                        timezone: document.getElementById('offsetB').value || "America/New_York"
                    };
                    console.log("Person B data:", personB);
                }
            }

            const formData = {
                personA,
                personB: personB,
                context: {
                    mode: getCurrentActiveTabMode(),
                    relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value,
                    intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value,
                    contact_channel: document.querySelector('input[name="contactChannel"]:checked')?.value,
                    is_ex_relationship: exRelationshipCheckbox?.checked || false
                }
            };

            // Add relationship_context for synastry/composite modes
            const relType = formData.context.relationship_type;
            const isRelationalMode = formData.context.mode && 
                (formData.context.mode.includes('synastry') || formData.context.mode.includes('composite'));
            
            if (isRelationalMode && relType) {
                const relContext = { 
                    type: relType.toUpperCase() 
                };
                
                // Add required fields based on type
                if (relType === 'partner') {
                    const tier = formData.context.intimacy_tier;
                    if (tier) relContext.intimacy_tier = tier;
                } else if (relType === 'family') {
                    const role = document.getElementById('relationshipRole')?.value;
                    if (role && role !== 'other') relContext.role = role;
                    else if (role === 'other') {
                        const customRole = document.getElementById('relationshipRoleCustom')?.value?.trim();
                        if (customRole) relContext.role = 'Custom';
                    }
                } else if (relType === 'friend') {
                    const role = document.getElementById('relationshipRole')?.value;
                    if (role && role !== 'other') relContext.role = role;
                    else if (role === 'other') {
                        const customRole = document.getElementById('relationshipRoleCustom')?.value?.trim();
                        if (customRole) relContext.role = 'Custom';
                    }
                }
                
                // Ex/Estranged flag (not for friends)
                if (relType !== 'friend' && exRelationshipCheckbox?.checked) {
                    relContext.ex_estranged = true;
                }
                
                // Notes
                const notes = document.getElementById('relationshipNotes')?.value?.trim();
                if (notes) relContext.notes = notes;
                
                formData.relationship_context = relContext;
            }

            if (relocationToggle && relocationToggle.checked) {
                const rawReloc = document.getElementById('relocationCoords').value.trim();
                const parsedReloc = parseLatLonFlexible ? parseLatLonFlexible(rawReloc) : null;
                if (parsedReloc) {
                    formData.relocation = {
                        enabled: true,
                        city: document.getElementById('relocationCity').value.trim(),
                        state: document.getElementById('relocationState').value.trim(),
                        latitude: parsedReloc.lat,
                        longitude: parsedReloc.lon,
                        input: rawReloc,
                        normalized: parsedReloc.normalized,
                        excludePersonB: !(document.getElementById('includePersonBRelocation')?.checked)
                    };
                } else {
                    // Fallback to legacy parseCoordinates if available
                    try {
                        const legacy = parseCoordinates(rawReloc);
                        if (legacy && legacy.latitude !== undefined) {
                            formData.relocation = {
                                enabled: true,
                                city: document.getElementById('relocationCity').value.trim(),
                                state: document.getElementById('relocationState').value.trim(),
                                latitude: legacy.latitude,
                                longitude: legacy.longitude,
                                input: rawReloc,
                                normalized: `${legacy.latitude}, ${legacy.longitude}`,
                                excludePersonB: !(document.getElementById('includePersonBRelocation')?.checked)
                            };
                        } else {
                            formData.relocation = { enabled: true, invalid: true, input: rawReloc };
                        }
                    } catch(e){
                        formData.relocation = { enabled: true, invalid: true, input: rawReloc };
                    }
                }
            } else {
                formData.relocation = { enabled: false };
            }

            const mode = formData.context.mode;
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits' || mode === 'balance_meter') {
                const startDateElement = document.getElementById('transitStartDate');
                const endDateElement = document.getElementById('transitEndDate');
                const stepElement = document.getElementById('transitStep');
                
                console.log('=== FRONTEND TRANSIT DEBUG ===');
                console.log('Transit mode detected (including balance_meter):', mode);
                console.log('Start date element:', startDateElement, 'Value:', startDateElement?.value);
                console.log('End date element:', endDateElement, 'Value:', endDateElement?.value);
                console.log('Step element:', stepElement, 'Value:', stepElement?.value);
                
                // Auto-fill dates for Balance Meter mode if empty
                if (mode === 'balance_meter') {
                    const todayStr = new Date().toISOString().split('T')[0];
                    const defaultEndDate = new Date();
                    defaultEndDate.setDate(defaultEndDate.getDate() + 7); // 1 week from today
                    const defaultEndStr = defaultEndDate.toISOString().split('T')[0];
                    
                    if (!startDateElement?.value) {
                        console.log('Auto-filling start date for Balance Meter:', todayStr);
                        if (startDateElement) startDateElement.value = todayStr;
                    }
                    if (!endDateElement?.value) {
                        console.log('Auto-filling end date for Balance Meter:', defaultEndStr);
                        if (endDateElement) endDateElement.value = defaultEndStr;
                    }
                    if (!stepElement?.value) {
                        console.log('Auto-filling step for Balance Meter: daily');
                        if (stepElement) stepElement.value = 'daily';
                    }
                }
                
                if (startDateElement && endDateElement && stepElement) {
                    formData.transitParams = {
                        startDate: startDateElement.value,
                        endDate: endDateElement.value,
                        step: stepElement.value
                    };
                    
                    console.log('Transit data added to form:', formData.transitParams);
                } else {
                    console.log('WARNING: Transit elements not found or missing values');
                    console.log('Elements found:', {
                        startDate: !!startDateElement,
                        endDate: !!endDateElement,
                        step: !!stepElement
                    });
                    
                    // For Balance Meter mode, provide fallback transit params
                    if (mode === 'balance_meter') {
                        const todayStr = new Date().toISOString().split('T')[0];
                        const defaultEndDate = new Date();
                        defaultEndDate.setDate(defaultEndDate.getDate() + 7);
                        const defaultEndStr = defaultEndDate.toISOString().split('T')[0];
                        
                        formData.transitParams = {
                            startDate: todayStr,
                            endDate: defaultEndStr,
                            step: 'daily'
                        };
                        console.log('Using fallback transit params for Balance Meter:', formData.transitParams);
                    }
                }
                console.log('=== END FRONTEND TRANSIT DEBUG ===');
            } else if (mode === 'natal_only') {
                console.log('=== NATAL ONLY MODE ===');
                console.log('Skipping transit parameter collection for natal_only mode');
                // No transit parameters needed for natal_only mode
                console.log('=== END NATAL ONLY MODE ===');
            }

            // Relationship role & notes capture
            const roleSel = document.getElementById('relationshipRole');
            const roleCustom = document.getElementById('relationshipRoleCustom');
            const roleVal = roleSel ? (roleSel.value === 'other' ? (roleCustom?.value?.trim() || '') : roleSel.value) : '';
            const notesVal = document.getElementById('relationshipNotes')?.value?.trim() || '';
            // Backward compatibility: normalize 'child' -> 'offspring'
            formData.context.relationship_role = (roleVal === 'child') ? 'offspring' : roleVal;
            formData.context.relationship_notes = notesVal;
            // Mutual exclusivity & cleanup
            const t = formData.context.relationship_type;
            if (t === 'partner') {
                formData.context.relationship_role = null;
            } else {
                formData.context.intimacy_tier = null;
            }
            if (t === 'friend' && formData.context.is_ex_relationship) {
                formData.context.is_ex_relationship = false; // clear ex for friend
            }
            console.log("=== FINAL FORM DATA ===");
            console.log(JSON.stringify(formData, null, 2));
            return formData;
        }

        // --- Save/Load Functions ---

        function saveChartData() {
            try {
                // Collect all form data
                const chartData = {
                    timestamp: new Date().toISOString(),
                    version: "1.0",
                    contextType: currentContextType,
                    personA: {
                        name: document.getElementById('nameA')?.value || '',
                        birth_city: document.getElementById('birth_cityA')?.value || '',
                        birth_state: document.getElementById('birth_stateA')?.value || '',
                        birth_date: document.getElementById('birth_dateA')?.value || '',
                        birth_time: document.getElementById('birth_timeA')?.value || '',
                        birth_country: document.getElementById('birth_countryA')?.value || '',
                        astro: document.getElementById('astroA')?.value || '',
                        offset: document.getElementById('offsetA')?.value || '',
                        zodiac: document.getElementById('zodiacA')?.value || ''
                    },
                    personB: {
                        name: document.getElementById('nameB')?.value || '',
                        birth_city: document.getElementById('birth_cityB')?.value || '',
                        birth_state: document.getElementById('birth_stateB')?.value || '',
                        birth_date: document.getElementById('birth_dateB')?.value || '',
                        birth_time: document.getElementById('birth_timeB')?.value || '',
                        birth_country: document.getElementById('birth_countryB')?.value || '',
                        astro: document.getElementById('astroB')?.value || '',
                        offset: document.getElementById('offsetB')?.value || '',
                        zodiac: document.getElementById('zodiacB')?.value || ''
                    },
                    relationalContext: {
                        relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value || '',
                        intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value || '',
                        contact_channel: document.querySelector('input[name="contactChannel"]:checked')?.value || '',
                        relationship_role: document.getElementById('relationshipRole')?.value || '',
                        relationship_role_custom: document.getElementById('relationshipRoleCustom')?.value || '',
                        relationship_notes: document.getElementById('relationshipNotes')?.value || '',
                        is_ex_relationship: document.getElementById('exRelationship')?.checked || false
                    },
                    transitParams: {
                        startDate: document.getElementById('transitStartDate')?.value || '',
                        endDate: document.getElementById('transitEndDate')?.value || '',
                        step: document.getElementById('transitStep')?.value || ''
                    },
                    relocation: {
                        enabled: document.getElementById('relocationToggle')?.checked || false,
                        coords: document.getElementById('relocationCoords')?.value || '',
                        includePersonB: document.getElementById('includePersonBRelocation')?.checked || false
                    },
                    contextMode: {
                        solo: document.querySelector('input[name="soloSubtype"]:checked')?.value || '',
                        relational: document.querySelector('input[name="relationalSubtype"]:checked')?.value || ''
                    }
                };

                // Generate filename with names and timestamp
                const nameA = chartData.personA.name || 'PersonA';
                const nameB = chartData.personB.name;
                const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                
                let filename;
                if (nameB && currentContextType === 'relational') {
                    filename = `math_brain_${nameA}_${nameB}_${timestamp}.json`;
                } else {
                    filename = `math_brain_${nameA}_${timestamp}.json`;
                }

                // Create and download file
                const dataStr = JSON.stringify(chartData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // Visual feedback
                const saveBtn = document.getElementById('saveDataBtn');
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '✅ Saved!';
                setTimeout(() => { saveBtn.textContent = originalText; }, 2000);

            } catch (error) {
                console.error('Error saving chart data:', error);
                alert('Error saving chart data: ' + error.message);
            }
        }

        function loadChartData(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const chartData = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!chartData.personA || !chartData.personB) {
                        throw new Error('Invalid chart data format');
                    }

                    // Set a flag to indicate we're loading data (to prevent clearing relationship selections)
                    window.isLoadingChartData = true;

                    // Load Person A data
                    if (chartData.personA) {
                        document.getElementById('nameA').value = chartData.personA.name || '';
                        document.getElementById('birth_cityA').value = chartData.personA.birth_city || '';
                        document.getElementById('birth_stateA').value = chartData.personA.birth_state || '';
                        document.getElementById('birth_dateA').value = chartData.personA.birth_date || '';
                        document.getElementById('birth_timeA').value = chartData.personA.birth_time || '';
                        document.getElementById('birth_countryA').value = chartData.personA.birth_country || '';
                        document.getElementById('astroA').value = chartData.personA.astro || '';
                        if (chartData.personA.offset) document.getElementById('offsetA').value = chartData.personA.offset;
                        if (chartData.personA.zodiac) document.getElementById('zodiacA').value = chartData.personA.zodiac;
                    }

                    // Load Person B data
                    if (chartData.personB) {
                        document.getElementById('nameB').value = chartData.personB.name || '';
                        document.getElementById('birth_cityB').value = chartData.personB.birth_city || '';
                        document.getElementById('birth_stateB').value = chartData.personB.birth_state || '';
                        document.getElementById('birth_dateB').value = chartData.personB.birth_date || '';
                        document.getElementById('birth_timeB').value = chartData.personB.birth_time || '';
                        document.getElementById('birth_countryB').value = chartData.personB.birth_country || '';
                        document.getElementById('astroB').value = chartData.personB.astro || '';
                        if (chartData.personB.offset) document.getElementById('offsetB').value = chartData.personB.offset;
                        if (chartData.personB.zodiac) document.getElementById('zodiacB').value = chartData.personB.zodiac;
                    }

                    // Load context type
                    if (chartData.contextType) {
                        const contextRadio = document.querySelector(`input[name="contextType"][value="${chartData.contextType}"]`);
                        if (contextRadio) {
                            contextRadio.checked = true;
                            updateContextType(chartData.contextType);
                        }
                    }

                    // Load relational context AFTER context type is set
                    setTimeout(() => {
                        if (chartData.relationalContext) {
                            const rel = chartData.relationalContext;
                            
                            // Temporarily enable relationship controls for data loading
                            const relationshipControls = document.querySelectorAll('input[name="relationshipType"], input[name="intimacyTier"], #exRelationship');
                            relationshipControls.forEach(control => {
                                control.disabled = false;
                                if (control.parentElement) {
                                    control.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                                }
                            });
                            
                            if (rel.relationship_type) {
                                const typeRadio = document.querySelector(`input[name="relationshipType"][value="${rel.relationship_type}"]`);
                                if (typeRadio) {
                                    typeRadio.checked = true;
                                    typeRadio.dispatchEvent(new Event('change'));
                                }
                            }
                            if (rel.intimacy_tier) {
                                const tierRadio = document.querySelector(`input[name="intimacyTier"][value="${rel.intimacy_tier}"]`);
                                if (tierRadio) tierRadio.checked = true;
                            }
                            if (rel.contact_channel) {
                                const channelRadio = document.querySelector(`input[name="contactChannel"][value="${rel.contact_channel}"]`);
                                if (channelRadio) channelRadio.checked = true;
                            }
                            if (rel.relationship_role) {
                                const roleSelect = document.getElementById('relationshipRole');
                                if (roleSelect) roleSelect.value = rel.relationship_role;
                            }
                            if (rel.relationship_role_custom) {
                                document.getElementById('relationshipRoleCustom').value = rel.relationship_role_custom;
                            }
                            if (rel.relationship_notes) {
                                document.getElementById('relationshipNotes').value = rel.relationship_notes;
                            }
                            if (rel.is_ex_relationship) {
                                document.getElementById('exRelationship').checked = rel.is_ex_relationship;
                            }
                        }
                        
                        // Clear the loading flag and re-evaluate visibility
                        window.isLoadingChartData = false;
                        if (window.evaluateRelationalContextVisibility) {
                            window.evaluateRelationalContextVisibility();
                        }
                    }, 100);

                    // Load transit params
                    if (chartData.transitParams) {
                        const trans = chartData.transitParams;
                        if (trans.startDate) document.getElementById('transitStartDate').value = trans.startDate;
                        if (trans.endDate) document.getElementById('transitEndDate').value = trans.endDate;
                        if (trans.step) document.getElementById('transitStep').value = trans.step;
                    }

                    // Load relocation
                    if (chartData.relocation) {
                        const reloc = chartData.relocation;
                        if (reloc.enabled) document.getElementById('relocationToggle').checked = true;
                        if (reloc.coords) document.getElementById('relocationCoords').value = reloc.coords;
                        if (reloc.includePersonB) document.getElementById('includePersonBRelocation').checked = true;
                    }

                    // Trigger relational context visibility check
                    if (window.evaluateRelationalContextVisibility) {
                        setTimeout(window.evaluateRelationalContextVisibility, 100);
                    }

                    // Visual feedback
                    const loadBtn = document.getElementById('loadDataBtn');
                    const originalText = loadBtn.textContent;
                    loadBtn.textContent = '✅ Loaded!';
                    setTimeout(() => { loadBtn.textContent = originalText; }, 2000);

                } catch (error) {
                    console.error('Error loading chart data:', error);
                    alert('Error loading chart data: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // --- Health Data Integration Functions ---

    function parseHealthAutoExportJSON(healthData) {
            // Auto-detect & normalize Health Auto Export variants (focus: stateOfMind, HRV, Resting HR, Sleep)
            try {
                if (!healthData || !healthData.data) return {};
                const raw = healthData.data;
                const metrics = {};

                const addMetricPoint = (metricKey, dateISO, value, extra={}) => {
                    if (value == null || isNaN(value)) return;
                    if (!metrics[metricKey]) metrics[metricKey] = [];
                    metrics[metricKey].push({ date: dateISO, value: +value, ...extra });
                };

                const toDateKey = (ts) => {
                    if (!ts) return null;
                    // Accept direct YYYY-MM-DD
                    if (typeof ts === 'string' && ts.length === 10 && /\d{4}-\d{2}-\d{2}/.test(ts)) return ts;
                    // Use Central time to compute calendar day
                    const d = new Date(ts);
                    if (isNaN(d)) return null;
                    try {
                        const fmt = new Intl.DateTimeFormat('en-CA', {
                            timeZone: 'America/Chicago', year: 'numeric', month: '2-digit', day: '2-digit'
                        });
                        return fmt.format(d); // en-CA yields YYYY-MM-DD
                    } catch(_) {
                        // Fallback to local if Intl/timeZone not available
                        const year = d.getFullYear();
                        const m = String(d.getMonth()+1).padStart(2,'0');
                        const day = String(d.getDate()).padStart(2,'0');
                        return `${year}-${m}-${day}`;
                    }
                };

                // 1. State of Mind (mood / emotion) → mood_valence
                if (Array.isArray(raw.stateOfMind)) {
                    const daily = {};
                    raw.stateOfMind.forEach(entry => {
                        const dateKey = toDateKey(entry.start || entry.date || entry.end);
                        if (!dateKey) return;
                        if (!daily[dateKey]) {
                            daily[dateKey] = {
                                totalValence: 0,
                                count: 0,
                                labels: new Set(),
                                associations: new Set(),
                                classifications: {}
                            };
                        }
                        const bucket = daily[dateKey];
                        if (typeof entry.valence === 'number') {
                            bucket.totalValence += entry.valence;
                            bucket.count += 1;
                        }
                        (entry.labels||[]).forEach(l => bucket.labels.add(l));
                        (entry.associations||[]).forEach(a => bucket.associations.add(a));
                        const cls = entry.valenceClassification || 'unclassified';
                        bucket.classifications[cls] = (bucket.classifications[cls]||0)+1;
                    });
                    Object.entries(daily).forEach(([date, aggr]) => {
                        const avg = aggr.count ? aggr.totalValence / aggr.count : null;
                        if (avg != null) {
                            // Determine dominant classification
                            let dominantCls = null, maxC = -1;
                            Object.entries(aggr.classifications).forEach(([cls,c]) => { if (c>maxC){dominantCls=cls;maxC=c;} });
                            addMetricPoint('mood_valence', date, avg, {
                                classification: dominantCls,
                                labels: Array.from(aggr.labels),
                                associations: Array.from(aggr.associations)
                            });
                            // Intensity proxy: count of distinct mood labels on that day
                            addMetricPoint('mood_label_count', date, aggr.labels.size || 0);
                        }
                    });
                }

                // 2. Generic metrics array (some exports) → expects [{ name, units, data:[{date,value}]}]
                if (Array.isArray(raw.metrics)) {
                    raw.metrics.forEach(metric => {
                        if (!metric || !metric.name || !Array.isArray(metric.data)) return;
                        const keyNorm = metric.name.toLowerCase();
                        let targetKey = null;
                        if (keyNorm.includes('variability') || keyNorm.includes('hrv')) targetKey = 'hrv';
                        else if ((keyNorm.includes('rest') || keyNorm.includes('resting')) && keyNorm.includes('heart')) targetKey = 'resting_hr';
                        else if (keyNorm.includes('walking') && keyNorm.includes('heart') && keyNorm.includes('average')) targetKey = 'walking_hr_avg';
                        else if (keyNorm.includes('heart_rate') && !keyNorm.includes('rest') && !keyNorm.includes('walking')) targetKey = 'heart_rate';
                        else if (keyNorm.includes('sleep') && (keyNorm.includes('analysis') || keyNorm.includes('duration') || keyNorm.includes('hours'))) targetKey = 'sleep_hours';
                        else if ((keyNorm.includes('wrist') || keyNorm.includes('skin')) && keyNorm.includes('temperature')) targetKey = 'sleep_temp';
                        else if (keyNorm.includes('walking_asymmetry')) targetKey = 'walk_asym_pct';
                        else if (keyNorm.includes('double_support')) targetKey = 'walk_double_support_pct';
                        else if ((keyNorm.includes('walking') || keyNorm.includes('running')) && keyNorm.includes('distance')) targetKey = 'walking_distance';
                        else if (keyNorm.includes('exercise_time') || (keyNorm.includes('exercise') && keyNorm.includes('minutes'))) targetKey = 'exercise_minutes';
                        else if (keyNorm.includes('stand_time') || (keyNorm.includes('stand') && keyNorm.includes('minutes'))) targetKey = 'stand_minutes';
                        else if (keyNorm.includes('stand_hour')) targetKey = 'stand_hours';
                        else if (keyNorm.includes('active_energy') || keyNorm.includes('basal_energy') || keyNorm.includes('active kilocalories') || keyNorm.includes('active calories')) targetKey = 'active_energy';
                        else if (keyNorm.includes('mindful_minutes') || keyNorm.includes('mindful')) targetKey = 'mindful_minutes';
                        else return; // ignore others for now
                        metric.data.forEach(dp => {
                            const dateKey = toDateKey(dp.date);
                            if (!dateKey) return;
                            let val = dp.value ?? dp.qty;
                            if (val == null) return;
                            if (targetKey === 'sleep_hours' && dp.durationMinutes) {
                                val = dp.durationMinutes / 60;
                            }
                            addMetricPoint(targetKey, dateKey, val, { unit: metric.units });
                        });
                    });
                }

                // 3. Sleep sessions (alternate structure) → sleep_hours
                // Accept keys like sleepSessions / sleep / sleepData
                const sleepContainer = raw.sleepSessions || raw.sleep || raw.sleepData;
                if (Array.isArray(sleepContainer)) {
                    const byDate = {};
                    sleepContainer.forEach(s => {
                        const start = new Date(s.start || s.begin || s.startDate);
                        const end = new Date(s.end || s.finish || s.endDate);
                        if (isNaN(start) || isNaN(end)) return;
                        const durationH = Math.max(0,(end - start) / (1000*60*60));
                        const dateKey = toDateKey(end.toISOString()); // assign to wake day
                        byDate[dateKey] = (byDate[dateKey]||0) + durationH;
                    });
                    Object.entries(byDate).forEach(([date,val]) => addMetricPoint('sleep_hours', date, val));
                }

                return metrics;
            } catch (e) {
                console.error('Error parsing health data:', e);
                throw new Error('Invalid health data format');
            }
        }

        function correlateHealthWithSeismograph(healthData, seismographData) {
            const correlations = [];
            
            try {
                // Group health data by date
                const healthByDate = {};
                Object.keys(healthData).forEach(metricName => {
                    healthData[metricName].forEach(point => {
                        const date = point.date.split('T')[0]; // Get YYYY-MM-DD
                        if (!healthByDate[date]) healthByDate[date] = {};
                        healthByDate[date][metricName] = point.value;
                    });
                });

                // Correlate with seismograph readings
                Object.keys(seismographData).forEach(date => {
                    const seismo = seismographData[date];
                    const health = healthByDate[date];
                    
                    if (health && seismo) {
                        correlations.push({
                            date: date,
                            magnitude: seismo.magnitude || 0,
                            valence: seismo.valence || 0,
                            volatility: seismo.volatility || 0,
                            health: health,
                            correlationScore: calculateCorrelationScore(seismo, health)
                        });
                    }
                });

                return correlations;
            } catch (error) {
                console.error('Error correlating health data:', error);
                return [];
            }
        }

        function calculateCorrelationScore(seismo, health) {
            // Heuristic similarity score (0..1). Future: replace with rolling Pearson across arrays.
            let scoreSum = 0, parts = 0;
            // Mood valence ↔ symbolic valence (directional alignment)
            if (typeof health.mood_valence === 'number' && typeof seismo.valence === 'number') {
                const hv = Math.max(-1, Math.min(1, health.mood_valence)); // already approx -1..+1
                const sv = Math.max(-1, Math.min(1, seismo.valence / 5)); // normalize -5..5 → -1..1
                const alignment = 1 - Math.abs(hv - sv) / 2; // 1 perfect, 0 worst
                scoreSum += alignment; parts++;
            }
            // HRV (if present) ↔ volatility (change sensitivity) – normalized inverse distance
            if (typeof health.hrv === 'number' && typeof seismo.volatility === 'number') {
                const h = Math.min(150, Math.max(0, health.hrv)) / 150; // crude 0..1
                const v = seismo.volatility / 5; // 0..1
                scoreSum += 1 - Math.abs(h - v); parts++;
            }
            // Sleep hours ↔ magnitude dampening (long sleep might appear with lower magnitude)
            if (typeof health.sleep_hours === 'number' && typeof seismo.magnitude === 'number') {
                const sleepN = Math.min(12, Math.max(0, health.sleep_hours)) / 12; // 0..1
                const magN = seismo.magnitude / 5; // 0..1
                // Assume moderate inverse relationship (regulation) – treat closeness to (sleepN + magN ≈ 1) as alignment
                const target = Math.abs((sleepN + magN) - 1);
                scoreSum += 1 - target; parts++;
            }
            return parts ? scoreSum / parts : 0;
        }

        function generateHealthCorrelationTable(correlations) {
            if (!correlations || correlations.length === 0) {
                return "No health data available for correlation analysis.";
            }

            let table = "## Health Data Correlation Analysis\n\n";
            table += "| Date | Magnitude | Valence | Volatility | Health Metrics | Correlation Score |\n";
            table += "|------|-----------|---------|------------|----------------|-------------------|\n";

            correlations.forEach(corr => {
                const healthSummary = Object.keys(corr.health).map(key => 
                    `${key}: ${corr.health[key]}`
                ).join(', ');
                
                table += `| ${corr.date} | ${corr.magnitude.toFixed(2)} | ${corr.valence.toFixed(2)} | ${corr.volatility.toFixed(2)} | ${healthSummary} | ${corr.correlationScore.toFixed(3)} |\n`;
            });

            table += "\n*Correlation scores range from 0 (no correlation) to 1 (perfect correlation)*\n\n";
            return table;
        }

        function loadHealthData(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const healthData = JSON.parse(e.target.result);
                    const parsedMetrics = parseHealthAutoExportJSON(healthData);
                    
                    loadedHealthData = parsedMetrics;
                    const metricKeys = Object.keys(parsedMetrics);
                    const coverageParts = metricKeys.map(k => {
                        const dates = (parsedMetrics[k]||[]).map(p=>p.date).filter(Boolean).sort();
                        if (!dates.length) return `${k}: —`;
                        return `${k}: ${dates[0]} → ${dates[dates.length-1]} (${dates.length}d)`;
                    });
                    const statusMsg = metricKeys.length
                      ? `${metricKeys.length} metrics loaded • ${coverageParts.join(' • ')}`
                      : 'No metrics recognized in file';
                    updateHealthDataStatus(statusMsg);
                    // Build per-date map for quick correlation badges
                    try {
                        const byDate = {};
                        metricKeys.forEach(mk => {
                            (parsedMetrics[mk]||[]).forEach(pt => {
                                const dkey = (pt.date||'').slice(0,10);
                                if (!/^\d{4}-\d{2}-\d{2}$/.test(dkey)) return;
                                if (!byDate[dkey]) byDate[dkey] = {};
                                byDate[dkey][mk] = pt.value;
                            });
                        });
                        window.WM_HEALTH_BY_DATE = byDate;
                    } catch(_) { window.WM_HEALTH_BY_DATE = null; }
                    // Show clear button
                    clearHealthDataBtn.classList.remove('hidden');
                    updateComparativeAvailability();
                    
                } catch (error) {
                    console.error('Error loading health data:', error);
                    alert('Error loading health data: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function clearHealthData() {
            loadedHealthData = null;
            window.WM_HEALTH_BY_DATE = null;
            updateHealthDataStatus("");
            clearHealthDataBtn.classList.add('hidden');
            updateComparativeAvailability();
            
            // Visual feedback
            const clearBtn = clearHealthDataBtn;
            const originalText = clearBtn.textContent;
            clearBtn.textContent = '✅ Cleared!';
            setTimeout(() => { clearBtn.textContent = originalText; }, 2000);
        }

        function updateHealthDataStatus(message, metrics = null) {
            if (message) {
                if (metrics && Object.keys(metrics).length > 0) {
                    const metricsList = Object.keys(metrics).map(key => {
                        const count = metrics[key].length;
                        const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `${displayName} (${count} days)`;
                    }).join(', ');
                    healthDataStatus.innerHTML = `<strong>${message}</strong><br><span class="text-xs text-gray-400">${metricsList}</span>`;
                } else {
                    healthDataStatus.textContent = message;
                }
                healthDataStatus.classList.remove('hidden');
                healthDataStatus.classList.add('text-green-400');
            } else {
                healthDataStatus.classList.add('hidden');
                healthDataStatus.classList.remove('text-green-400');
            }
        }

    // --- Balance Meter Log Ingestion ---
    let loadedSeismographData = null; // date -> { magnitude, valence, volatility }

    function loadSeismographJson(file){
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e){
                try {
                    const text = e.target.result;
                    const parsed = JSON.parse(text);
                    
                                        // Validate the JSON structure and support three shapes:
                                        // 1) { map: { YYYY-MM-DD: { magnitude,valence,volatility } } }
                                        // 2) Raven wrapper with { seismograph_by_date: { ... } }
                                        // 3) Raven Balance Meter with { balance_meter: { daily_entries: { YYYY-MM-DD: { seismograph:{...} | magnitude/valence/volatility } } } }
                                        if (!parsed || typeof parsed !== 'object') throw new Error('Invalid JSON structure');
                                        let candidateMap = null;
                                        if (parsed.map && typeof parsed.map === 'object') {
                                            candidateMap = parsed.map;
                                        } else if (parsed.seismograph_by_date && typeof parsed.seismograph_by_date === 'object') {
                                            candidateMap = parsed.seismograph_by_date;
                                        } else if (parsed.balance_meter?.daily_entries && typeof parsed.balance_meter.daily_entries === 'object') {
                                            const raw = parsed.balance_meter.daily_entries;
                                            const out = {};
                                            Object.keys(raw).forEach(date => {
                                                const entry = raw[date];
                                                if (!entry || typeof entry !== 'object') return;
                                                const s = entry.seismograph && typeof entry.seismograph === 'object' ? entry.seismograph : entry;
                                                const mag = Number(s.magnitude);
                                                const val = Number(s.valence);
                                                const vol = Number(s.volatility);
                                                if (Number.isFinite(mag) && Number.isFinite(val) && Number.isFinite(vol)) {
                                                    out[date] = { magnitude: mag, valence: val, volatility: vol };
                                                }
                                            });
                                            if (Object.keys(out).length) candidateMap = out;
                                        }
                                        if (!candidateMap) throw new Error('File must contain Balance Meter daily bars via "seismograph_by_date", "map", or "balance_meter.daily_entries"');
                    
                    // Validate that map has date entries
                    const dates = Object.keys(candidateMap);
                    if (dates.length === 0) {
                        throw new Error('No date entries found in JSON map');
                    }
                    
                    // Validate date format and data structure
                    for (const date of dates) {
                        if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                            throw new Error(`Invalid date format: ${date}. Expected YYYY-MM-DD`);
                        }
                        
                        const entry = candidateMap[date];
                        if (!entry || typeof entry !== 'object') {
                            throw new Error(`Invalid entry for date ${date}`);
                        }
                        
                        // Ensure required numeric fields
                        ['magnitude', 'valence', 'volatility'].forEach(field => {
                            if (typeof entry[field] !== 'number' || !Number.isFinite(entry[field])) {
                                throw new Error(`Invalid ${field} for date ${date}: must be a finite number`);
                            }
                        });
                        
                        // Ensure hooks is an array if present
                        if (entry.hooks && !Array.isArray(entry.hooks)) {
                            throw new Error(`Invalid hooks for date ${date}: must be an array`);
                        }
                    }
                    
                    loadedSeismographData = candidateMap;
                    updateSeismoDataStatus(dates.length + ' Balance Meter days loaded');
                    clearSeismoBtn.classList.remove('hidden');
                    updateComparativeAvailability();
                } catch(err){
                    console.error('Balance Meter JSON parse error:', err);
                    alert('Error parsing Balance Meter JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function clearSeismograph(){
            loadedSeismographData = null;
            updateSeismoDataStatus('');
            clearSeismoBtn.classList.add('hidden');
            updateComparativeAvailability();
            const btn = clearSeismoBtn;
            const originalText = btn.textContent; btn.textContent = '✅ Cleared!';
            setTimeout(()=> btn.textContent = originalText, 2000);
        }

        function updateSeismoDataStatus(message){
            if (message){
                seismoDataStatus.textContent = message;
                seismoDataStatus.classList.remove('hidden');
                seismoDataStatus.classList.add('text-green-400');
            } else {
                seismoDataStatus.classList.add('hidden');
                seismoDataStatus.classList.remove('text-green-400');
            }
        }

        function updateComparativeAvailability(){
            const ready = !!(loadedHealthData && loadedSeismographData);
            if (ready){
                genComparativeBtn.classList.remove('hidden');
                genComparativeBtn.disabled = false;
                genComparativePdfBtn.classList.remove('hidden');
                genComparativePdfBtn.disabled = false;
            } else {
                genComparativeBtn.disabled = true;
                genComparativePdfBtn.disabled = true;
                if (loadedHealthData || loadedSeismographData){
                    genComparativeBtn.classList.remove('hidden');
                    genComparativePdfBtn.classList.remove('hidden');
                } else {
                    genComparativeBtn.classList.add('hidden');
                    genComparativePdfBtn.classList.add('hidden');
                }
            }
        }

        function generateComparativeReport(){
            try {
                if (!loadedHealthData || !loadedSeismographData) {
                    alert('Please load both Health JSON and Seismograph JSON first.');
                    return;
                }
                if (typeof generateComparativeReportMarkdown !== 'function'){
                    throw new Error('Comparative reporter not available');
                }
                const md = generateComparativeReportMarkdown(loadedSeismographData, loadedHealthData);
                const fname = `comparative_${new Date().toISOString().slice(0,10)}.md`;
                downloadFile(md, fname, 'text/markdown');
                const original = genComparativeBtn.textContent; genComparativeBtn.textContent = '✅ Exported!';
                setTimeout(()=> genComparativeBtn.textContent = original, 2000);
            } catch (e){
                console.error('Comparative export failed:', e);
                alert('Failed to generate comparative report: ' + e.message);
            }
        }

        async function generateComparativeReportPDF(){
            try {
                if (!loadedHealthData || !loadedSeismographData) {
                    alert('Please load both Health JSON and Seismograph JSON first.');
                    return;
                }
                if (typeof generateComparativeReportMarkdown !== 'function'){
                    throw new Error('Comparative reporter not available');
                }
                
                // Check if html2pdf is available with enhanced loading check
                if (!isPDFLibraryReady()) {
                    console.error('html2pdf library not loaded, attempting to wait for it...');
                    
                    try {
                        // Try waiting for the library to load with shorter timeout
                        await waitForPDFLibrary(3000);
                        console.log('PDF library loaded successfully after waiting');
                    } catch (error) {
                        console.error('PDF library failed to load:', error);
                        
                        // Direct fallback to print without confusing user with dialogs
                        console.log('Using print-to-PDF fallback');
                        const person1Name = document.getElementById('nameA').value || 'PersonA';
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                        const filename = `correlation_analysis_${person1Name}_${timestamp}.pdf`;
                        
                        printReportAsPDF(md, filename);
                        
                        // Update button state
                        btn.textContent = '✅ Print Dialog Opened!';
                        setTimeout(() => { btn.textContent = originalText; btn.disabled = false; }, 3000);
                        return;
                    }
                }

                const btn = document.getElementById('genComparativePdfBtn');
                const originalText = btn.textContent;
                btn.textContent = '⏳ Generating PDF...';
                btn.disabled = true;

                // Generate markdown report
                const md = generateComparativeReportMarkdown(loadedSeismographData, loadedHealthData);
                
                // Convert to HTML
                const htmlContent = convertMarkdownToHTML(md);
                
                // Generate filename
                const person1Name = document.getElementById('nameA').value || 'PersonA';
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const filename = `correlation_analysis_${person1Name}_${timestamp}.pdf`;
                
                // Create temporary element for PDF generation
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.top = '-9999px';
                document.body.appendChild(tempDiv);
                
                // PDF generation options
                const options = {
                    margin: [10, 10, 10, 10],
                    filename: filename,
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { 
                        scale: 2, 
                        useCORS: true,
                        letterRendering: true,
                        allowTaint: false
                    },
                    jsPDF: { 
                        unit: 'mm', 
                        format: 'a4', 
                        orientation: 'portrait',
                        compress: true
                    },
                    pagebreak: { mode: 'avoid-all', before: '.page-break' }
                };
                
                // Generate and download PDF
                const pdfBlob = await html2pdf().set(options).from(tempDiv).outputPdf('blob');
                
                // Create download link and trigger
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Clean up
                document.body.removeChild(tempDiv);
                
                // Success feedback
                btn.textContent = '✅ Downloaded!';
                setTimeout(() => { btn.textContent = originalText; btn.disabled = false; }, 2000);
                
            } catch (e){
                console.error('Comparative PDF export failed:', e);
                alert('Failed to generate correlation PDF: ' + e.message);
                
                // Restore button state
                const btn = document.getElementById('genComparativePdfBtn');
                btn.textContent = '📑 Download Correlation (.pdf)';
                btn.disabled = false;
            }
        }

        // Note: Enhanced printReportAsPDF function is defined in the head section

        // Convert markdown to HTML for PDF generation
        function convertMarkdownToHTML(markdown) {
            // Simple markdown to HTML conversion
            let html = markdown
                // Headers
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                // Bold and italic
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                // Links
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
                // Code blocks
                .replace(/```[\s\S]*?```/g, '<pre><code>$&</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Lists
                .replace(/^\- (.*)$/gm, '<li>$1</li>')
                .replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>')
                // Tables (basic support)
                .replace(/\|.*\|/g, (match) => {
                    const cells = match.split('|').filter(cell => cell.trim());
                    return '<tr>' + cells.map(cell => `<td>${cell.trim()}</td>`).join('') + '</tr>';
                })
                .replace(/(<tr>.*<\/tr>)/gs, '<table border="1" style="border-collapse: collapse; width: 100%; margin: 10px 0;">$1</table>')
                // Line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');
            
            // Wrap in basic HTML structure with PDF-friendly styling
            return `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body { 
                            font-family: 'Times New Roman', serif; 
                            line-height: 1.4; 
                            color: #333; 
                            max-width: 100%; 
                            padding: 20px;
                            font-size: 12px;
                        }
                        h1 { color: #2c5aa0; font-size: 18px; margin: 20px 0 10px 0; }
                        h2 { color: #2c5aa0; font-size: 16px; margin: 15px 0 8px 0; }
                        h3 { color: #2c5aa0; font-size: 14px; margin: 12px 0 6px 0; }
                        p { margin: 8px 0; }
                        table { border-collapse: collapse; width: 100%; margin: 10px 0; font-size: 10px; }
                        td, th { border: 1px solid #ccc; padding: 4px; text-align: left; }
                        code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
                        pre { background: #f5f5f5; padding: 10px; border-radius: 5px; overflow-wrap: break-word; }
                        strong { color: #2c5aa0; }
                        .page-break { page-break-before: always; }
                    </style>
                </head>
                <body>
                    <p>${html}</p>
                </body>
                </html>
            `;
        }

        // Populate Mirror/Balance Meter tab content based on result
        function populateTabContent(result, formData, report, hasTransitsMode, hasTransitData) {
            console.log('=== POPULATE TAB CONTENT DEBUG ===');
            console.log('Has balance_meter in result:', Boolean(result?.balance_meter));
            console.log('Has person A transits:', Boolean(result?.person_a?.chart?.transitsByDate));
            console.log('Report length:', report?.length);
            
            try {
                const balanceWrap = document.getElementById('balanceMeterTabContent');
                if (!balanceWrap) {
                    console.log('ERROR: balanceMeterTabContent element not found');
                    return;
                }
                
                console.log('Found balance wrap element:', balanceWrap);
                
                // Clear previous content
                balanceWrap.innerHTML = '';
                
                // Decide what to render for the Balance Meter tab
                const activeTab = (typeof getCurrentActiveTabMode === 'function') ? getCurrentActiveTabMode() : 'mirror';
                console.log('Active tab for populate:', activeTab);
                console.log('Balance Meter tab content element:', document.getElementById('balance-meter-content'));
                console.log('Balance Meter tab content hidden class:', document.getElementById('balance-meter-content')?.classList.contains('hidden'));
                
                // Force check the actual DOM state
                const balanceTabElement = document.getElementById('balanceMeterModeTab');
                const mirrorTabElement = document.getElementById('mirrorModeTab');
                console.log('DOM state check:');
                console.log('- Balance tab aria-selected:', balanceTabElement?.getAttribute('aria-selected'));
                console.log('- Mirror tab aria-selected:', mirrorTabElement?.getAttribute('aria-selected'));
                console.log('- Balance content hidden:', document.getElementById('balance-meter-content')?.classList.contains('hidden'));
                console.log('- Mirror content hidden:', document.getElementById('mirror-content')?.classList.contains('hidden'));
                
                if (result && result.balance_meter) {
                    console.log('Rendering server-provided Balance Meter payload');
                    // Render server-provided Balance Meter payload
                    try {
                        const balanceHTML = renderBalanceMeterHTML(result.balance_meter, result);
                        console.log('Built Balance Meter HTML, length:', balanceHTML?.length);
                        balanceWrap.innerHTML = balanceHTML;
                        console.log('Appended Balance Meter content to tab');
                    } catch (e) {
                        console.warn('Balance Meter render failed, falling back to JSON view:', e);
                        const pre = document.createElement('pre');
                        pre.className = 'whitespace-pre-wrap text-xs text-gray-300 bg-gray-900/60 p-4 rounded border border-gray-700';
                        pre.textContent = JSON.stringify(result.balance_meter, null, 2);
                        balanceWrap.appendChild(pre);
                    }
                } else if ((activeTab === 'balance_meter' || balanceTabElement?.getAttribute('aria-selected') === 'true') && (result?.person_a?.chart?.transitsByDate)) {
                    console.log('Synthesizing Balance Meter payload from transits (using DOM check)');
                    // Synthesize a minimal Balance Meter payload from available transits
                    try {
                        const synthetic = synthesizeBalanceMeterPayload(result, formData);
                        console.log('Synthesized payload:', synthetic ? 'success' : 'failed');
                        const balanceHTML = renderBalanceMeterHTML(synthetic);
                        console.log('Built synthetic Balance Meter HTML, length:', balanceHTML?.length);
                        balanceWrap.innerHTML = balanceHTML;
                        console.log('Appended synthetic Balance Meter content to tab');
                    } catch (e) {
                        console.warn('Synthetic Balance Meter render failed:', e);
                        balanceWrap.innerHTML = '<p class="text-gray-400 text-sm">No Balance Meter data for this selection.</p>';
                    }
                } else {
                    console.log('No Balance Meter data available, showing message');
                    console.log('Conditions not met:');
                    console.log('- activeTab === balance_meter:', activeTab === 'balance_meter');
                    console.log('- balanceTabElement aria-selected === true:', balanceTabElement?.getAttribute('aria-selected') === 'true');
                    console.log('- has person A transits:', Boolean(result?.person_a?.chart?.transitsByDate));
                    // Enhanced placeholder with guidance
                    balanceWrap.innerHTML = `
                        <div class="bg-gray-800 p-8 rounded-xl border border-gray-700 text-center">
                            <div class="mb-4">
                                <span class="text-6xl">⚖️</span>
                            </div>
                            <h3 class="text-xl font-semibold text-gray-300 mb-3">Balance Meter Analysis</h3>
                            <p class="text-gray-400 mb-4">Triple-channel architecture combining Seismograph, Balance Channel, and SFD measurements</p>
                            <div class="bg-gray-700/50 p-4 rounded-lg border border-gray-600 mb-4">
                                <p class="text-sm text-gray-300 mb-2">To generate Balance Meter data:</p>
                                <ol class="text-sm text-gray-400 text-left space-y-1">
                                    <li>1. Enter birth data and location</li>
                                    <li>2. Set a date range for transit analysis</li>
                                    <li>3. Click "Get My Mirror" to generate reports</li>
                                    <li>4. Balance Meter will appear alongside other analyses</li>
                                </ol>
                            </div>
                            <div class="flex items-center justify-center gap-4 text-xs text-gray-500">
                                <span class="flex items-center gap-1"><span class="w-2 h-2 bg-purple-500 rounded-full"></span> Seismograph v1.0</span>
                                <span class="flex items-center gap-1"><span class="w-2 h-2 bg-teal-500 rounded-full"></span> Balance v1.1</span>
                                <span class="flex items-center gap-1"><span class="w-2 h-2 bg-amber-500 rounded-full"></span> SFD v1.2</span>
                                <span class="flex items-center gap-1"><span class="w-2 h-2 bg-emerald-500 rounded-full"></span> Resilience Layer</span>
                            </div>
                        </div>
                    `;
                }
                console.log('=== END POPULATE TAB CONTENT DEBUG ===');
            } catch (e) {
                console.warn('populateTabContent encountered an issue:', e);
            }
        }

        // Build a minimal, consistent Balance Meter payload from existing transit seismograph entries
        function synthesizeBalanceMeterPayload(result, formData) {
            const daily_entries = result?.person_a?.chart?.transitsByDate || {};

            // Derive simple channel averages (for summary cards)
            let seismoAvg = 0, balAvg = 0, sfdAvg = 0, count = 0;
            Object.values(daily_entries).forEach(d => {
                const s = d?.seismograph; const b = d?.balance; const f = d?.sfd;
                if (s && typeof s.valence === 'number') seismoAvg += s.valence;
                if (b && typeof b.valence === 'number') balAvg += b.valence;
                if (f && typeof f.sfd === 'number') sfdAvg += f.sfd;
                count++;
            });
            const channel_summary = count > 0 ? {
                seismograph_average: +(seismoAvg / count).toFixed(2),
                balance_average: +(balAvg / count).toFixed(2),
                sfd_average: +(sfdAvg / count).toFixed(2),
                dominant_channel: 'derived',
                volatility_index: (result?.person_a?.derived?.seismograph_summary?.volatility) || undefined
            } : null;

            const sortedKeys = Object.keys(daily_entries).sort();
            const period = {
                start: formData?.transitParams?.startDate || sortedKeys[0],
                end: formData?.transitParams?.endDate || sortedKeys[sortedKeys.length - 1],
                step: formData?.transitParams?.step || 'daily'
            };

            return {
                period,
                schema_version: '1.2',
                channel_summary,
                daily_entries,
                person: { name: result?.person_a?.details?.name || 'Subject' }
            };
        }

        // --- API Call ---

        async function generateReport() {
            totalRowCount = 0; // Reset counter for each report
            WovenMapConfig.debugLog("Generate button clicked");
            
            // Debug: Check current tab mode
            const currentMode = getCurrentActiveTabMode();
            console.log("🔍 DEBUG: Current active tab mode:", currentMode);
            console.log("🔍 DEBUG: Balance Meter tab aria-selected:", document.getElementById('balanceMeterModeTab')?.getAttribute('aria-selected'));
            console.log("🔍 DEBUG: Mirror tab aria-selected:", document.getElementById('mirrorModeTab')?.getAttribute('aria-selected'));
            
            if (!validateForm()) {
                console.log("❌ DEBUG: Form validation failed");
                return;
            }

            console.log("✅ DEBUG: Form validation passed");
            hideError();
            generateBtn.disabled = true;
            loadingIndicator.classList.remove('hidden');
            try { loadingIndicator.setAttribute('aria-busy','true'); } catch(_){}
            reportOutput.classList.add('hidden');
            // Hide Mirror tab report display when starting new generation
            const mirrorReportDisplay = document.getElementById('mirrorReportDisplay');
            if (mirrorReportDisplay) {
                mirrorReportDisplay.classList.add('hidden');
            }
            // Hide report action buttons when starting new generation
            // Copy report removed
            document.getElementById('downloadReport').classList.add('hidden');
            document.getElementById('downloadPDF').classList.add('hidden');
            document.getElementById('pdfOptions').classList.add('hidden');

            try {
                const formData = collectFormData();
                
                // Debug: Log form data structure
                console.log("DEBUG: Collected form data:");
                console.log("- Mode:", formData.context?.mode);
                console.log("- Transit params:", formData.transitParams);
                console.log("- Person A:", !!formData.personA);
                console.log("- Full form data:", JSON.stringify(formData, null, 2));
                
                // Log the complete data being sent to API
                console.log("=== SENDING TO API ===");
                console.log("Full form data:", JSON.stringify(formData, null, 2));
                console.log("PersonA structure:", JSON.stringify(formData.personA, null, 2));
                WovenMapConfig.debugLog("Sending data to API", formData);
                
                // Double-check required fields using configuration
                // Skip person validation for sky-only mode
                if (formData?.context?.mode !== 'sky_transits') {
                    const requiredFields = WovenMapConfig.validation.requiredFields.person;
                    const missingFields = requiredFields.filter(field => {
                        const value = formData.personA[field];
                        return value === undefined || value === null || value === "";
                    });
                    if (missingFields.length > 0) {
                        throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
                    }
                }
                
                // Use chunking-aware generation to handle large date ranges
                const result = await generateReportWithChunking(formData);

                // --- Shape Harmonization Shim ---
                (function harmonizeResultShape(r){
                    try {
                        // Synastry: ensure r.synastry.aspects present if nested chart form used
                        if (r.synastry && !r.synastry.aspects && r.synastry.chart?.aspects && Array.isArray(r.synastry.chart.aspects)) {
                            r.synastry.aspects = r.synastry.chart.aspects;
                        }
                        // Composite: some earlier frontend code expects composite.chart.* already; if only composite.aspects given, wrap
                        if (r.composite && !r.composite.chart && r.composite.aspects) {
                            r.composite.chart = { aspects: r.composite.aspects };
                        }
                        // Transit containers: normalize transitsByDate key if only transits present & shaped as date map
                        const maybePromote = (chartObj) => {
                            if (!chartObj || chartObj.transitsByDate) return;
                            if (chartObj.transits && !Array.isArray(chartObj.transits)) {
                                // Heuristic: if it's an object whose keys look like YYYY-MM-DD
                                const keys = Object.keys(chartObj.transits || {});
                                if (keys.length && keys.every(k => /^\d{4}-\d{2}-\d{2}$/.test(k))) {
                                    chartObj.transitsByDate = chartObj.transits; // promote
                                }
                            }
                        };
                        if (r.person_a?.chart) maybePromote(r.person_a.chart);
                        if (r.person_b?.chart) maybePromote(r.person_b.chart);
                        if (r.synastry) maybePromote(r.synastry); // in case synastry transits delivered similarly
                        if (r.composite) maybePromote(r.composite);
                    } catch (e) {
                        console.warn('Shape harmonization encountered an issue:', e);
                    }
                })(result);

                // Store result data for downloads
                latestResultData = result;
                // Attach v1.4 Empty Templates into result.reports for JSON download parity
                try {
                    const formDataContext = collectFormData();
                    const aDetails = result?.person_a?.details || formDataContext?.personA || {};
                    const bDetails = result?.person_b?.details || formDataContext?.personB || {};
                    // Normalize to birthDate/time/city/state where possible
                    const normA = {
                        name: aDetails.name,
                        birthDate: aDetails.birthDate || (aDetails.year ? `${aDetails.year}-${String(aDetails.month||'').padStart(2,'0')}-${String(aDetails.day||'').padStart(2,'0')}` : undefined),
                        birthTime: aDetails.birthTime || ((aDetails.hour!=null && aDetails.minute!=null) ? `${String(aDetails.hour).padStart(2,'0')}:${String(aDetails.minute).padStart(2,'0')}` : undefined),
                        birthCity: aDetails.birthCity || aDetails.city,
                        birthState: aDetails.birthState || aDetails.nation,
                        timezone: aDetails.timezone
                    };
                    const normB = {
                        name: bDetails.name,
                        birthDate: bDetails.birthDate || (bDetails.year ? `${bDetails.year}-${String(bDetails.month||'').padStart(2,'0')}-${String(bDetails.day||'').padStart(2,'0')}` : undefined),
                        birthTime: bDetails.birthTime || ((bDetails.hour!=null && bDetails.minute!=null) ? `${String(bDetails.hour).padStart(2,'0')}:${String(bDetails.minute).padStart(2,'0')}` : undefined),
                        birthCity: bDetails.birthCity || bDetails.city,
                        birthState: bDetails.birthState || bDetails.nation,
                        timezone: bDetails.timezone
                    };
                    const templateCtx = { personA: normA, personB: normB, relocation: formDataContext?.relocation };
                    result.reports = result.reports || {};
                    result.reports.templates = {
                        solo_mirror: buildSoloMirrorEmptyTemplate(templateCtx),
                        relational_mirror: buildRelationalMirrorEmptyTemplate(templateCtx),
                        solo_balance: buildSoloBalanceEmptyTemplate(templateCtx),
                        relational_balance: buildRelationalBalanceEmptyTemplate(templateCtx)
                    };
                } catch (e) { console.debug('Template scaffolds attach skipped', e); }
                // If we're in the Balance tab and server omitted balance_meter, attach a synthesized payload for export parity
                try {
                    const activeTabMode2 = (typeof getCurrentActiveTabMode === 'function') ? getCurrentActiveTabMode() : 'mirror';
                    if (!latestResultData.balance_meter && activeTabMode2 === 'balance_meter' && latestResultData?.person_a?.chart?.transitsByDate) {
                        latestResultData.balance_meter = synthesizeBalanceMeterPayload(latestResultData, formData);
                    }
                } catch(e) { console.debug('Optional attach of synthesized balance_meter skipped', e); }

                // Generate report based on mode
                let report;
                const activeTabMode = (typeof getCurrentActiveTabMode === 'function') ? getCurrentActiveTabMode() : 'mirror';
                const hasServerBalance = Boolean(result.balance_meter);
                
                console.log('=== REPORT GENERATION DEBUG ===');
                console.log('Active tab mode:', activeTabMode);
                console.log('Result mode:', result.mode);
                console.log('Has server balance:', hasServerBalance);
                console.log('Has person A transits:', Boolean(result?.person_a?.chart?.transitsByDate));
                
                // Simplified logic: if Balance Meter tab is active, try to render Balance Meter
                const shouldRenderBalance = activeTabMode === 'balance_meter';
                
                console.log('Should render balance:', shouldRenderBalance);
                console.log('=== END REPORT GENERATION DEBUG ===');
                
                if (shouldRenderBalance) {
                    // Generate Balance Meter report for download/copy/PDF
                    const payload = hasServerBalance ? result.balance_meter : synthesizeBalanceMeterPayload(result, formData);
                    report = buildBalanceMeterReport(payload);
                    console.log('Generated Balance Meter report, length:', report?.length);
                } else {
                    // Generate Mirror report using Clear Mirror template
                    const displayOptions = {
                        includeExecutiveSummary: false,
                        includeJsonAppendix: false,
                        includeProvenance: false
                    };
                    
                    // Use Clear Mirror template for user-facing reports
                    report = generateClearMirrorReport(result, displayOptions);
                    console.log('Generated Clear Mirror report, length:', report?.length);
                }
                
                // Store the generated report for tab switching
                if (report && report.length > 0) {
                    if (shouldRenderBalance) {
                        // Store Balance Meter report
                        latestResultData.balance_meter_report = report;
                    } else {
                        // Store Mirror report
                        latestResultData.mirror_report = report;
                    }
                }
                
                // Check if we have transit hooks that warrant seismograph auto-append
                const hasTransitsMode = formData.context.mode.includes('transits');
                const hasTransitData = result.person_a?.chart?.transitsByDate || result.person_b?.chart?.transitsByDate || result.composite?.transitsByDate || result.synastry?.transitsByDate;

                // If Balance tab is the target, switch to it BEFORE populating so active-tab checks work
                if (shouldRenderBalance) {
                    console.log('🔍 DEBUG: Switching to Balance Meter tab');
                    document.getElementById('balanceMeterModeTab')?.click();
                    console.log('🔍 DEBUG: Balance Meter tab clicked, checking if content is visible');
                    setTimeout(() => {
                        console.log('🔍 DEBUG: Balance Meter content visibility after tab switch:', !document.getElementById('balance-meter-content')?.classList.contains('hidden'));
                    }, 100);
                } else {
                    console.log('🔍 DEBUG: Switching to Mirror tab');
                    document.getElementById('mirrorModeTab')?.click();
                }

                // Populate all tab content (now that the intended tab is active)
                populateTabContent(result, formData, report, hasTransitsMode, hasTransitData);

                // Check for bonus reports and notify user
                const hasMirrorReport = report && report.length > 0;
                const hasBalanceMeterData = Boolean(result.balance_meter) || Boolean(result?.person_a?.chart?.transitsByDate);
                const currentMode = (typeof getCurrentActiveTabMode === 'function') ? getCurrentActiveTabMode() : 'mirror';
                
                // Show notification about bonus reports available
                showBonusReportNotification(hasMirrorReport, hasBalanceMeterData, currentMode);

                // Check if ANY report was generated (Mirror or Balance Meter)
                const mirrorReportExists = report && report.length > 0;
                const balanceMeterReportExists = result.reports?.balance_meter_report && result.reports.balance_meter_report.length > 0;

                if (mirrorReportExists || balanceMeterReportExists) {
                    // Determine which report to show in the global reportContent based on active tab
                    const currentMode = (typeof getCurrentActiveTabMode === 'function') ? getCurrentActiveTabMode() : 'mirror';
                    const isCurrentlyBalanceMode = currentMode === 'balance_meter';
                    
                    // Populate the global reportContent based on currently active tab
                    if (isCurrentlyBalanceMode && balanceMeterReportExists) {
                        reportContent.textContent = result.reports.balance_meter_report;
                    } else if (mirrorReportExists) {
                        reportContent.textContent = report;
                    } else if (balanceMeterReportExists) {
                        reportContent.textContent = result.reports.balance_meter_report;
                    }
                    
                    // Always populate the Mirror tab's visible report area if Mirror report exists
                    if (mirrorReportExists) {
                        const mirrorReportContent = document.getElementById('mirrorReportContent');
                        const mirrorReportDisplay = document.getElementById('mirrorReportDisplay');
                        if (mirrorReportContent && mirrorReportDisplay) {
                            mirrorReportContent.textContent = report;
                            mirrorReportDisplay.classList.remove('hidden');
                        }
                    }

                    reportOutput.classList.remove('hidden');
                    
                    document.getElementById('downloadReport').classList.remove('hidden');
                    document.getElementById('downloadPDF').classList.remove('hidden');
                    document.getElementById('pdfOptions').classList.remove('hidden');
                } else {
                    reportOutput.classList.add('hidden');
                    // Also hide the Mirror tab report display
                    const mirrorReportDisplay = document.getElementById('mirrorReportDisplay');
                    if (mirrorReportDisplay) {
                        mirrorReportDisplay.classList.add('hidden');
                    }
                }
                
                updateSeismographTabIndicator();

                // Auto-focus + reveal animation so user sees the new report immediately
                try {
                    // Smooth scroll to the report container
                    reportOutput.scrollIntoView({ behavior: 'smooth', block: 'start' });

                    // Apply a transient highlight pulse
                    reportContent.classList.add('ring-2','ring-teal-400/70','shadow-lg');
                    setTimeout(() => {
                        reportContent.classList.add('animate-pulse');
                    }, 80);
                    setTimeout(() => {
                        reportContent.classList.remove('animate-pulse');
                    }, 1400);
                    setTimeout(() => {
                        reportContent.classList.remove('ring-2','ring-teal-400/70','shadow-lg');
                    }, 2000);

                    // Move keyboard focus for accessibility
                    if (reportContent?.setAttribute) {
                        reportContent.setAttribute('tabindex','-1');
                        reportContent.focus({ preventScroll: true });
                    }
                } catch(e) { console.debug('Report reveal UX enhancement skipped', e); }

            } catch (error) {
                console.error('Error generating report:', error);
                showError(`Failed to generate report: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
                loadingIndicator.classList.add('hidden');
                try { loadingIndicator.setAttribute('aria-busy','false'); } catch(_){}
            }
        }

        // --- Event Listeners & UI Updates ---

        function setupEventListeners() {
            // Tab switching functionality
            function switchTab(activeTabId, activeContentId) {
                console.log('🔧 DEBUG: switchTab called with:', activeTabId, activeContentId);
                
                // Hide all tab content
                const allTabContent = ['mirror-content', 'balance-meter-content'];
                allTabContent.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('hidden');
                        console.log('🔧 DEBUG: Hidden content:', id);
                    }
                });
                
                // Reset all tab buttons and clean up bonus indicators for clicked tab
                const allTabs = ['mirrorModeTab', 'balanceMeterModeTab'];
                allTabs.forEach(id => {
                    const tab = document.getElementById(id);
                    if (tab) {
                        tab.setAttribute('aria-selected', 'false');
                        tab.className = 'px-6 py-2 text-sm font-medium rounded-md bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors duration-200';
                        
                        // Remove bonus indicator from the tab that's being activated (user has seen it)
                        if (id === activeTabId) {
                            const bonusIndicator = tab.querySelector('.bonus-indicator');
                            if (bonusIndicator) {
                                bonusIndicator.remove();
                            }
                        }
                    }
                });
                
                // Activate selected tab
                const activeTab = document.getElementById(activeTabId);
                const activeContent = document.getElementById(activeContentId);
                console.log('🔧 DEBUG: Found elements - activeTab:', !!activeTab, 'activeContent:', !!activeContent);
                
                if (activeTab && activeContent) {
                    activeTab.setAttribute('aria-selected', 'true');
                    activeTab.className = 'px-6 py-2 text-sm font-medium rounded-md bg-teal-600 text-white transition-colors duration-200';
                    activeContent.classList.remove('hidden');
                    console.log('🔧 DEBUG: Successfully activated tab:', activeTabId, 'and content:', activeContentId);
                    
                    // Update global reportContent based on active tab for downloads/copy
                    if (latestResultData) {
                        const reportContent = document.getElementById('reportContent');
                        if (reportContent && activeTabId === 'balanceMeterModeTab') {
                            // Switch to Balance Meter content if available
                            if (latestResultData.reports?.balance_meter_report) {
                                reportContent.textContent = latestResultData.reports.balance_meter_report;
                            }
                        } else if (reportContent && activeTabId === 'mirrorModeTab') {
                            // Switch to Mirror content if available
                            if (latestResultData.mirror_report) {
                                reportContent.textContent = latestResultData.mirror_report;
                            }
                        }
                    }
                    
                    // Update mode description
                    const descriptions = {
                        'mirrorModeTab': '<strong class="text-teal-300">Mirror:</strong> Geometry + reflection in one stream. Always includes the full skeletal ledger (angles, houses, hooks) plus the recognition layer. Seismograph trace auto-appends when transit hooks exist.',
                        'balanceMeterModeTab': '<strong class="text-teal-300">Balance Meter:</strong> Triple-channel analysis (Seismograph v1.0, Balance Channel v1.1, SFD v1.2) showing crisis detection, rebalanced perspective, and net support measurement in integrated tables.'
                    };
                    const modeDesc = document.getElementById('modeDescription');
                    if (modeDesc && descriptions[activeTabId]) {
                        modeDesc.innerHTML = descriptions[activeTabId];
                    }
                }
            }
            
            // Tab click handlers
            document.getElementById('mirrorModeTab')?.addEventListener('click', () => {
                switchTab('mirrorModeTab', 'mirror-content');
                updateAppMode('mirror');
            });
            document.getElementById('balanceMeterModeTab')?.addEventListener('click', () => {
                console.log('🔧 DEBUG: Balance Meter tab clicked');
                try {
                    switchTab('balanceMeterModeTab', 'balance-meter-content');
                    updateAppMode('balance_meter');
                    console.log('🔧 DEBUG: Balance Meter tab mode updated successfully');
                } catch (error) {
                    console.error('🔧 DEBUG: Error in Balance Meter tab click:', error);
                }
            });
            
            // Main button
            generateBtn.addEventListener('click', generateReport);

            // Monitor Person B fields to show/hide relational context sections
            function checkPersonBFields() {
                const personBName = document.getElementById('nameB');
                const contextModeSection = document.getElementById('context-mode-section');
                const relationalContextSection = document.getElementById('relational-context-section');
                
                if (personBName && contextModeSection && relationalContextSection) {
                    const hasPersonB = personBName.value.trim().length > 0;
                    if (hasPersonB) {
                        // Show proper relational context section
                        relationalContextSection.classList.remove('hidden');
                        // Keep legacy context mode hidden (it's not the right interface)
                        contextModeSection.classList.add('hidden');
                    } else {
                        // Hide both when no Person B
                        contextModeSection.classList.add('hidden');
                        relationalContextSection.classList.add('hidden');
                    }
                }
            }

            // Add event listeners to Person B fields
            const personBFields = ['nameB', 'birth_cityB', 'birth_dateB', 'birth_timeB'];
            personBFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', checkPersonBFields);
                    field.addEventListener('change', checkPersonBFields);
                }
            });

            // Initial check
            checkPersonBFields();

            // Save/Load buttons
            document.getElementById('saveDataBtn').addEventListener('click', saveChartData);
            document.getElementById('loadDataBtn').addEventListener('click', () => {
                document.getElementById('loadDataInput').click();
            });
            document.getElementById('loadDataInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadChartData(e.target.files[0]);
                }
            });

            // Health Data buttons
            document.getElementById('loadHealthDataBtn').addEventListener('click', () => {
                document.getElementById('healthDataInput').click();
            });
            document.getElementById('healthDataInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadHealthData(e.target.files[0]);
                }
            });
            document.getElementById('clearHealthDataBtn').addEventListener('click', clearHealthData);
            
            // Health Data Help Modal
            document.getElementById('healthDataHelpBtn').addEventListener('click', () => {
                document.getElementById('healthDataHelpModal').classList.remove('hidden');
            });
            document.getElementById('closeHealthDataHelp').addEventListener('click', () => {
                document.getElementById('healthDataHelpModal').classList.add('hidden');
            });
            document.getElementById('healthDataHelpModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('healthDataHelpModal')) {
                    document.getElementById('healthDataHelpModal').classList.add('hidden');
                }
            });

            // Modal
            mathBrainInfoBtn.addEventListener('click', () => {
                mathBrainModal.classList.remove('hidden');
                try { document.getElementById('math-brain-modal-content')?.focus({ preventScroll: true }); } catch(_){}
            });
            closeMathBrainModal.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            closeMathBrainModalBottom.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            mathBrainModal.addEventListener('click', (e) => {
                if (e.target === mathBrainModal) mathBrainModal.classList.add('hidden');
            });
            // Close Math Brain modal on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !mathBrainModal.classList.contains('hidden')) {
                    mathBrainModal.classList.add('hidden');
                }
            });

            // Copy report removed; keep stub if reintroduced later
            if (false && copyBtn) copyBtn.addEventListener('click', async () => {
                try {
                    // For copy, use enhanced version with executive summary but no JSON appendix (too large)
                    if (latestResultData) {
                        const copyOptions = {
                            includeExecutiveSummary: true,
                            includeJsonAppendix: false,
                            includeProvenance: true
                        };
                        const isBalanceMode = (latestResultData?.mode === 'balance_meter') ||
                                              (typeof getCurrentActiveTabMode === 'function' && getCurrentActiveTabMode() === 'balance_meter') ||
                                              (window.currentAppMode === 'balance_meter');
                        const fullReport = (isBalanceMode && latestResultData.balance_meter)
                            ? buildBalanceMeterReport(latestResultData.balance_meter, latestResultData)
                            : generateMarkdownReport(latestResultData, copyOptions);
                        await navigator.clipboard.writeText(fullReport);
                    } else {
                        await navigator.clipboard.writeText(reportContent.textContent);
                    }
                    if (copyBtn) {
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => { if (copyBtn) copyBtn.textContent = '📋 Copy Report'; }, 2000);
                    }
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            // Download report as JSON file (Raven wrapper)
            document.getElementById('downloadReport').addEventListener('click', () => {
                if (!latestResultData) {
                    showError('No report available for download. Please generate a report first.');
                    return;
                }
                try {
                    console.log('Starting JSON download process...');
                    // Capture optional reader notes into exported JSON
                    try {
                        const notesEl = document.getElementById('readerNotes');
                        const note = (notesEl && notesEl.value && notesEl.value.trim()) ? notesEl.value.trim() : null;
                        if (note) {
                            window.userNotesForDay = Array.isArray(window.userNotesForDay) ? [...window.userNotesForDay, note] : [note];
                        }
                    } catch(_){}

                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    let person1Name = document.getElementById('nameA').value || 'PersonA';
                    const person2Name = document.getElementById('nameB').value;
                    
                    // Try to get authoritative subject names from latestResultData
                    if (latestResultData.balance_meter?.person?.name) {
                        person1Name = latestResultData.balance_meter.person.name;
                    } else if (latestResultData.person_a?.details?.name) {
                        person1Name = latestResultData.person_a.details.name;
                    }
                    
                    // Get date range from form, but also try Balance Meter period if available
                    let startDate = document.getElementById('transitStartDate').value;
                    let endDate = document.getElementById('transitEndDate').value;
                    
                    // If no form dates but Balance Meter has period, use that
                    if (latestResultData.balance_meter?.period && (!startDate || !endDate)) {
                        startDate = latestResultData.balance_meter.period.start;
                        endDate = latestResultData.balance_meter.period.end;
                    }
                    let dateRange = '';
                    if (startDate && endDate) {
                        if (startDate === endDate) {
                            dateRange = `_${startDate}`;
                        } else {
                            dateRange = `_${startDate}_to_${endDate}`;
                        }
                    }
                    
                    // Build Raven wrapper JSON
                    const ravenJson = buildRavenJsonReport(latestResultData);

                    // Determine report type label
                    const isRel = Boolean(ravenJson?.context?.type === 'relational' || person2Name);
                    const reportType = isRel ? '_relational' : '_solo';

                    let filename;
                    if (person2Name) {
                        filename = `report_${person1Name}_${person2Name}${reportType}${dateRange}_${timestamp}.json`;
                    } else {
                        filename = `report_${person1Name}${reportType}${dateRange}_${timestamp}.json`;
                    }
                    
                    console.log('Creating JSON blob and download link...');
                    const blob = new Blob([JSON.stringify(ravenJson, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log('JSON download completed successfully');
                    
                    // Brief visual feedback
                    const btn = document.getElementById('downloadReport');
                    btn.textContent = '✅ JSON saved!';
                    setTimeout(() => { btn.textContent = '📄 Download JSON'; }, 2000);
                    
                    // Safe logging
                    if (typeof logger !== 'undefined') {
                        logger.info('Report downloaded', { filename, size: blob.size, kind: 'json' });
                    } else {
                        console.log('Report downloaded:', { filename, size: blob.size, kind: 'json' });
                    }
                } catch (err) {
                    console.error('Failed to download report: ', err);
                    console.error('Error details:', err.message, err.stack);
                    showError(`Failed to download report: ${err.message}. Please try again.`);
                }
            });

            // Download report as PDF
            document.getElementById('downloadPDF').addEventListener('click', async () => {
                if (!latestResultData) {
                    showError('No report available for download. Please generate a report first.');
                    return;
                }
                try {
                    console.log('Starting PDF download process...');
                    
                    // Generate markdown report for PDF conversion
                    const downloadOptions = {
                        includeExecutiveSummary: true,
                        includeJsonAppendix: false, // Skip JSON for PDF to keep it readable
                        includeProvenance: true
                    };
                    
                    console.log('Generating markdown report for PDF...');
                    const isBalanceMode = (latestResultData?.mode === 'balance_meter') ||
                                          (typeof getCurrentActiveTabMode === 'function' && getCurrentActiveTabMode() === 'balance_meter') ||
                                          (window.currentAppMode === 'balance_meter');
                    const markdownReport = (isBalanceMode && latestResultData.balance_meter)
                        ? buildBalanceMeterReport(latestResultData.balance_meter, latestResultData)
                        : generateMarkdownReport(latestResultData, downloadOptions);
                    
                    // Check if html2pdf is available with enhanced loading check
                    if (!isPDFLibraryReady()) {
                        console.error('html2pdf library not loaded, attempting to wait for it...');
                        
                        try {
                            // Try waiting for the library to load with shorter timeout
                            await waitForPDFLibrary(3000);
                            console.log('PDF library loaded successfully after waiting');
                        } catch (error) {
                            console.error('PDF library failed to load:', error);
                            
                            // Direct fallback to print without confusing user with dialogs
                            console.log('Using print-to-PDF fallback for main report');
                            printReportAsPDF(markdownReport, filename);
                            
                            // Update button state
                            btn.innerHTML = '✅ Print Dialog Opened!';
                            setTimeout(() => {
                                btn.innerHTML = '📑 Download PDF<span class="block text-xs opacity-80">Professional PDF report</span>';
                            }, 3000);
                            return;
                        }
                    }
                    
                    // Convert markdown to HTML for PDF generation
                    const htmlContent = convertMarkdownToHTML(markdownReport);
                    
                    // Generate filename
                    let person1Name = document.getElementById('nameA').value || 'PersonA';
                    const person2Name = document.getElementById('nameB').value;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    
                    // For Balance Meter reports, try to get the actual person name from the data
                    if (isBalanceMode && latestResultData.balance_meter?.person?.name) {
                        person1Name = latestResultData.balance_meter.person.name;
                    } else if (isBalanceMode && latestResultData.person_a?.details?.name) {
                        person1Name = latestResultData.person_a.details.name;
                    }
                    
                    // Get date range from form, but also try Balance Meter period if available
                    let startDate = document.getElementById('transitStartDate').value;
                    let endDate = document.getElementById('transitEndDate').value;
                    
                    // If no form dates but Balance Meter has period, use that
                    if (isBalanceMode && latestResultData.balance_meter?.period && (!startDate || !endDate)) {
                        startDate = latestResultData.balance_meter.period.start;
                        endDate = latestResultData.balance_meter.period.end;
                    }
                    let dateRange = '';
                    if (startDate && endDate) {
                        if (startDate === endDate) {
                            dateRange = `_${startDate}`;
                        } else {
                            dateRange = `_${startDate}_to_${endDate}`;
                        }
                    }
                    
                    // Determine report type
                    const reportType = isBalanceMode ? '_balance_meter' : '_mirror';
                    
                    let filename;
                    if (person2Name) {
                        filename = `WovenMap_${person1Name}_${person2Name}${reportType}${dateRange}_${timestamp}.pdf`;
                    } else {
                        filename = `WovenMap_${person1Name}${reportType}${dateRange}_${timestamp}.pdf`;
                    }
                    
                    // Show loading state
                    const btn = document.getElementById('downloadPDF');
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '⏳ Generating PDF...';
                    btn.disabled = true;
                    
                    // Create a temporary element for PDF generation
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlContent;
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.left = '-9999px';
                    tempDiv.style.top = '-9999px';
                    document.body.appendChild(tempDiv);
                    
                    // PDF generation options
                    const options = {
                        margin: [10, 10, 10, 10],
                        filename: filename,
                        image: { type: 'jpeg', quality: 0.98 },
                        html2canvas: { 
                            scale: 2, 
                            useCORS: true,
                            letterRendering: true,
                            allowTaint: false
                        },
                        jsPDF: { 
                            unit: 'mm', 
                            format: 'a4', 
                            orientation: 'portrait',
                            compress: true
                        },
                        pagebreak: { mode: 'avoid-all', before: '.page-break' }
                    };
                    
                    // Generate PDF blob and handle download based on user preference
                    const autoDownload = document.getElementById('autoDownloadPDF').checked;
                    
                    if (autoDownload) {
                        // Force automatic download without browser prompt
                        const pdfBlob = await html2pdf().set(options).from(tempDiv).outputPdf('blob');
                        
                        // Create download link and trigger automatically
                        const url = URL.createObjectURL(pdfBlob);
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = filename;
                        downloadLink.style.display = 'none';
                        
                        // Add to DOM, click, and remove (forces download without prompt in most browsers)
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // Clean up blob URL
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    } else {
                        // Use html2pdf's built-in save method (may prompt for filename)
                        await html2pdf().set(options).from(tempDiv).save();
                    }
                    
                    // Clean up
                    document.body.removeChild(tempDiv);
                    
                    console.log('PDF download completed successfully');
                    btn.innerHTML = '✅ PDF Downloaded!';
                    setTimeout(() => { 
                        btn.innerHTML = originalText; 
                        btn.disabled = false;
                    }, 2000);
                    
                } catch (err) {
                    console.error('Failed to generate PDF: ', err);
                    showError(`Failed to generate PDF: ${err.message}. Please try again.`);
                    
                    // Reset button state
                    const btn = document.getElementById('downloadPDF');
                    if (btn) {
                        btn.innerHTML = '📑 Download PDF<span class="block text-xs opacity-80">Professional PDF report</span>';
                        btn.disabled = false;
                    }
                }
            });

            // (Removed deprecated JSON download button logic)

            // Seismograph MD wiring
            loadSeismoBtn = document.getElementById('loadSeismoBtn');
            clearSeismoBtn = document.getElementById('clearSeismoBtn');
            seismoMdInput = document.getElementById('seismoMdInput');
            seismoDataStatus = document.getElementById('seismoDataStatus');
            genComparativeBtn = document.getElementById('genComparativeBtn');
            genComparativePdfBtn = document.getElementById('genComparativePdfBtn');

            loadSeismoBtn?.addEventListener('click', ()=> seismoMdInput.click());
            seismoMdInput?.addEventListener('change', (e)=>{ if (e.target.files && e.target.files.length) loadSeismographJson(e.target.files[0]); });
            clearSeismoBtn?.addEventListener('click', clearSeismograph);
            genComparativeBtn?.addEventListener('click', generateComparativeReport);
            genComparativePdfBtn?.addEventListener('click', generateComparativeReportPDF);

            // Toggle mode help panel
            toggleModeHelp.addEventListener('click', () => {
                const isHidden = modeHelpPanel.classList.contains('hidden');
                modeHelpPanel.classList.toggle('hidden');
                toggleModeHelp.textContent = isHidden ? '🧭 Hide mode guide' : '🧭 What does each mode do?';
            });

            // Prefill today's date for transit dates (legacy button)
            if (prefillTodayBtn) {
                prefillTodayBtn.addEventListener('click', prefillTodayDates);
            }
                // Simple Mode: filter controls suppressed (defaults applied globally)

            // Toggle step size help panel
            stepSizeHelpBtn.addEventListener('click', () => {
                const isHidden = stepSizeHelpPanel.classList.contains('hidden');
                stepSizeHelpPanel.classList.toggle('hidden');
                stepSizeHelpBtn.textContent = isHidden ? '❓ Hide explanation' : '❓ What does this do?';
            });

            // Date range validation with real-time feedback
            function validateDateRange() {
                if (!transitStartDate.value || !transitEndDate.value) return;
                
                const start = new Date(transitStartDate.value);
                const end = new Date(transitEndDate.value);
                const daySpan = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                const stepSize = transitStep.value || '1d';
                
                // Remove existing validation messages
                const existingWarning = document.getElementById('dateRangeWarning');
                const existingInfo = document.getElementById('dateRangeInfo');
                if (existingWarning) existingWarning.remove();
                if (existingInfo) existingInfo.remove();
                
                // Skip validation for same-day ranges
                if (daySpan === 0) return;
                
                let maxDays, warningClass = '', warningText = '';
                const stepKey = (stepSize === '7d' || stepSize === 'weekly') ? 'weekly'
                                 : (stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly') ? 'monthly'
                                 : 'daily';
                const limits = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]) || { max: 45, warnRatio: 0.8 };
                maxDays = limits.max;
                const warnDays = Math.floor(limits.max * (limits.warnRatio || 0.8));
                const isWeekly = stepKey === 'weekly';
                const isMonthly = stepKey === 'monthly';
                if (daySpan > warnDays) {
                    warningClass = daySpan > maxDays ? 'text-red-400' : 'text-yellow-400';
                    if (daySpan > maxDays) {
                        const hardMsg = isWeekly
                            ? `⚠️ ${daySpan} days exceeds ${(Math.round(maxDays/30*10)/10)}-month limit for weekly calculations`
                            : isMonthly
                            ? `⚠️ ${daySpan} days exceeds ${(Math.round(maxDays/30*10)/10)}-month limit for monthly calculations`
                            : `⚠️ ${daySpan} days exceeds ${maxDays}-day limit for daily calculations`;
                        warningText = hardMsg;
                    } else {
                        const softMsg = isWeekly
                            ? `⚠️ ${daySpan} days is a long range (${Math.ceil(daySpan/7)} weeks)`
                            : isMonthly
                            ? `⚠️ ${daySpan} days is a long range (${Math.ceil(daySpan/30)} months)`
                            : `⚠️ ${daySpan} days is approaching daily limit (${maxDays} days max)`;
                        warningText = softMsg;
                    }
                }
                
                // Show warning if needed
                if (warningText) {
                    const warningDiv = document.createElement('div');
                    warningDiv.id = 'dateRangeWarning';
                    warningDiv.className = `mt-2 text-xs ${warningClass}`;
                    warningDiv.innerHTML = warningText;
                    transitEndDate.parentNode.appendChild(warningDiv);
                }
                
                // Show helpful calculation info for longer ranges
                if (daySpan > 7) {
                    const actualSteps = stepSize === '7d' || stepSize === 'weekly' ? Math.ceil(daySpan / 7) :
                                       stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? Math.ceil(daySpan / 30) :
                                       daySpan;
                    
                    const stepType = stepSize === '7d' || stepSize === 'weekly' ? 'weekly calculations' :
                                    stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? 'monthly calculations' :
                                    'daily calculations';
                    
                    const infoText = `📊 Will generate ~${actualSteps} ${stepType}`;
                    
                    if (!document.getElementById('dateRangeInfo')) {
                        const infoDiv = document.createElement('div');
                        infoDiv.id = 'dateRangeInfo';
                        infoDiv.className = 'mt-1 text-xs text-teal-300';
                        infoDiv.textContent = infoText;
                        transitEndDate.parentNode.appendChild(infoDiv);
                    } else {
                        document.getElementById('dateRangeInfo').textContent = infoText;
                    }
                } else {
                    const existingInfo = document.getElementById('dateRangeInfo');
                    if (existingInfo) existingInfo.remove();
                }
            }

            // Add listeners for real-time validation
            transitStartDate.addEventListener('change', validateDateRange);
            transitEndDate.addEventListener('change', validateDateRange);
            transitStep.addEventListener('change', validateDateRange);

            // Context mode switching
            document.querySelectorAll('input[name="contextMode"]').forEach(radio => {
                radio.addEventListener('change', updateFormUI);
            });

            // Relocation toggle
            relocationToggle.addEventListener('change', () => {
                relocationFields.classList.toggle('hidden', !relocationToggle.checked);
                updateRelocationPersonBOption();
            });

            // Relational context visibility refinement:
            // Show immediately when relational context type selected. If user returns to solo/weather, hide.
            // While still in relational context, do NOT auto-hide just because Person B fields are blank.
            const personBInputs = ['nameB', 'birth_cityB', 'birth_stateB', 'birth_dateB', 'birth_timeB', 'birth_countryB', 'astroB'];
            function evaluateRelationalContextVisibility(){
                const anyFilled = personBInputs.some(id => document.getElementById(id).value.trim() !== '');
                const relContextSection = document.getElementById('relational-context-section');
                const isPersonBExpanded = document.getElementById('personB-toggle')?.getAttribute('aria-expanded') === 'true';
                const isLoadingData = window.isLoadingChartData || false;
                console.log('[REL VIS] anyFilled:', anyFilled, 'currentContextType:', currentContextType, 'personBExpanded:', isPersonBExpanded, 'isLoadingData:', isLoadingData);
                
                // Show relational context if:
                // 1. We're in relational mode, OR
                // 2. Person B section is expanded, OR  
                // 3. Any Person B field has data
                const shouldShow = currentContextType === 'relational' || isPersonBExpanded || anyFilled;
                const isInRelationalMode = currentContextType === 'relational';
                
                console.log('[REL VIS] shouldShow:', shouldShow, 'isInRelationalMode:', isInRelationalMode, 'reasons:', {
                    relationalMode: currentContextType === 'relational',
                    personBExpanded: isPersonBExpanded, 
                    personBData: anyFilled
                });
                
                if (relContextSection) {
                    const wasHidden = relContextSection.classList.contains('hidden');
                    if (shouldShow) {
                        relContextSection.classList.remove('hidden');
                        console.log('[REL VIS] Showing relational context - reason:', 
                            currentContextType === 'relational' ? 'relational mode' : 
                            isPersonBExpanded ? 'Person B expanded' : 'Person B data entered');
                        if (wasHidden) {
                            console.log('[REL VIS] ✅ Context section was hidden, now shown');
                        }
                        
                        // Enable/disable relationship type controls based on actual relational mode
                        // BUT skip this during data loading to allow restoration
                        if (!isLoadingData) {
                            const relationshipControls = relContextSection.querySelectorAll('input[name="relationshipType"], input[name="intimacyTier"], #exRelationship');
                            relationshipControls.forEach(control => {
                                control.disabled = !isInRelationalMode;
                                if (control.parentElement) {
                                    if (isInRelationalMode) {
                                        control.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                                    } else {
                                        control.parentElement.classList.add('opacity-50', 'cursor-not-allowed');
                                    }
                                }
                            });
                            
                            // Clear selections if not in relational mode (but not during data loading)
                            if (!isInRelationalMode) {
                                clearRelationshipTypeSelections();
                            }
                        }
                        
                    } else {
                        relContextSection.classList.add('hidden');
                        console.log('[REL VIS] ❌ Hiding relational context section');
                        // Only clear selections if not loading data
                        if (!isLoadingData) {
                            clearRelationshipTypeSelections();
                        }
                    }
                } else {
                    console.error('[REL VIS] ⚠️ relational-context-section element not found!');
                }
            }
            // Make function globally accessible
            window.evaluateRelationalContextVisibility = evaluateRelationalContextVisibility;
            
            personBInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', evaluateRelationalContextVisibility);
            });
            // Initial evaluation
            evaluateRelationalContextVisibility();
            
            // Intimacy tier visibility
            function resetRelationalStateFor(type){
                const roleSelect = document.getElementById('relationshipRole');
                const customRoleInput = document.getElementById('relationshipRoleCustom');
                const roleBlock = document.getElementById('relationship-role-block');
                const exRow = document.getElementById('exRelationshipRow');
                const exCb = document.getElementById('exRelationship');
                // Clear any custom visibility
                if (type === 'partner') {
                    if (roleSelect) roleSelect.value='';
                    if (customRoleInput) { customRoleInput.value=''; customRoleInput.classList.add('hidden'); }
                } else { // leaving partner
                    document.querySelectorAll('input[name="intimacyTier"]').forEach(r=> r.checked=false);
                }
                // Hide ex for friend
                if (exRow && exCb) {
                    const hideEx = type === 'friend';
                    exRow.classList.toggle('hidden', hideEx);
                    if (hideEx) exCb.checked = false;
                }
                // Focus first interactive element for accessibility
                if (type === 'partner') {
                    const firstTier = document.querySelector('input[name="intimacyTier"]');
                    firstTier && firstTier.focus();
                } else if (roleBlock && !roleBlock.classList.contains('hidden')) {
                    const firstRole = document.getElementById('relationshipRole');
                    firstRole && firstRole.focus();
                }
            }

            document.querySelectorAll('input[name="relationshipType"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value;
                    console.log('[REL TYPE] Changed to:', relationshipType);
                    if (!relationshipType) return;
                    const isPartner = relationshipType === 'partner';
                    if (intimacyTierDropdown) {
                        intimacyTierDropdown.classList.toggle('hidden', !isPartner);
                        if (!isPartner) {
                            // Clear any previously selected intimacy tiers when leaving partner
                            document.querySelectorAll('input[name="intimacyTier"]').forEach(r=> r.checked=false);
                        }
                    }
                    const roleBlock = document.getElementById('relationship-role-block');
                    const roleSelect = document.getElementById('relationshipRole');
                    const roleCustom = document.getElementById('relationshipRoleCustom');
                    if (roleBlock && roleSelect) {
                        roleSelect.innerHTML = '';
                        if (relationshipType === 'family') {
                            roleBlock.classList.remove('hidden');
                            const familyOptions = [
                                {v:'', l:'Select role (required)'}, 
                                {v:'parent', l:'Parent'}, 
                                {v:'offspring', l:'Offspring'}, 
                                {v:'sibling', l:'Sibling'}, 
                                {v:'cousin', l:'Cousin'}, 
                                {v:'extended', l:'Extended family'}, 
                                {v:'guardian', l:'Guardian'}, 
                                {v:'mentor', l:'Mentor'}, 
                                {v:'other', l:'Other / Custom'}
                            ];
                            familyOptions.forEach(o=>{ const opt=document.createElement('option'); opt.value=o.v; opt.textContent=o.l; roleSelect.appendChild(opt); });
                        } else if (relationshipType === 'friend') {
                            roleBlock.classList.remove('hidden');
                            const friendOptions = [
                                {v:'', l:'(optional)'}, 
                                {v:'acquaintance', l:'Acquaintance'}, 
                                {v:'mentor', l:'Mentor'}, 
                                {v:'other', l:'Other / Custom'}
                            ];
                            friendOptions.forEach(o=>{ const opt=document.createElement('option'); opt.value=o.v; opt.textContent=o.l; roleSelect.appendChild(opt); });
                        } else {
                            roleBlock.classList.add('hidden');
                        }
                        if (roleCustom) roleCustom.classList.add('hidden');
                    }
                    resetRelationalStateFor(relationshipType);
                });
            });
        }

        // =============================================================================
        // NEW UX IMPROVEMENT FUNCTIONS
        // =============================================================================
        
        // Global state for the app mode
        let currentAppMode = 'mirror'; // Always mirror - seismograph is an add-on section
        let currentContextType = 'solo'; // 'solo', 'relational', 'weather'
        
        function updateAppMode(mode) {
            currentAppMode = mode || 'mirror';
            
            // Update tab appearance
            const mirrorTab = document.getElementById('mirrorModeTab');
            const balanceMeterTab = document.getElementById('balanceMeterModeTab');
            const modeDescription = document.getElementById('modeDescription');
            const generateBtn = document.getElementById('generateReport');
            const showWiringBtn = document.getElementById('showWiringBtn');
            
            // Reset all tabs
            [mirrorTab, balanceMeterTab].forEach(tab => {
                if (tab) {
                    tab.classList.remove('bg-teal-600', 'text-white');
                    tab.classList.add('bg-gray-700', 'text-gray-300');
                    tab.setAttribute('aria-selected', 'false');
                }
            });
            
            // Activate the current tab
            const activeTab = currentAppMode === 'balance_meter' ? balanceMeterTab : mirrorTab;
            if (activeTab) {
                activeTab.classList.add('bg-teal-600', 'text-white');
                activeTab.classList.remove('bg-gray-700', 'text-gray-300');
                activeTab.setAttribute('aria-selected', 'true');
            }
            
            // Update description and button text based on mode
            if (currentAppMode === 'balance_meter') {
                if (modeDescription) {
                    modeDescription.innerHTML = '<strong class="text-teal-300">Balance Meter:</strong> Triple-channel analysis (Seismograph v1.0, Balance Channel v1.1, SFD v1.2) showing crisis detection, rebalanced perspective, and net support measurement in integrated tables.';
                }
                if (generateBtn) {
                    generateBtn.textContent = '⚖️ Generate Balance Report';
                }
            } else {
                if (modeDescription) {
                    modeDescription.innerHTML = '<strong class="text-teal-300">Mirror:</strong> Geometry + reflection in one stream. Always includes the full skeletal ledger (angles, houses, hooks) plus the recognition layer. Seismograph trace auto-appends when transit hooks exist.';
                }
                if (generateBtn) {
                    generateBtn.textContent = '✨ Get My Mirror';
                }
            }
            
            if (showWiringBtn) {
                showWiringBtn.style.display = 'inline';
            }
            
            // Auto-populate today's date in Mirror mode
            autoPopulateTodayDates();
            
            updateUIBasedOnMode();
        }

        // --- Seismograph Auto-Append Logic ---
        function checkAndAppendSeismograph() {
            // Seismograph automatically appends to Mirror when transit hooks exist
            if (!latestResultData) return;
            
            const hasTransitData = latestResultData.person_a?.chart?.transitsByDate || 
                                 latestResultData.person_b?.chart?.transitsByDate || 
                                 latestResultData.composite?.transitsByDate || 
                                 latestResultData.synastry?.transitsByDate;
            
            if (hasTransitData) {
                // Check if any day has actual transit hooks
                let hasTransitHooks = false;
                const transitDataSources = [
                    latestResultData.person_a?.chart?.transitsByDate,
                    latestResultData.person_b?.chart?.transitsByDate,
                    latestResultData.composite?.transitsByDate,
                    latestResultData.synastry?.transitsByDate
                ].filter(Boolean);
                
                for (const transitData of transitDataSources) {
                    for (const dayData of Object.values(transitData)) {
                        if ((dayData.hooks || []).some(h => h.kind === 'transit')) {
                            hasTransitHooks = true;
                            break;
                        }
                    }
                    if (hasTransitHooks) break;
                }
                
                if (hasTransitHooks) {
                    // Triple-channel data now accessed via Balance Meter only
                    console.log('✅ Transit hooks detected - Balance Meter triple-channel available');
                } else {
                    console.log('ℹ️ No transit hooks found - Mirror only');
                }
            }
        }

        function updateSeismographTabIndicator() {
            // No separate seismograph tab; indicator not used
            console.log('Seismograph folded into Balance Meter; no tab indicator');
        }
        
        function updateContextType(contextType) {
            currentContextType = contextType;
            console.log('[CTX] Switching contextType ->', contextType);
            
            // Update Weather badge visibility
            const weatherBadge = document.getElementById('weather-badge');
            if (weatherBadge) {
                if (contextType === 'weather') {
                    weatherBadge.classList.remove('hidden');
                } else {
                    weatherBadge.classList.add('hidden');
                }
            }
            
            // Update the legacy context mode for compatibility
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (contextType === 'solo') {
                hidePersonBSection();
                hideRelationalSubtypes();
                hideRelationalContext();
                showSoloSubtypes();
                // Default to current solo subtype or natal_transits
                const soloSubtype = document.querySelector('input[name="soloSubtype"]:checked')?.value || 'natal_transits';
                updateSoloSubtype(soloSubtype);
            } else if (contextType === 'relational') {
                showPersonBSection();
                showRelationalSubtypes();
                showRelationalContext(); // ensure visible
                const rcs = document.getElementById('relational-context-section');
                if (rcs && rcs.classList.contains('hidden')) {
                    console.warn('[CTX] Relational context was hidden unexpectedly; forcing show.');
                    rcs.classList.remove('hidden');
                }
                hideSoloSubtypes();
                // Default to composite for relational
                const relationalSubtype = document.querySelector('input[name="relationalSubtype"]:checked')?.value || 'composite';
                updateRelationalSubtype(relationalSubtype);
                
                // Re-enable relationship type controls when switching to relational mode
                const relationshipControls = document.querySelectorAll('input[name="relationshipType"], input[name="intimacyTier"], #exRelationship');
                relationshipControls.forEach(control => {
                    control.disabled = false;
                    if (control.parentElement) {
                        control.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                });
                
                // Evaluate relational context visibility after switching
                if (window.evaluateRelationalContextVisibility) {
                    setTimeout(window.evaluateRelationalContextVisibility, 100);
                }
            } else if (contextType === 'weather') {
                // Weather only mode - hide person sections
                hidePersonBSection();
                hideRelationalSubtypes();
                hideSoloSubtypes();
                hideRelationalContext();
                // Set to transit-only mode
                contextModeInputs.forEach(input => { input.checked = input.checked && false; });
            }
            
            updateFormUI();
        }
        
        function updateSoloSubtype(subtype) {
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (subtype === 'natal_only') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_only';
                });
            } else if (subtype === 'natal_transits') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_transits';
                });
            }
            
            updateFormUI();
        }
        
        function updateRelationalSubtype(subtype) {
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (subtype === 'synastry') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'synastry_transits';
                });
            } else if (subtype === 'composite') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'composite_transits';
                });
            }
            
            updateFormUI();
        }
        
        function showPersonBSection() {
            const personBToggle = document.getElementById('personB-toggle');
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            
            if (personBToggle && personBDetails) {
                personBToggle.setAttribute('aria-expanded', 'true');
                personBDetails.classList.remove('hidden');
                if (personBChevron) {
                    personBChevron.classList.add('rotate-180');
                }
            }
        }
        
        function hidePersonBSection() {
            const personBToggle = document.getElementById('personB-toggle');
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            
            if (personBToggle && personBDetails) {
                personBToggle.setAttribute('aria-expanded', 'false');
                personBDetails.classList.add('hidden');
                if (personBChevron) {
                    personBChevron.classList.remove('rotate-180');
                }
            }
        }
        
        function showSoloSubtypes() {
            const soloSubtypes = document.getElementById('solo-subtypes');
            if (soloSubtypes) {
                soloSubtypes.classList.remove('hidden');
            }
        }
        
        function hideSoloSubtypes() {
            const soloSubtypes = document.getElementById('solo-subtypes');
            if (soloSubtypes) {
                soloSubtypes.classList.add('hidden');
            }
        }
        
        function showRelationalSubtypes() {
            const relationalSubtypes = document.getElementById('relational-subtypes');
            if (relationalSubtypes) {
                relationalSubtypes.classList.remove('hidden');
            }
        }
        
        function hideRelationalSubtypes() {
            const relationalSubtypes = document.getElementById('relational-subtypes');
            if (relationalSubtypes) {
                relationalSubtypes.classList.add('hidden');
            }
        }
        
        function showRelationalContext() {
            const relationalContext = document.getElementById('relational-context-section');
            if (relationalContext) {
                relationalContext.classList.remove('hidden');
            }
        }
        
        function hideRelationalContext() {
            const relationalContext = document.getElementById('relational-context-section');
            if (relationalContext) {
                relationalContext.classList.add('hidden');
                // Clear relationship type selections when hiding relational context
                clearRelationshipTypeSelections();
            }
        }
        
        function clearRelationshipTypeSelections() {
            // Clear all relationship type radio buttons
            document.querySelectorAll('input[name="relationshipType"]').forEach(radio => {
                radio.checked = false;
            });
            // Clear intimacy tier selections
            document.querySelectorAll('input[name="intimacyTier"]').forEach(radio => {
                radio.checked = false;
            });
            // Clear ex-relationship checkbox
            const exRelCheckbox = document.getElementById('exRelationship');
            if (exRelCheckbox) {
                exRelCheckbox.checked = false;
            }
        }
        
        function autoPopulateTodayDates() {
            const todayStr = getTodayDateString();
            const startDate = document.getElementById('transitStartDate');
            const endDate = document.getElementById('transitEndDate');
            
            if (startDate && endDate) {
                // Only auto-populate if fields are empty
                if (!startDate.value) startDate.value = todayStr;
                if (!endDate.value) endDate.value = todayStr;
            }
        }
        
        function showAdvancedTransitOptions() {
            const advancedOptions = document.getElementById('advanced-transit-options');
            if (advancedOptions) {
                advancedOptions.classList.remove('hidden');
            }
        }
        
        function hideAdvancedTransitOptions() {
            const advancedOptions = document.getElementById('advanced-transit-options');
            if (advancedOptions) {
                advancedOptions.classList.add('hidden');
            }
        }
        
        function updateUIBasedOnMode() {
            const mathBrainBanner = document.querySelector('#context-options .bg-yellow-900');
            
            if (currentAppMode === 'mirror') {
                // Hide Math Brain banner in Mirror mode
                if (mathBrainBanner) {
                    mathBrainBanner.style.display = 'none';
                }
                hideAdvancedTransitOptions();
            }
        }
        
        function togglePersonB() {
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            const personBToggle = document.getElementById('personB-toggle');
            
            if (personBDetails && personBChevron && personBToggle) {
                const isExpanded = personBToggle.getAttribute('aria-expanded') === 'true';
                
                personBToggle.setAttribute('aria-expanded', !isExpanded);
                personBDetails.classList.toggle('hidden');
                personBChevron.classList.toggle('rotate-180');
                
                // If expanding and we're in solo mode, switch to relational
                if (!isExpanded && currentContextType === 'solo') {
                    const relationalRadio = document.querySelector('input[name="contextType"][value="relational"]');
                    if (relationalRadio) {
                        relationalRadio.checked = true;
                        updateContextType('relational');
                    }
                }
                
                // Show relationship context when Person B is expanded in any relational mode
                if (!isExpanded && (currentContextType === 'relational' || 
                    ['synastry_transits', 'composite_transits'].includes(document.querySelector('input[name="contextMode"]:checked')?.value))) {
                    showRelationalContext();
                }
                
                // Update form UI to enable/disable Person B based on expansion state
                updateFormUI();
                
                // Evaluate relational context visibility when Person B is toggled
                setTimeout(() => {
                    const evaluateFunc = window.evaluateRelationalContextVisibility;
                    if (evaluateFunc) evaluateFunc();
                }, 50);
            }
        }
        
        function toggleRelocation() {
            const relocationDetails = document.getElementById('relocation-details');
            const relocationChevron = document.getElementById('relocation-chevron');
            const relocationToggle = document.getElementById('relocationToggle');
            const relocationHeader = document.getElementById('relocation-toggle-header');
            
            if (relocationDetails && relocationChevron && relocationHeader) {
                const isExpanded = relocationHeader.getAttribute('aria-expanded') === 'true';
                
                relocationHeader.setAttribute('aria-expanded', !isExpanded);
                relocationDetails.classList.toggle('hidden');
                relocationChevron.classList.toggle('rotate-180');
                
                // Also toggle the checkbox
                if (relocationToggle) {
                    relocationToggle.checked = !isExpanded;
                }
            }
        }
        
        function setupProgressiveDisclosureEventListeners() {
            console.log('🔧 DEBUG: Setting up progressive disclosure event listeners');
            
            // Context type selection
            document.querySelectorAll('input[name="contextType"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateContextType(e.target.value));
            });
            
            // Solo subtypes
            document.querySelectorAll('input[name="soloSubtype"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateSoloSubtype(e.target.value));
            });
            
            // Relational subtypes
            document.querySelectorAll('input[name="relationalSubtype"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateRelationalSubtype(e.target.value));
            });
            
            // Person B toggle
            const personBToggle = document.getElementById('personB-toggle');
            if (personBToggle) {
                personBToggle.addEventListener('click', togglePersonB);
                personBToggle.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        togglePersonB();
                    }
                });
            }
            
            // Relocation toggle
            const relocationHeader = document.getElementById('relocation-toggle-header');
            if (relocationHeader) {
                relocationHeader.addEventListener('click', toggleRelocation);
                relocationHeader.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleRelocation();
                    }
                });
            }
            const relocationToggleElInline = document.getElementById('relocationToggle');
            if (relocationToggleElInline){
                relocationToggleElInline.addEventListener('change', updateRelocationNote);
            }
            
            // Today default button
            const todayDefaultBtn = document.getElementById('todayDefault');
            if (todayDefaultBtn) {
                todayDefaultBtn.addEventListener('click', () => {
                    const todayStr = getTodayDateString();
                    document.getElementById('transitStartDate').value = todayStr;
                    document.getElementById('transitEndDate').value = todayStr;
                    
                    // Visual feedback
                    todayDefaultBtn.textContent = '✅ Set to Today';
                    setTimeout(() => {
                        todayDefaultBtn.textContent = '📅 Use Today';
                    }, 2000);
                });
            }
            
            // Expand transit options button
            const expandTransitBtn = document.getElementById('expandTransitOptions');
            if (expandTransitBtn) {
                expandTransitBtn.addEventListener('click', () => {
                    const advancedOptions = document.getElementById('advanced-transit-options');
                    if (advancedOptions) {
                        const isHidden = advancedOptions.classList.contains('hidden');
                        advancedOptions.classList.toggle('hidden');
                        expandTransitBtn.textContent = isHidden ? '⚙️ Hide Options' : '⚙️ More Options';
                    }
                });
            }
            
            // Context help toggle
            const contextHelpBtn = document.getElementById('context-help-btn');
            const contextHelpPanel = document.getElementById('context-help-panel');
            if (contextHelpBtn && contextHelpPanel) {
                contextHelpBtn.addEventListener('click', () => {
                    const isHidden = contextHelpPanel.classList.contains('hidden');
                    contextHelpPanel.classList.toggle('hidden');
                    contextHelpBtn.textContent = isHidden ? '🧭 Hide Guide' : '🧭 Context Guide';
                });
            }
            
            // Show Wiring button (scroll to geometry section)
            const showWiringBtn = document.getElementById('showWiringBtn');
            if (showWiringBtn) {
                showWiringBtn.addEventListener('click', () => {
                    // Ensure we're in Mirror mode (geometry always embedded now)
                    if (currentAppMode !== 'mirror') updateAppMode('mirror');
                    // Scroll to report section and optionally highlight geometry skeleton heading
                    const reportSection = document.getElementById('reportOutput');
                    if (reportSection && !reportSection.classList.contains('hidden')) {
                        reportSection.scrollIntoView({ behavior: 'smooth' });
                        const geomHeader = reportSection.querySelector('h2, h1');
                        if (geomHeader) {
                            geomHeader.classList.add('ring-2','ring-teal-400','ring-offset-2','ring-offset-gray-900');
                            setTimeout(()=>geomHeader.classList.remove('ring-2','ring-teal-400','ring-offset-2','ring-offset-gray-900'),1800);
                        }
                    }
                });
            }
        }
        
        // =============================================================================
        // END NEW UX IMPROVEMENT FUNCTIONS
        // =============================================================================

        // ---------- Relocation Defaults & Persistence (Panama City baseline) ----------
        const DEFAULT_RELOC = { city: 'Panama City', state: 'FL', coords: "30°10'N, 85°40'W" };
        const RELOC_PREF_KEY = 'wm_pref_default_reloc_enabled';
        const DMS_RE = /^\s*([0-9]{1,3})\s*[°]?\s*([0-9]{1,2})?\s*['′]?\s*([0-9]{1,2}(?:\.\d+)?)?\s*([NnSs])\s*,?\s*([0-9]{1,3})\s*[°]?\s*([0-9]{1,2})?\s*['′]?\s*([0-9]{1,2}(?:\.\d+)?)?\s*([EeWw])\s*$/;
        const DEC_RE = /^\s*(-?\d{1,3}(?:\.\d+)?)\s*,\s*(-?\d{1,3}(?:\.\d+)?)\s*$/;
        function dmsToDec(d,m,s,h){const sign=/[SsWw]/.test(h)?-1:1;return sign*(+d+(+(m||0))/60+(+(s||0))/3600);}        
        function parseLatLonFlexible(input){
            if(!input) return null;
            const m1 = DEC_RE.exec(input); if(m1){ const lat=+m1[1], lon=+m1[2];
                return (isFinite(lat)&&isFinite(lon)&&Math.abs(lat)<=90&&Math.abs(lon)<=180)
                  ? {lat, lon, normalized:`${lat.toFixed(6)}, ${lon.toFixed(6)}`} : null; }
            const cleaned = input.replace(/°|º/g,'°').replace(/’|′/g,"'");
            const m2 = DMS_RE.exec(cleaned); if(m2){ const lat=dmsToDec(m2[1],m2[2],m2[3],m2[4]); const lon=dmsToDec(m2[5],m2[6],m2[7],m2[8]);
                return (isFinite(lat)&&isFinite(lon)) ? {lat, lon, normalized:`${lat.toFixed(6)}, ${lon.toFixed(6)}`} : null; }
            return null;
        }
        function attachCoordValidator(inputId, hintId){
            const el=document.getElementById(inputId), hint=document.getElementById(hintId);
            if(!el||!hint) return; 
            el.addEventListener('blur', ()=>{ const v=el.value.trim(); if(!v){ hint.textContent=''; hint.className='mt-1 text-xs'; return; }
                const ok=parseLatLonFlexible(v); if(ok){ hint.textContent=`✓ Normalized: ${ok.normalized}`; hint.className='mt-1 text-xs text-teal-300'; }
                else { hint.textContent='Invalid. Use "lat, lon" (e.g., 30.1667, -85.6667) or DMS (30°10\'N, 85°40\'W).'; hint.className='mt-1 text-xs text-red-400'; }
            });
        }
        function applyRelocDefaults(openSection=true){
            const t=document.getElementById('relocationToggle');
            const city=document.getElementById('relocationCity');
            const st=document.getElementById('relocationState');
            const c=document.getElementById('relocationCoords');
            if(!t||!city||!st||!c) return; 
            city.value=DEFAULT_RELOC.city; st.value=DEFAULT_RELOC.state; c.value=DEFAULT_RELOC.coords; t.checked=true;
            if(openSection){
                document.getElementById('relocation-details')?.classList.remove('hidden');
                document.getElementById('relocation-toggle-header')?.setAttribute('aria-expanded','true');
            }
            c.dispatchEvent(new Event('blur'));
            updateRelocationNote();
        }
        function wireUseDefaultRelocButton(){
            const btn=document.getElementById('useDefaultRelocation');
            if(!btn) return; btn.addEventListener('click', ()=> applyRelocDefaults(true));
        }
        function loadRelocPref(){ return localStorage.getItem(RELOC_PREF_KEY)==='1'; }
        function saveRelocPref(v){ localStorage.setItem(RELOC_PREF_KEY, v?'1':'0'); }
        function updateRelocationNote(){
            const note = document.getElementById('relocation-default-note');
            const toggle = document.getElementById('relocationToggle');
            if(!note || !toggle) return;
            if(toggle.checked){
                note.textContent = 'Relocation overlay ACTIVE using current values (modify city/coords as needed).';
                note.className='mb-4 text-xs text-teal-300';
            } else {
                note.textContent = "Panama City, FL (30°10'N, 85°40'W) is pre-filled as a suggested relocation reference. It is NOT applied until you enable the checkbox.";
                note.className='mb-4 text-xs text-gray-500 italic';
            }
        }


        function updateFormUI() {
            const modeSel = document.querySelector('input[name="contextMode"]:checked');
            const mode = modeSel ? modeSel.value : (currentContextType === 'weather' ? 'sky_transits' : 'natal_transits');
            console.log('[UPDATE UI] Current mode:', mode);

            const isNatalOnly = mode === 'natal_only';
            const isNatal = mode === 'natal_transits';
            const isSynastryTransits = mode === 'synastry_transits';
            const isCompositeTransits = mode === 'composite_transits';
            
            console.log('[UPDATE UI] Mode analysis:', { isNatalOnly, isNatal, isSynastryTransits, isCompositeTransits });
            
            // Person B should be enabled for relational context OR when manually expanded
            const isRelationalContext = currentContextType === 'relational';
            const isPersonBExpanded = document.getElementById('personB-toggle')?.getAttribute('aria-expanded') === 'true';
            const showPersonB = isRelationalContext || isPersonBExpanded || (!isNatalOnly && !isNatal);
            // Visual dim only when not active; keep header clickable to allow expansion
            personBCard.style.opacity = showPersonB ? '1' : '0.5';
            // Never fully disable pointer events on the whole card (so header can always be clicked)
            personBCard.style.pointerEvents = 'auto';
            // Instead, disable the form controls inside when not active
            const personBInputs = personBCard.querySelectorAll('input, select, button:not(#personB-toggle)');
            personBInputs.forEach(el => {
                if (el.id === 'personB-toggle') return; // safeguard
                if (!showPersonB) {
                    el.setAttribute('disabled','disabled');
                    el.classList.add('cursor-not-allowed','opacity-70');
                } else {
                    el.removeAttribute('disabled');
                    el.classList.remove('cursor-not-allowed','opacity-70');
                }
            });

            const showTransitFields = !isNatalOnly; // Show transit fields for all modes except natal_only
            console.log('[UPDATE UI] Transit fields:', { showTransitFields, isNatalOnly, transitDateFields: !!transitDateFields });
            
            if (transitDateFields) {
                transitDateFields.style.display = showTransitFields ? 'block' : 'none';
                console.log('[UPDATE UI] ✅ Transit fields display set to:', showTransitFields ? 'block' : 'none');
                
                // Debug parent visibility
                const parent = transitDateFields.parentElement;
                const grandParent = parent?.parentElement;
                console.log('[UPDATE UI] Parent visibility check:', {
                    parentId: parent?.id || 'no-id',
                    parentClasses: parent?.className || '',
                    parentDisplay: parent ? getComputedStyle(parent).display : 'not found',
                    grandParentId: grandParent?.id || 'no-id', 
                    grandParentClasses: grandParent?.className || '',
                    grandParentDisplay: grandParent ? getComputedStyle(grandParent).display : 'not found'
                });
            } else {
                console.error('[UPDATE UI] ❌ transitDateFields element not found!');
            }

            // CRITICAL: Relocation overlay available for ALL chart modes (natal_only and transit modes)
            // Relocation is about geometric foundation shift, not timing - affects natal architecture context
            const showRelocation = currentContextType !== 'weather';
            if (relocationSection) relocationSection.style.display = showRelocation ? 'block' : 'none';

            // Hide Person A card entirely in weather mode (no natal)
            const personACard = document.getElementById('personA-card');
            if (personACard) {
                if (currentContextType === 'weather') personACard.classList.add('hidden');
                else personACard.classList.remove('hidden');
            }
            
            // Update Person B relocation option visibility
            updateRelocationPersonBOption();
            
            // Show/hide relational context section based on whether this is a relational mode
            const isRelationalMode = isSynastryTransits || isCompositeTransits;
            if (isRelationalMode || currentContextType === 'relational') {
                showRelationalContext();
            } else {
                hideRelationalContext();
            }
        }
        
        function updateRelocationPersonBOption() {
            const mode = document.querySelector('input[name="contextMode"]:checked').value;
            const showPersonB = mode !== 'natal';
            const relocationEnabled = relocationToggle && relocationToggle.checked;
            
            // Show the Person B relocation option only if Person B is present and relocation is enabled
            if (relocationPersonBOption) {
                if (showPersonB && relocationEnabled) {
                    relocationPersonBOption.classList.remove('hidden');
                } else {
                    relocationPersonBOption.classList.add('hidden');
                }
            }
        }

        // Initial UI setup on page load
    document.addEventListener('DOMContentLoaded', () => {
            // Legacy deep-link normalization (?mode=geometry -> mirror#geometry-skeleton)
            try {
                const params = new URLSearchParams(location.search);
                const legacyMode = params.get('mode');
                if (legacyMode === 'geometry') {
                    // Replace state without adding history entry
                    const newUrl = location.pathname + '?mode=mirror#geometry-skeleton';
                    history.replaceState({}, '', newUrl);
                    // Defer scroll until after first render
                    setTimeout(()=>{
                        const anchor = document.getElementById('geometry-skeleton') || document.querySelector('[id="geometry-skeleton"]');
                        anchor && anchor.scrollIntoView({behavior:'smooth', block:'start'});
                    }, 1200);
                }
            } catch(e){ console.warn('Deep-link normalization failed', e); }
            // DOM Elements assignment
            generateBtn = document.getElementById('generateReport');
            loadingIndicator = document.getElementById('loadingIndicator');
            errorDisplay = document.getElementById('errorDisplay');
            errorMessage = document.getElementById('errorMessage');
            reportOutput = document.getElementById('reportOutput');
            reportContent = document.getElementById('reportContent');
            // copyBtn removed (Copy Report button no longer present)
            downloadReportBtn = document.getElementById('downloadReport');
            mathBrainInfoBtn = document.getElementById('math-brain-info-btn');
            mathBrainModal = document.getElementById('math-brain-modal');
            closeMathBrainModal = document.getElementById('close-math-brain-modal');
            closeMathBrainModalBottom = document.getElementById('close-math-brain-modal-bottom');
            relocationToggle = document.getElementById('relocationToggle');
            relocationFields = document.getElementById('relocationFields');
            transitDateFields = document.getElementById('quick-transit-section'); // The actual transit section, not the legacy hidden one
            personBCard = document.getElementById('personB-card');
            relocationSection = document.getElementById('relocation-section');

            // Raw data toggle functionality
            const toggleRawDataBtn = document.getElementById('toggleRawData');
            const hideRawDataBtn = document.getElementById('hideRawData');
            const rawDataSection = document.getElementById('rawDataSection');
            
            if (toggleRawDataBtn && hideRawDataBtn && rawDataSection) {
                toggleRawDataBtn.addEventListener('click', () => {
                    rawDataSection.classList.remove('hidden');
                    toggleRawDataBtn.style.display = 'none';
                });
                
                hideRawDataBtn.addEventListener('click', () => {
                    rawDataSection.classList.add('hidden');
                    toggleRawDataBtn.style.display = 'inline';
                });
            }
            
            // PDF Library Readiness Check
            setTimeout(() => {
                if (!isPDFLibraryReady()) {
                    console.warn('PDF library not yet ready, will wait for it when needed');
                    // Optionally, you could preload it here:
                    waitForPDFLibrary(10000).then(() => {
                        console.log('PDF library successfully loaded in background');
                    }).catch((error) => {
                        console.warn('PDF library failed to load in background:', error);
                    });
                } else {
                    console.log('PDF library ready at page load');
                }
            }, 1000);
            // What's New (dismissible) wiring
            try {
                const whatsNewId = 'whats-new-2025-09-07';
                const dismissBtnId = 'dismiss-whats-new-2025-09-07';
                const dismissedKey = `wm_dismissed_${whatsNewId}`;
                const card = document.getElementById(whatsNewId);
                const dismissBtn = document.getElementById(dismissBtnId);
                const dismissed = localStorage.getItem(dismissedKey) === '1';
                if (card) {
                    if (dismissed) {
                        card.classList.add('hidden');
                    } else if (dismissBtn) {
                        dismissBtn.addEventListener('click', () => {
                            localStorage.setItem(dismissedKey, '1');
                            card.classList.add('hidden');
                        });
                    }
                }
            } catch(e){ console.warn('Whats-new card wiring failed', e); }
            relationalContextSection = document.getElementById('relational-context-section');
            intimacyTierDropdown = document.getElementById('intimacy-tier-dropdown');
            exRelationshipCheckbox = document.getElementById('exRelationship');
            relocationPersonBOption = document.getElementById('relocationPersonBOption');
            includePersonBRelocationEl = document.getElementById('includePersonBRelocation');
            transitStartDate = document.getElementById('transitStartDate');
            transitEndDate = document.getElementById('transitEndDate');
            transitStep = document.getElementById('transitStep');
            relocationCoordsInput = document.getElementById('relocationCoords');
            
            // Health Data UI elements
            loadHealthDataBtn = document.getElementById('loadHealthDataBtn');
            clearHealthDataBtn = document.getElementById('clearHealthDataBtn');
            healthDataInput = document.getElementById('healthDataInput');
            healthDataStatus = document.getElementById('healthDataStatus');
            toggleModeHelp = document.getElementById('toggle-mode-help');
            modeHelpPanel = document.getElementById('mode-help-panel');
            prefillTodayBtn = document.getElementById('prefillToday');
            stepSizeHelpBtn = document.getElementById('stepSizeHelp');
            stepSizeHelpPanel = document.getElementById('stepSizeHelpPanel');
            // Sync help copy with configured limits
            try {
                const panel = stepSizeHelpPanel;
                if (panel) {
                    const paras = Array.from(panel.querySelectorAll('p'));
                    const apiProt = paras.find(p => /API Protection/i.test(p.textContent||''));
                    const dMax = (window.WOVEN_STEP_LIMITS?.daily?.max)||45;
                    const wMax = (window.WOVEN_STEP_LIMITS?.weekly?.max)||270;
                    const mMax = (window.WOVEN_STEP_LIMITS?.monthly?.max)||550;
                    const wMonths = Math.round(wMax/30);
                    const mMonths = Math.round(mMax/30);
                    if (apiProt) {
                        apiProt.innerHTML = `<b>API Protection</b>: Configured limits — Daily=${dMax} days max, Weekly=${wMonths} months max, Monthly=${mMonths} months max.`;
                    }
                }
            } catch(e){ console.warn('Could not refresh Step Size help copy', e); }
            // Relationship role custom field toggle (delegated)
            document.addEventListener('change', (e)=>{
                if (e.target && e.target.id === 'relationshipRole') {
                    const roleCustom = document.getElementById('relationshipRoleCustom');
                    roleCustom && roleCustom.classList.toggle('hidden', e.target.value !== 'other');
                }
            });

            console.log("DOM elements assigned:", {
                generateBtn: !!generateBtn,
                loadingIndicator: !!loadingIndicator,
                errorDisplay: !!errorDisplay,
                transitStartDate: !!transitStartDate,
                transitEndDate: !!transitEndDate,
                transitStep: !!transitStep,
                relocationCoordsInput: !!relocationCoordsInput,
                seismoMdInput: !!document.getElementById('seismoMdInput'),
                genComparativeBtn: !!document.getElementById('genComparativeBtn'),
                relocationSection: !!relocationSection
            });

            // Developer hint: override step limits from console if desired
            try {
                console.info('Step limits in use:', window.WOVEN_STEP_LIMITS);
                console.info('To override limits in this browser, run:', "localStorage.setItem('wm_step_limits_override', JSON.stringify({daily:{max:60,warnRatio:0.85},weekly:{max:360},monthly:{max:720}})); location.reload();");
            } catch(_) {}

            setupEventListeners();
            setupProgressiveDisclosureEventListeners(); // New UX improvement functions
            
            updateFormUI();
            
            // Relocation default wiring & persistence
            // Ensure hint container exists
            if(document.getElementById('relocationCoords') && !document.getElementById('relocationCoordsError')){
                const hint=document.createElement('div'); hint.id='relocationCoordsError'; hint.className='mt-1 text-xs'; hint.setAttribute('aria-live','polite');
                document.getElementById('relocationCoords').parentNode.appendChild(hint);
            }
            attachCoordValidator('relocationCoords','relocationCoordsError');
            wireUseDefaultRelocButton();
            if(loadRelocPref()) { applyRelocDefaults(false); }
            // Add persistence checkbox inside details if not present
            const details = document.getElementById('relocation-details');
            if(details && !document.getElementById('alwaysUseDefaultReloc')){
                const wrap=document.createElement('label');
                wrap.className='mt-3 flex items-center gap-2 text-sm';
                wrap.innerHTML='<input id="alwaysUseDefaultReloc" type="checkbox" class="h-4 w-4"> Always use Panama City by default';
                details.appendChild(wrap);
                const cb=document.getElementById('alwaysUseDefaultReloc');
                cb.checked=loadRelocPref();
                cb.addEventListener('change',e=> saveRelocPref(e.target.checked));
            }
            // Header quick button
            const relocQuickBtn = document.getElementById('relocQuickBtn');
            const relocToggleEl = document.getElementById('relocationToggle');
            if (relocQuickBtn){
                // Only apply defaults when user clicks; show neutral visual otherwise
                relocQuickBtn.addEventListener('click', ()=>{
                    applyRelocDefaults(true);
                    document.getElementById('relocation-section')?.scrollIntoView({behavior:'smooth', block:'start'});
                    if (relocQuickBtn) { relocQuickBtn.setAttribute('aria-pressed','true'); relocQuickBtn.classList.add('bg-teal-600','text-white'); }
                });
                // Sync visual state with checkbox
                if (relocToggleEl) {
                    const syncQuickBtn = () => {
                        const checked = !!relocToggleEl.checked;
                        relocQuickBtn.setAttribute('aria-pressed', checked ? 'true' : 'false');
                        if (checked) { relocQuickBtn.classList.add('bg-teal-600','text-white'); }
                        else { relocQuickBtn.classList.remove('bg-teal-600','text-white'); }
                        updateRelocationNote();
                    };
                    relocToggleEl.addEventListener('change', syncQuickBtn);
                    // initial sync
                    syncQuickBtn();
                }
            }
            // Initial note state if not already updated
            updateRelocationNote();

            // Initialize with Mirror mode
            updateAppMode('mirror');
            updateContextType('solo');
            
            // Auto-prefill transit dates with today for convenience
            const todayStr = getTodayDateString();
            if (transitStartDate && transitEndDate) {
                transitStartDate.value = todayStr;
                transitEndDate.value = todayStr;
            }
            
            // Initial check for intimacy tier
            const isPartner = document.querySelector('input[name="relationshipType"]:checked')?.value === 'partner';
            intimacyTierDropdown.classList.toggle('hidden', !isPartner);
            
            // Mobile-specific initialization
            initializeMobileSupport();
            
            // Gentle auto-timezone mapping for Person A (Bryn Mawr → Eastern)
            try {
                const tzSelect = document.getElementById('offsetA');
                const city = document.getElementById('birth_cityA');
                const state = document.getElementById('birth_stateA');
                const coords = document.getElementById('astroA');
                const userTouched = { value: false };
                if (tzSelect) {
                    tzSelect.addEventListener('change', () => { userTouched.value = true; }, { once: true });
                }
                const maybeSetEastern = () => {
                    if (!tzSelect || userTouched.value) return;
                    const cityVal = (city?.value || '').trim().toLowerCase();
                    const stateVal = (state?.value || '').trim().toUpperCase();
                    const coordVal = (coords?.value || '').trim();
                    let shouldEastern = false;
                    // City/state hint
                    if (cityVal === 'bryn mawr' && (stateVal === 'PA' || stateVal === 'PENNSYLVANIA')) shouldEastern = true;
                    // Rough coord hint for Eastern US (lon between -67 and -82, lat between 25 and 47)
                    if (!shouldEastern && coordVal) {
                        const m = coordVal.match(/-?\d+\.?\d*/g);
                        if (m && m.length >= 2) {
                            const lat = parseFloat(m[0]);
                            const lon = parseFloat(m[1]);
                            if (isFinite(lat) && isFinite(lon) && lon <= -67 && lon >= -82 && lat >= 25 && lat <= 47) {
                                shouldEastern = true;
                            }
                        }
                    }
                    if (shouldEastern && tzSelect.value !== 'America/New_York') {
                        tzSelect.value = 'America/New_York';
                    }
                };
                // Run once on load; also re-run when user pastes coords or edits city/state (but don't override after manual change)
                maybeSetEastern();
                city?.addEventListener('blur', maybeSetEastern);
                state?.addEventListener('blur', maybeSetEastern);
                coords?.addEventListener('change', maybeSetEastern);
            } catch (e) { console.debug('tz auto-map skipped:', e); }

            // Auth0 & Poetic Brain Integration
            // Note: Early initializer disabled to avoid double init. Unified initializer runs at page bottom.
            // See "Auth0 Init & UI Wiring" IIFE near the end of the file.
            
            // Validate safe lexicon implementation
            validateSafeLexicon();
        });
        
        // Mobile support initialization
        function initializeMobileSupport() {
            console.log('Initializing mobile support...');
            
            // Check if we're on a mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isSmallScreen = window.innerWidth <= 768;
            
            console.log('Mobile detection:', { isMobile, isSmallScreen, userAgent: navigator.userAgent });
            
            if (isMobile || isSmallScreen) {
                // Add mobile class to body for additional styling hooks
                document.body.classList.add('mobile-device');
                
                // Fix date inputs on mobile
                const dateInputs = document.querySelectorAll('input[type="date"]');
                dateInputs.forEach(input => {
                    // Ensure proper date format handling
                    input.addEventListener('input', function(e) {
                        console.log('Date input changed:', e.target.id, 'value:', e.target.value);
                        
                        // Validate the date format
                        if (e.target.value && !/^\d{4}-\d{2}-\d{2}$/.test(e.target.value)) {
                            console.warn('Date format issue detected:', e.target.value);
                            // Try to convert common formats
                            if (e.target.value.includes('/')) {
                                const parts = e.target.value.split('/');
                                if (parts.length === 3) {
                                    // Assume MM/DD/YYYY format and convert to YYYY-MM-DD
                                    const month = parts[0].padStart(2, '0');
                                    const day = parts[1].padStart(2, '0');
                                    const year = parts[2];
                                    const isoDate = `${year}-${month}-${day}`;
                                    console.log('Converting date format:', e.target.value, 'to', isoDate);
                                    e.target.value = isoDate;
                                }
                            }
                        }
                    });
                    
                    // Prevent iOS zoom on focus
                    input.addEventListener('focus', function(e) {
                        console.log('Date input focused:', e.target.id);
                        e.target.style.fontSize = '16px';
                    });
                });
                
                // Also handle time inputs
                const timeInputs = document.querySelectorAll('input[type="time"]');
                timeInputs.forEach(input => {
                    input.addEventListener('focus', function(e) {
                        e.target.style.fontSize = '16px';
                    });
                });
                
                // Handle text inputs that might become date inputs on mobile
                const textInputs = document.querySelectorAll('input[type="text"]');
                textInputs.forEach(input => {
                    input.addEventListener('focus', function(e) {
                        e.target.style.fontSize = '16px';
                    });
                });
                
                console.log('Mobile support initialized');
            }
        }

    <!-- Legacy Auth0 block removed to prevent double initialization -->

</script>
<!-- ---- Auth0 Init & UI Wiring (runs after SDK loader) ---- -->
<script>
(async () => {
  try {
        // Skip if already initialized
        if (window._auth0) {
            console.info('[Auth0 Debug] Auth0 already initialized; skipping duplicate init');
            return;
        }
    // Show the current origin (helps confirm redirect_uri)
    const originEl = document.getElementById('auth-debug-origin');
    if (originEl) { originEl.textContent = location.origin; originEl.classList.remove('hidden'); }

    // 1) Wait for SDK loader promise (defined earlier in the page)
    if (window.__auth0Ready) {
      try {
        await window.__auth0Ready;
        console.info('[Auth0 Debug] __auth0Ready resolved');
      } catch (e) {
        console.warn('[Auth0 Debug] __auth0Ready rejected:', e);
      }
    } else {
      console.warn('[Auth0 Debug] __auth0Ready not found; continuing anyway');
    }

    // 2) Resolve the creation function regardless of namespace style
    const createClient =
      (window.auth0 && window.auth0.createAuth0Client) ||
      window.createAuth0Client;

    if (typeof createClient !== 'function') {
      console.warn('SDK loaded but createAuth0Client missing; enabling buttons with fallback alert.');
      document.querySelectorAll('.auth-btn').forEach(b => {
        if (!b) return;
        b.disabled = false;
        b.addEventListener('click', () => alert('Auth is unavailable because the Auth0 SDK did not initialize. See console.'));
      });
      return;
    }

    // 3) Fetch config from your Netlify function
    const cfgResp = await fetch('/.netlify/functions/auth-config', { cache: 'no-store' });
    if (!cfgResp.ok) throw new Error('auth-config HTTP ' + cfgResp.status);
    const cfg = await cfgResp.json();
    console.log('[Auth0 Debug] fetched config:', cfg);

    if (!cfg?.domain || !cfg?.clientId) {
      console.warn('[Auth0 Debug] Missing domain/clientId in config; enabling buttons without auth.');
      document.querySelectorAll('.auth-btn').forEach(b => {
        if (!b) return;
        b.disabled = false;
        b.addEventListener('click', () => alert('Auth is not configured (missing domain/clientId).'));
      });
      return;
    }

        // Handle Auth0 error redirects (e.g., audience misconfiguration)
        const urlParams = new URLSearchParams(location.search);
        if (urlParams.has('error')) {
            const err = urlParams.get('error');
            const desc = decodeURIComponent(urlParams.get('error_description') || '');
            console.warn('[Auth0 Debug] Authorization error:', err, desc);
            alert('Login could not start: ' + desc + '\n\nTip: Ensure your Auth0 API (Dashboard → APIs) exists and AUTH0_AUDIENCE matches its Identifier. You can still log in without API access tokens.');
            // Clean query to avoid re-alerting on reload
            history.replaceState({}, document.title, location.pathname);
        }

        // 4) Create the client (omit audience here to allow basic login even if API isn’t set up).
                const auth0Client = await createClient({
            domain: (cfg.domain || '').replace(/^https?:\/\//, ''),
      clientId: cfg.clientId,
      authorizationParams: {
                redirect_uri: location.origin
      }
    });
    window._auth0 = auth0Client;

    // 5) Handle redirect callback (if we just returned from Auth0)
    if (location.search.includes('code=') && location.search.includes('state=')) {
      try {
        console.info('[Auth0 Debug] Handling redirect callback…');
        await auth0Client.handleRedirectCallback();
        // Clean the query string for aesthetics
        window.history.replaceState({}, document.title, location.pathname);
      } catch (e) {
        console.error('[Auth0 Debug] handleRedirectCallback failed:', e);
      }
    }

    // 6) UI helpers
    const $ = s => document.querySelector(s);
    const googleBtn = $('#google-login-button');
    const logoutBtn = $('#logout-button');

        function enableAuthUI() {
            [googleBtn, logoutBtn].forEach(b => { if (b) b.disabled = false; });
        }

        async function refreshUI() {
            const authed = await auth0Client.isAuthenticated();
            if (logoutBtn) logoutBtn.classList.toggle('hidden', !authed);
            if (googleBtn) googleBtn.classList.toggle('hidden', authed);
            console.info('[Auth0 Debug] UI state →', authed ? 'authenticated' : 'logged out');
        }

    // 7) Wire events
    enableAuthUI();
    await refreshUI();

    // Only Google login is exposed in UI

        if (googleBtn) {
            googleBtn.addEventListener('click', async () => {
                try {
                    console.info('[Auth0 Debug] loginWithRedirect(connection=google-oauth2)');
                    await auth0Client.loginWithRedirect({
                        authorizationParams: { connection: 'google-oauth2' }
                    });
                } catch (e) {
                    console.error('[Auth0] google redirect failed:', e);
                    alert('Google login failed. Check console for details: ' + (e && (e.message || e.error_description || e.error) || 'unknown error'));
                }
            });
        }

    if (logoutBtn) {
      logoutBtn.addEventListener('click', async () => {
        try {
          console.info('[Auth0 Debug] logout() → returnTo origin');
          await auth0Client.logout({ logoutParams: { returnTo: location.origin } });
        } catch (e) {
          console.error('[Auth0] logout failed:', e);
        }
      });
    }

    console.info('✅ Auth0 client initialized successfully');
  } catch (err) {
    console.error('[Auth0 Init] Failed:', err);
    // Failsafe: enable buttons and warn on click so "nothing" never happens
        if (!window._auth0) {
            document.querySelectorAll('.auth-btn').forEach(b => {
                if (!b) return;
                b.disabled = false;
                // Only attach a fallback alert if no successful client exists
                b.addEventListener('click', () => alert('Auth is unavailable. Check console for errors.'));
            });
        }
  }
})();
</script>
</body>
</html>

    <!DOCTYPE html>
    <!-- COPILOT_GUIDE: CLEAR MIRROR DOWNSTREAM ONLY
     - Math Brain payload is geometry-only. Do NOT generate narrative (Clear Mirror) here.
     - Never emit keys named field, voice, or map back to serverless layer.
     - Provide RAVEN_NUDGE + Mirror flags so downstream Poetic Brain (Raven Calder) can translate FIELD → MAP → VOICE.
     - Use hooks (≤2° preference), seismograph (magnitude, valence, volatility, scaling_strategy/confidence), retrograde flags, and True/Mean Node distinctions.
     - Timezone baseline preference: America/Chicago (Central). Emit TZ check hints; do not auto-correct silently.
     - Add Mini Glossary + Raven Checklist at footer for non-Raven consumers.
     - TODO[RAVEN]: Read seismograph scaling to nuance stability vs emergent signal.
     - TODO[RAVEN]: If multiple retrograde_involved hooks, surface a "revision/recursion" nuance.
  
        === STYLE NOTE: TERMINOLOGY LAYERING (Woven Map) ===
        Purpose: Prevent collapse into mechanistic language ("wiring"). Prefer mythic metaphors by layer:
            1. Natal / Personality Context → "Reveal the Weave" (structural identity, natal pattern coherence)
            2. Transit (daily / short-term) → "Trace the Threads" (live activations tugged or loosening)
            3. Transit Aggregation / Macro Patterns → "Currents" / "Seismograph" (field states, symbolic weather, volatility)
        Raven Calder (Poetic Brain) alone produces narrative/interpretation. Math Brain supplies geometry + nudges only.
        If NOT Raven Calder GPT:
            - Auto-append Mini Glossary footer.
            - Reinforce role distinction: "Math Brain finds the coordinates; Poetic Brain translates the weave."
        
    -->
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Woven Map Math Brain - Pure Astrological Geometry</title>
        <link href="dist/output.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <style>
            :root {
                /* Modern color palette */
                --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                --bg-dark: #0f0f14;
                --bg-card: rgba(255, 255, 255, 0.03);
                --bg-card-hover: rgba(255, 255, 255, 0.05);
                --border-subtle: rgba(255, 255, 255, 0.08);
                --border-active: rgba(102, 126, 234, 0.5);
                --text-primary: #f3f4f6;
                --text-secondary: #9ca3af;
                --text-muted: #6b7280;
                --accent-teal: #14b8a6;
                --accent-purple: #8b5cf6;
                --accent-blue: #3b82f6;
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
                background-color: var(--bg-dark); /* Fallback */
                background: var(--bg-dark);
                color: var(--text-primary);
                line-height: 1.6;
                min-height: 100vh;
                position: relative;
                overflow-x: hidden;
            }

            /* Subtle background gradient - static */
            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at 20% 80%, rgba(102, 126, 234, 0.08) 0%, transparent 50%),
                            radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.08) 0%, transparent 50%),
                            radial-gradient(circle at 40% 40%, rgba(20, 184, 166, 0.04) 0%, transparent 50%);
                pointer-events: none;
            }

            /* Modern container styling */
            .container {
                position: relative;
                z-index: 1;
            }

            /* Enhanced header styling */
            header h1 {
                background: var(--primary-gradient);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: -0.02em;
                line-height: 1.2;
            }

            /* Tab navigation with modern styling */
            .bg-gray-800 {
                background: var(--bg-card) !important;
                border: 1px solid var(--border-subtle);
                backdrop-filter: blur(10px);
            }

            /* Modern button styling */
            .bg-teal-600 {
                background: var(--primary-gradient) !important;
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            }

            .hover\:bg-teal-700:hover {
                transform: translateY(-1px);
                box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4) !important;
            }

            /* Form enhancements */
            .bg-gray-700 {
                background: var(--bg-card) !important;
                border: 1px solid var(--border-subtle);
                backdrop-filter: blur(10px);
            }

            .bg-gray-700:hover {
                background: var(--bg-card-hover) !important;
                border-color: rgba(255, 255, 255, 0.1);
            }

            /* Input field styling */
            input, select, textarea {
                background: rgba(255, 255, 255, 0.05) !important;
                border: 1px solid var(--border-subtle) !important;
                border-radius: 12px !important;
                color: var(--text-primary) !important;
                transition: all 0.3s ease;
            }

            input:focus, select:focus, textarea:focus {
                background: rgba(255, 255, 255, 0.08) !important;
                border-color: var(--border-active) !important;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1) !important;
                outline: none !important;
            }



            /* Card styling enhancements */
            .rounded-lg {
                border-radius: 16px !important;
            }

            .rounded {
                border-radius: 12px !important;
            }

            /* Seismograph specific styling */
            .border-teal-500 {
                border-color: rgba(20, 184, 166, 0.3) !important;
                background: linear-gradient(135deg, rgba(20, 184, 166, 0.05) 0%, rgba(102, 126, 234, 0.03) 100%) !important;
            }

            /* Tab indicator - uses Tailwind's animate-pulse utility */
            .transit-indicator {
                /* Tailwind handles pulse animation via animate-pulse class */
            }



            /* Table improvements */
            table {
                border-collapse: separate;
                border-spacing: 0;
            }

            th {
                background: rgba(102, 126, 234, 0.1) !important;
                font-weight: 600;
            }

            tr:hover td {
                background: var(--bg-card-hover) !important;
            }

            /* Pattern card styling */
            .pattern-card {
                transition: all 0.3s ease;
                border-radius: 12px !important;
            }

            .pattern-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            }

            /* Mobile optimizations */
            @media (max-width: 768px) {
                /* Date input styling on mobile */
                input[type="date"] {
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    background-color: rgba(255, 255, 255, 0.05) !important;
                    color: var(--text-primary) !important;
                    border: 1px solid var(--border-subtle) !important;
                    padding: 0.75rem !important;
                    border-radius: 12px !important;
                    font-size: 16px;
                    text-align: left !important;
                }

                input[type="date"]::-webkit-datetime-edit-text,
                input[type="date"]::-webkit-datetime-edit-month-field,
                input[type="date"]::-webkit-datetime-edit-day-field,
                input[type="date"]::-webkit-datetime-edit-year-field {
                    color: var(--text-primary);
                }

                input[type="date"]::-webkit-calendar-picker-indicator {
                    background-color: var(--text-primary);
                    border-radius: 3px;
                    cursor: pointer;
                    opacity: 0.8;
                }

                input[type="time"] {
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    background-color: rgba(255, 255, 255, 0.05) !important;
                    color: var(--text-primary) !important;
                    border: 1px solid var(--border-subtle) !important;
                    text-align: left !important;
                }

                /* Mobile tap targets */
                input[type="radio"], input[type="checkbox"] {
                    min-width: 20px;
                    min-height: 20px;
                    margin-right: 12px;
                }

                label {
                    min-height: 44px;
                    display: flex;
                    align-items: center;
                }

                /* Seismograph mobile optimizations */
                .swipeable-card {
                    touch-action: pan-x;
                    transition: transform 0.2s ease;
                }

                .swipeable-card:active {
                    transform: scale(0.98);
                }

                .overflow-x-auto {
                    -webkit-overflow-scrolling: touch;
                }

                button {
                    min-height: 44px;
                    touch-action: manipulation;
                }
            }

            /* Custom scrollbar */
            ::-webkit-scrollbar {
                width: 10px;
            }

            ::-webkit-scrollbar-track {
                background: var(--bg-dark);
            }

            ::-webkit-scrollbar-thumb {
                background: var(--border-subtle);
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: var(--border-active);
            }

            /* Range slider styling */
            input[type="range"] {
                height: 6px;
                background: var(--border-subtle);
                border-radius: 3px;
                outline: none;
            }

            input[type="range"]::-webkit-slider-thumb {
                appearance: none;
                width: 18px;
                height: 18px;
                background: var(--accent-blue);
                border-radius: 50%;
                cursor: pointer;
            }

            input[type="range"]::-moz-range-thumb {
                width: 18px;
                height: 18px;
                background: var(--accent-blue);
                border-radius: 50%;
                cursor: pointer;
                border: none;
            }

            /* Animation utilities */
            .animate-fade-in-out {
                animation: fadeInOut 8s ease-in-out forwards;
            }

            @keyframes fadeInOut {
                0%, 100% { opacity: 0; transform: translateY(-20px); }
                10%, 90% { opacity: 1; transform: translateY(0); }
            }

            /* Loading states */
            .loading::after {
                content: '';
                width: 1rem;
                height: 1rem;
                border: 2px solid transparent;
                border-top-color: currentColor;
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
                display: inline-block;
                margin-left: 0.5rem;
            }

            @keyframes spin {
                to { transform: rotate(360deg); }
            }

            /* Button improvements */
            button:hover {
                transform: translateY(-1px);
            }

            button:active {
                transform: translateY(0);
            }

            /* Smooth transitions for interactive elements */
            a, button, input, select, textarea, .clickable {
                transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), 
                            opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                            background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                            border-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                            box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* Filter panel animations */
            #seismographFiltersPanel {
                transition: all 0.3s ease;
                max-height: 0;
                overflow: hidden;
            }

            #seismographFiltersPanel:not(.hidden) {
                max-height: 400px;
            }
            
            /* Seismograph chart responsiveness - prevent horizontal scrolling */
            .seismograph-content-area {
                overflow-x: auto;
                width: 100%;
            }
            
            .seismograph-content-area canvas {
                max-width: 100%;
                height: auto;
            }
            
            /* Ensure sticky controls work properly on all screen sizes */
            @media (max-width: 768px) {
                .sticky {
                    position: relative; /* Fall back to relative on very small screens */
                }
            }

            /* ---- Report Reading Surface Enhancements ---- */
            .report-surface { font-variant-ligatures:none; }
            .report-surface::-webkit-scrollbar { width:10px; }
            .report-surface::-webkit-scrollbar-track { background:rgba(31,41,55,.55); border-radius:6px; }
            .report-surface::-webkit-scrollbar-thumb { background:linear-gradient(to bottom,#0d9488,#0e7490); border-radius:6px; }
            .report-surface::-webkit-scrollbar-thumb:hover { background:linear-gradient(to bottom,#14b8a6,#06b6d4); }
            .report-surface h1, .report-surface h2, .report-surface h3 { font-family:'Inter',sans-serif; font-weight:600; letter-spacing:.5px; }
            .report-surface h1 { font-size:1.05rem; margin-top:.85rem; margin-bottom:.4rem; color:#5eead4; }
            .report-surface h2 { font-size:.95rem; margin-top:.75rem; margin-bottom:.35rem; color:#67e8f9; }
            .report-surface h3 { font-size:.85rem; margin-top:.65rem; margin-bottom:.3rem; color:#a5f3fc; }
            .report-surface code { background:#1e293b; padding:2px 4px; border-radius:4px; font-size:.9em; }
            .report-surface hr { border:0; border-top:1px solid rgba(148,163,184,.25); margin:.8rem 0; }
            .report-surface ul { list-style:disc; margin-left:1.1rem; margin-bottom:.4rem; }
            .report-surface table { border-collapse:collapse; width:100%; font-size:.72rem; margin:.6rem 0 .9rem; }
            .report-surface th, .report-surface td { border:1px solid rgba(71,85,105,.55); padding:4px 6px; }
            .report-surface th { background:#0f172a; font-weight:500; color:#7dd3fc; }
            .report-surface tr:nth-child(even){ background:rgba(30,41,59,.55); }
            .report-surface a { color:#38bdf8; text-decoration:underline; }
            .report-surface a:hover { color:#7dd3fc; }
            .report-surface .tag { display:inline-block; background:#164e63; color:#cffafe; padding:2px 6px; margin:1px 3px 1px 0; border-radius:4px; font-size:.55rem; letter-spacing:.5px; }
            .report-surface .faint { color:#64748b; }
            .report-surface .section-break { margin:1rem 0 .55rem; padding-top:.25rem; border-top:1px dashed rgba(94,234,212,.35); }
            /* Flash highlight for Show Wiring anchor scroll */
            .flash-wire { outline:3px solid currentColor; outline-offset:2px; animation:flashWire 900ms ease-in-out; }
            @media (prefers-contrast: more) { .flash-wire { outline-width:4px; } }
            @keyframes flashWire { 0%{filter:brightness(1.2);} 100%{filter:brightness(1);} }
            @media (min-width:1024px){ .report-surface { font-size:12px; } }
        </style>
        
        <!-- PDF Generation Library - Load early -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    </head>
<body class="bg-gray-900 text-gray-200">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Woven Map Math Brain</h1>
            <p class="text-gray-400 mt-2 flex items-center justify-center gap-2">Pure Astrological Geometry Computation
                <button id="math-brain-info-btn" class="ml-2 text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                    What is Math Brain? (Glossary)
                </button>
            </p>
            
            <!-- Weather Badge (shown when Planetary Weather is selected) -->
            <div id="weatherBadge" class="hidden mt-4 mb-2">
                <div class="inline-flex items-center gap-2 px-3 py-1 bg-gradient-to-r from-blue-600 to-purple-600 text-white text-sm font-medium rounded-full border border-blue-500/30">
                    <span class="text-lg">🌤️</span>
                    <span>Weather</span>
                </div>
            </div>
            
            <!-- Mirror/Seismograph/Balance Meter Tab Switch -->
            <div class="mt-6 mb-4">
                <div class="flex justify-center">
                    <div class="bg-gray-800 p-1 rounded-lg border border-gray-600 inline-flex" role="tablist" aria-label="Output Mode">
                        <button id="mirrorModeTab" type="button" role="tab" aria-selected="true" aria-controls="mirror-content" 
                                class="px-6 py-2 text-sm font-medium rounded-md bg-teal-600 text-white transition-colors duration-200" 
                                data-mode="mirror">
                            Mirror
                        </button>
                        <button id="balanceMeterModeTab" type="button" role="tab" aria-selected="false" aria-controls="balance-meter-content" 
                                class="px-6 py-2 text-sm font-medium rounded-md bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors duration-200" 
                                data-mode="balance_meter">
                            Balance Meter
                        </button>
                    </div>
                </div>
                <div class="mt-2 text-xs text-gray-400 text-center">
                    <span id="modeDescription">
                        <strong class="text-teal-300">Mirror:</strong> Geometry + reflection in one stream. Always includes the full skeletal ledger (angles, houses, hooks) plus the recognition layer. Seismograph trace auto-appends when transit hooks exist.
                    </span>
                </div>
            </div>
        </header>

        <!-- Glossary Modal -->
        <div id="math-brain-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 hidden">
          <div class="bg-gray-900 rounded-lg shadow-xl max-w-lg w-full p-6 relative border border-teal-500">
            <button id="close-math-brain-modal" class="absolute top-2 right-2 text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            <h2 class="text-xl font-bold text-teal-300 mb-2">Math Brain & Poetic Brain: The Woven Map Framework</h2>
            <p class="text-sm text-gray-200 mb-3">
              <b>Math Brain</b>: computes planetary positions, aspects, house placements. Outputs geometry, no meaning.<br>
              <b>Poetic Brain</b>: translates geometry into felt/narrative language. Diagnostic, not predictive.<br>
              <b>TL;DR</b>: Math Brain finds the coordinates. Poetic Brain speaks the language you can feel.
            </p>
            <h3 class="text-teal-200 font-semibold mt-4 mb-1">Glossary</h3>
            <ul class="text-xs text-gray-300 space-y-1 max-h-48 overflow-y-auto pr-2">
              <li><b>FIELD → MAP → VOICE</b>: FIELD = energetic climate, MAP = geometry, VOICE = felt reflection.</li>
              <li><b>Recognition-First Principle</b>: Choose diagnostic mode based on real question, not technical curiosity.</li>
              <li><b>Context Modes</b>: Natal (single person), Synastry (interaction), Transit (current currents), Composite (relationship entity).</li>
              <li><b>Ping</b>: Recognized resonance between chart and experience.</li>
              <li><b>SST</b>: Falsifiability filter. WB = Within Boundary, ABE = At Boundary Edge, OSR = Outside Symbolic Range.</li>
              <li><b>Echo Loop</b>: Dyadic cycle under 1° orb.</li>
              <li><b>REF</b>: Relational Echo Field, macro-pattern resonance between two charts.</li>
              <li><b>Intimacy Tier</b>: P1 = Platonic, P2 = FWB, P3 = Romantic.</li>
              <li><b>Clear Mirror</b>: Testable, non-mystical phrasing.</li>
              <li><b>29° Crisis Node</b>: Planet at 29°, volatility.</li>
              <li><b>Symbolic Weather Overlay</b>: Current transits as energetic "weather".</li>
              <li><b>Paradox Line</b>: Internal contradiction.</li>
            </ul>
            <div class="mt-4 text-right">
              <button id="close-math-brain-modal-bottom" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-1 px-4 rounded">Close</button>
            </div>
          </div>
        </div>

        <main>
            <!-- Person A & B Cards -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div id="personA-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <div class="flex items-center justify-between mb-4 border-b border-gray-700 pb-2">
                        <h2 class="text-2xl font-semibold text-white">Person A / Natal Chart</h2>
                        <div class="flex items-center gap-2">
                            <button id="relocQuickBtn" type="button" aria-pressed="false" class="text-xs px-3 py-1 rounded-full border border-gray-600 text-gray-300 hover:bg-gray-700/20 transition-colors" title="Apply Panama City relocation overlay">Reloc: Panama City</button>
                        </div>
                    </div>
                    <div class="space-y-5">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameA" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="DH Cross">
                            <input type="text" id="birth_cityA" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="Bryn Mawr">
                            <input type="text" id="birth_stateA" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="PA">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="date" id="birth_dateA" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="1973-07-24">
                            <input type="text" id="birth_timeA" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="14:30">
                            <select id="offsetA" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600">
                                <option value="America/Chicago" selected>Central (Chicago)</option>
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska</option>
                                <option value="Pacific/Honolulu">Hawaii</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="birth_countryA" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="US">
                            <select id="zodiacA" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div>
                            <label for="astroA" class="block mb-2 text-sm font-medium text-gray-300">Birth Coordinates</label>
                            <input type="text" id="astroA" placeholder="e.g., 40°1'N, 75°18'W or 40.01, -75.31" class="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600" value="40°1'N, 75°18'W">
                        </div>
                    </div>
                </div>
                
                <!-- Person B Card with Progressive Disclosure -->
                <div id="personB-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <!-- Person B Toggle Header -->
                    <div id="personB-toggle" class="flex items-center justify-between mb-4 cursor-pointer hover:bg-gray-750 p-2 -m-2 rounded transition-colors" role="button" tabindex="0" aria-expanded="false" aria-controls="personB-details">
                        <h2 class="text-2xl font-semibold text-white border-b border-gray-700 pb-2 border-b-0 pb-0">Person B (Optional)</h2>
                        <svg id="personB-chevron" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    
                    <!-- Person B Details (collapsible) -->
                    <div id="personB-details" class="hidden">
                        <div class="border-b border-gray-700 mb-4"></div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <input type="text" id="nameB" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_cityB" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_stateB" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <input type="date" id="birth_dateB" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_timeB" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <select id="offsetB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                    <option value="America/New_York">Eastern (New York)</option>
                                    <option value="America/Chicago">Central (Chicago)</option>
                                    <option value="America/Denver">Mountain (Denver)</option>
                                    <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                    <option value="America/Anchorage">Alaska</option>
                                    <option value="Pacific/Honolulu">Hawaii</option>
                                </select>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <input type="text" id="birth_countryB" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <select id="zodiacB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                    <option value="Tropic">Tropic</option>
                                    <option value="Sidereal">Sidereal</option>
                                </select>
                            </div>
                            <div>
                               <label for="astroB" class="block mb-1 text-sm font-medium text-gray-300">Birth Coordinates</label>
                               <input type="text" id="astroB" placeholder="e.g., 30.16, -85.66" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            </div>
                            <button id="pasteAstroB" class="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded text-sm">
                              Paste AstroSeek Data
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Gate: Simplified Selection -->
            <div id="context-gate-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold text-white">What do you want to explore?</h2>
                    <button id="context-help-btn" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 Context Guide
                    </button>
                </div>
                
                <!-- Context Help Panel (initially hidden) -->
                <div id="context-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Context Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Solo →</span>
                            <div class="text-gray-300">
                                <div>Chart your inner landscape and its current activations. <em>"What patterns am I carrying, and how is today pressing on them?"</em></div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Relational →</span>
                            <div class="text-gray-300">
                                <div>Map how two charts weave together, plus the currents moving through that dynamic. <em>"What happens when our patterns touch?"</em></div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Weather →</span>
                            <div class="text-gray-300">
                                <div>Current planetary currents without personal chart context. <em>"What's the energetic weather right now?"</em></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity.
                        </p>
                    </div>
                </div>
                
                <div id="context-selection" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <label class="flex items-center p-4 border border-gray-600 rounded-lg hover:border-teal-500 transition-colors cursor-pointer">
                        <input type="radio" name="contextType" value="solo" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                        <div>
                            <div class="text-white font-medium">Solo</div>
                            <div class="text-gray-400 text-sm">Chart your inner weave</div>
                        </div>
                    </label>
                    <label class="flex items-center p-4 border border-gray-600 rounded-lg hover:border-teal-500 transition-colors cursor-pointer">
                        <input type="radio" name="contextType" value="relational" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                        <div>
                            <div class="text-white font-medium">Relational</div>
                            <div class="text-gray-400 text-sm">Where two patterns touch</div>
                        </div>
                    </label>
                    <label class="flex items-center p-4 border border-gray-600 rounded-lg hover:border-teal-500 transition-colors cursor-pointer">
                        <input type="radio" name="contextType" value="weather" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                        <div>
                            <div class="text-white font-medium">Planetary Weather Only</div>
                            <div class="text-gray-400 text-sm">Sky patterns without personal charts</div>
                        </div>
                    </label>
                </div>
                
                <!-- Solo Subtype Selection (initially visible for solo mode) -->
                <div id="solo-subtypes" class="mt-4 p-4 bg-gray-750 rounded-lg border border-gray-600">
                    <h3 class="text-sm font-medium text-white mb-3">What type of solo analysis?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="soloSubtype" value="natal_only" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white text-sm">Chart Only</div>
                                <div class="text-gray-400 text-xs">Foundational natal architecture</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="soloSubtype" value="natal_transits" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                            <div>
                                <div class="text-white text-sm">Chart + Transits</div>
                                <div class="text-gray-400 text-xs">Your chart + current currents</div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <!-- Relational Subtype Selection (initially hidden) -->
                <div id="relational-subtypes" class="hidden mt-4 p-4 bg-gray-750 rounded-lg border border-gray-600">
                    <h3 class="text-sm font-medium text-white mb-3">What type of relational analysis?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationalSubtype" value="synastry" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white text-sm">Synastry + Transits</div>
                                <div class="text-gray-400 text-xs">Laying two old maps on top of each other—where rivers line up, where mountains clash</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationalSubtype" value="composite" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                            <div>
                                <div class="text-white text-sm">Composite + Transits</div>
                                <div class="text-gray-400 text-xs">Sketching a third map from the overlap—what country appears when you travel together</div>
                            </div>
                        </label>
                    </div>
                    
                    <!-- Relational Mode Explanation -->
                    <div class="mt-4 p-3 bg-gray-800 rounded-lg border border-gray-600">
                        <div class="text-xs text-gray-300 space-y-2">
                            <div>
                                <strong class="text-teal-300">Synastry</strong> is like laying two old maps on top of each other to see where the rivers line up and where the mountains clash. It shows where each of you naturally flows toward or grinds against the other.
                            </div>
                            <div>
                                <strong class="text-teal-300">Composite</strong> is more like sketching a third map out of the overlap—what kind of country appears when you travel together, even if only for a short spell. That land isn't yours alone or theirs alone; it only exists when the two maps are laid together.
                            </div>
                            <div class="text-gray-400 italic mt-2">
                                Remember: The mirror does not mean the journey is happening—only that, if the two paths touch, this is what the water would show.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Mode Section (legacy - will be hidden and auto-updated) -->
            <div id="context-mode-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500 hidden">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-semibold text-white">Context Mode</h2>
                    <button id="toggle-mode-help" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 What does each mode do?
                    </button>
                </div>
                
                <!-- Symbolic Purpose Guide (initially hidden) -->
                <div id="mode-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Mode Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Natal+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current planetary field on individual chart. <em>"How is today's current flowing through me?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: If a date range is added, the system checks for all periods of exact or near-exact resonance between those dates—not just today.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Comp+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current field on the shared connection. <em>"How is today's current flowing through our bond?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: Adding a date range means the system maps every significant current on the connection during that window. Results are limited to that span.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Syn+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current field on relational dynamics. <em>"How is today's current flowing through our interaction?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: With a date range, the system searches for all windows where relational tension or harmony becomes active during the specified time frame.</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity. 
                            Each mode serves a specific diagnostic purpose within the FIELD → MAP → VOICE framework.
                        </p>
                        <p class="text-xs text-gray-400 mt-2">
                            <strong class="text-teal-300">Date Range Effect:</strong> Adding a date range turns a "today" reading into a scan for all matching patterns over that period, revealing field windows and thresholds—not just a snapshot.
                        </p>
                    </div>
                </div>
                
                <!-- Context Mode Selection -->
                <div class="flex flex-wrap items-center gap-4 mb-4">
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_transits" class="mr-2" checked>
                        <span class="text-gray-300">Natal Chart + Transits</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="composite_transits" class="mr-2">
                        <span class="text-gray-300">Composite + Transits</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="contextMode" value="synastry_transits" class="mr-2">
                        <span class="text-gray-300">Synastry + Transits</span>
                    </label>
                </div>
                
            </div>
            
            <!-- Progressive Disclosure Sections -->
            
            <!-- Transit Date Range with Progressive Disclosure -->
            <div id="optional-details-section" class="space-y-6">
                
                <!-- Quick Transit Settings (Mirror Mode Default) -->
                <div id="quick-transit-section" class="bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold text-white">Date Range</h2>
                        <div class="flex items-center gap-4">
                            <button id="todayDefault" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded text-sm transition-colors">
                                📅 Use Today
                            </button>
                            <button id="expandTransitOptions" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                                ⚙️ More Options
                            </button>
                        </div>
                    </div>
                    
                    <!-- Simple Date Inputs -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="transitStartDate" class="block text-gray-300 font-medium mb-1">Start Date:</label>
                            <input type="date" id="transitStartDate" name="transitStartDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" required>
                        </div>
                        <div>
                            <label for="transitEndDate" class="block text-gray-300 font-medium mb-1">End Date:</label>
                            <input type="date" id="transitEndDate" name="transitEndDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" required>
                        </div>
                    </div>
                    
                    <!-- Advanced Transit Options (initially hidden) -->
                    <div id="advanced-transit-options" class="hidden mt-4 pt-4 border-t border-gray-700">
                        <div class="flex justify-between items-center mb-2">
                            <label for="transitStep" class="block text-gray-300 font-medium">Step Size:</label>
                            <button id="stepSizeHelp" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                                ❓ What does this do?
                            </button>
                        </div>
                        <select id="transitStep" name="transitStep" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <option value="1d">Daily (1 day intervals)</option>
                            <option value="7d">Weekly (7 day intervals)</option>
                            <option value="1m">Monthly (1 month intervals)</option>
                        </select>
                        <!-- Step Size Help Panel (initially hidden) -->
                        <div id="stepSizeHelpPanel" class="hidden mt-2 p-3 bg-gray-750 rounded-lg border border-teal-600 text-sm">
                            <h4 class="text-teal-300 font-semibold mb-2">📊 Step Size Explained</h4>
                            <p class="text-gray-200 mb-2">Step size controls how frequently transit calculations are performed within your date range:</p>
                            <ul class="text-gray-300 space-y-1 ml-4">
                                <li><b>Daily</b>: Calculate transits for every single day (most detailed, max 45 days)</li>
                                <li><b>Weekly</b>: Calculate transits every 7 days (good balance, max 6 months)</li>
                                <li><b>Monthly</b>: Calculate transits once per month (fastest, max 1 year)</li>
                            </ul>
                            <div class="mt-3 p-2 bg-gray-800 rounded border border-gray-600">
                                <p class="text-teal-300 text-xs font-medium mb-1">📏 Recommended Date Ranges (API-Optimized):</p>
                                <ul class="text-gray-400 text-xs space-y-1 ml-2">
                                    <li>• <strong>1-14 days:</strong> Use Daily for detailed analysis</li>
                                    <li>• <strong>2 weeks-3 months:</strong> Use Weekly for balance</li>
                                    <li>• <strong>3-6 months:</strong> Use Monthly for overview</li>
                                    <li>• <strong>Today only:</strong> Daily for current transits</li>
                                </ul>
                                <p class="text-yellow-200 mt-2 text-xs"><b>API Protection</b>: Conservative limits prevent excessive API usage. Daily=45 days max, Weekly=9 months max, Monthly=18 months max.</p>
                            </div>
                            <p class="text-yellow-200 mt-2 text-xs"><b>Performance Note</b>: Longer ranges with finer steps may take more time to process and generate larger datasets.</p>
                        </div>
                    </div>
                </div>

                <!-- Relocation Overlay with Progressive Disclosure -->
                <div id="relocation-section" class="bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500">
                    <div class="flex items-center justify-between cursor-pointer hover:bg-gray-750 p-2 -m-2 rounded transition-colors" 
                         id="relocation-toggle-header" role="button" tabindex="0" aria-expanded="false" aria-controls="relocation-details">
                        <div class="flex items-center">
                            <input type="checkbox" id="relocationToggle" class="mr-4 h-6 w-6 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <h3 class="text-lg font-medium text-white">Relocation Overlay</h3>
                                <p class="text-sm text-teal-300">Check this to compare how your chart shifts if you lived elsewhere</p>
                                <p class="text-xs text-gray-400">Same planets, different stage - where your patterns express in daily life</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button id="useDefaultRelocation" type="button" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">Use my default</button>
                            <svg id="relocation-chevron" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- Relocation Details (collapsible) -->
                    <div id="relocation-details" class="hidden">
                        <p id="relocation-default-note" class="mb-4 text-xs text-gray-500 italic">
                            Panama City, FL (30°10'N, 85°40'W) is pre-filled as a suggested relocation reference. It is NOT applied until you enable the checkbox.
                        </p>
                        <div class="mt-4 pt-4 border-t border-gray-700 space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label for="relocationCity" class="block mb-1 text-sm font-medium text-gray-300">Relocation City</label>
                                    <input type="text" id="relocationCity" placeholder="e.g., Panama City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="Panama City">
                                </div>
                                <div>
                                    <label for="relocationState" class="block mb-1 text-sm font-medium text-gray-300">State/Province</label>
                                    <input type="text" id="relocationState" placeholder="e.g., FL" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="FL">
                                </div>
                            </div>
                            
                            <div>
                                <label for="relocationCoords" class="block mb-1 text-sm font-medium text-gray-300">
                                    Relocation Coordinates
                                    <span class="text-xs text-gray-500">(Required for overlay calculations)</span>
                                </label>
                                <input type="text" id="relocationCoords" placeholder="e.g., 30°10'N, 85°40'W or 34.0522, -118.2437" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="30°10'N, 85°40'W">
                                <div class="mt-1 text-xs text-gray-500">
                                    <strong class="text-gray-400">Supported formats:</strong>
                                    <br>• <strong>Astroseek format:</strong> "30°10'N, 85°40'W" (degrees/minutes with direction)
                                    <br>• <strong>Decimal degrees:</strong> "40.7128, -74.0060" (positive = N/E, negative = S/W)
                                    <br>• Get coordinates from <a href="https://astroseek.com/astrology-birth-chart-calculator-map" target="_blank" class="text-teal-400 underline">Astroseek</a> or Google Maps
                                </div>
                                
                                <!-- Validation Error for Relocation Coords -->
                                <div id="relocationCoordsError" class="hidden mt-1 text-xs text-red-400">
                                    Please enter valid coordinates in format: latitude, longitude
                                </div>
                            </div>
                            
                            <div class="bg-gray-750 p-3 rounded border border-gray-600">
                                <h4 class="text-sm font-medium text-teal-300 mb-2">How Relocation Works:</h4>
                                <ul class="text-xs text-gray-400 space-y-1">
                                    <li>• <strong class="text-gray-300">Same birth chart, different stage set</strong> - planets and aspects unchanged</li>
                                    <li>• <strong class="text-gray-300">Houses and angles shift</strong> - where your patterns get expressed in daily life</li>
                                    <li>• <strong class="text-gray-300">Tectonic (where), not timing</strong> - foundational context shift; timing of the sky doesn't change</li>
                                    <li>• <strong class="text-gray-300">Diagnostic value</strong> - shows where natal currents plug into new ground</li>
                                </ul>
                                <div class="mt-2 p-2 bg-gray-800 rounded border border-gray-600">
                                    <p class="text-xs text-teal-300">
                                        <strong>Example:</strong> Sun in 12th (private) → Sun at Midheaven (public stage). 
                                        Same solar nature, different life domain where it gets expressed.
                                    </p>
                                </div>
                            </div>
                            
                            <!-- Person B Relocation Option (only visible when Person B is present) -->
                            <div id="relocationPersonBOption" class="hidden">
                                <div class="flex items-center p-3 bg-gray-750 rounded border border-gray-600">
                                    <input type="checkbox" id="includePersonBRelocation" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                                    <label for="includePersonBRelocation" class="text-gray-300 font-medium">
                                        Also relocate Person B to same location
                                        <span class="text-xs text-gray-500 block">
                                            <strong>Default:</strong> Only Person A gets relocated. <br>
                                            <strong>Check this if:</strong> Person B is also in the same relocation city. <br>
                                            <strong>Leave unchecked if:</strong> Person B remains in their birth location.
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Legacy hidden sections for compatibility -->
            <div class="hidden">
                <div id="context-toggle" class="flex items-center mb-4">
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_only" class="mr-2">
                        <span class="text-gray-300">Natal Chart Only</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_transits" class="mr-2" checked>
                        <span class="text-gray-300">Natal Chart + Transits</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="balance_meter" class="mr-2">
                        <span class="text-gray-300">Balance Meter (Health Data Comparison)</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="composite_transits" class="mr-2">
                        <span class="text-gray-300">Composite + Transits</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="contextMode" value="synastry_transits" class="mr-2">
                        <span class="text-gray-300">Synastry + Transits</span>
                    </label>
                </div>
                
                <!-- Legacy transit fields for compatibility -->
                <div id="transit-date-range-fields" class="mb-6 hidden">
                  <div class="flex justify-between items-center mb-2">
                    <label for="transitStartDate" class="block text-gray-300 font-medium">Transit Start Date (YYYY-MM-DD):</label>
                    <button id="prefillToday" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                        📅 Use Today for Quick Check
                    </button>
                  </div>
                </div>
            </div>
                
                <!-- Additional Context Options -->
                <div id="context-options" class="space-y-4">
                    <div class="bg-yellow-900 border border-yellow-700 text-yellow-100 px-4 py-3 rounded mb-4">
                        <div class="flex">
                            <div class="flex-shrink-0">
                                <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="ml-3">
                                <h3 class="text-sm font-medium">Math Brain Protocol Active</h3>
                                <div class="mt-2 text-sm">
                                    This panel computes geometry only. Interpretation lives in the Mirror.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            </div>

            <!-- Relational Context Section (conditional visibility) - moved from hidden context-mode-section -->
            <div id="relational-context-section" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500" role="region" aria-labelledby="relational-context-heading">
                <h2 id="relational-context-heading" class="text-xl font-semibold mb-4 text-white">Relational Context</h2>
                <p class="text-gray-400 text-sm mb-4">Detected potential dynamics:</p>
                <ul id="context-readout" class="list-disc list-inside space-y-2 mb-4 text-gray-300"></ul>
                <div id="relationship-type-query">
                    <p class="text-lg font-medium text-white mb-2">How would you categorize this connection?</p>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="partner" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Partner</div>
                                <div class="text-gray-400 text-xs">Romantic / undefined-intimate</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="friend" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Friend / Colleague</div>
                                <div class="text-gray-400 text-xs">Friend or colleague</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="family" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Family Member</div>
                                <div class="text-gray-400 text-xs">Family member</div>
                            </div>
                        </label>
                    </div>
                    <div id="exRelationshipRow" class="mt-4 pt-3 border-t border-gray-600">
                        <label class="flex items-center p-2 hover:bg-gray-750 rounded cursor-pointer">
                            <input type="checkbox" id="exRelationship" class="mr-3 h-4 w-4 text-red-400 focus:ring-red-500 border-gray-600 rounded bg-gray-700">
                            <span class="text-gray-300">Ex or Estranged</span>
                            <span class="text-xs text-gray-500 ml-2">(not valid for Friend/Colleague)</span>
                        </label>
                    </div>
                    <!-- Relationship Role (conditional) -->
                    <div id="relationship-role-block" class="mt-4 hidden" aria-live="polite">
                        <label for="relationshipRole" class="block text-sm font-medium text-gray-300">
                            Relationship Role 
                            <span class="text-xs text-gray-400">(Person B relative to A)</span>
                        </label>
                        <select id="relationshipRole" class="mt-1 w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-sm"></select>
                        <input id="relationshipRoleCustom" placeholder="Custom role (e.g., half-brother, stepmother)" class="mt-2 w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-sm hidden" />
                        <div class="mt-2">
                            <label for="relationshipNotes" class="block text-xs font-medium text-gray-400">Relationship Notes (optional)</label>
                            <textarea id="relationshipNotes" rows="2" class="w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-xs" placeholder="Any clarifying context (e.g., estranged, adopted)"></textarea>
                        </div>
                    </div>
                    <div id="intimacy-tier-dropdown" class="mt-4 hidden">
                        <p class="text-md font-medium text-white mb-2">Select intimacy tier (required for Partner):</p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P1" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P1 – Platonic</div>
                                    <div class="text-gray-400 text-xs">No sexual/romantic expectations</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P2" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P2 – FWB</div>
                                    <div class="text-gray-400 text-xs">Sexual, no romantic commitment</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P3" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P3 – Situationship</div>
                                    <div class="text-gray-400 text-xs">Fluid rules/expectations</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P4" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P4 – Low-commitment</div>
                                    <div class="text-gray-400 text-xs">Uneven investment, minimal care</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P5a" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P5a – Committed</div>
                                    <div class="text-gray-400 text-xs">Romantic + sexual</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P5b" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P5b – Committed</div>
                                    <div class="text-gray-400 text-xs">Romantic, no sexual</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Contact Channel Toggle -->
                    <div class="mt-6 p-4 bg-gray-750 rounded-lg border border-gray-600">
                        <p class="text-md font-medium text-white mb-3">Contact Channel:</p>
                        <p class="text-xs text-gray-400 mb-4">Is this an active relationship channel (currently exchanging), or a dormant one (not currently exchanging)?</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                                <input type="radio" name="contactChannel" value="live" class="mr-3 h-4 w-4 text-teal-400 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                                <div>
                                    <div class="text-white text-sm">🟢 Live</div>
                                    <div class="text-gray-400 text-xs">Currently in contact / active exchange</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                                <input type="radio" name="contactChannel" value="latent" class="mr-3 h-4 w-4 text-teal-400 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">⚫ Latent</div>
                                    <div class="text-gray-400 text-xs">Not currently in contact / no active exchange</div>
                                </div>
                            </label>
                        </div>
                        <div class="mt-3 p-2 bg-gray-800 rounded text-xs text-gray-300">
                            <strong class="text-teal-300">Live:</strong> Enables interaction overlays ("when A does this, B may respond...") <br>
                            <strong class="text-teal-300">Latent:</strong> Parallel weather only (side-by-side individual readings)
                        </div>
                    </div>
                </div>
            </div>

            <!-- Primary Action -->
            <div class="text-center mb-12">
                <button id="generateReport" class="bg-gradient-to-r from-teal-600 to-teal-700 hover:from-teal-700 hover:to-teal-800 text-white font-bold py-4 px-12 rounded-lg text-xl shadow-lg transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    ✨ Get My Mirror
                </button>
            </div>

            <!-- Secondary Actions - Core Workflow -->
            <div class="text-center mb-8">
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md mx-auto">
                    <h3 class="text-white font-medium mb-4">📋 Chart Management</h3>
                    <p class="text-xs text-gray-400 mb-4">Keep your current setup to reuse later</p>
                    <div class="flex justify-center gap-3">
                        <button id="saveDataBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                            💾 Save Setup
                        </button>
                        <button id="loadDataBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                            📂 Load Setup
                        </button>
                    </div>
                    <input type="file" id="loadDataInput" accept=".json" class="hidden">
                </div>
            </div>

            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center mb-8">
                <div class="inline-flex items-center px-4 py-2 font-semibold leading-6 text-sm shadow rounded-md text-white bg-teal-600 transition ease-in-out duration-150">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="loadingText">Computing Astrological Geometry...</span>
                </div>
            </div>

            <!-- Optional Data Overlays (Advanced) -->
            <div class="max-w-4xl mx-auto mb-8">
                <div class="text-center mb-4">
                    <h3 class="text-lg font-medium text-gray-300 mb-2">📋 Optional Data Overlays</h3>
                    <p class="text-sm text-gray-400 max-w-2xl mx-auto">
                        These are <strong>completely optional</strong> advanced features. Upload data files to overlay correlations with your astrological patterns. 
                        <br><span class="text-teal-400">Order: Generate your base chart first, then optionally add overlays and regenerate.</span>
                    </p>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Health Data Overlay -->
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg border-t-4 border-purple-500">
                        <h3 class="text-white font-medium mb-2 flex items-center gap-2">
                            🏥 Health Data Overlay
                            <button id="healthDataHelpBtn" class="text-xs text-purple-300 hover:text-purple-400 focus:outline-none" title="How to setup Health Auto Export">
                                ❓
                            </button>
                        </h3>
                        <p class="text-xs text-gray-400 mb-2">Compare Apple Health metrics (sleep, HRV, mood) with astrological transits</p>
                        <p class="text-xs text-blue-300 mb-4"><strong>Produces:</strong> Correlation tables showing how your health patterns align with planetary movements</p>
                        <div class="space-y-2">
                            <button id="loadHealthDataBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                                📱 Upload Health Data
                            </button>
                            <button id="clearHealthDataBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden">
                                ✖️ Clear Health Data
                            </button>
                        </div>
                        <input type="file" id="healthDataInput" accept=".json" class="hidden">
                        <div id="healthDataStatus" class="text-xs text-green-400 hidden mt-2"></div>
                        <p class="text-xs text-purple-400 mt-2">Compatible with iOS "Health Auto Export" app</p>
                    </div>

                    <!-- Balance Meter -->
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg border-t-4 border-cyan-500">
                        <h3 class="text-white font-medium mb-2 flex items-center gap-2">
                            📊 Balance Meter
                            <button class="text-xs text-cyan-300 hover:text-cyan-400 focus:outline-none" title="Upload symbolic logs (.md) to cross-check currents">
                                ❓
                            </button>
                        </h3>
                        <p class="text-xs text-gray-400 mb-2">Cross-reference your personal symbolic logs with chart patterns</p>
                        <p class="text-xs text-cyan-300 mb-4"><strong>Produces:</strong> Comparative analysis showing how your recorded experiences align with astrological indicators</p>
                        
                        <!-- Balance Meter Mode Option -->
                        <div class="mb-4 p-3 bg-gray-750 rounded border border-cyan-600">
                            <label class="flex items-center">
                                <input type="checkbox" id="balanceMeterMode" class="mr-3 h-4 w-4 text-cyan-600 focus:ring-cyan-500 border-gray-600 rounded bg-gray-700">
                                <span class="text-gray-300 font-medium">
                                    Generate Balance Meter Report
                                    <span class="text-xs text-gray-400 block">
                                        Focus on triple-channel analysis (Seismograph, Balance Channel, SFD) for health correlation
                                    </span>
                                </span>
                            </label>
                        </div>
                        
                        <div class="space-y-2">
                            <button id="loadSeismoBtn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                                📄 Upload Balance Meter Data
                            </button>
                            <button id="clearSeismoBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden">
                                ✖️ Clear Balance Meter Data
                            </button>
                            <button id="genComparativeBtn" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200 hidden" disabled>
                                🔗 Generate Comparative Report
                            </button>
                        </div>
                        <input type="file" id="seismoMdInput" accept=".md,.markdown,text/markdown" class="hidden">
                        <div id="seismoDataStatus" class="text-xs text-gray-500 hidden mt-2"></div>
                        <p class="text-xs text-cyan-400 mt-2">Accepts Markdown (.md) files with dated entries</p>
                    </div>
                </div>
            </div>

            <!-- Health Data Help Modal -->
            <div id="healthDataHelpModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-gray-800 p-6 rounded-lg max-w-2xl max-h-96 overflow-y-auto border border-purple-500">
                    <h3 class="text-lg font-semibold text-purple-300 mb-4">Health Auto Export Setup Guide</h3>
                    <div class="text-sm text-gray-300 space-y-3">
                        <p><strong class="text-white">Required App:</strong> "Health Auto Export" from iOS App Store</p>
                        <p><strong class="text-white">Recommended Settings:</strong></p>
                        <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Quick Export tab</li>
                            <li>Aggregation Interval: <span class="text-green-400">days</span></li>
                            <li>Aggregate Data: <span class="text-green-400">ON</span></li>
                        </ul>
                        <p><strong class="text-white">Include These Metrics:</strong></p>
                        <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Heart Rate Variability (HRV)</li>
                            <li>Resting Heart Rate</li>
                            <li>Sleep Sessions</li>
                            <li>State of Mind (optional - can use separate CSV)</li>
                        </ul>
                        <p class="text-yellow-300"><strong>Note:</strong> Other metrics (workouts, ECG, etc.) are safely ignored.</p>
                        <p class="text-blue-300"><strong>Privacy:</strong> Data stays in your browser - no server upload.</p>
                    </div>
                    <button id="closeHealthDataHelp" class="mt-4 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded text-sm">Close</button>
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorDisplay" class="hidden bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-8">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium">Error computing geometry</h3>
                        <div id="errorMessage" class="mt-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Report Output -->
            <div id="reportOutput" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg">
                
                <!-- Tab Content Areas -->
                <div id="mirror-content" role="tabpanel" aria-labelledby="mirrorModeTab">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-semibold text-white">Pure Astrological Geometry</h2>
                        
                        <!-- Progressive Disclosure: Raw Data Toggle -->
                        <button id="toggleRawData" class="text-xs text-gray-400 underline hover:text-gray-300 focus:outline-none">
                            Show Raw Data
                        </button>
                    </div>

                    <!-- Orientation Banner -->
                    <div class="mb-6 p-4 bg-gray-750 rounded-lg border border-gray-600">
                        <p class="text-sm text-gray-300">
                            What you see below is Math Brain output — raw geometry only. Raven Calder translates this into plain, resonant insights. 
                            These files are structured for both humans and AI to read.
                        </p>
                    </div>

                <!-- Action Zones -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <!-- For Readers Zone -->
                    <div class="bg-gray-750 p-4 rounded-lg border border-emerald-600">
                        <h3 class="text-emerald-300 font-medium mb-3">📖 For Readers</h3>
                        <div class="space-y-2">
                            <button id="downloadReport" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-medium py-2 px-3 rounded text-sm transition-colors hidden">
                                📄 Download Report
                                <span class="block text-xs opacity-80">Formatted file with your chart results</span>
                            </button>
                            <button id="downloadPDF" class="w-full bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-3 rounded text-sm transition-colors hidden">
                                📑 Download PDF
                                <span class="block text-xs opacity-80">Professional PDF report</span>
                            </button>
                            <div id="pdfOptions" class="text-xs text-gray-400 mt-1 hidden">
                                <label class="flex items-center gap-1">
                                    <input type="checkbox" id="autoDownloadPDF" checked class="w-3 h-3">
                                    <span>Auto-download (no filename prompt)</span>
                                </label>
                            </div>
                            <button id="copyReport" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-medium py-2 px-3 rounded text-sm transition-colors hidden">
                                📋 Copy Report
                                <span class="block text-xs opacity-80">Copy results to clipboard</span>
                            </button>
                        </div>
                    </div>

                </div>

                <!-- Progressive Disclosure: Raw Data Content -->
                <div id="rawDataSection" class="hidden">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-medium text-white">Raw Output Data</h3>
                        <button id="hideRawData" class="text-xs text-gray-400 underline hover:text-gray-300 focus:outline-none">
                            Hide Raw Data
                        </button>
                    </div>
                    <!-- Simple Mode: Hook / Aspect Filter Controls intentionally hidden (retained for future advanced mode) -->
                    <div id="hookFilters" class="hidden"></div>
                    <div id="reportContent" class="report-surface whitespace-pre-wrap font-mono text-[11px] leading-relaxed bg-gray-900/80 backdrop-blur-sm p-4 rounded-lg border border-gray-700/70 overflow-auto max-h-[34rem] shadow-inner selection:bg-teal-600/40 selection:text-teal-50">
                    </div>
                </div>
                
                <!-- Balance Meter Tab Content -->
                <div id="balance-meter-content" role="tabpanel" aria-labelledby="balanceMeterModeTab" class="hidden">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-semibold text-white">Balance Meter</h2>
                    </div>
                    <div id="balanceMeterTabContent" class="space-y-6">
                        <!-- Balance Meter content will be populated dynamically -->
                    </div>
                </div>
                
            </div>
        </main>

        <footer class="text-center text-gray-500 text-sm mt-12">
            <p>&copy; 2024 Woven Map Report Generator. Math Brain + Poetic Brain Framework.</p>
        </footer>
    </div>

    <script src="config.js"></script>
    <script src="src/parsers/seismograph-md.js"></script>
    <script src="src/reporters/comparative-report.js"></script>
    <script>
// --- Global row counter for report summary ---
let totalRowCount = 0;
// UI Filter State (persist across renders)
// Simple Mode defaults (no user toggles rendered)
window.WOVEN_UI_FILTERS = { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };

// Universal context reference for browser/server compatibility
const WOVEN_GLOBAL = (typeof globalThis !== 'undefined') ? globalThis : (typeof window !== 'undefined' ? window : {});

// Step-size limits (centralized + configurable)
// Defaults are intentionally conservative; warnings trigger at 80% of max.
const DEFAULT_STEP_LIMITS = {
    daily:  { max: 45,  warnRatio: 0.8, label: 'daily calculations' },
    weekly: { max: 270, warnRatio: 0.8, label: 'weekly calculations' },
    monthly:{ max: 550, warnRatio: 0.8, label: 'monthly calculations' }
};
function resolveStepLimits(){
    try {
        // Allow overrides via config.js if present
        const conf = (typeof WovenMapConfig !== 'undefined' && WovenMapConfig && WovenMapConfig.api && WovenMapConfig.api.limits && WovenMapConfig.api.limits.steps)
            ? WovenMapConfig.api.limits.steps : null;
        // Allow developer/browser overrides via localStorage
        const ls = localStorage.getItem('wm_step_limits_override');
        const lsParsed = ls ? JSON.parse(ls) : null;
        const merged = JSON.parse(JSON.stringify(DEFAULT_STEP_LIMITS));
        const apply = (src) => {
            if (!src) return;
            ['daily','weekly','monthly'].forEach(k => {
                if (src[k]) {
                    if (Number.isFinite(+src[k].max)) merged[k].max = +src[k].max;
                    if (Number.isFinite(+src[k].warnRatio)) merged[k].warnRatio = Math.max(0, Math.min(1, +src[k].warnRatio));
                    if (typeof src[k].label === 'string') merged[k].label = src[k].label;
                }
            });
        };
        apply(conf); apply(lsParsed);
        return merged;
    } catch(e){
        console.warn('Step limits override parse failed; using defaults', e);
        return DEFAULT_STEP_LIMITS;
    }
}
window.WOVEN_STEP_LIMITS = resolveStepLimits();

// --- Helper for lean/legacy aspect/transit row keys ---
function rowNamesAndOrb(r) {
    const transit = r.transit_body ?? r.p1_name ?? r.planet_a ?? '—';
    const natal   = r.natal_target ?? r.p2_name ?? r.planet_b ?? '—';
    const aspect  = r.aspect ?? r.aspect_name ?? r.name ?? '—';
    let orb = r.orb;
    if (!Number.isFinite(orb)) orb = Number(r.orbit);
    if (!Number.isFinite(orb)) orb = null;
    return { transit, natal, aspect, orb };
}
// --- Dual-read helpers for natal/synastry aspects ---
function nameA(r){ return r.p1_name ?? (legacyTouch('natal/synastry:p1_name'), r.planet_a) ?? r.transit_body ?? '—'; }
function nameB(r){ return r.p2_name ?? (legacyTouch('natal/synastry:p2_name'), r.planet_b) ?? r.natal_target ?? '—'; }
function aspectA(r){ return r.aspect ?? (legacyTouch('natal/synastry:aspect_name'), r.aspect_name) ?? '—'; }
function orbA(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('natal/synastry:orbit/diff'), (r.orbit ?? r.diff)); }

function formatAspectRow(r){
    const A = nameA(r), B = nameB(r), asp = aspectA(r);
    const o = orbA(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// --- Global legacy usage telemetry ---
window.WM_LEGACY_HITS = 0;
function legacyTouch(tag){ 
    window.WM_LEGACY_HITS++; 
    console.warn(`[LEGACY] used: ${tag}`); 
}

function nameT(r){ return r.transit_body ?? (legacyTouch('p1_name'), r.p1_name); }
function nameN(r){ return r.natal_target ?? (legacyTouch('p2_name'), r.p2_name); }
function aspectT(r){ return r.aspect ?? (legacyTouch('aspect_name'), r.aspect_name); }
function orbT(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('orbit/diff'), (r.orbit ?? r.diff)); }

function formatTransitRow(r){
    const A = nameT(r), B = nameN(r), asp = aspectT(r);
    const o = orbT(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// ---- aspect math (for fallback orb) ----
const ASPECTS = { conjunction:0, sextile:60, square:90, trine:120, opposition:180,
    quincunx:150, quintile:72, biquintile:144, 'semi-square':45, semisquare:45, sesquiquadrate:135 };
function degNorm(d){ let x=d%360; return x<0?x+360:x; }
function sep(a,b){ const d=Math.abs(degNorm(a)-degNorm(b)); return d>180?360-d:d; }
function computeOrbFromLongitudes(lon1, lon2, aspectName){
    if(!Number.isFinite(lon1) || !Number.isFinite(lon2)) return null;
    const exact = ASPECTS[(aspectName||'').toLowerCase()];
    if(!Number.isFinite(exact)) return null;
    return Math.abs(sep(lon1, lon2) - exact);
}
function bandOrb(orb){ if(!Number.isFinite(orb)) return 'wide';
    if(orb<=1) return 'tight'; if(orb<=3) return 'close'; if(orb<=6) return 'medium'; return 'wide';
}
function valenceHint(aspect){
    const a=(aspect||'').toLowerCase();
    if(['square','opposition','sesquiquadrate','semisquare','semi-square','quincunx'].includes(a)) return 'hot';
    if(['trine','sextile','quintile','biquintile'].includes(a)) return 'cool';
    return 'neutral_to_hot';
}

// ---- normalizers that accept any shape ----
function normalizeTransitRow(row){
    if (row && row.transit_body && row.natal_target) {
        const aspect = row.aspect || row.aspect_name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.transit_lon, row.natal_lon, aspect);
        return {
            transit_body: row.transit_body,
            natal_target: row.natal_target,
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.transit_lon ?? null,
            natal_lon: row.natal_lon ?? null,
            transit_house: row.transit_house ?? null,
            natal_house: row.natal_house ?? null,
            transit_is_retrograde: !!row.transit_is_retrograde,
            natal_is_retrograde: !!row.natal_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.planet_a || row.planet_b)) {
        const aspect = row.aspect_name || row.aspect || row.type || '';
        let orb = Number.isFinite(row.orbit) ? row.orbit
                        : Number.isFinite(row.orb) ? row.orb
                        : computeOrbFromLongitudes(row.abs_pos_a, row.abs_pos_b, aspect);
        return {
            transit_body: row.planet_a || '—',
            natal_target: row.planet_b || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.abs_pos_a ?? null,
            natal_lon: row.abs_pos_b ?? null,
            transit_house: row.p1_house ?? row.house1 ?? null,
            natal_house: row.p2_house ?? row.house2 ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.p1_name || row.p2_name)) {
        const aspect = row.aspect || row.name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.p1_abs_pos, row.p2_abs_pos, aspect);
        return {
            transit_body: row.p1_name || '—',
            natal_target: row.p2_name || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.p1_abs_pos ?? null,
            natal_lon: row.p2_abs_pos ?? null,
            transit_house: row.p1_house ?? null,
            natal_house: row.p2_house ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    return null;
}
function normalizeTransitBlock(block){
    if (Array.isArray(block)) {
        return block.map(normalizeTransitRow).filter(Boolean);
    }
    if (block && block.chart && Array.isArray(block.chart.aspects)) {
        return block.chart.aspects.map(normalizeTransitRow).filter(Boolean);
    }
    return [];
}
function renderTransitDay(dateStr, items){
    const rows = normalizeTransitBlock(items);
    if (!Array.isArray(rows) || rows.length === 0) return `<h4>${dateStr}</h4><p><em>No computed aspects.</em></p>`;
    const lines = rows.map(r => {
        const orbTxt = (r && typeof r.orb === 'number' && Number.isFinite(r.orb)) ? `${r.orb.toFixed(2)}°` : '—';
        return `• <strong>${r.transit_body}</strong> ${r.aspect} <strong>${r.natal_target}</strong> (${orbTxt}, ${r.orb_band}, ${r.valence_hint})`;
    });
    return `<h4>${dateStr}</h4><ul><li>${lines.join("</li><li>")}</li></ul>`;
}
        // Global UI element references
    let generateBtn, loadingIndicator, errorDisplay, errorMessage, reportOutput, reportContent, copyBtn, downloadReportBtn, mathBrainInfoBtn, mathBrainModal, closeMathBrainModal, closeMathBrainModalBottom, relocationToggle, relocationFields, transitDateFields, personBCard, relocationSection, relationalContextSection, intimacyTierDropdown, toggleModeHelp, modeHelpPanel, prefillTodayBtn, stepSizeHelpBtn, stepSizeHelpPanel, exRelationshipCheckbox, relocationPersonBOption, includePersonBRelocationEl, transitStartDate, transitEndDate, transitStep, relocationCoordsInput, loadHealthDataBtn, clearHealthDataBtn, healthDataInput, healthDataStatus, loadSeismoBtn, clearSeismoBtn, seismoMdInput, seismoDataStatus, genComparativeBtn;

        // Store health data for correlation analysis
        let loadedHealthData = null;

        // Defensive check for window/globalThis
        if (typeof window === 'undefined') {
            console.warn('window is not defined; running in non-browser context');
        }

        // Store the latest result data for downloads
        let latestResultData = null;

        // --- Utility Functions ---

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
            reportOutput.classList.add('hidden');
            // Hide report action buttons when showing error
            document.getElementById('copyReport').classList.add('hidden');
            document.getElementById('downloadReport').classList.add('hidden');
            document.getElementById('downloadPDF').classList.add('hidden');
            document.getElementById('pdfOptions').classList.add('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        // Non-destructive error notification for non-critical failures (like download issues)
        function showNotification(message, type = 'error') {
            // Create or reuse notification element
            let notification = document.getElementById('notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification';
                notification.className = 'fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-md transition-all duration-300 transform translate-x-full';
                document.body.appendChild(notification);
            }
            
            // Set content and styling based on type
            const bgColor = type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-blue-600';
            notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-md transition-all duration-300 transform ${bgColor} text-white`;
            notification.textContent = message;
            
            // Show notification
            notification.classList.remove('translate-x-full');
            notification.classList.add('translate-x-0');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (notification && notification.parentNode) {
                    notification.classList.remove('translate-x-0');
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (notification && notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Helper function to get opposite zodiac sign for South Node calculation
        function getOppositeSign(sign) {
            const opposites = {
                'Ari': 'Lib', 'Tau': 'Sco', 'Gem': 'Sag', 'Can': 'Cap',
                'Leo': 'Aqu', 'Vir': 'Pis', 'Lib': 'Ari', 'Sco': 'Tau',
                'Sag': 'Gem', 'Cap': 'Can', 'Aqu': 'Leo', 'Pis': 'Vir'
            };
            return opposites[sign] || sign;
        }

        // Helper function to check if any house cusps are available in chart data
        function hasAnyHouseCusps(chart) {
            const houseKeys = [
                'first_house', 'second_house', 'third_house', 'fourth_house',
                'fifth_house', 'sixth_house', 'seventh_house', 'eighth_house', 
                'ninth_house', 'tenth_house', 'eleventh_house', 'twelfth_house'
            ];
            return houseKeys.some(key => chart[key] && chart[key].sign && chart[key].position !== undefined);
        }

        // Reusable function to render natal chart data for any person
        function renderNatalChartData(chart, personName) {
            let md = '';
            
            try {
                // Chart Angles - only show if available
                if (chart.asc || chart.ascendant) {
                    md += `### Chart Angles\n\n`;
                    const asc = chart.asc || chart.ascendant;
                    const mc = chart.mc || chart.midheaven;
                    const dsc = chart.dsc || chart.descendant;
                    const ic = chart.ic || chart.imum_coeli;
                    
                    if (asc && asc.sign && asc.position !== undefined) {
                        md += `- **Ascendant (ASC)**: ${asc.sign} ${asc.position.toFixed(2)}°\n`;
                    }
                    if (mc && mc.sign && mc.position !== undefined) {
                        md += `- **Midheaven (MC)**: ${mc.sign} ${mc.position.toFixed(2)}°\n`;
                    }
                    if (dsc && dsc.sign && dsc.position !== undefined) {
                        md += `- **Descendant (DSC)**: ${dsc.sign} ${dsc.position.toFixed(2)}°\n`;
                    }
                    if (ic && ic.sign && ic.position !== undefined) {
                        md += `- **Imum Coeli (IC)**: ${ic.sign} ${ic.position.toFixed(2)}°\n`;
                    }
                    md += `\n`;
                }
                
                // Natal Planet Positions  
                md += `### Natal Planet Positions\n\n`;
                
                // Core planets in standard order
                const planets = [
                    { key: 'sun', name: 'Sun' },
                    { key: 'moon', name: 'Moon' },
                    { key: 'mercury', name: 'Mercury' },
                    { key: 'venus', name: 'Venus' },
                    { key: 'mars', name: 'Mars' },
                    { key: 'jupiter', name: 'Jupiter' },
                    { key: 'saturn', name: 'Saturn' },
                    { key: 'uranus', name: 'Uranus' },
                    { key: 'neptune', name: 'Neptune' },
                    { key: 'pluto', name: 'Pluto' },
                    { key: 'chiron', name: 'Chiron' }
                ];
                
                planets.forEach(planet => {
                    const planetData = chart[planet.key];
                    if (planetData && planetData.sign && planetData.position !== undefined) {
                        const house = planetData.house || 'Unknown';
                        const retrograde = planetData.retrograde ? ' ℞' : '';
                        md += `- **${planet.name}**: ${planetData.sign} ${planetData.position.toFixed(2)}° (House ${house})${retrograde}\n`;
                    }
                });
                
                // Lunar Nodes if available - prioritize true_node over mean_node for accuracy
                const northNode = chart.true_node || chart.mean_node || chart.north_node;
                if (northNode && northNode.sign && northNode.position !== undefined) {
                    md += `\n### Lunar Nodes\n\n`;
                    const house = northNode.house || 'Unknown';
                    const nodeType = chart.true_node ? 'True' : chart.mean_node ? 'Mean' : '';
                    md += `- **North Node${nodeType ? ` (${nodeType})` : ''}**: ${northNode.sign} ${northNode.position.toFixed(2)}° (House ${house})\n`;
                    
                    // South Node is opposite North Node
                    const southNodePos = (northNode.position + 180) % 360;
                    const southNodeSign = getOppositeSign(northNode.sign);
                    if (southNodeSign) {
                        md += `- **South Node${nodeType ? ` (${nodeType})` : ''}**: ${southNodeSign} ${southNodePos.toFixed(2)}°\n`;
                    }
                }
                
                // House Cusps if available - check all 12 houses
                if (hasAnyHouseCusps(chart)) {
                    md += `\n### House Cusps\n\n`;
                    const houses = [
                        { key: 'first_house', name: '1st House', description: 'Identity, Stance' },
                        { key: 'second_house', name: '2nd House', description: 'Resource, Security' },
                        { key: 'third_house', name: '3rd House', description: 'Exchange, Signals' },
                        { key: 'fourth_house', name: '4th House', description: 'Root, Anchor' },
                        { key: 'fifth_house', name: '5th House', description: 'Creative, Expression' },
                        { key: 'sixth_house', name: '6th House', description: 'Craft, Rhythm' },
                        { key: 'seventh_house', name: '7th House', description: 'Relational, Mirror' },
                        { key: 'eighth_house', name: '8th House', description: 'Depth, Crossing' },
                        { key: 'ninth_house', name: '9th House', description: 'Horizon, Philosophy' },
                        { key: 'tenth_house', name: '10th House', description: 'Apex, Projection' },
                        { key: 'eleventh_house', name: '11th House', description: 'Network, Belonging' },
                        { key: 'twelfth_house', name: '12th House', description: 'Dream, Spirit' }
                    ];
                    
                    houses.forEach(house => {
                        const houseData = chart[house.key];
                        if (houseData && houseData.sign && houseData.position !== undefined) {
                            md += `- **${house.name}**: ${houseData.sign} ${houseData.position.toFixed(2)}° (${house.description})\n`;
                        }
                    });
                }
                
                md += `\n`;
            } catch (error) {
                console.log(`Error rendering ${personName} natal chart data:`, error);
                md += `*Natal chart data available but could not be displayed due to formatting.*\n\n`;
            }
            
            return md;
        }

        // --- Date Utility Functions ---

        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function prefillTodayDates() {
            const todayStr = getTodayDateString();
            document.getElementById('transitStartDate').value = todayStr;
            document.getElementById('transitEndDate').value = todayStr;
            
            // Brief visual feedback
            prefillTodayBtn.textContent = '✅ Set to Today';
            setTimeout(() => { 
                prefillTodayBtn.textContent = '📅 Use Today for Quick Check'; 
            }, 2000);
        }

        // --- Download Functions ---

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        // Chunking functions for handling large date ranges
        function calculateDaySpan(transitParams) {
            if (!transitParams?.startDate || !transitParams?.endDate) return 0;
            const start = new Date(transitParams.startDate);
            const end = new Date(transitParams.endDate);
            return Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;
        }

        function createDateChunks(transitParams, chunkSize = 10) {
            const start = new Date(transitParams.startDate);
            const end = new Date(transitParams.endDate);
            const chunks = [];
            
            let currentStart = new Date(start);
            
            while (currentStart <= end) {
                let currentEnd = new Date(currentStart);
                currentEnd.setDate(currentEnd.getDate() + chunkSize - 1);
                
                if (currentEnd > end) {
                    currentEnd = new Date(end);
                }
                
                chunks.push({
                    startDate: currentStart.toISOString().split('T')[0],
                    endDate: currentEnd.toISOString().split('T')[0],
                    step: transitParams.step
                });
                
                // advance to the day after the currentEnd (robust across months/years)
                currentStart = new Date(currentEnd);
                currentStart.setDate(currentStart.getDate() + 1);
            }
            
            return chunks;
        }

        function mergeChunkedResults(results) {
            // Merge multiple chunked results into a single coherent result
            if (!results.length) return null;
            
            const merged = JSON.parse(JSON.stringify(results[0])); // Deep clone first result
            
            // Merge transitsByDate for each entity
            for (let i = 1; i < results.length; i++) {
                const result = results[i];
                
                // Merge Person A transits
                if (result.person_a?.chart?.transitsByDate && merged.person_a?.chart?.transitsByDate) {
                    Object.assign(merged.person_a.chart.transitsByDate, result.person_a.chart.transitsByDate);
                }
                
                // Merge Person B transits
                if (result.person_b?.chart?.transitsByDate && merged.person_b?.chart?.transitsByDate) {
                    Object.assign(merged.person_b.chart.transitsByDate, result.person_b.chart.transitsByDate);
                }
                
                // Merge Composite transits
                if (result.composite?.transitsByDate && merged.composite?.transitsByDate) {
                    Object.assign(merged.composite.transitsByDate, result.composite.transitsByDate);
                }
                
                // Merge Synastry transits
                if (result.synastry?.transitsByDate && merged.synastry?.transitsByDate) {
                    Object.assign(merged.synastry.transitsByDate, result.synastry.transitsByDate);
                }
            }
            
            return merged;
        }

        async function generateReportWithChunking(formData) {
            const startTime = Date.now();
            const daySpan = calculateDaySpan(formData.transitParams);
            const mode = formData.context.mode;
            
            // Initialize run statistics tracking
            window.lastRunStats = {
                api_calls: 0,
                calc_ms: 0,
                hooks_accepted: 0,
                hooks_rejected: 0,
                chunks_processed: 0
            };
            
            // Auto-chunk for ranges > 15 days to stay under 6MB limit
            if (daySpan > 15 && mode.includes('transits')) {
                console.log(`Auto-chunking ${daySpan}-day range into smaller segments`);
                
                // Determine optimal chunk size based on step size
                let chunkSize = 10; // Default: 10 days per chunk
                if (formData.transitParams.step === '7d' || formData.transitParams.step === 'weekly') {
                    chunkSize = 21; // 3 weeks per chunk for weekly data
                } else if (formData.transitParams.step === '1m' || formData.transitParams.step === 'monthly') {
                    chunkSize = 60; // 2 months per chunk for monthly data
                }
                
                const chunks = createDateChunks(formData.transitParams, chunkSize);
                const results = [];
                
                // Update loading indicator to show progress
                const loadingText = document.getElementById('loadingText');
                const originalText = loadingText?.textContent || 'Computing Astrological Geometry...';
                
                const failed = [];
                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    
                    // Create a new formData object with chunked transit parameters
                    // CRITICAL: Don't modify transitParams directly - create new payload per chunk
                    const chunkData = JSON.parse(JSON.stringify(formData)); // Deep clone
                    chunkData.transitParams = chunk;
                    
                    // Update progress
                    if (loadingText) {
                        loadingText.textContent = `Processing chunk ${i + 1} of ${chunks.length} (${chunk.startDate} to ${chunk.endDate})...`;
                    }
                    
                    console.log(`Processing chunk ${i + 1}/${chunks.length}: ${chunk.startDate} to ${chunk.endDate}`);
                    
                    try {
                        const apiEndpoint = WovenMapConfig.getApiEndpoint('astrologyMathBrain');
                        const timeoutMs = 60000; // Longer timeout for chunked requests
                        const controller = new AbortController();
                        const timeoutHandle = setTimeout(() => controller.abort(), timeoutMs);

                        let response;
                        try {
                            response = await fetch(apiEndpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(chunkData),
                                signal: controller.signal
                            });
                            // Track API call
                            window.lastRunStats.api_calls++;
                        } finally {
                            clearTimeout(timeoutHandle);
                        }

                        if (!response.ok) {
                            const errorBody = await response.text();
                            throw new Error(`Chunk ${i + 1} failed: HTTP ${response.status} - ${errorBody}`);
                        }

                        const result = await response.json();
                        // Track chunk processing
                        window.lastRunStats.chunks_processed++;
                        
                        if (result.error) {
                            throw new Error(`Chunk ${i + 1} error: ${result.error}`);
                        }
                        
                        results.push(result);
                        
                        // Brief pause between chunks to avoid overwhelming the server
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        
                    } catch (error) {
                        console.error(`Chunk ${i + 1} failed:`, error);
                        failed.push({ index: i + 1, start: chunk.startDate, end: chunk.endDate, message: error.message });
                        // Continue to try remaining chunks (partial success strategy)
                    }
                }
                
                // Restore loading text
                if (loadingText) {
                    loadingText.textContent = 'Merging results...';
                    // restore shortly after to base message
                    setTimeout(()=>{ try{ loadingText.textContent = originalText; } catch(_){} }, 300);
                }
                
                console.log(`Processed ${chunks.length} chunks → success: ${results.length}, failed: ${failed.length}. Merging results...`);
                if (failed.length) {
                    console.warn('Chunk failures:', failed);
                }
                if (!results.length) {
                    throw new Error('All chunk requests failed; no data could be retrieved.');
                }
                return mergeChunkedResults(results);
            }
            
            // Single request for shorter ranges
            const apiEndpoint = WovenMapConfig.getApiEndpoint('astrologyMathBrain');
            const timeoutMs = (WovenMapConfig?.api?.timeout && Number.isFinite(+WovenMapConfig.api.timeout)) ? +WovenMapConfig.api.timeout : 30000;
            const controller = new AbortController();
            const timeoutHandle = setTimeout(() => controller.abort(), timeoutMs);

            let response;
            try {
                response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData),
                    signal: controller.signal
                });
            } finally {
                clearTimeout(timeoutHandle);
            }

            if (!response.ok) {
                const errorBody = await response.text();
                let errorMessage = `HTTP error! status: ${response.status}`;
                try {
                    const errorJson = JSON.parse(errorBody);
                    if (errorJson.error) {
                       errorMessage += ` - ${errorJson.error}`;
                    } else {
                       errorMessage += ` - ${errorBody}`;
                    }
                } catch (e) {
                    errorMessage += ` - ${errorBody}`;
                }
                throw new Error(errorMessage);
            }

            const result = await response.json();
            if (result.error) {
                throw new Error(result.error);
            }
            
            // Finalize run statistics for single request
            window.lastRunStats.calc_ms = Date.now() - startTime;
            
            return result;
        }

        // === EXECUTIVE SUMMARY AND JSON APPENDIX GENERATORS ===
        
        // Helper functions for executive summary
        function aspectSymbol(asp) {
            const symbols = { 
                opp: "☍", opposition: "☍",
                conj: "☌", conjunction: "☌", 
                trine: "△", sextile: "✧", 
                square: "□", quinc: "⚼", quincunx: "⚼"
            };
            return symbols[asp] || asp;
        }
        
        function formatDegree(n) { 
            return `${n.toFixed(1)}°`; 
        }
        
        function formatNumber(n) { 
            return (n ?? NaN).toFixed(2).replace(/NaN/, "—"); 
        }
        
        function generateExecutiveSummary(data, opts = {}) {
            const { includeHealthLine = true, includeProvenance = true } = opts;
            
            // Extract first day seismograph data
            const firstDayRaw = data.person_a?.chart?.transitsByDate ? 
                Object.values(data.person_a.chart.transitsByDate)[0] :
                data.sky_transits?.transitsByDate ? 
                Object.values(data.sky_transits.transitsByDate)[0] : null;
            
            const firstDayData = firstDayRaw ? normalizeEntry(firstDayRaw) : null;
            
            const formData = collectFormData();
            const mode = formData.context.mode;
            const currentDate = new Date().toISOString().split('T')[0];
            const personA = data.person_a?.details || formData.personA;
            
            // Extract top hooks
            const top = firstDayData?.hooks?.slice(0, 3) || [];
            const hooksStr = top
                .map(h => `${h.p1_display || h.p1_name}${aspectSymbol(h._aspect || h.aspect)}${h.p2_display || h.p2_name} (${formatDegree(h._orb || h.orb || 0)})`)
                .join(", ") || "—";
            
            // Health data
            const healthData = data.health_analysis;
            const health = healthData?.present ? 
                `present${healthData.fidelity_index ? ` | Fidelity ${healthData.fidelity_index.toFixed(1)}/5` : ""}` : 
                "absent";
            
            // Provenance
            const ephemerisSource = data.provenance?.ephemeris_source || "AstrologerAPI-v4";
            const ephemerisHash = data.provenance?.ephemeris_hash || "unknown";
            const prov = `${ephemerisSource} | hash ${ephemerisHash.slice(0, 8)}…`;
            
            // Clamp valence for headline; keep raw for debug transparency
            const rawVal = firstDayData?.seismograph?.valence ?? 0;
            const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
            const clampedVal = clamp(rawVal,-5,5);
            // Retrograde breakdown (transiting retro bodies vs retro-tagged aspects)
            let retroTransitPlanets = 0; let retroTaggedAspects = 0;
            if (firstDayData) {
                const retroBodies = new Set();
                (firstDayData.hooks||[]).forEach(h=>{ if(h.transit_is_retrograde) retroBodies.add(h.p1_name||h.p1_display); if(h.transit_is_retrograde||h.natal_is_retrograde) retroTaggedAspects++; });
                (firstDayData.filtered_aspects||[]).forEach(a=>{ if(a.transit_is_retrograde) retroBodies.add(a.p1_name||a.p1_display); if(a.transit_is_retrograde||a.natal_is_retrograde) retroTaggedAspects++; });
                retroTransitPlanets = retroBodies.size;
            }
            const lines = [
                `# Exec Summary (${data.provenance?.math_brain_version || '0.2.1'})`,
                `Date: ${currentDate}  TZ: ${personA?.timezone || 'UTC'}  Context: ${mode?.toUpperCase() || 'N/A'}`,
                `Triple Channel: ${firstDayData ? tripleChannelLine(firstDayData) : 'No data'}`,
                `Magnitude: ${formatNumber(firstDayData?.seismograph?.magnitude)} (${toMagnitudeTerm(firstDayData?.seismograph?.magnitude || 0)}) | Valence: ${getValenceEmoji(clampedVal)} ${formatNumber(clampedVal)} (${toValenceTerm(clampedVal)}) | Volatility: ${formatNumber(firstDayData?.seismograph?.volatility)}`,
                `Valence_raw (debug): ${formatNumber(rawVal)}`,
                `Top Hooks (orb-capped): ${hooksStr} • [Geometry](#geometry-skeleton)`,
                `Transiting ℞ planets: ${retroTransitPlanets}  ℞-tagged aspects: ${retroTaggedAspects}  OSR: ${(firstDayData?.osr_flags || []).length}`,
                includeHealthLine ? `Health Link: ${health}` : undefined,
                includeProvenance ? `Provenance: ${prov}` : undefined
            ].filter(Boolean);
            
            return lines.join("\n");
        }
        
        function generateJsonAppendix(data, runStats = {}) {
            const transitsByDate = data.person_a?.chart?.transitsByDate || data.sky_transits?.transitsByDate || {};
            const CALIBRATION_BOUNDARY = (data.provenance && data.provenance.calibration_boundary) || '2025-09-05';
            const engines = data.provenance?.engine_versions || { seismograph: 'v1.0', balance: 'v1.1', sfd: 'v1.2' };
            const reconstructed = Boolean(data.reconstructed || (Object.keys(transitsByDate).some(d => d < CALIBRATION_BOUNDARY)));

            const entries = Object.entries(transitsByDate).map(([date, day]) => {
                // Normalize nested/flat balance & sfd
                const balance = day.balance && typeof day.balance === 'object'
                    ? day.balance
                    : (Number.isFinite(day.balance) ? { magnitude: day.seismograph?.magnitude || 0, valence: day.balance, version: 'v1.1' } : undefined);
                const sfd = day.sfd && typeof day.sfd === 'object'
                    ? day.sfd
                    : (Number.isFinite(day.sfd) || Number.isFinite(day.splus) || Number.isFinite(day.sminus))
                        ? { sfd: day.sfd || 0, sPlus: day.splus || 0, sMinus: day.sminus || 0, version: 'v1.2' }
                        : undefined;

                return {
                    schema: 'WM-Chart-1.2',
                    date,
                    seismograph: {
                        magnitude: day.seismograph?.magnitude || 0,
                        valence: day.seismograph?.valence || 0,
                        version: 'v1.0'
                    },
                    ...(balance ? { balance } : {}),
                    ...(sfd ? { sfd } : {}),
                    meta: {
                        calibration_boundary: CALIBRATION_BOUNDARY,
                        engine_versions: engines,
                        reconstructed
                    }
                };
            });

            return entries;
        }
        
        function generateProvenance(data, runStats = {}) {
            const lines = [
                "## Provenance & Processing Metadata\n",
                `**Ephemeris Source**: ${data.provenance?.ephemeris_source || 'AstrologerAPI-v4'}`,
                `**Ephemeris Hash**: ${data.provenance?.ephemeris_hash || 'unknown'}`,
                `**Node Preference**: ${data.provenance?.node_preference || 'True Node (preferred)'}`,
                `**Orb Caps Applied**: Luminaries ${data.provenance?.orb_caps?.luminaries || 12}°, Planets ${data.provenance?.orb_caps?.planets || 8}°, Points ${data.provenance?.orb_caps?.points || 6}°`,
                `**Max Ephemeris Delta**: ±${data.provenance?.max_ephemeris_delta || 0.01}°`,
                `**Processing Stats**: ${runStats.api_calls || 0} API calls, ${runStats.calc_ms || 0}ms calculation time`,
                `**Hook Stats**: ${runStats.hooks_accepted || 0} accepted, ${runStats.hooks_rejected || 0} rejected`,
                `**Deterministic Seed**: ${data.provenance?.deterministic_seed || 'None'}`,
                `**Error Budget**: Max ephemeris variance within tolerance for geometric fidelity`
            ];
            
            return lines.join("\n");
        }
        
        function validateAppendix(payload) {
            // Simple validation - check required fields
            try {
                if (!payload || typeof payload !== 'object') {
                    return { ok: false, errors: ['Payload must be an object'] };
                }
                
                const errors = [];
                
                // Check meta section
                if (!payload.meta) errors.push('meta section missing');
                else {
                    if (!payload.meta.wm_schema) errors.push('meta.wm_schema missing');
                    if (!payload.meta.math_brain_version) errors.push('meta.math_brain_version missing');
                    if (!payload.meta.generated_utc) errors.push('meta.generated_utc missing');
                    if (!payload.meta.ephemeris) errors.push('meta.ephemeris missing');
                    if (!payload.meta.run_stats) errors.push('meta.run_stats missing');
                }
                
                // Check subject section
                if (!payload.subject) errors.push('subject section missing');
                else {
                    if (!payload.subject.name) errors.push('subject.name missing');
                    if (!payload.subject.dob) errors.push('subject.dob missing');
                    if (!payload.subject.tob) errors.push('subject.tob missing');
                    if (!payload.subject.loc) errors.push('subject.loc missing');
                }
                
                // Check seismograph section
                if (!payload.seismograph) errors.push('seismograph section missing');
                else if (!Array.isArray(payload.seismograph)) errors.push('seismograph must be an array');
                
                return errors.length === 0 ? { ok: true } : { ok: false, errors };
            } catch (e) {
                return { ok: false, errors: [`Validation error: ${e.message}`] };
            }
        }

        // === BALANCE METER / SFD HELPERS ===
        
        function sfdVerdict(sfd) {
            if (sfd == null) return null;
            if (sfd >= 0.75)  return "stabilizers prevail";
            if (sfd <= -0.75) return "stabilizers cut";
            return "stabilizers mixed";
        }
        
        function fmtSigned(n) {
            if (n == null || Number.isNaN(+n)) return "?";
            const x = +n;
            return `${x >= 0 ? "+" : ""}${x.toFixed(1)}`;
        }
        
        function tripleChannelLine({ seismograph, balance, sfd }) {
            const mag = seismograph?.magnitude;
            const magTxt = Number.isFinite(mag) ? mag.toFixed(1) : "?";
            const val = seismograph?.valence;
            const valEmoji = Number.isFinite(val) ? getValenceEmoji(Math.max(-5, Math.min(5, val))) : '';
            const parts = [`⚡ ${magTxt}`, `Val ${valEmoji} ${fmtSigned(val)}`];

            if (balance && Number.isFinite(balance.valence)) {
                const balEmoji = getValenceEmoji(Math.max(-5, Math.min(5, balance.valence)));
                parts.push(`Bal ${balEmoji} ${fmtSigned(balance.valence)}`);
            }

            if (sfd && Number.isFinite(sfd.sfd)) {
                const verdict = sfdVerdict(sfd.sfd);
                if (verdict) {
                    const sPlus = Number.isFinite(sfd.sPlus) ? sfd.sPlus.toFixed(1) : '?';
                    const sMinus = Number.isFinite(sfd.sMinus) ? sfd.sMinus.toFixed(1) : '?';
                    parts.push(`${verdict} (SFD ${fmtSigned(sfd.sfd)}; S+ ${sPlus}/S− ${sMinus})`);
                } else {
                    parts.push(`SFD ${fmtSigned(sfd.sfd)}`);
                }
            }

            return parts.join(" · ");
        }
        
        // Normalize entry for consistent nested data structure
        function normalizeEntry(e) {
            const out = { ...e };
            out.seismograph = e.seismograph ?? { 
                magnitude: e.magnitude || 0, 
                valence: e.valence || 0, 
                volatility: e.volatility || 0,
                version: "v1.0" 
            };
            out.balance = e.balance ?? (
                Number.isFinite(e.balance_valence) ? { 
                    magnitude: out.seismograph.magnitude, 
                    valence: e.balance_valence, 
                    version: "v1.1" 
                } : undefined
            );
            out.sfd = e.sfd ?? (
                (e.sfd != null || e.splus != null || e.sminus != null)
                    ? { sfd: e.sfd || 0, sPlus: e.splus || 0, sMinus: e.sminus || 0, version: "v1.2" }
                    : undefined
            );
            return out;
        }

        // Generate simplified seismograph markdown section for auto-append to Mirror reports
        function buildBalanceMeterReport(balanceMeterData) {
            if (!balanceMeterData) return 'No Balance Meter data available.';

            let md = `# Balance Meter Report\n\n`;
            md += `**Subject**: ${balanceMeterData.person?.name || 'Unknown'}\n`;
            md += `**Period**: ${balanceMeterData.period?.start} to ${balanceMeterData.period?.end}\n`;
            md += `**Schema**: WM-Chart-${balanceMeterData.schema_version}\n\n`;

            md += `## Executive Summary\n\n`;
            
            const summary = balanceMeterData.channel_summary;
            if (summary) {
                const seisAvg = Number.isFinite(summary.seismograph_average) ? summary.seismograph_average : 0;
                const balAvg = Number.isFinite(summary.balance_average) ? summary.balance_average : 0;
                const seisEmoji = getValenceEmoji(Math.max(-5, Math.min(5, seisAvg)));
                const balEmoji = getValenceEmoji(Math.max(-5, Math.min(5, balAvg)));
                md += `**Triple Channel Averages**:\n`;
                md += `- Seismograph (valence): ${seisEmoji} ${seisAvg.toFixed(2)}\n`;
                md += `- Balance (valence): ${balEmoji} ${balAvg.toFixed(2)}\n`;
                md += `- SFD (support–friction): ${(Number.isFinite(summary.sfd_average) ? summary.sfd_average : 0).toFixed(2)}\n\n`;
                
                if (summary.dominant_channel) {
                    md += `**Dominant Channel**: ${summary.dominant_channel}\n`;
                }
                if (Number.isFinite(summary.volatility_index)) {
                    md += `**Volatility Index**: 🌪️ ${summary.volatility_index.toFixed(2)}\n`;
                }
                md += `\n`;
            }

            md += `## Daily Entries\n\n`;
            md += `| Date | Triple Channel | SFD Verdict | Top Hooks |\n`;
            md += `|------|-----------------|-------------|----------|\n`;

            if (balanceMeterData.daily_entries) {
                const dates = Object.keys(balanceMeterData.daily_entries).sort();
                
                dates.forEach(date => {
                    const day = normalizeEntry(balanceMeterData.daily_entries[date]);
                    if (!day) return;
                    
                    // Generate triple channel display
                    const channelLine = tripleChannelLine({ 
                        seismograph: day.seismograph, 
                        balance: day.balance, 
                        sfd: day.sfd 
                    });
                    
                    // Get SFD verdict
                    const verdict = sfdVerdict(day.sfd || {});
                    
                    // Get top hooks for this day
                    const hooks = (day.hooks || []).slice(0, 2);
                    const topHooks = hooks.map(h => {
                        const orb = Math.abs(h._orb || h.orb || 0).toFixed(1);
                        return `${h.p1_name} ${h._aspect || h.aspect} ${h.p2_name} (${orb}°)`;
                    }).join(', ') || '—';
                    
                    md += `| ${date} | ${channelLine.replace(/\|/g, '\\|')} | ${verdict} | ${topHooks.replace(/\|/g, '\\|')} |\n`;
                });
            }

            md += `\n## Methodology\n\n`;
            md += `This Balance Meter report focuses on the **triple-channel architecture** for health-oriented astrological analysis:\n\n`;
            md += `1. **Seismograph v1.0**: Crisis-weighted transit intensity\n`;
            md += `2. **Balance v1.1**: Rebalanced valence using planetary locality factors\n`;
            md += `3. **SFD v1.2**: Support-Friction Differential tracking supportive vs disruptive transits\n\n`;
            md += `The **SFD Verdict** indicates whether supportive forces ("stabilizers prevail"), disruptive forces ("cuts"), or mixed patterns ("mixed") dominate each day.\n\n`;
            md += `For correlation with health metrics, focus on SFD patterns and Balance Channel trends.\n\n`;

            return md;
        }

        function buildSeismographMarkdownSection(data) {
            if (!data) return 'No seismograph data available.';

            let md = '## Seismograph Trace (Auto-Append)\n\n';
            md += '> **Protocol**: Seismograph always rides on the Mirror skeleton for falsifiability. Without geometry + hooks, the trace cannot be falsified.\n\n';

            // Process each dataset that has transit data
            const datasets = [];
            
            if (data.person_a?.chart?.transitsByDate) {
                datasets.push({ title: `${data.person_a.details?.name || 'Person A'} Transits`, data: data.person_a.chart.transitsByDate });
            }
            if (data.person_b?.chart?.transitsByDate) {
                datasets.push({ title: `${data.person_b.details?.name || 'Person B'} Transits`, data: data.person_b.chart.transitsByDate });
            }
            if (data.synastry?.transitsByDate) {
                datasets.push({ title: 'Synastry Transits', data: data.synastry.transitsByDate });
            }
            if (data.composite?.transitsByDate) {
                datasets.push({ title: 'Composite Transits', data: data.composite.transitsByDate });
            }
            
            // Generate tables for each dataset
            datasets.forEach(({ title, data: transitData }) => {
                const dates = Object.keys(transitData).sort();
                if (dates.length === 0) return;
                
                md += `### ${title}\n\n`;
                md += '| Date | Triple Channel | Top Hooks |\n';
                md += '|------|-----------------|----------|\n';
                
                dates.forEach(date => {
                    const day = normalizeEntry(transitData[date]);
                    if (!day) return;
                    
                    // Generate triple channel display
                    const channelLine = tripleChannelLine({ 
                        seismograph: day.seismograph, 
                        balance: day.balance, 
                        sfd: day.sfd 
                    });
                    
                    // Get top hooks for this day
                    const hooks = (day.hooks || []).slice(0, 2);
                    const topHooks = hooks.map(h => {
                        const orb = Math.abs(h._orb || h.orb || 0).toFixed(1);
                        return `${h.p1_name} ${h._aspect || h.aspect} ${h.p2_name} (${orb}°)`;
                    }).join(', ') || '—';
                    
                    md += `| ${date} | ${channelLine.replace(/\|/g, '\\|')} | ${topHooks.replace(/\|/g, '\\|')} |\n`;
                });
                
                md += '\n';
            });
            
            if (datasets.length === 0) {
                md += 'No transit hooks detected for this time window.\n\n';
            } else {
                md += '**Triple Channel Notes**: ⚡ = magnitude (0–5), Val = net seismograph valence (−5…+5), Bal = balance channel valence (−5…+5), SFD = Support–Friction Differential with verdict\n\n';
            }
            
            return md;
        }

        function generateMarkdownReport(data, options = {}) {
            // MATH BRAIN COMPLIANCE (PROTOCOL LAYER 1: GEOMETRY ONLY):
            // - Output pure astrological geometry with provenance tracking
            // - Include RAVEN_NUDGE for downstream Poetic Brain (Raven Calder) processing
            // - Layer separation: GEOMETRY ONLY → Clear Mirror → Poetic Codex
            // - NO narrative, interpretation, or advice generation here
            // - Protocol compliance: mirror_ready flags, rejections taxonomy, scaling confidence
            
            const {
                includeExecutiveSummary = false,
                includeJsonAppendix = false,
                includeProvenance = false
            } = options;
            
            const formData = collectFormData();
            const currentDate = new Date().toISOString().split('T')[0];
            // Prefer authoritative server-returned details if present (may include normalization/zodiac defaults)
            const personA = (data.person_a && data.person_a.details) ? data.person_a.details : formData.personA;
            const personB = (data.person_b && data.person_b.details) ? data.person_b.details : formData.personB;
            const mode = formData.context.mode;
            const isSky = mode === 'sky_transits';
            
            let md = '';
            
            // Executive Summary (optional, at top)
            if (includeExecutiveSummary) {
                md += generateExecutiveSummary(data, { includeHealthLine: true, includeProvenance: true });
                md += '\n\n---\n\n';
            }
            
            // Protocol Layer Headers
            md += `# Woven Map System Report\n\n`;
            md += `## Protocol Layer 1: Geometry Only\n\n`;
            md += `**Generated**: ${currentDate}\n`;
            md += `**Context Mode**: ${mode.replace(/_/g, ' ').toUpperCase()}\n`;
            md += `**Schema**: ${data.schema || 'WM-Chart-1.0'}\n`;
            md += `**Math Brain Version**: ${(data.provenance?.math_brain_version)||'0.x'}\n`;
            md += `**Ephemeris Source**: ${data.provenance?.ephemeris_source || 'AstrologerAPI-v4'}\n`;
            md += `**Mirror Status**: ${data.mirror_ready ? 'Ready for downstream processing' : 'Incomplete'}\n`;
            md += `**Contract**: ${data.contract || 'clear-mirror/1.2'}\n\n`;
            
            // Critical Protocol Reminder
            md += `> **Math Brain Role**: Symbolic scaffolding engine providing pure geometry.\n`;
            md += `> **Boundary**: No narrative, prediction, or interpretation. Mirror, not mandate.\n`;
            md += `> **Next Layer**: Clear Mirror translation via Poetic Brain (Raven Calder).\n\n`;
            
            // RAVEN_NUDGE Section (Protocol Requirement)
            md += `### RAVEN_NUDGE (Downstream Processing Guidance)\n\n`;
            md += `**Protocol Flow**: FIELD → MAP → VOICE translation required\n`;
            md += `**Sources Required**: Poetic Codex • FIELD_MAP_VOICE rules • Hook Stack • Seismograph Protocol\n`;
            md += `**Geometry Flags**: `;
            
            // Add specific flags based on data analysis
            const geometryFlags = [];
            let nodeTypes = new Set();
            let retrogradeCount = 0;
            let scaleConfidenceIssues = false;
            let hasDispersedInfluence = false;
            
            // Analyze the data for specific flags
            if (data.person_a?.chart?.transitsByDate) {
                const firstDay = Object.values(data.person_a.chart.transitsByDate)[0];
                if (firstDay?.retrograde_aspects?.length >= 2) {
                    geometryFlags.push('retrograde recursion');
                    retrogradeCount = firstDay.retrograde_aspects.length;
                }
                if (firstDay?.seismograph?.scaleConfidence < 0.7) {
                    geometryFlags.push('low scale confidence');
                    scaleConfidenceIssues = true;
                }
                if (firstDay?.hooks?.length === 0) {
                    geometryFlags.push('dispersed influence');
                    hasDispersedInfluence = true;
                }
                
                // Check for node types in hooks and aspects
                const allAspects = [...(firstDay.hooks || []), ...(firstDay.filtered_aspects || [])];
                allAspects.forEach(a => {
                    if (a.p1_name?.includes('True_Node') || a.p2_name?.includes('True_Node')) nodeTypes.add('True Node');
                    if (a.p1_name?.includes('Mean_Node') || a.p2_name?.includes('Mean_Node')) nodeTypes.add('Mean Node');
                });
            }
            
            // Check synastry/composite for additional patterns
            if (data.synastry?.aspects) {
                const tightAspects = data.synastry.aspects.filter(a => Math.abs(a.orbit) <= 1);
                if (tightAspects.length >= 2) geometryFlags.push('echo loop formation');
            }
            
            md += geometryFlags.length ? geometryFlags.join(' • ') : 'standard geometry';
            md += `\n`;
            
            md += `**Node Distinction**: `;
            if (nodeTypes.size > 0) {
                md += Array.from(nodeTypes).join(' and ') + ' present';
                if (nodeTypes.has('True Node') && nodeTypes.has('Mean Node')) {
                    md += ' — prefer True Node precision for tight orbs';
                }
            } else {
                md += 'Standard node handling (True Node preferred)';
            }
            md += `\n`;
            
            if (!isSky && personA && personA.timezone) {
                md += `**Timezone Check**: Target America/Chicago (Central) — Current: ${personA.timezone} ${personA.timezone === 'America/Chicago' ? '✓' : '⚠ Normalize required'}\n`;
            } else if (isSky) {
                md += `**Timezone Baseline**: America/Chicago (Central) — used for day-bucketing hints\n`;
            }
            md += `**Falsifiability**: All outputs must pass "Does this land?" test\n`;
            md += `**Agency Reinforcement**: Every output must preserve client autonomy\n`;
            
            // Add specific processing alerts
            if (retrogradeCount >= 2 || scaleConfidenceIssues || hasDispersedInfluence || nodeTypes.size > 1) {
                md += `**Processing Alerts**:\n`;
                if (retrogradeCount >= 2) md += `- ${retrogradeCount} retrograde aspects detected → internal revision themes likely\n`;
                if (scaleConfidenceIssues) md += `- Scale confidence below threshold → caution framing advised\n`;
                if (hasDispersedInfluence) md += `- No tight hooks → background stability or dispersed pattern\n`;
                if (nodeTypes.size > 1) md += `- Multiple node types present → ensure precision consistency\n`;
            }
            md += `\n`;
            
            // === RAVEN CALDER POETIC BRAIN INSTRUCTIONS ===
            md += `### INSTRUCTIONS FOR RAVEN CALDER POETIC BRAIN\n\n`;
            
            if (isSky) {
                md += `**WEATHER READING PROTOCOL:**\n`;
                md += `- **Subject**: Planetary weather only (no natal anchoring)\n`;
                md += `- **Mirror Focus**: Macro currents (magnitude/valence/volatility), hooks sampled without houses/angles\n`;
                md += `- **Scope**: Symbolic climate; use personal charts separately if attribution is needed\n`;
            } else if (personB && formData.context.relationship_type) {
                // Two-person relational reading instructions
                md += `**RELATIONAL READING PROTOCOL:**\n`;
                md += `- **Subject Clarity**: Always identify who is who (${personA.name} vs ${personB.name})\n`;
                md += `- **Bidirectional Analysis**: Address dynamics from both perspectives\n`;
                md += `- **Relationship Status**: ${formData.context.is_ex_relationship ? 'LATENT (ex-relationship - no active exchange)' : 'ACTIVE (ongoing relationship)'}\n`;
                
                if (formData.context.contact_channel) {
                    md += `- **Contact Channel**: ${formData.context.contact_channel === 'live' ? 'LIVE (regular contact/interaction)' : 'LATENT (minimal/dormant contact)'}\n`;
                }
                
                md += `- **Intimacy Context**: ${formData.context.intimacy_tier || 'unspecified'}\n`;
                md += `- **Mirror Focus**: Relational dynamics, shared field currents, echo patterns\n`;
                
                if (data.synastry?.aspects?.length > 0) {
                    md += `- **Synastry Available**: ${data.synastry.aspects.length} aspects - analyze interaction patterns\n`;
                }
                if (data.composite?.chart) {
                    md += `- **Composite Available**: Merged entity dynamics present\n`;
                }
                
                md += `\n**Required Elements in Response:**\n`;
                md += `1. Individual seismograph interpretation for both ${personA.name} AND ${personB.name}\n`;
                md += `2. Relational field analysis (how their patterns interact)\n`;
                md += `3. Clear attribution: "For ${personA.name}..." vs "For ${personB.name}..."\n`;
                md += `4. Bidirectional dynamics: How A affects B AND how B affects A\n`;
                
            } else if (personB) {
                // Two-person but no relationship context (comparison mode)
                md += `**COMPARATIVE READING PROTOCOL:**\n`;
                md += `- **Subject Clarity**: Always identify who is who (${personA.name} vs ${personB.name})\n`;
                md += `- **Individual Focus**: Analyze each person's geometry separately\n`;
                md += `- **No Relational Assumption**: Treat as independent charts unless synastry present\n`;
                md += `- **Mirror Focus**: Individual seismographs, separate hook stacks\n`;
                
            } else {
                // Single person reading instructions
                md += `**SOLO READING PROTOCOL:**\n`;
                md += `- **Subject**: ${personA.name} (single-person analysis)\n`;
                md += `- **Mirror Focus**: Individual seismograph, personal hook stack, internal currents\n`;
                md += `- **Temporal Context**: ${mode.includes('transit') ? 'Transits to natal geometry' : 'Natal geometry only'}\n`;
                
                if (mode.includes('transit') && formData.transitParams?.startDate) {
                    const daySpan = formData.transitParams.endDate ? 
                        Math.ceil((new Date(formData.transitParams.endDate) - new Date(formData.transitParams.startDate)) / (1000 * 60 * 60 * 24)) : 1;
                    
                    if (daySpan === 1) {
                        md += `- **Single Day Focus**: Deep-dive into specific day's current patterns\n`;
                        md += `- **Barometer Emphasis**: Detailed single-day barometric reading\n`;
                    } else {
                        md += `- **Time Range**: ${daySpan}-day span - analyze macro patterns and trends\n`;
                        md += `- **Seismograph Emphasis**: Pattern detection across time range\n`;
                    }
                }
            }
            
            md += `\n**Universal Requirements:**\n`;
            md += `- **Falsifiability**: Every statement must be testable against lived experience\n`;
            md += `- **Agency Preservation**: No deterministic claims - mirror, not mandate\n`;
            md += `- **Geometry First**: Build from math brain data, add poetic voice layer\n`;
            md += `- **Landing Test**: Does this resonate with actual lived experience?\n`;
            
            if (geometryFlags.includes('low scale confidence') || scaleConfidenceIssues) {
                md += `- **Caution Flag**: Scale confidence issues detected - frame interpretations tentatively\n`;
            }
            
            if (hasDispersedInfluence) {
                md += `- **Pattern Note**: No tight hooks detected - background stability or dispersed influence\n`;
            }
            
            md += `\n---\n\n`;
            
            // Range and Context
            if (formData.transitParams?.startDate && formData.transitParams?.endDate) {
                const stepMap = { '1d':'Daily', 'daily':'Daily', '7d':'Weekly', 'weekly':'Weekly', '1m':'Monthly', '1mo':'Monthly', 'monthly':'Monthly' };
                const rawStep = formData.transitParams.step || 'daily';
                const stepHuman = stepMap[rawStep] || rawStep;
                const startDate = new Date(formData.transitParams.startDate);
                const endDate = new Date(formData.transitParams.endDate);
                const daySpan = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                
                md += `**Temporal Scope**: ${formData.transitParams.startDate} → ${formData.transitParams.endDate}\n`;
                md += `**Step Resolution**: ${stepHuman} (${daySpan} day span)\n`;
                const stepKey = (rawStep === '7d' || rawStep === 'weekly') ? 'weekly' : ((rawStep === '1m' || rawStep === '1mo' || rawStep === 'monthly') ? 'monthly' : 'daily');
                const limit = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]?.max) || 45;
                md += `**Protocol Check**: ${daySpan <= limit ? '✓ Within safety limit' : '⚠ Exceeds recommended span'}\n\n`;
            }

            if (!isSky && personA) {
                // Subject Details (FIELD Layer)
                md += `## Subject Details — Reveal the Weave\n\n`;
                md += `### Primary Subject: ${personA.name}\n\n`;
                md += `- **Birth Date**: ${personA.year}-${String(personA.month).padStart(2, '0')}-${String(personA.day).padStart(2, '0')}\n`;
                md += `- **Birth Time**: ${String(personA.hour).padStart(2, '0')}:${String(personA.minute).padStart(2, '0')}\n`;
                md += `- **Location**: ${personA.city}, ${personA.nation}\n`;
                md += `- **Coordinates**: ${personA.latitude}, ${personA.longitude}\n`;
                md += `- **Timezone**: ${personA.timezone}\n`;
                md += `- **Zodiac Type**: ${personA.zodiac_type}\n\n`;
                md += `**TZ Check (Person A)**: expected \`America/Chicago\` (Central).\n`;
                md += `**Observed**: \`${personA.timezone}\` → ${personA.timezone === 'America/Chicago' ? 'OK' : '⚠ Normalize before mirroring'}\n\n`;
            }

            // Secondary Subject Details (if present)
                        if (personB) {
                md += `### Secondary Subject: ${personB.name}\n\n`;
                md += `- **Birth Date**: ${personB.year}-${String(personB.month).padStart(2, '0')}-${String(personB.day).padStart(2, '0')}\n`;
                md += `- **Birth Time**: ${String(personB.hour).padStart(2, '0')}:${String(personB.minute).padStart(2, '0')}\n`;
                md += `- **Location**: ${personB.city}, ${personB.nation}\n`;
                md += `- **Coordinates**: ${personB.latitude}, ${personB.longitude}\n`;
                md += `- **Timezone**: ${personB.timezone}\n`;
                md += `- **Zodiac Type**: ${personB.zodiac_type}\n\n`;

                                const relRole = formData.context.relationship_role;
                                const relNotes = formData.context.relationship_notes;
                                if (relRole || relNotes) {
                                    md += `- **Relationship Role**: ${relRole || 'unspecified'}${relNotes? ` — ${relNotes}`:''}\n\n`;
                                }

                // Relationship Context (if present)
                if (formData.context.relationship_type) {
                    md += `## Relationship Context\n\n`;
                    md += `- **Type**: ${formData.context.relationship_type}`;
                    if (formData.context.is_ex_relationship) {
                        md += ` (ex - no longer active)`;
                    }
                    md += `\n`;
                    if (formData.context.intimacy_tier) {
                        md += `- **Intimacy Tier**: ${formData.context.intimacy_tier}\n`;
                    }
                    if (formData.context.contact_channel) {
                        md += `- **Contact Channel**: ${formData.context.contact_channel === 'live' ? '🟢 Live (active exchange)' : '⚫ Latent (dormant channel)'}\n`;
                    }
                    md += `\n`;
                }
            }

            // Relocation (if present)
            if (data.relocation_a && data.relocation_a.status === 'OK') {
                md += `## Relocation Overlay\n\n`;
                md += `- **Location**: ${formData.relocation?.city || 'Unknown'}\n`;
                md += `- **Coordinates**: ${formData.relocation?.latitude}, ${formData.relocation?.longitude}\n`;
                
                if (data.relocation_b && data.relocation_b.status === 'OK') {
                    md += `- **Scope**: Both Person A and Person B relocated\n`;
                } else if (formData.relocation?.excludePersonB) {
                    md += `- **Scope**: Only Person A relocated (Person B excluded)\n`;
                } else {
                    md += `- **Scope**: Person A relocated\n`;
                }
                md += `\n`;
            }

            // Unified Geometry Skeleton (always present in Mirror output)
            md += `## Geometry — The Skeleton of the Land <a id="geometry-skeleton"></a>\n\n`;
            if (data.person_a?.chart && (data.person_a.chart.status === 'OK' || data.person_a.chart.sun)) {
                md += `### ${personA.name} Natal Angles & Planet Positions\n\n`;
                const chartA = data.person_a.chart.data || data.person_a.chart;
                md += renderNatalChartData(chartA, personA.name);
            }
            if (data.person_b?.chart && (data.person_b.chart.status === 'OK' || data.person_b.chart.sun)) {
                md += `### ${personB.name} Natal Angles & Planet Positions\n\n`;
                const chartB = data.person_b.chart.data || data.person_b.chart;
                md += renderNatalChartData(chartB, personB.name);
            }

            // Relocation Chart Summaries (if present)
            if (data.relocation_a?.status === 'OK') {
                md += `## ${personA.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_a.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            if (data.relocation_b?.status === 'OK') {
                md += `## ${personB.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_b.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Composite Chart Summary (if present)
            if (data.composite?.chart?.status === 'OK') {
                md += `## Composite Chart Summary\n\n`;
                const chart = data.composite.chart.data.subject;
                md += `- **Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Aspects Summary
            if (data.person_a?.chart?.aspects && data.person_a.chart.aspects.length > 0) {
                md += `## Person A Major Aspects\n\n`;
                data.person_a.chart.aspects.slice(0, 10).forEach(aspect => {
                    // Dual-read for orb field
                    const orb = (Number.isFinite(aspect.orb) ? aspect.orb :
                                 Number.isFinite(aspect.orbit) ? aspect.orbit :
                                 Number.isFinite(aspect.diff) ? aspect.diff : null);
                    const p1 = aspect.p1_name || aspect.planet_a || aspect.transit_body || '—';
                    const p2 = aspect.p2_name || aspect.planet_b || aspect.natal_target || '—';
                    const asp = aspect.aspect || aspect.aspect_name || aspect.name || '—';
                    md += `- **${p1}** ${asp} **${p2}** (${orb !== null ? orb.toFixed(1) : '—'}° orb)\n`;
                });
                md += `\n`;
            }

            if (data.synastry?.aspects && data.synastry.aspects.length > 0) {
                md += `## Relational Echo Field Analysis\n\n`;
                md += `### Bidirectional Aspect Inventory\n\n`;
                md += `> **Protocol**: Each aspect rendered from both A→B and B→A perspectives for narrative reflection generation\n`;
                md += `> **Echo Loop Detection**: Aspects within ±3° orb creating self-reinforcing dynamics\n`;
                md += `> **Attribution Rule**: PersonA vs PersonB explicit — no generic "they" or "both" until confirmed\n\n`;
                
                // Group aspects by orb ranges for Echo Loop analysis
                const tight = data.synastry.aspects.filter(a => Math.abs(a.orbit) <= 1);
                const echoRange = data.synastry.aspects.filter(a => Math.abs(a.orbit) > 1 && Math.abs(a.orbit) <= 3);
                const background = data.synastry.aspects.filter(a => Math.abs(a.orbit) > 3 && Math.abs(a.orbit) <= 6);
                
                if (tight.length > 0) {
                    md += `**Echo Loops (≤1° orb) — ${tight.length} aspects:**\n\n`;
                    tight.forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        const aspectCode = `EL-${String(index + 1).padStart(2, '0')}`;
                        md += `- **${aspectCode}**: ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                        md += `  - **Direction**: ${aspect.p1_name} (${initiator}) → ${aspect.p2_name} (${receiver})\n`;
                        md += `  - **Reciprocal**: ${aspect.p2_name} (${receiver}) ← ${aspect.p1_name} (${initiator})\n`;
                    });
                    md += `\n`;
                }
                
                if (echoRange.length > 0) {
                    md += `**Relational Echo Field (1-3° orb) — ${echoRange.length} aspects:**\n\n`;
                    echoRange.forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        const aspectCode = `REF-${String(index + 1).padStart(2, '0')}`;
                        md += `- **${aspectCode}**: ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                    });
                    md += `\n`;
                }
                
                if (background.length > 0) {
                    md += `**Background Geometry (3-6° orb) — ${background.length} aspects:**\n\n`;
                    background.slice(0, 10).forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        md += `- ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                    });
                    if (background.length > 10) md += `... (${background.length - 10} additional background aspects)\n`;
                    md += `\n`;
                }
                
                // REF Detection and Polarity Code Assignment
                if (tight.length >= 2 || (tight.length >= 1 && echoRange.length >= 1)) {
                    md += `**REF Macro Structure Detection**:\n`;
                    md += `- **Echo Loop Count**: ${tight.length}\n`;
                    md += `- **Echo Field Count**: ${echoRange.length}\n`;
                    md += `- **Convergence Threshold**: ${tight.length >= 2 ? 'Met' : 'Partial'}\n`;
                    
                    // Generate provisional polarity codes based on aspect types
                    const aspectTypes = [...tight, ...echoRange.slice(0, 2)].map(a => a.aspect.toLowerCase());
                    const hasHard = aspectTypes.some(a => ['square', 'opposition'].includes(a));
                    const hasSoft = aspectTypes.some(a => ['trine', 'sextile'].includes(a));
                    const hasConjunction = aspectTypes.some(a => a === 'conjunction');
                    
                    let polarityHint = '';
                    if (hasHard && hasConjunction) polarityHint = 'F21 (Frictional Attraction)';
                    else if (hasHard && hasSoft) polarityHint = 'M15 (Mixed Tension)';
                    else if (hasConjunction && hasSoft) polarityHint = 'H12 (Harmonic Blend)';
                    else if (hasHard) polarityHint = 'C18 (Challenge Dynamic)';
                    else if (hasSoft) polarityHint = 'E09 (Ease Flow)';
                    else polarityHint = 'TBD (Complex Pattern)';
                    
                    md += `- **Provisional Polarity Code**: ${polarityHint} — requires MAP layer confirmation\n`;
                    md += `- **Attribution**: ${personA.name} ↔ ${personB.name} (bidirectional analysis required)\n\n`;
                }
            }

            // Composite Field Dynamics (if present)
            if (data.composite?.chart?.aspects && data.composite.chart.aspects.length > 0) {
                md += `## Composite Field Dynamics — Shared Structural Patterns\n\n`;
                md += `### Composite Chart Aspects\n\n`;
                md += `> **Protocol**: Composite represents shared field dynamics, not individual attribution\n\n`;
                data.composite.chart.aspects.slice(0, 15).forEach(aspect => {
                    md += `- **${aspect.p1_name}** ${aspect.aspect} **${aspect.p2_name}** (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                });
                md += `\n`;
            }

            // Protocol Compliance Reminder
            md += `## Protocol Compliance Check\n\n`;
            md += `> **Geometry Layer Complete**: Calculations and aspect patterns documented\n`;
            md += `> **Boundary Maintained**: No narrative, prediction, or interpretation included\n`;
            md += `> **Next Required**: Clear Mirror translation via Poetic Brain (Raven Calder)\n`;
            md += `> **Contract**: mirror-ready geometry with appropriate nudges provided\n\n`;

            // Transit Analysis (if mode includes transits and is not natal_only)
            if (mode.includes('_transits') && mode !== 'natal_only') {
                const transitStartDate = formData.transitParams?.startDate;
                const transitEndDate = formData.transitParams?.endDate;
                
                console.log('=== MARKDOWN TRANSIT DEBUG ===');
                console.log('Transit mode detected in markdown generation:', mode);
                console.log('Transit dates from form:', transitStartDate, 'to', transitEndDate);
                console.log('Data object keys:', Object.keys(data));
                console.log('Person A has transitsByDate?', !!data.person_a?.chart?.transitsByDate);
                console.log('Person B has transitsByDate?', !!data.person_b?.chart?.transitsByDate);
                
                if (data.person_a?.chart?.transitsByDate) {
                    console.log('Person A transit dates available:', Object.keys(data.person_a.chart.transitsByDate));
                }
                if (data.person_b?.chart?.transitsByDate) {
                    console.log('Person B transit dates available:', Object.keys(data.person_b.chart.transitsByDate));
                }
                
                md += `## Protocol Layer 2: Live Activations — Trace the Threads\n\n`;
                md += `**Temporal Scope**: ${transitStartDate} to ${transitEndDate}\n`;
                md += `**Purpose**: Identify active tugging patterns and symbolic weather overlays\n`;
                md += `**Processing**: Seismograph aggregation with magnitude, valence, volatility metrics\n\n`;

                                // --- New Unified Hook / Seismograph Renderer ---
                                const ui = window.WOVEN_UI_FILTERS || { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };
                
                                const NAME_MAP = { Medium_Coeli:'Midheaven (MC)', MC:'Midheaven (MC)', Mean_Node:'North Node', Mean_South_Node:'South Node', Mean_Lilith:'Lilith' };
                                const labelName = n => NAME_MAP[n] || n;
                                const aspectGlyph = a => ({conjunction:'☌', opposition:'☍', square:'□', trine:'△', sextile:'✧'})[a] || a;
                                                function hookLine(h){
                                                    let orbVal = h._orb??h.orb; 
                                                    const sign = (typeof orbVal==='number' && orbVal<0)? -1:1;
                                                    const absOrb = (typeof orbVal==='number')? Math.abs(orbVal): orbVal;
                                                    const exact = (typeof absOrb==='number' && absOrb<=0.2) ? '★ ' : '';
                                                    // Phase arrow: if approaching flag supplied else derive from sign (negative = separating) fallback
                                                    let phaseArrow = '';
                                                    if (h.approaching === true) phaseArrow = '↑'; else if (h.approaching === false) phaseArrow = '↓'; else phaseArrow = (sign>0? '↑':'↓');
                                                    return `${exact}${labelName(h.p1_display||h.p1_name)} ${aspectGlyph(h._aspect||h.aspect)} ${labelName(h.p2_display||h.p2_name)} — ${(absOrb)?.toFixed ? absOrb.toFixed(1): '—'}° ${phaseArrow}`.trim();
                                                }
                                function classifyClient(a){
                                    const cls = a._class || a.class || ''; // major, minor, harmonic
                                    if (cls==='major') return 'Major';
                                    if (cls==='minor') return 'Minor';
                                    if (cls==='harmonic') return 'Harmonic';
                                    return 'Other';
                                }
                                function passClientFilters(a){
                                    const orb = a._orb ?? a.orb;
                                    const tight = typeof orb==='number' && orb<=2;
                                    const cls = a._class;
                                    const isMinor = cls==='minor';
                                    const isHarm = cls==='harmonic';
                                    const isSelf = a.p1_name===a.p2_name;
                                    if (ui.tightOnly && !tight) return false;
                                    if (!ui.showMinor && isMinor) return false;
                                    if (!ui.showHarmonic && isHarm) return false;
                                    if (!ui.showSelf && isSelf) return false;
                                    return true;
                                }
                                                function deriveCounts(filteredList){
                                                    const counts = { majors_tight:0, majors_loose:0, minors:0, harmonics:0, self_aspects:0 };
                                                    filteredList.forEach(a=>{
                                                        const orb = a._orb??a.orb??99;
                                                        const isSelf = a.p1_name===a.p2_name;
                                                        if (isSelf) counts.self_aspects++;
                                                        if (a._class==='major') { if (orb<=2) counts.majors_tight++; else counts.majors_loose++; }
                                                        else if (a._class==='minor') counts.minors++; else if (a._class==='harmonic') counts.harmonics++;
                                                    });
                                                    return counts;
                                                }
                                                // Hook pruning utilities
                                                function pruneHooks(list){
                                                    if(!Array.isArray(list)) return [];
                                                    const ORB_CAPS = { luminary:6, planet:4, point:3 }; // tightened hook layer caps
                                                    function bodyClass(n){
                                                        const name = (n||'').toLowerCase();
                                                        if (['sun','moon'].includes(name)) return 'luminary';
                                                        if (['ascendant','midheaven','mc','ic','north node','south node','node','lilith','chiron'].includes(name)) return 'point';
                                                        return 'planet';
                                                    }
                                                    // Filter by orb caps
                                                    const capped = list.filter(a=>{
                                                        const orb = Math.abs(a._orb??a.orb??99);
                                                        const aClass = bodyClass(a.p1_name);
                                                        const bClass = bodyClass(a.p2_name);
                                                        const cap = Math.min( ORB_CAPS[aClass]||5, ORB_CAPS[bClass]||5 );
                                                        return orb <= cap;
                                                    });
                                                    // Diversity: limit max 2 entries per symbolic point (Node/Lilith/Chiron) and 2 per identical pair signature
                                                    const pointNames = new Set(['north node','south node','node','lilith','chiron']);
                                                    const pointCounts = {}; const pairCounts = {};
                                                    const diversified = [];
                                                    for (const h of capped.sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; return (Math.abs(a._orb??a.orb??99)) - (Math.abs(b._orb??b.orb??99)); })) {
                                                        const aName=(h.p1_name||'').toLowerCase();
                                                        const bName=(h.p2_name||'').toLowerCase();
                                                        const pairKey = [aName,bName].sort().join('_');
                                                        const involvesPoint = pointNames.has(aName)||pointNames.has(bName);
                                                        if (involvesPoint){
                                                            pointCounts[aName] = pointCounts[aName]||0;
                                                            pointCounts[bName] = pointCounts[bName]||0;
                                                        }
                                                        pairCounts[pairKey] = pairCounts[pairKey]||0;
                                                        if (involvesPoint){
                                                            const totalPointHits = (pointCounts[aName]||0)+(pointCounts[bName]||0);
                                                            if (totalPointHits >=4) continue; // roughly 2 each combined ceiling
                                                        }
                                                        if (pairCounts[pairKey] >=2) continue;
                                                        // accept
                                                        diversified.push(h);
                                                        if (pointNames.has(aName)) pointCounts[aName]++;
                                                        if (pointNames.has(bName)) pointCounts[bName]++;
                                                        pairCounts[pairKey]++;
                                                        if (diversified.length>=8) break; // cap hooks shown
                                                    }
                                                    return diversified;
                                                }
                                                function buildDaySection(date, day){
                                                    if(!day) return '';
                                                    // Hooks sort tie-break by smaller orb
                                                    const rawHooksSorted = (day.hooks?.slice()||[]).sort((a,b)=>{
                                                        const wDiff = (b._weight||0) - (a._weight||0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        const oa = Math.abs(a._orb??a.orb??99); const ob = Math.abs(b._orb??b.orb??99); return oa - ob;
                                                    });
                                                    const hooks = pruneHooks(rawHooksSorted);
                                                    const filteredAll = (day.filtered_aspects||[]).filter(passClientFilters);
                                                    const counts = deriveCounts(filteredAll);
                                                    // Invariant check (debug only)
                                                    if ((counts.majors_tight + counts.majors_loose + counts.minors + counts.harmonics + counts.self_aspects) !== filteredAll.length){
                                                        console.warn('Count invariant mismatch', date, counts, filteredAll.length);
                                                    }
                                                    let summaryLine = `${date} — Majors: ${counts.majors_tight + counts.majors_loose} (tight ${counts.majors_tight}, loose ${counts.majors_loose}) · Minors: ${counts.minors} · Harmonics: ${counts.harmonics}`;
                                                    let out = `<details><summary>${summaryLine}</summary>\n\n`;
                                                    const suppressed = rawHooksSorted.length - hooks.length;
                                                    out += `**Hooks** (orb caps applied; diversity filtered${suppressed>0?`, ${suppressed} suppressed`:''})\n`;
                                                    hooks.forEach(h=> out += `- ${hookLine(h)}\n`);
                                                    if (suppressed>0){
                                                        // Provide extended weighted influences list (may exceed caps)
                                                        out += `\n**Top Weighted Influences (may exceed caps)**\n`;
                                                        rawHooksSorted.slice(0,8).forEach(h=>{ if(!hooks.includes(h)) out += `- ${hookLine(h)}\n`; });
                                                    }
                                                    if (!hooks.length) out += `- —\n`;
                                                    out += `\n**Filtered aspects (${filteredAll.length})**  *Loose majors (>6°) omitted from hooks*\n`;
                                                    filteredAll.forEach(a=>{
                                                        const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                        out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt}) — ${classifyClient(a)}\n`;
                                                    });
                                                    if (Array.isArray(day.aspects) && day.aspects.length){
                                                        out += `\n<details><summary>Full list (raw ${day.aspects.length})</summary>\n\n`;
                                                        day.aspects.slice(0,40).forEach(a=>{
                                                            const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                            out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt})\n`;
                                                        });
                                                        if (day.aspects.length>40) out += `... (${day.aspects.length-40} more)\n`;
                                                        out += `</details>\n`;
                                                    }
                                                    out += `\n</details>\n\n`;
                                                    return out;
                                                }

                                                // REMOVED: FIELD/MAP/VOICE Translation Bridge
                                                // Math Brain Compliance: This function violated protocol by generating interpretive content.
                                                // FIELD → MAP → VOICE translation is exclusively handled by downstream Poetic Brain (Raven Calder).
                                                // Math Brain outputs geometry only with appropriate nudges for downstream processing.
                                                
                                                // Enhanced buildSummaryTable with three-tier protocol structure
                                                function buildEnhancedSummaryTable(title, dailyMap) {
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    
                                                    // Determine context layer based on title content for proper mythic metaphors
                                                    let contextLayer = 'Trace the Threads'; // Default for transits
                                                    if (title.toLowerCase().includes('composite')) {
                                                        contextLayer = 'Currents + Seismograph';
                                                    }
                                                    
                                                    let out = `## ${title} — ${contextLayer}\n\n`;
                                                    out += `> **Math Brain Protocol**: Geometry Only • Mirror-ready for downstream Poetic Brain (Raven Calder)\n`;
                                                    out += `> **Layer**: Symbolic scaffolding for MAP → VOICE translation\n\n`;
                                                    
                                                    dates.forEach(d => {
                                                        const day = dailyMap[d];
                                                        const mag = (day.seismograph?.magnitude || 0).toFixed(2);
                                                        const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(2);
                                                        const vol = (day.seismograph?.volatility || 0).toFixed(2);
                                                        const trend = day.valence_trend || 0;
                                                        const trendArrow = trend > 0.5 ? ' ↗' : trend < -0.5 ? ' ↘' : '';
                                                        const scaleConf = day.seismograph?.scaleConfidence?.toFixed(3) || '—';
                                                        
                                                        // 1. Seismograph Readout (pure geometry)
                                                        out += `### ${d} — Seismograph Readout\n`;
                                                        out += `**Magnitude:** ${mag} • **Valence:** ${val}${trendArrow} • **Volatility:** ${vol} • **Scale Confidence:** ${scaleConf}\n\n`;
                                                        
                                                        // 2. Top Hooks (geometry with retrograde flags)
                                                        const filteredHooks = applyStrictOrbCaps(day.hooks || []);
                                                        const topHooks = filteredHooks.slice(0, 5);
                                                        
                                                        out += `**Geometry Hooks** _(orb caps applied)_:\n`;
                                                        if (topHooks.length === 0) {
                                                            out += `- No hooks within protocol orb caps\n`;
                                                        } else {
                                                            topHooks.forEach(h => {
                                                                const retroSymbol = (h.p1_retrograde ? '℞' : '') + (h.p2_retrograde ? '℞' : '');
                                                                const weightFlag = h._weight >= 0.8 ? ' ●' : h._weight >= 0.5 ? ' ◐' : '';
                                                                out += `- ${hookLine(h)}${retroSymbol ? ' ' + retroSymbol : ''}${weightFlag}\n`;
                                                            });
                                                        }
                                                        
                                                        // 3. Retrograde Recursion Band (if ≥2 retrograde aspects per protocol)
                                                        const retrogradeAspects = day.retrograde_aspects || [];
                                                        if (retrogradeAspects.length >= 2) {
                                                            out += `\n**Retrograde Recursion Pattern** _(${retrogradeAspects.length} aspects)_:\n`;
                                                            retrogradeAspects.slice(0, 4).forEach(a => {
                                                                const orb = Math.abs(a._orb || a.orb || 0).toFixed(1);
                                                                const body1 = (a.p1_retrograde ? '℞' : '') + labelName(a.p1_name);
                                                                const body2 = (a.p2_retrograde ? '℞' : '') + labelName(a.p2_name);
                                                                out += `- ${body1} ${aspectGlyph(a._aspect)} ${body2} (${orb}°)\n`;
                                                            });
                                                            if (retrogradeAspects.length > 4) out += `- ... (${retrogradeAspects.length - 4} more)\n`;
                                                        }
                                                        
                                                        // 4. Protocol Nudges for Downstream Processing
                                                            const includePoetic = (typeof document !== 'undefined' && document.getElementById('poeticFlagsToggle')?.checked);
                                                            if (includePoetic) {
                                                                const realMag = parseFloat(mag);
                                                                const realVal = parseFloat(val);
                                                                out += `\n**Poetic Prep Flags (optional; interpretive – not geometry):**\n`;
                                                                if (realMag >= 6 && parseFloat(vol) >= 3) {
                                                                    out += `- Current cluster: high magnitude + volatility (mirror before narrative)\n`;
                                                                }
                                                                if (Math.abs(realVal) >= 3) {
                                                                    out += `- Valence extreme (${val}) – directional tension needs framing\n`;
                                                                }
                                                                if (retrogradeAspects.length >= 2) {
                                                                    out += `- Retrograde recursion band (${retrogradeAspects.length}) – internal revision motif\n`;
                                                                }
                                                                if (scaleConf !== '—' && parseFloat(scaleConf) < 0.7) {
                                                                    out += `- Low scale confidence (${scaleConf}) – treat as provisional signal\n`;
                                                                }
                                                                if (topHooks.length === 0) {
                                                                    out += `- Sparse hook density – diffuse / background state\n`;
                                                                }
                                                                if (realMag < 2 && Math.abs(realVal) < 0.5) {
                                                                    out += `- Low activation baseline – avoid over-interpretation\n`;
                                                                }
                                                            } else {
                                                                out += `\n<details><summary><em>Enable Poetic Prep Flags (interpretive layer)</em></summary>Activate the toggle in Seismograph filters to surface optional salience prompts. Math Brain keeps geometry neutral by default.</details>\n`;
                                                            }
                                                        
                                                        // 5. Raw Aspect Inventory with Rejection Taxonomy (collapsible)
                                                        const allAspects = day.filtered_aspects || [];
                                                        const rejections = day.rejections || [];
                                                        
                                                        if (allAspects.length > 0 || rejections.length > 0) {
                                                            out += `\n<details><summary>Aspect Processing Summary — ${allAspects.length} accepted, ${rejections.length} rejected</summary>\n\n`;
                                                            
                                                            if (allAspects.length > 0) {
                                                                out += `**Accepted Aspects (${allAspects.length}):**\n`;
                                                                allAspects.forEach(a => {
                                                                    const orb = Math.abs(a._orb || a.orb || 0).toFixed(1);
                                                                    const retroFlag = (a.p1_retrograde || a.p2_retrograde) ? ' ℞' : '';
                                                                    const classFlag = a._class ? ` [${a._class}]` : '';
                                                                    const weightFlag = a._weight ? ` w=${a._weight.toFixed(2)}` : '';
                                                                    out += `- ${labelName(a.p1_name)} ${aspectGlyph(a._aspect)} ${labelName(a.p2_name)} (${orb}°)${retroFlag}${classFlag}${weightFlag}\n`;
                                                                });
                                                            }
                                                            
                                                            if (rejections.length > 0) {
                                                                out += `\n**Rejection Taxonomy (${rejections.length}):**\n`;
                                                                const rejectionGroups = {};
                                                                rejections.forEach(r => {
                                                                    if (!rejectionGroups[r.reason]) rejectionGroups[r.reason] = [];
                                                                    rejectionGroups[r.reason].push(r);
                                                                });
                                                                
                                                                Object.entries(rejectionGroups).forEach(([reason, items]) => {
                                                                    out += `- **${reason}** (${items.length}): `;
                                                                    const samples = items.slice(0, 3).map(r => `${r.aspect} (${Math.abs(r.orb || 0).toFixed(1)}°)`);
                                                                    out += samples.join(', ');
                                                                    if (items.length > 3) out += `, +${items.length - 3} more`;
                                                                    out += `\n`;
                                                                });
                                                            }
                                                            
                                                            out += `\n</details>\n\n`;
                                                        }
                                                        
                                                        out += `---\n\n`;
                                                    });
                                                    
                                                    // Add scaling strategy summary
                                                    const sampleDay = Object.values(dailyMap)[0];
                                                    if (sampleDay?.seismograph?.scalingStrategy) {
                                                        out += `**Scaling Protocol**: ${sampleDay.seismograph.scalingStrategy}`;
                                                        if (sampleDay.seismograph.scaleConfidence !== undefined) {
                                                            const confidence = sampleDay.seismograph.scaleConfidence;
                                                            const n = Math.round(confidence * 14);
                                                            out += ` (${n}/14 day window, confidence=${confidence.toFixed(3)})`;
                                                        }
                                                        out += `\n\n`;
                                                    }
                                                    
                                                    return out;
                                                }
                                                
                                                // Apply strict orb caps for Top Hooks
                                                function applyStrictOrbCaps(hooks) {
                                                    const ORB_CAPS = { luminary: 6, planet: 4, point: 3 };
                                                    
                                                    function getBodyType(name) {
                                                        const n = (name || '').toLowerCase();
                                                        if (['sun', 'moon'].includes(n)) return 'luminary';
                                                        if (['ascendant', 'midheaven', 'mc', 'ic', 'north node', 'south node', 'lilith', 'chiron'].includes(n)) return 'point';
                                                        return 'planet';
                                                    }
                                                    
                                                    return hooks.filter(h => {
                                                        const orb = Math.abs(h._orb || h.orb || 99);
                                                        const type1 = getBodyType(h.p1_name);
                                                        const type2 = getBodyType(h.p2_name);
                                                        const cap = Math.min(ORB_CAPS[type1] || 5, ORB_CAPS[type2] || 5);
                                                        return orb <= cap;
                                                    }).sort((a, b) => {
                                                        // Sort by weight, then by orb tightness
                                                        const wDiff = (b._weight || 0) - (a._weight || 0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        return Math.abs(a._orb || a.orb || 99) - Math.abs(b._orb || b.orb || 99);
                                                    });
                                                }

                                                function buildSummaryTable(title, dailyMap){
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    const single = dates.length===1;
                                                    let out = `## ${title} — Seismograph ${single?'(Daily Range)':'(Range)'}\n\n| Date | Magnitude | Valence | Volatility | Top Hooks |\n|------|-----------:|--------:|-----------:|-----------|\n`;
                                                    dates.forEach(d=>{
                                                        const day = dailyMap[d];
                                                        // Limit to top 3 hooks by weight desc w/ tie-break
                                                        const hooks = (day.hooks||[]).slice().sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; const oa=a._orb??a.orb??99; const ob=b._orb??b.orb??99; return oa-ob; }).slice(0,3);
                                                        const peak = hooks.map(h=> hookLine(h)).join(', ');
                                                        const rawVal = (day.seismograph?.valence??0);
                                                        const clampedVal = Math.max(-5, Math.min(5, rawVal));
                                                        out += `| ${d} | ${(day.seismograph?.magnitude??0).toFixed(2)} | ${clampedVal.toFixed(2)} | ${(day.seismograph?.volatility??0).toFixed(2)} | ${peak.replace(/\|/g,'\\|') || '—'} |\n`;
                                                    });
                                                    out += `\nMagnitude=aggregate charge (0–10 est), Valence=net tension (−=friction, +=ease), Volatility=dispersion of charge.\n`;
                                                    out += `_Valence emoji: 🌑 (negative), 🌗 (neutral), 🌞 (positive). Examples → negative: 🌋/⚔️/♻️/↔️/🌫️/⏳/🧩/🕳️; positive: 🌱/⚖️/🌊/✨/🌈/🔥/🦋/💎._\n`;
                                                    
                                                    // Add confidence scaling information if available
                                                    const sampleDay = Object.values(dailyMap)[0];
                                                    if (sampleDay?.seismograph?.scaleConfidence !== undefined) {
                                                        const confidence = sampleDay.seismograph.scaleConfidence;
                                                        const n = Math.round(confidence * 14);
                                                        out += `Scaling: blended (n=${n}, confidence=${confidence})\n`;
                                                    }
                                                    
                                                    out += `\n`;
                                                    return out;
                                                }
                
                                md += `### Daily Seismograph Readouts\n\n`;
                                // Sky dataset (weather-only)
                                if (isSky && (data.sky?.transitsByDate || data.transitsByDate)) {
                                    const skyMap = data.sky?.transitsByDate || data.transitsByDate;
                                    md += buildEnhancedSummaryTable(`Planetary Weather`, skyMap);
                                }
                                if (data.person_a?.chart?.transitsByDate && personA?.name) md += buildEnhancedSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildEnhancedSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildEnhancedSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Legacy Table View\n`;
                                if (isSky && (data.sky?.transitsByDate || data.transitsByDate)) {
                                    const skyMap = data.sky?.transitsByDate || data.transitsByDate;
                                    md += buildSummaryTable(`Planetary Weather`, skyMap);
                                }
                                if (data.person_a?.chart?.transitsByDate && personA?.name) md += buildSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Daily Hooks\n\n_Orb shows absolute degrees. Phase: ↑ applying (tightening) · ↓ separating (widening). Hook layer caps: ≤6° luminaries, ≤4° planets, ≤3° points; broader orbs remain in Raw._\n`;
                                if (data.person_a?.chart?.transitsByDate){
                                    Object.keys(data.person_a.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_a.chart.transitsByDate[d]); });
                                }
                                if (data.person_b?.chart?.transitsByDate){
                                    Object.keys(data.person_b.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_b.chart.transitsByDate[d]); });
                                }
                                if (data.composite?.transitsByDate){
                                    Object.keys(data.composite.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.composite.transitsByDate[d]); });
                                }
                
                console.log('=== END MARKDOWN TRANSIT DEBUG ===');

                // Synastry Transits (transits to synastry aspects)
                if (mode.includes('synastry') && data.synastry?.transitsByDate) {
                    md += `### Synastry Transit Activations\n\n`;
                    const synastryTransits = data.synastry.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(synastryTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = synastryTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_owner ? `${transit.p2_owner} ${transit.p2_name}` : (transit.p2_name ?? "?");
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant synastry transit activations in the specified date range.\n\n`;
                    }
                }

                // Composite Transits (for composite modes)
                if (mode.includes('composite') && data.composite?.transitsByDate) {
                    md += `### Composite Chart Transits\n\n`;
                    const compositeTransits = data.composite.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(compositeTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = compositeTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_name ?? "?";
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant composite transits in the specified date range.\n\n`;
                    }
                }
            }

            // Footer: Protocol Compliance & Safety Requirements
            const isRavenConsumer = data.raven_consumer === 'RAVEN_CALDER_GPT';
            
            md += `## Safety & Hygiene Protocol\n\n`;
            
            // Agency Clause (Required by Protocol)
            md += `### Agency Reinforcement (Required)\n\n`;
            md += `**Agency Statement**: This geometric analysis provides symbolic weather patterns, not deterministic outcomes. `;
            md += `You remain the author of your choices and the validator of any resonance. `;
            md += `The map supports your agency—it never overrides it. If something doesn't land, it doesn't count.\n\n`;
            
            // Temporal and Rate Limits
            md += `### Protocol Limits\n\n`;
            const dMax = (window.WOVEN_STEP_LIMITS?.daily?.max)||45;
            const wMaxM = Math.round(((window.WOVEN_STEP_LIMITS?.weekly?.max)||270)/30);
            const mMaxM = Math.round(((window.WOVEN_STEP_LIMITS?.monthly?.max)||550)/30);
            md += `- **Max Date Span**: Daily up to ${dMax} days; Weekly up to ${wMaxM} months; Monthly up to ${mMaxM} months (current: ${formData.transitParams ? Math.ceil((new Date(formData.transitParams.endDate) - new Date(formData.transitParams.startDate)) / (1000 * 60 * 60 * 24)) : 'N/A'} days)\n`;
            md += `- **Rate Limits**: 50 transit requests per day per user\n`;
            md += `- **Narrative Hygiene**: No deterministic or fatalistic language permitted\n`;
            md += `- **Falsifiability**: All outputs subject to "Does this land?" validation\n\n`;
            
            // Glossary for non-Raven consumers
            if (!isRavenConsumer) {
                md += `## Symbolic Glossary (for Non-Raven GPT Consumers)\n\n`;
                md += `| Term | Definition |\n`;
                md += `|------|------------|\n`;
                md += `| **Weave** | Structural identity patterns revealed through natal geometry |\n`;
                md += `| **Threads** | Live activation patterns through transiting aspects |\n`;
                md += `| **Currents** | Macro field states from seismograph aggregation |\n`;
                md += `| **Seismograph** | Two-axis symbolic measurement: Magnitude (X), Valence (Y), Volatility Index |\n`;
                md += `| **Echo Loop** | Bidirectional aspect within ±3° orb creating reinforcing relational dynamic |\n`;
                md += `| **REF** | Relational Echo Field — macro structure from converging Echo Loops |\n`;
                md += `| **Hook** | Salient daily aspect for focused attention (strict orb caps applied) |\n`;
                md += `| **Recursion Band** | Retrograde aspect pattern indicating internal revision themes |\n\n`;
                
                md += `### System Role Clarity\n\n`;
                md += `- **Math Brain**: Finds coordinates, measures angles, provides geometric scaffolding\n`;
                md += `- **Poetic Brain (Raven Calder)**: Translates geometry into felt language and mirrors\n`;
                md += `- **User**: Validates resonance, maintains agency, decides what lands\n\n`;
            }
            
            // Raven Processing Checklist
            md += `### Raven Calder Processing Checklist\n\n`;
            md += `**Required Sources**: `;
            md += `☐ Poetic Codex • ☐ FIELD_MAP_VOICE rules • ☐ Hook Stack protocols • ☐ Seismograph guidelines\n\n`;
            md += `**Geometry Verification**: `;
            md += `☐ Retrograde flags applied • ☐ True/Mean Node distinctions noted • ☐ Coordinates normalized • ☐ Timezone validated\n\n`;
            md += `**Protocol Compliance**: `;
            md += `☐ Recognition-first approach • ☐ SST taxonomy respected • ☐ Falsifiability maintained • ☐ Agency preserved\n\n`;
            md += `**Output Standards**: `;
            md += `☐ Mirror not mandate • ☐ No prediction claims • ☐ Testable reflections • ☐ Clear boundary maintenance\n\n`;
            
            md += `---\n\n`;
            md += `*Generated by Woven Map Math Brain — Pure Geometric Scaffolding Engine*\n`;
            md += `*Contract: clear-mirror/1.2 • Protocol: FIELD → MAP → VOICE • Version: ${(data.provenance?.math_brain_version)||'0.x'}*`;

            // Optional: Append Health Correlation if health data is present and we have Person A transits
            try {
                if (typeof loadedHealthData === 'object' && loadedHealthData && data.person_a?.chart?.transitsByDate) {
                    const correlations = correlateHealthWithSeismograph(loadedHealthData, data.person_a.chart.transitsByDate);
                    if (correlations && correlations.length) {
                        md += `\n---\n\n`;
                        md += generateHealthCorrelationTable(correlations);
                    }
                }
            } catch (e) {
                console.warn('Health correlation append skipped:', e);
            }
            
            // Add Provenance & Processing Metadata section
            if (includeProvenance) {
                md += '\n\n' + generateProvenance(data, window.lastRunStats || {});
            }
            
            // Add JSON Appendix
            if (includeJsonAppendix) {
                const jsonAppendix = generateJsonAppendix(data, window.lastRunStats || {});
                md += '\n\n---\n\n## Machine-Readable Appendix (JSON)\n\n';
                md += '```json\n';
                md += JSON.stringify(jsonAppendix, null, 2);
                md += '\n```\n';
            }

            return md;
        }

        
        // SEISMOGRAPH FUNCTIONS
        // =============================================================================

    function buildSeismographDisplay(data) {
            if (!data) return '<p>No data available for seismograph analysis.</p>';
            
            // Store data globally for CSV export and filtering
            window.seismographData = data;
            window.seismographFilters = {
                minMagnitude: 0,
                minValence: -5,
                maxValence: 5,
                minVolatility: 0,
                showPatterns: true
            };
            
            let html = `
                <div class="space-y-6">
                    <!-- Fixed Control Header - Always visible and not scrollable -->
                    <div class="sticky top-0 z-10 bg-gray-800 p-4 rounded-lg border border-teal-500 shadow-lg">
                        <h3 class="text-lg font-semibold text-teal-300 mb-3">Seismograph Overview</h3>
                        ${loadedHealthData ? `<div class="bg-purple-900 p-2 rounded mb-3 text-sm">
                            <span class="text-purple-300">🏥 Health Data Loaded:</span> 
                            <span class="text-white">${Object.keys(loadedHealthData).length} metrics available for correlation analysis</span>
                        </div>` : `<div class="bg-gray-700 p-2 rounded mb-3 text-sm">
                            <span class="text-gray-300">💡 Tip:</span> 
                            <span class="text-white">Upload Health Auto Export JSON above for correlation analysis</span>
                        </div>`}
                        <!-- Control Buttons - Sticky and always visible -->
                        <div class="flex flex-wrap gap-2 mb-4" aria-label="Seismograph controls">
                            <button id="toggleSeismographView" aria-live="polite" class="px-3 py-1 bg-teal-600 text-white rounded text-sm hover:bg-teal-700" title="Cycle: Table → Arc → Barometer → Mobile">
                                🔄 View: Table
                            </button>
                            <button id="downloadAllSeismographCSV" class="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700" title="Download CSV per dataset">
                                📁 Download All CSV
                            </button>
                            <button id="toggleSeismographFilters" class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700" title="Show/Hide Filters">
                                🔍 Filters
                            </button>
                            <button id="queueSeismographAnalysis" class="px-3 py-1 bg-purple-600 text-white rounded text-sm hover:bg-purple-700" title="Queue pattern & cycle analysis (runs asynchronously)">
                                📦 Queue Analysis
                            </button>
                            <button id="toggleGlossary" class="px-3 py-1 bg-indigo-600 text-white rounded text-sm hover:bg-indigo-700" title="Open Seismograph Glossary">
                                📖 Glossary
                            </button>
                        </div>
                        <p class="text-sm text-gray-300 mb-3 leading-relaxed">
                            <strong>Macro (Seismograph Arc):</strong> Normalized activation curve (Magnitude scaled to 0–5) with valence drift path.<br>
                            <strong>Micro (Barometer):</strong> Daily bar pulses (Magnitude 0–5) with textual valence annotations (V:+/-x.x) and volatility shading.<br>
                            <strong>Scales:</strong> Magnitude 0–5 (normalized), Valence -5..+5 (annotation only), Volatility 0–5. Raw source magnitude (0–10) preserved in tables.
                        </p>
                        ${buildSeismographFilters()}
                        <div class="mt-4 text-xs text-gray-400 border-t border-gray-700 pt-3">
                            Normalization happens only in visual arc/barometer layers. Tables retain raw magnitude (0–10) for auditability.
                        </div>
                    </div>
                    
                    <!-- Scrollable Content Area -->
                    <div class="seismograph-content-area">`;
            
            // Pattern detection results
            html += '<div id="seismographPatterns"></div>';
            // Raven Voice panel container (hidden until analysis queued)
            html += '<div id="ravenVoicePanel" class="hidden mt-4 bg-gray-800 p-4 rounded border border-teal-600"><h4 class="text-teal-300 font-semibold mb-2">🗣️ Raven Voice</h4><div class="text-sm text-gray-200" id="ravenVoiceContent">Queue an analysis or hover (future) elements for contextual synthesis. FIELD → MAP remain primary; this is optional VOICE.</div></div>';
            // Global tooltip element (created once)
            if(!document.getElementById('globalHoverTooltip')){
                setTimeout(()=>{const t=document.createElement('div'); t.id='globalHoverTooltip'; t.className='pointer-events-none fixed z-50 px-2 py-1 rounded bg-gray-900/90 text-[11px] text-gray-100 border border-teal-500 shadow'; t.style.display='none'; document.body.appendChild(t);},0);
            }
            

            // Glossary Modal (fixed overlay - outside scrollable content)

            // View toggle container
            html += '<div id="seismographViewContainer">';
            
            // Glossary Modal - Expanded with Valence Maps

            html += `
                <div id="seismographGlossaryModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 p-4" aria-labelledby="glossary-title" role="dialog" aria-modal="true">
                    <div class="bg-gray-900 rounded-lg shadow-xl max-w-4xl w-full p-6 relative border border-indigo-500 overflow-y-auto max-h-[90vh]">
                        <button id="closeGlossary" class="absolute top-3 right-3 text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                        <h2 id="glossary-title" class="text-2xl font-bold text-indigo-300 mb-4">🌌 Woven Map Glossary (Balance Meter)</h2>
                        
                        <div class="space-y-6">
                            <!-- Core Dimensions -->
                            <div>
                                <h3 class="text-lg font-semibold text-white mb-3 border-b border-gray-700 pb-2">Core Dimensions</h3>
                                <ul class="space-y-3 text-sm">
                    <li><strong>Magnitude ⚡ (0–5)</strong> — <span class="text-gray-300">Size of symbolic pressure. Neutral in tone (how much, not which way); ceiling scale ensures comparability.</span></li>
                    <li><strong>Valence 🌞🌑🌗</strong> — <span class="text-gray-300">Directional tilt of pressure (supportive / restrictive / mixed).</span>
                                        <ul class="ml-4 mt-2 space-y-1 text-xs text-gray-400">
                        <li><strong>🌞 Positive:</strong> harmonizes, stabilizes, opens pathways.</li>
                        <li><strong>🌑 Negative:</strong> constrains, destabilizes, blocks.</li>
                        <li><strong>🌗 Mixed:</strong> simultaneous support and strain.</li>
                                        </ul>
                    </li>
                    <li><strong>Volatility 🌪️</strong> — <span class="text-gray-300">Distribution of pressure (low = concentrated; high = scattered/stormy).</span></li>
                    <li><strong>SFD (Support–Friction Differential)</strong> — <span class="text-gray-300">Splits S+ vs S−, nets the differential.</span></li>
                                </ul>
                            </div>

                            <!-- Negative Valence Types -->
                            <div>
                                <h3 class="text-lg font-semibold text-rose-300 mb-3 border-b border-gray-700 pb-2">🌑 Map of Negative Valence Types</h3>
                                <p class="text-xs text-gray-400 mb-3 italic">When energy pulls down, contracts, destabilizes</p>
                                <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3 text-sm">
                                    <li>♾️ <strong>Recursion Pull</strong> — <span class="text-gray-300">Old cycles resurface; déjà vu gravity.</span></li>
                                    <li>⚔️ <strong>Friction Clash</strong> — <span class="text-gray-300">Mars-style conflict, arguments, accidents, heat.</span></li>
                                    <li>↔️ <strong>Cross Current</strong> — <span class="text-gray-300">Competing priorities, mixed flows, confusion.</span></li>
                                    <li>🌫️ <strong>Fog / Dissolution</strong> — <span class="text-gray-300">Blurred boundaries, scattered signal.</span></li>
                                    <li>🌋 <strong>Pressure / Eruption</strong> — <span class="text-gray-300">Compression that forces release.</span></li>
                                    <li>⏳ <strong>Saturn Weight</strong> — <span class="text-gray-300">Heaviness, delay, endurance tests.</span></li>
                                    <li>🧩 <strong>Fragmentation</strong> — <span class="text-gray-300">Fractured focus, scatter.</span></li>
                                    <li>🕳️ <strong>Entropy Drift</strong> — <span class="text-gray-300">Inertia, slow leak of momentum.</span></li>
                                </ul>
                            </div>

                            <!-- Positive Valence Types -->
                            <div>
                                <h3 class="text-lg font-semibold text-emerald-300 mb-3 border-b border-gray-700 pb-2">🌞 Map of Positive Valence Types</h3>
                                <p class="text-xs text-gray-400 mb-3 italic">When energy uplifts, harmonizes, expands</p>
                                <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3 text-sm">
                                    <li>🌱 <strong>Fertile Field</strong> — <span class="text-gray-300">Growth, new opportunities, creativity sprouts.</span></li>
                                    <li>✨ <strong>Harmonic Resonance</strong> — <span class="text-gray-300">Trines/sextiles, things click, natural flow.</span></li>
                                    <li>💎 <strong>Expansion Lift</strong> — <span class="text-gray-300">Jupiter blessing, confidence, abundance.</span></li>
                                    <li>🔥 <strong>Combustion Clarity</strong> — <span class="text-gray-300">Pressure breaks but reveals hidden truth, sudden insight.</span></li>
                                    <li>🦋 <strong>Liberation / Release</strong> — <span class="text-gray-300">Uranian breakthroughs, freedom, change feels fresh.</span></li>
                                    <li>⚖️ <strong>Integration</strong> — <span class="text-gray-300">Opposites reconcile; balance returns.</span></li>
                                    <li>🌊 <strong>Flow Tide</strong> — <span class="text-gray-300">Ease, adaptability, emotions moving freely.</span></li>
                                    <li>🌈 <strong>Visionary Spark</strong> — <span class="text-gray-300">Inspiration, Neptune dream turned into art, spiritual elevation.</span></li>
                                </ul>
                            </div>

                            <div>
                                <h3 class="text-lg font-semibold text-amber-300 mb-3 border-b border-gray-700 pb-2">Sources of Force</h3>
                                <ul class="space-y-2 text-sm">
                                    <li><strong>Orb (🎯)</strong> → <span class="text-gray-300">Closer = stronger.</span></li>
                                    <li><strong>Aspect Type (🌀)</strong> → <span class="text-gray-300">Major = thunder, Minor = whispers.</span></li>
                                    <li><strong>Planetary Potency (🪐)</strong> → <span class="text-gray-300">Fast planets = sparks, slow planets = tectonic.</span></li>
                                    <li><strong>Natal Resonance (📡)</strong> → <span class="text-gray-300">Hits angles, luminaries, nodes = amplified.</span></li>
                                    <li><strong>Recursion (♾️)</strong> → <span class="text-gray-300">Overlapping themes echo louder.</span></li>
                                </ul>
                            </div>

                            <div>
                                <h3 class="text-lg font-semibold text-cyan-300 mb-3 border-b border-gray-700 pb-2">Quick Navigation</h3>
                                <ol class="space-y-2 text-sm">
                                    <li><strong>1. Valence</strong> = Is it 🌞 lifting, 🌑 pressing, or 🌗 neutral?</li>
                                    <li><strong>2. Type</strong> = Which "weather flavor" (🌪️ Recursion, 🌱 Fertility, etc.)?</li>
                                    <li><strong>3. Magnitude</strong> ⚡ = How loud is it?</li>
                                    <li><strong>4. Volatility</strong> 🌪️ = Is it steady or stormy?</li>
                                </ol>
                            </div>

                            <div class="bg-gray-800 p-4 rounded border border-gray-600">
                                <p class="text-sm text-gray-300">
                                    👉 So negative valence isn't just "bad vibes" — it could be <strong>weight (Saturn), fog (Neptune), eruption (Pluto), or clash (Mars)</strong>.<br>
                                    And positive valence isn't just "good vibes" — it could be <strong>growth (Jupiter), clarity (Sun), flow (Moon), or liberation (Uranus)</strong>.
                                </p>
                            </div>
                            
                            <div class="text-center pt-4 border-t border-gray-700">
                                <button id="glossary-close-secondary" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded text-sm">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // View toggle container - inside scrollable content area
            html += '<div id="seismographViewContainer">';

            // Build tables for sky/person/composite
            if (data.sky?.transitsByDate) {
                html += buildSeismographTable('Planetary Weather', data.sky.transitsByDate);
            } else if (data.transitsByDate) {
                html += buildSeismographTable('Planetary Weather', data.transitsByDate);
            }
            if (data.person_a?.chart?.transitsByDate) {
                const personAName = data.person_a?.info?.name || 'Person A';
                html += buildSeismographTable(personAName, data.person_a.chart.transitsByDate);
            }
            
            if (data.person_b?.chart?.transitsByDate) {
                const personBName = data.person_b?.info?.name || 'Person B';
                html += buildSeismographTable(personBName, data.person_b.chart.transitsByDate);
            }
            
            if (data.composite?.transitsByDate) {
                html += buildSeismographTable('Composite', data.composite.transitsByDate);
            }
            
            if (data.synastry?.transitsByDate) {
                html += buildSeismographTable('Synastry Transits', data.synastry.transitsByDate);
            }
            
            // Mobile cards view (hidden by default)
            html += '<div id="seismographMobileView" class="hidden">';
            if (data.sky?.transitsByDate || data.transitsByDate) {
                const map = data.sky?.transitsByDate || data.transitsByDate;
                html += buildMobileSeismographCards('Planetary Weather', map);
            }
            if (data.person_a?.chart?.transitsByDate) {
                const personAName = data.person_a?.info?.name || 'Person A';
                html += buildMobileSeismographCards(personAName, data.person_a.chart.transitsByDate);
            }
            if (data.person_b?.chart?.transitsByDate) {
                const personBName = data.person_b?.info?.name || 'Person B';
                html += buildMobileSeismographCards(personBName, data.person_b.chart.transitsByDate);
            }
            if (data.composite?.transitsByDate) {
                html += buildMobileSeismographCards('Composite', data.composite.transitsByDate);
            }
            if (data.synastry?.transitsByDate) {
                html += buildMobileSeismographCards('Synastry Transits', data.synastry.transitsByDate);
            }
            html += '</div>';
            
            html += '</div>'; // Close seismographViewContainer
            html += '</div>'; // Close seismograph-content-area
            html += '</div>'; // Close space-y-6
            return html;
        }

        function buildSeismographFilters() {
            return `
                <div id="seismographFiltersPanel" class="hidden mt-4 p-4 bg-gray-700 rounded border">
                    <h4 class="text-sm font-semibold text-blue-300 mb-3">Filter Thresholds</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-xs">
                        <div>
                            <label class="block text-gray-300 mb-1">Min Magnitude</label>
                            <input type="range" id="filterMinMagnitude" min="0" max="10" step="0.1" value="0" 
                                   class="w-full accent-blue-500">
                            <span id="filterMinMagnitudeValue" class="text-blue-300">0.0</span>
                        </div>
                        <div>
                            <label class="block text-gray-300 mb-1">Min Valence</label>
                            <input type="range" id="filterMinValence" min="-5" max="5" step="0.1" value="-5" 
                                   class="w-full accent-blue-500">
                            <span id="filterMinValenceValue" class="text-blue-300">-5.0</span>
                        </div>
                        <div>
                            <label class="block text-gray-300 mb-1">Max Valence</label>
                            <input type="range" id="filterMaxValence" min="-5" max="5" step="0.1" value="5" 
                                   class="w-full accent-blue-500">
                            <span id="filterMaxValenceValue" class="text-blue-300">5.0</span>
                        </div>
                        <div>
                            <label class="block text-gray-300 mb-1">Min Volatility</label>
                            <input type="range" id="filterMinVolatility" min="0" max="5" step="0.1" value="0" 
                                   class="w-full accent-blue-500">
                            <span id="filterMinVolatilityValue" class="text-blue-300">0.0</span>
                        </div>
                        <div class="md:col-span-4 mt-1">
                            <label class="inline-flex items-center gap-2 text-[11px] font-medium text-gray-300 select-none">
                                <input id="poeticFlagsToggle" type="checkbox" class="rounded border-gray-600 bg-gray-800 text-teal-500 focus:ring-teal-500">
                                <span>Include <span class="text-teal-300 font-semibold">Poetic Prep Flags</span> (salience prompts – not geometry)</span>
                            </label>
                            <p class="text-[10px] text-gray-400 mt-1 leading-snug">Filtering adjusts interpretation scope. Math Brain mirrors raw geometry; enabling flags adds optional prompts for the downstream Poetic Brain without altering calculations.</p>
                        </div>
                    </div>
                    <div class="mt-3 flex gap-2">
                        <button id="applySeismographFilters" class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
                            Apply Filters
                        </button>
                        <button id="resetSeismographFilters" class="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700">
                            Reset
                        </button>
                    </div>
                </div>`;
        }

        function buildSeismographTable(title, dailyMap) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) {
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title}</h4>
                    <p class="text-gray-400">No transit data available for this period.</p>
                </div>`;
            }
            
            const dates = Object.keys(dailyMap).sort();
            
            let html = `
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-lg font-semibold text-yellow-300">${title}</h4>
                        <button onclick="downloadSeismographCSV('${title}', window.seismographData)" 
                                class="px-2 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700">
                            📄 CSV
                        </button>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm border border-gray-600 rounded seismograph-table">
                            <thead class="bg-gray-700">
                                <tr class="text-[11px] uppercase tracking-wide">
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Date</th>
                                    <th class="px-3 py-2 text-right text-teal-300 border-b border-gray-600 align-bottom">Magnitude<br><span class="text-[10px] normal-case font-normal text-gray-400">Field Intensity</span></th>
                                    <th colspan="2" class="px-3 py-1 text-center text-amber-300 border-b border-gray-600 align-bottom">Modifiers<br><span class="text-[10px] normal-case font-normal text-gray-400">Tone & Turbulence (independent)</span></th>
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Top Hooks</th>
                                </tr>
                                <tr class="text-[11px] tracking-wide bg-gray-700/80">
                                    <th></th>
                                    <th class="text-right text-gray-400 font-normal">⚡ Mag</th>
                                    <th class="text-right text-gray-400 font-normal">↗︎ Val</th>
                                    <th class="text-right text-gray-400 font-normal">📊 Vol</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>`;
            
            // Shape normalizer so UI accepts either flat or nested channel payloads
            function normalizeEntry(e){
                const seismograph = e.seismograph ?? { magnitude: e.magnitude, valence: e.valence, version: 'v1.0' };
                const balance = e.balance ?? (
                    (Number.isFinite(e.balance_valence) || Number.isFinite(e.balanceMagnitude))
                        ? { magnitude: e.balanceMagnitude ?? seismograph.magnitude, valence: e.balance_valence, version: 'v1.1' }
                        : undefined
                );
                const sfd = e.sfd ?? (
                    (Number.isFinite(e.sfd_value) || Number.isFinite(e.splus) || Number.isFinite(e.sminus) || Number.isFinite(e.sfd))
                        ? { sfd: e.sfd ?? e.sfd_value, sPlus: e.splus ?? e.Splus, sMinus: e.sminus ?? e.Sminus, version: 'v1.2' }
                        : undefined
                );
                return { ...e, seismograph, balance, sfd };
            }

            const healthByDate = (typeof window !== 'undefined' && window.WM_HEALTH_BY_DATE) ? window.WM_HEALTH_BY_DATE : null;
            dates.forEach(date => {
                const dayRaw = dailyMap[date];
                if (!dayRaw) return;
                const day = normalizeEntry(dayRaw);
                
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                // Compact summary line with optional Balance/SFD
                const fmtSigned = (n)=>`${n>=0?'+':''}${n.toFixed(1)}`;
                let summary = `Mag ${mag} · Val ${fmtSigned(parseFloat(val))}`;
                if (day.balance && Number.isFinite(day.balance.valence)) summary += ` | Bal ${fmtSigned(day.balance.valence)}`;
                if (day.sfd && Number.isFinite(day.sfd.sfd)) {
                    const sp = Number.isFinite(day.sfd.sPlus) ? day.sfd.sPlus.toFixed(1) : '0.0';
                    const sm = Number.isFinite(day.sfd.sMinus) ? day.sfd.sMinus.toFixed(1) : '0.0';
                    summary += ` | SFD ${fmtSigned(day.sfd.sfd)} (S+${sp}/S−${sm})`;
                }
                
                // Get top 3 hooks
                const hooks = (day.hooks || []).slice(0, 3);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || h.p1_display || '?'} ${h.aspect || h._aspect || '?'} ${h.p2_name || h.p2_display || '?'}`).join(', ')
                    : '—';
                
                // Optional correlation score (raw data only - no salience labels)
                let badge = '';
                if (healthByDate) {
                    const hb = healthByDate[date];
                    if (hb) {
                        const sObj = { magnitude: parseFloat(mag), valence: parseFloat(val), volatility: parseFloat(vol) };
                        try {
                            const score = calculateCorrelationScore(sObj, hb);
                            // Show correlation score without automatic salience interpretation
                            // User must determine if correlation reflects lived experience
                            if (score >= 0.45) {
                                const detail = Object.keys(hb).map(k=>`${k}:${hb[k]}`).join(', ');
                                badge = `<span class="ml-2 text-[10px] px-1.5 py-0.5 rounded bg-gray-600 text-gray-300" title="health: ${detail}; correlation=${score.toFixed(3)}">r=${score.toFixed(2)}</span>`;
                            }
                        } catch(_){}
                    }
                }

                // Reduced semantic coloring – keep magnitude emphasis only (valence annotation neutral)
                const magColor = parseFloat(mag) > 7 ? 'text-red-400' : parseFloat(mag) > 5 ? 'text-yellow-400' : 'text-teal-300';
                const valColor = 'text-gray-300';
                const volColor = 'text-gray-300';
                
                // Enhanced valence display with emoji
                const valenceEmoji = getValenceEmoji(parseFloat(val));
                const valenceDisplay = `${valenceEmoji} ${val}`;
                
                html += `
                    <tr class="hover:bg-gray-700 transition-colors">
                        <td class="px-3 py-2 border-b border-gray-700 text-teal-300 whitespace-nowrap">${date} ${badge}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${magColor}" title="Symbolic field scalar (independent)">${mag}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${valColor}" title="Directional tone: ${getValenceType(parseFloat(val))}">${valenceDisplay}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${volColor}" title="Turbulence / spread of activation">${vol}<br><span class="text-[10px] text-gray-400">${summary}</span></td>
                        <td class="px-3 py-2 border-b border-gray-700 text-gray-300 text-xs" title="${hookText}">${hookText.length > 50 ? hookText.substring(0, 50) + '...' : hookText}</td>
                    </tr>`;
            });
            
            html += `
                            </tbody>
                        </table>
                        <div class="mt-2 text-[10px] text-gray-400 flex flex-col gap-1 leading-snug">
                            <div><span class="text-teal-300 font-semibold">Magnitude</span> = field intensity (hook density + weighted alignment). Not computed from Valence or Volatility.</div>
                            <div><span class="text-amber-300 font-semibold">Valence</span> = net directional tone. <span class="text-amber-300 font-semibold">Volatility</span> = turbulence / variance. Both modify lived experience of the field but do not derive it.</div>
                            <div>Three independent dials → mirror first, interpret later. <span class="text-gray-300">Mirror, not mandate.</span></div>
                        </div>
                    </div>
                </div>`;
            
            return html;
        }

        function buildSeismographTableFiltered(title, dailyMap, filters) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) {
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title}</h4>
                    <p class="text-gray-400">No transit data available for this period.</p>
                </div>`;
            }
            
            const dates = Object.keys(dailyMap).sort();
            
            // Filter dates based on seismograph values
            const filteredDates = dates.filter(date => {
                const day = dailyMap[date];
                if (!day || !day.seismograph) return false;
                
                const mag = day.seismograph.magnitude || 0;
                const val = day.seismograph.valence || 0;
                const vol = day.seismograph.volatility || 0;
                
                return mag >= filters.minMagnitude &&
                       val >= filters.minValence &&
                       val <= filters.maxValence &&
                       vol >= filters.minVolatility;
            });
            
            let html = `
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-lg font-semibold text-yellow-300">${title}</h4>
                        <div class="flex gap-2 items-center">
                            <span class="text-xs text-blue-400">Filtered: ${filteredDates.length}/${dates.length}</span>
                            <button onclick="downloadSeismographCSV('${title}', window.seismographData)" 
                                    class="px-2 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700">
                                📄 CSV
                            </button>
                        </div>
                    </div>`;
                    
            if (filteredDates.length === 0) {
                html += `<p class="text-orange-400 text-sm">No dates match current filter criteria.</p></div>`;
                return html;
            }
            
            html += `
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm border border-gray-600 rounded seismograph-table">
                            <thead class="bg-gray-700">
                                <tr class="text-[11px] uppercase tracking-wide">
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Date</th>
                                    <th class="px-3 py-2 text-right text-teal-300 border-b border-gray-600 align-bottom">Magnitude<br><span class="text-[10px] normal-case font-normal text-gray-400">Field Intensity</span></th>
                                    <th colspan="2" class="px-3 py-1 text-center text-amber-300 border-b border-gray-600 align-bottom">Modifiers<br><span class="text-[10px] normal-case font-normal text-gray-400">Tone & Turbulence (independent)</span></th>
                                    <th class="px-3 py-2 text-left text-gray-300 border-b border-gray-600 align-bottom">Top Hooks</th>
                                </tr>
                                <tr class="text-[11px] tracking-wide bg-gray-700/80">
                                    <th></th>
                                    <th class="text-right text-gray-400 font-normal">⚡ Mag</th>
                                    <th class="text-right text-gray-400 font-normal">↗︎ Val</th>
                                    <th class="text-right text-gray-400 font-normal">📊 Vol</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>`;
            
            const healthByDate = (typeof window !== 'undefined' && window.WM_HEALTH_BY_DATE) ? window.WM_HEALTH_BY_DATE : null;
            filteredDates.forEach(date => {
                const day = dailyMap[date];
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                const hooks = (day.hooks || []).slice(0, 3);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || h.p1_display || '?'} ${h.aspect || h._aspect || '?'} ${h.p2_name || h.p2_display || '?'}`).join(', ')
                    : '—';
                
                // Optional correlation score (raw data only - no salience labels)
                let badge = '';
                if (healthByDate) {
                    const hb = healthByDate[date];
                    if (hb) {
                        try {
                            const sObj = { magnitude: parseFloat(mag), valence: parseFloat(val), volatility: parseFloat(vol) };
                            const score = calculateCorrelationScore(sObj, hb);
                            // Show correlation score without automatic salience interpretation
                            // User must determine if correlation reflects lived experience
                            if (score >= 0.45) {
                                badge = `<span class="ml-2 text-[10px] px-1.5 py-0.5 rounded bg-gray-600 text-gray-300" title="correlation=${score.toFixed(3)}">r=${score.toFixed(2)}</span>`;
                            }
                        } catch(_){}
                    }
                }

                // Reduced semantic coloring – magnitude only
                const magColor = parseFloat(mag) > 7 ? 'text-red-300 font-bold' : parseFloat(mag) > 5 ? 'text-yellow-400' : 'text-teal-300';
                const valColor = 'text-gray-300';
                const volColor = 'text-gray-300';
                
                // Enhanced valence display with emoji
                const valenceEmoji = getValenceEmoji(parseFloat(val));
                const valenceDisplay = `${valenceEmoji} ${val}`;
                
                html += `
                    <tr class="hover:bg-gray-700 transition-colors">
                        <td class="px-3 py-2 border-b border-gray-700 text-teal-300 whitespace-nowrap">${date} ${badge}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${magColor}" title="Symbolic field scalar (independent)">${mag}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${valColor}" title="Directional tone: ${getValenceType(parseFloat(val))}">${valenceDisplay}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-right ${volColor}" title="Turbulence / spread of activation">${vol}</td>
                        <td class="px-3 py-2 border-b border-gray-700 text-gray-300 text-xs" title="${hookText}">${hookText.length > 50 ? hookText.substring(0, 50) + '...' : hookText}</td>
                    </tr>`;
            });
            
            html += `
                            </tbody>
                        </table>
                        <div class="mt-2 text-[10px] text-gray-400 flex flex-col gap-1 leading-snug">
                            <div><span class="text-teal-300 font-semibold">Magnitude</span> = field intensity (hook density + weighted alignment). Independent axis.</div>
                            <div><span class="text-amber-300 font-semibold">Valence</span> = directional tone; <span class="text-amber-300 font-semibold">Volatility</span> = turbulence. Modify experience, not source magnitude.</div>
                            <div>Three dials; no derivation chain. <span class="text-gray-300">Mirror first → interpret later.</span></div>
                        </div>
                    </div>
                </div>`;
            
            return html;
        }

        function buildMobileSeismographCardsFiltered(title, dailyMap, filters) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) return '';
            
            const dates = Object.keys(dailyMap).sort();
            
            // Filter dates
            const filteredDates = dates.filter(date => {
                const day = dailyMap[date];
                if (!day || !day.seismograph) return false;

                const mag = day.seismograph.magnitude || 0;
                const val = day.seismograph.valence || 0;
                const vol = day.seismograph.volatility || 0;

                return mag >= filters.minMagnitude &&
                       val >= filters.minValence &&
                       val <= filters.maxValence &&
                       vol >= filters.minVolatility;
            });
            
            if (filteredDates.length === 0) {
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} - Mobile View</h4>
                    <p class="text-orange-400 text-sm">No dates match current filter criteria.</p>
                </div>`;
            }
            
            let html = `<div class="mb-6">
                <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} - Mobile View (${filteredDates.length}/${dates.length})</h4>
                <div class="space-y-3">`;

            filteredDates.forEach(date => {
                const rawDay = dailyMap[date];
                if (!rawDay) return;
                
                const day = normalizeEntry(rawDay);
                const channelLine = tripleChannelLine({ 
                    seismograph: day.seismograph, 
                    balance: day.balance, 
                    sfd: day.sfd 
                });
                
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                const hooks = (day.hooks || []).slice(0, 2);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || '?'} ${h.aspect || '?'} ${h.p2_name || '?'}`).join('<br>')
                    : 'No significant hooks';
                
                // Color coding for cards
                const cardClass = parseFloat(mag) > 7 ? 'border-red-500' : parseFloat(mag) > 5 ? 'border-yellow-500' : 'border-teal-500';
                
                html += `
                    <div class="bg-gray-700 p-3 rounded border-l-4 ${cardClass} swipeable-card">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-teal-300 font-semibold">${date}</span>
                            <div class="text-xs text-gray-400">
                                M:${mag} V:${val} Vol:${vol}
                            </div>
                        </div>
                        <div class="text-[10px] text-gray-300 mt-1" title="Triple Channel Summary">${channelLine}</div>
                        <div class="text-sm text-gray-300">${hookText}</div>
                    </div>`;
            });
            
            html += `</div></div>`;
            return html;
        }

        function buildMobileSeismographCards(title, dailyMap) {
            if (!dailyMap || Object.keys(dailyMap).length === 0) return '';
            
            const dates = Object.keys(dailyMap).sort();
            
            let html = `<div class="mb-6">
                <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} - Mobile View</h4>
                <div class="space-y-3">`;
            
            dates.forEach(date => {
                const rawDay = dailyMap[date];
                if (!rawDay) return;
                
                const day = normalizeEntry(rawDay);
                const channelLine = tripleChannelLine({ 
                    seismograph: day.seismograph, 
                    balance: day.balance, 
                    sfd: day.sfd 
                });
                
                // Shorter version for mobile
                const mag = (day.seismograph?.magnitude || 0).toFixed(1);
                const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(1);
                const vol = (day.seismograph?.volatility || 0).toFixed(1);
                
                const hooks = (day.hooks || []).slice(0, 2);
                const hookText = hooks.length > 0 
                    ? hooks.map(h => `${h.p1_name || '?'} ${h.aspect || '?'} ${h.p2_name || '?'}`).join('<br>')
                    : 'No significant hooks';
                
                html += `
                    <div class="bg-gray-700 p-3 rounded border-l-4 border-teal-500 swipeable-card">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-teal-300 font-semibold">${date}</span>
                            <div class="text-xs text-gray-400">
                                M:${mag} V:${val} Vol:${vol}
                            </div>
                        </div>
                        <div class="text-[10px] text-gray-300 mt-1" title="Triple Channel Summary">${channelLine}</div>
                        <div class="text-sm text-gray-300">${hookText}</div>
                    </div>`;
            });
            
            html += `</div></div>`;
            return html;
        }

        function downloadSeismographCSV(title, data) {
            const dailyMap = title === 'Person A' ? data?.person_a?.chart?.transitsByDate :
                           title === 'Person B' ? data?.person_b?.chart?.transitsByDate :
                           title === 'Composite' ? data?.composite?.transitsByDate :
                           title === 'Synastry Transits' ? data?.synastry?.transitsByDate : null;
            
            if (!dailyMap) {
                console.warn('No data available for CSV export:', title);
                return;
            }
            
            const dates = Object.keys(dailyMap).sort();
            let csv = 'Date,mag_v1_0,val_v1_0,vol,scale_confidence,bal_val_v1_1,sfd_v1_2,splus_v1_2,sminus_v1_2,calibration_boundary,reconstructed,engine_versions,Top_Hooks\n';
            
            const boundary = (window.seismographData && window.seismographData.provenance && window.seismographData.provenance.calibration_boundary) || '';
            const reconstructed = (window.seismographData && window.seismographData.reconstructed) ? 'true' : '';
            const engines = (window.seismographData && window.seismographData.provenance && window.seismographData.provenance.engine_versions) || null;
            const enginesJson = engines ? JSON.stringify(engines).replace(/"/g, '""') : '';

            dates.forEach(date => {
                const rawDay = dailyMap[date];
                if (!rawDay) return;
                
                const day = normalizeEntry(rawDay);
                const mag = (day.seismograph?.magnitude ?? '').toString();
                const val = (day.seismograph?.valence ?? '').toString();
                const vol = (day.seismograph?.volatility ?? '').toString();
                const conf = (day.seismograph?.scaleConfidence ?? '').toString();
                const bal = (day.balance && Number.isFinite(day.balance.valence)) ? day.balance.valence.toString() : '';
                const sfd = (day.sfd && Number.isFinite(day.sfd.sfd)) ? day.sfd.sfd.toString() : '';
                const splus = (day.sfd && Number.isFinite(day.sfd.sPlus)) ? day.sfd.sPlus.toString() : '';
                const sminus = (day.sfd && Number.isFinite(day.sfd.sMinus)) ? day.sfd.sMinus.toString() : '';

                const hooks = (day.hooks || []).slice(0, 3);
                const hookText = hooks.map(h => `${h.p1_name || '?'} ${h.aspect || '?'} ${h.p2_name || '?'}`).join('; ');
                const hookEsc = `"${hookText.replace(/"/g,'""')}"`;

                csv += `${date},${mag},${val},${vol},${conf},${bal},${sfd},${splus},${sminus},${boundary},${reconstructed},"${enginesJson}",${hookEsc}\n`;
            });
            
            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `seismograph_${title.replace(/\s+/g, '_')}_${timestamp}.csv`;
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadAllSeismographData() {
            if (!window.seismographData) {
                console.warn('No seismograph data available for export');
                return;
            }
            
            const data = window.seismographData;
            const timestamp = new Date().toISOString().slice(0, 10);
            
            // Download individual CSVs
            if (data.person_a?.chart?.transitsByDate) {
                downloadSeismographCSV('Person A', data);
            }
            if (data.person_b?.chart?.transitsByDate) {
                downloadSeismographCSV('Person B', data);
            }
            if (data.composite?.transitsByDate) {
                downloadSeismographCSV('Composite', data);
            }
            if (data.synastry?.transitsByDate) {
                downloadSeismographCSV('Synastry Transits', data);
            }
        }

        // --- Seismograph Analysis Queue & Voice Synthesis Layer ---
        let seismographAnalysisQueue = [];
        let seismographAnalysisRunning = false;
        function queueSeismographAnalysis(){
            seismographAnalysisQueue.push(Date.now());
            const btn = document.getElementById('queueSeismographAnalysis');
            if(btn){
                const original = btn.dataset.labelOriginal || btn.textContent.trim();
                btn.dataset.labelOriginal = original;
                btn.textContent = '⏳ Queued…';
                btn.disabled = true;
                btn.classList.add('opacity-70','cursor-wait');
            }
            processSeismographAnalysisQueue();
        }
        function processSeismographAnalysisQueue(){
            if(seismographAnalysisRunning) return;
            if(!seismographAnalysisQueue.length) return;
            seismographAnalysisRunning = true;
            seismographAnalysisQueue.shift();
            setTimeout(()=>{ // simulate async batch
                detectSeismographPatterns();
                seismographAnalysisRunning = false;
                const btn = document.getElementById('queueSeismographAnalysis');
                if(btn){
                    btn.textContent = '✅ Analysis Complete';
                    setTimeout(()=>{
                        btn.textContent = '📦 Queue Analysis';
                        btn.disabled = false;
                        btn.classList.remove('opacity-70','cursor-wait');
                    },1400);
                }
                synthesizeRavenVoiceFromPatterns();
                if(seismographAnalysisQueue.length) processSeismographAnalysisQueue();
            }, 60);
        }
        function synthesizeRavenVoiceFromPatterns(){
            const panel = document.getElementById('ravenVoicePanel');
            const content = document.getElementById('ravenVoiceContent');
            if(!panel||!content) return;
            const patterns = window.latestSeismographPatterns || [];
            if(!patterns.length){
                panel.classList.remove('hidden');
                content.innerHTML = 'No significant macro pattern clusters. Geometry baseline steady; micro hooks carry modulation.';
                return;
            }
            const top = patterns.slice(0,3).map(p=>`<span class=\"text-teal-300\">${p.subject}</span>: ${p.description}`).join('<br>');
            content.innerHTML = `<div class=\"space-y-2\">${top}<div class=\"text-[10px] text-gray-400 pt-1 border-t border-gray-700\">VOICE = optional synthesis. FIELD/MAP (tables & charts) remain falsifiable core.</div></div>`;
            panel.classList.remove('hidden');
        }
        // Tooltip helpers (foundation for future richer contextual hovers)
        function attachSeismographTooltip(el,text){ if(!el) return; el.addEventListener('mouseenter',e=>showGlobalTooltip(e,text)); el.addEventListener('mouseleave', hideGlobalTooltip); el.addEventListener('mousemove', moveGlobalTooltip); }
        function showGlobalTooltip(e,text){ const t=document.getElementById('globalHoverTooltip'); if(!t) return; t.innerHTML=text; t.style.display='block'; moveGlobalTooltip(e);} 
        function moveGlobalTooltip(e){ const t=document.getElementById('globalHoverTooltip'); if(!t) return; const pad=12; t.style.left=(e.clientX+pad)+'px'; t.style.top=(e.clientY+pad)+'px'; }
        function hideGlobalTooltip(){ const t=document.getElementById('globalHoverTooltip'); if(t) t.style.display='none'; }

        function detectSeismographPatterns(data) {
            if (!data) data = window.seismographData;
            if (!data) return;
            
            let patterns = [];
            
            // Analyze each dataset
            ['person_a', 'person_b', 'composite'].forEach(key => {
                const dailyMap = data[key]?.chart?.transitsByDate;
                if (!dailyMap) return;
                
                const name = key === 'person_a' ? 'Person A' : 
                           key === 'person_b' ? 'Person B' : 'Composite';
                
                const dates = Object.keys(dailyMap).sort();
                const values = dates.map(date => ({
                    date,
                    magnitude: dailyMap[date].seismograph?.magnitude || 0,
                    valence: dailyMap[date].seismograph?.valence || 0,
                    volatility: dailyMap[date].seismograph?.volatility || 0
                }));
                
                if (values.length < 3) return; // Need at least 3 days for meaningful analysis
                
                // 1. Detect valence trends (more sensitive threshold)
                const valenceTrend = detectTrend(values.map(v => v.valence));
                if (Math.abs(valenceTrend) > 0.05) { // Lowered from 0.1 to catch subtler trends
                    const strength = Math.abs(valenceTrend);
                    const direction = valenceTrend > 0 ? 'Increasing ease/flow' : 'Increasing tension/friction';
                    patterns.push({
                        type: 'valence_trend',
                        subject: name,
                        description: `${direction} (${strength.toFixed(3)} units/day)`,
                        strength: strength,
                        priority: strength > 0.2 ? 'high' : strength > 0.1 ? 'medium' : 'low'
                    });
                }
                
                // 2. Detect magnitude trends
                const magnitudeTrend = detectTrend(values.map(v => v.magnitude));
                if (Math.abs(magnitudeTrend) > 0.1) { // Magnitude trends need to be more significant
                    const direction = magnitudeTrend > 0 ? 'Intensifying' : 'Subsiding';
                    patterns.push({
                        type: 'magnitude_trend',
                        subject: name,
                        description: `${direction} activation levels (${Math.abs(magnitudeTrend).toFixed(3)} units/day)`,
                        strength: Math.abs(magnitudeTrend),
                        priority: Math.abs(magnitudeTrend) > 0.3 ? 'high' : 'medium'
                    });
                }
                
                // 3. Detect volatility spikes (high volatility periods)
                const highVolatilityDays = values.filter(v => v.volatility > 3.5).length;
                if (highVolatilityDays > Math.max(2, dates.length * 0.2)) {
                    patterns.push({
                        type: 'volatility_spike',
                        subject: name,
                        description: `High volatility period (${highVolatilityDays}/${dates.length} days above 3.5)`,
                        intensity: highVolatilityDays / dates.length,
                        priority: highVolatilityDays > dates.length * 0.5 ? 'high' : 'medium'
                    });
                }
                
                // 4. Detect sustained high magnitude
                const highMagCount = values.filter(v => v.magnitude > 5.5).length; // Lowered from 6.0
                if (highMagCount > Math.max(2, dates.length * 0.25)) {
                    patterns.push({
                        type: 'sustained_pressure',
                        subject: name,
                        description: `Sustained high activation (${highMagCount}/${dates.length} days above 5.5)`,
                        intensity: highMagCount / dates.length,
                        priority: highMagCount > dates.length * 0.5 ? 'high' : 'medium'
                    });
                }
                
                // 5. Detect sustained low activity (potential stagnation)
                const lowMagCount = values.filter(v => v.magnitude < 1.5).length;
                if (lowMagCount > Math.max(3, dates.length * 0.4)) {
                    patterns.push({
                        type: 'low_activity',
                        subject: name,
                        description: `Extended quiet period (${lowMagCount}/${dates.length} days below 1.5)`,
                        intensity: lowMagCount / dates.length,
                        priority: 'low'
                    });
                }
                
                // 6. Detect extreme valence periods
                const extremePositiveCount = values.filter(v => v.valence > 3.0).length;
                const extremeNegativeCount = values.filter(v => v.valence < -3.0).length;
                
                if (extremePositiveCount > Math.max(2, dates.length * 0.2)) {
                    patterns.push({
                        type: 'extreme_ease',
                        subject: name,
                        description: `Extended ease period (${extremePositiveCount}/${dates.length} days above +3.0 valence)`,
                        intensity: extremePositiveCount / dates.length,
                        priority: 'medium'
                    });
                }
                
                if (extremeNegativeCount > Math.max(2, dates.length * 0.2)) {
                    patterns.push({
                        type: 'extreme_tension',
                        subject: name,
                        description: `Extended friction period (${extremeNegativeCount}/${dates.length} days below -3.0 valence)`,
                        intensity: extremeNegativeCount / dates.length,
                        priority: extremeNegativeCount > dates.length * 0.4 ? 'high' : 'medium'
                    });
                }
                
                // 7. Detect cycles (improved algorithm)
                const magnitudeCycle = detectCyclePeriod(values.map(v => v.magnitude));
                if (magnitudeCycle > 0 && magnitudeCycle <= dates.length / 2) {
                    patterns.push({
                        type: 'magnitude_cycle',
                        subject: name,
                        description: `${magnitudeCycle}-day activation cycle detected`,
                        period: magnitudeCycle,
                        priority: magnitudeCycle >= 7 && magnitudeCycle <= 14 ? 'high' : 'medium' // Weekly/bi-weekly cycles are significant
                    });
                }
                
                // 8. Detect volatility stability
                const avgVolatility = values.reduce((sum, v) => sum + v.volatility, 0) / values.length;
                const volatilityStdDev = Math.sqrt(values.reduce((sum, v) => sum + Math.pow(v.volatility - avgVolatility, 2), 0) / values.length);
                
                if (volatilityStdDev < 0.5 && avgVolatility < 2.0) {
                    patterns.push({
                        type: 'stable_period',
                        subject: name,
                        description: `Stable energy pattern (low volatility variation: ${volatilityStdDev.toFixed(2)})`,
                        stability: 1 - volatilityStdDev,
                        priority: 'low'
                    });
                }
            });
            
            // Sort patterns by priority and strength
            patterns.sort((a, b) => {
                const priorityOrder = { high: 3, medium: 2, low: 1 };
                const aPriority = priorityOrder[a.priority] || 1;
                const bPriority = priorityOrder[b.priority] || 1;
                
                if (aPriority !== bPriority) return bPriority - aPriority;
                
                // Secondary sort by strength/intensity
                const aStrength = a.strength || a.intensity || 0;
                const bStrength = b.strength || b.intensity || 0;
                return bStrength - aStrength;
            });
            
            displaySeismographPatterns(patterns);
            window.latestSeismographPatterns = patterns;
        }

        function detectTrend(values) {
            if (values.length < 3) return 0;
            
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            
            values.forEach((y, x) => {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            });
            
            const n = values.length;
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            return slope;
        }

        function detectCyclePeriod(values) {
            if (values.length < 6) return 0;
            
            // Simple autocorrelation to detect cycles
            let bestPeriod = 0;
            let bestCorrelation = 0;
            
            for (let period = 2; period <= Math.floor(values.length / 2); period++) {
                let correlation = 0;
                let count = 0;
                
                for (let i = 0; i < values.length - period; i++) {
                    correlation += values[i] * values[i + period];
                    count++;
                }
                
                correlation /= count;
                
                if (correlation > bestCorrelation) {
                    bestCorrelation = correlation;
                    bestPeriod = period;
                }
            }
            
            return bestCorrelation > 0.5 ? bestPeriod : 0;
        }

        function displaySeismographPatterns(patterns) {
            const container = document.getElementById('seismographPatterns');
            if (!container) return;
            
            if (patterns.length === 0) {
                container.innerHTML = `
                    <div class="bg-gray-800 p-4 rounded border border-gray-600 mb-4">
                        <h4 class="text-purple-300 font-semibold mb-2">Pattern Analysis</h4>
                        <p class="text-gray-400">No significant patterns detected in current data.</p>
                    </div>`;
                return;
            }
            
            // Group patterns by priority
            const groupedPatterns = {
                high: patterns.filter(p => p.priority === 'high'),
                medium: patterns.filter(p => p.priority === 'medium'),
                low: patterns.filter(p => p.priority === 'low')
            };
            
            let html = `
                <div class="bg-gray-800 p-4 rounded border border-purple-500 mb-4">
                    <h4 class="text-purple-300 font-semibold mb-3">🔮 Pattern Detection Results (${patterns.length} patterns found)</h4>`;
            
            // High priority patterns
            if (groupedPatterns.high.length > 0) {
                html += `
                    <div class="mb-4">
                        <h5 class="text-red-300 font-semibold mb-2 flex items-center">
                            🚨 High Priority Patterns (${groupedPatterns.high.length})
                        </h5>
                        <div class="space-y-2">`;
                
                groupedPatterns.high.forEach(pattern => {
                    const typeColor = getPatternTypeColor(pattern.type);
                    const typeIcon = getPatternTypeIcon(pattern.type);
                    
                    html += `
                        <div class="bg-red-900/20 border border-red-500/30 p-3 rounded pattern-card">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold ${typeColor}">${typeIcon} ${pattern.subject}</span>
                                <span class="text-xs text-red-300 bg-red-800/50 px-2 py-1 rounded">${pattern.type.replace(/_/g, ' ')}</span>
                            </div>
                            <p class="text-sm text-gray-200 mt-1">${pattern.description}</p>
                        </div>`;
                });
                
                html += `</div></div>`;
            }
            
            // Medium priority patterns
            if (groupedPatterns.medium.length > 0) {
                html += `
                    <div class="mb-4">
                        <h5 class="text-yellow-300 font-semibold mb-2 flex items-center">
                            ⚠️ Medium Priority Patterns (${groupedPatterns.medium.length})
                        </h5>
                        <div class="space-y-2">`;
                
                groupedPatterns.medium.forEach(pattern => {
                    const typeColor = getPatternTypeColor(pattern.type);
                    const typeIcon = getPatternTypeIcon(pattern.type);
                    
                    html += `
                        <div class="bg-yellow-900/20 border border-yellow-500/30 p-3 rounded pattern-card">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold ${typeColor}">${typeIcon} ${pattern.subject}</span>
                                <span class="text-xs text-yellow-300 bg-yellow-800/50 px-2 py-1 rounded">${pattern.type.replace(/_/g, ' ')}</span>
                            </div>
                            <p class="text-sm text-gray-200 mt-1">${pattern.description}</p>
                        </div>`;
                });
                
                html += `</div></div>`;
            }
            
            // Low priority patterns (collapsible)
            if (groupedPatterns.low.length > 0) {
                html += `
                    <div class="mb-4">
                        <h5 class="text-gray-300 font-semibold mb-2 flex items-center cursor-pointer" onclick="toggleLowPriorityPatterns()">
                            <span id="lowPriorityToggle">▶</span> Low Priority Patterns (${groupedPatterns.low.length})
                        </h5>
                        <div id="lowPriorityPatterns" class="hidden space-y-2">`;
                
                groupedPatterns.low.forEach(pattern => {
                    const typeColor = getPatternTypeColor(pattern.type);
                    const typeIcon = getPatternTypeIcon(pattern.type);
                    
                    html += `
                        <div class="bg-gray-700/50 border border-gray-500/30 p-3 rounded pattern-card">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold ${typeColor}">${typeIcon} ${pattern.subject}</span>
                                <span class="text-xs text-gray-400 bg-gray-600/50 px-2 py-1 rounded">${pattern.type.replace(/_/g, ' ')}</span>
                            </div>
                            <p class="text-sm text-gray-300 mt-1">${pattern.description}</p>
                        </div>`;
                });
                
                html += `</div></div>`;
            }
            
            html += `</div>`;
            container.innerHTML = html;
        }

        function getPatternTypeColor(type) {
            const colors = {
                valence_trend: 'text-blue-400',
                magnitude_trend: 'text-red-400',
                volatility_spike: 'text-orange-400',
                sustained_pressure: 'text-red-300',
                low_activity: 'text-gray-400',
                extreme_ease: 'text-green-400',
                extreme_tension: 'text-red-400',
                magnitude_cycle: 'text-purple-400',
                stable_period: 'text-teal-400'
            };
            return colors[type] || 'text-gray-300';
        }

        function getPatternTypeIcon(type) {
            const icons = {
                valence_trend: '📈',
                magnitude_trend: '⚡',
                volatility_spike: '📊',
                sustained_pressure: '🔥',
                low_activity: '😴',
                extreme_ease: '🌟',
                extreme_tension: '⚠️',
                magnitude_cycle: '🔄',
                stable_period: '🧘'
            };
            return icons[type] || '📊';
        }

        function toggleLowPriorityPatterns() {
            const container = document.getElementById('lowPriorityPatterns');
            const toggle = document.getElementById('lowPriorityToggle');
            
            if (container && toggle) {
                const isHidden = container.classList.contains('hidden');
                
                if (isHidden) {
                    container.classList.remove('hidden');
                    toggle.textContent = '▼';
                } else {
                    container.classList.add('hidden');
                    toggle.textContent = '▶';
                }
            }
        }

        function setupSeismographEventListeners() {
            // Toggle filters
            const toggleFilters = document.getElementById('toggleSeismographFilters');
            const filtersPanel = document.getElementById('seismographFiltersPanel');
            if (toggleFilters && filtersPanel) {
                toggleFilters.addEventListener('click', () => {
                    filtersPanel.classList.toggle('hidden');
                });
            }
            
            // Download all CSV
            const downloadAllBtn = document.getElementById('downloadAllSeismographCSV');
            if (downloadAllBtn) {
                downloadAllBtn.addEventListener('click', downloadAllSeismographData);
            }
            
            // Queue analysis (replaces direct pattern detection trigger)
            const queueBtn = document.getElementById('queueSeismographAnalysis');
            if (queueBtn) {
                queueBtn.addEventListener('click', () => queueSeismographAnalysis());
            }
            
            // Filter controls
            ['MinMagnitude', 'MinValence', 'MaxValence', 'MinVolatility'].forEach(name => {
                const slider = document.getElementById(`filter${name}`);
                const display = document.getElementById(`filter${name}Value`);
                if (slider && display) {
                    slider.addEventListener('input', () => {
                        display.textContent = parseFloat(slider.value).toFixed(1);
                    });
                }
            });
            
            // Apply filters button
            const applyBtn = document.getElementById('applySeismographFilters');
            if (applyBtn) {
                applyBtn.addEventListener('click', applySeismographFilters);
            }
            
            // Reset filters button
            const resetBtn = document.getElementById('resetSeismographFilters');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetSeismographFilters);
            }
            
            // Glossary modal
            const glossaryModal = document.getElementById('seismographGlossaryModal');
            const toggleGlossaryBtn = document.getElementById('toggleGlossary');
            const closeGlossaryBtn = document.getElementById('closeGlossary');
            const closeGlossarySecondaryBtn = document.getElementById('glossary-close-secondary');

            const openGlossary = () => glossaryModal.classList.remove('hidden');
            const closeGlossary = () => glossaryModal.classList.add('hidden');

            if (toggleGlossaryBtn) toggleGlossaryBtn.addEventListener('click', openGlossary);
            if (closeGlossaryBtn) closeGlossaryBtn.addEventListener('click', closeGlossary);
            if (closeGlossarySecondaryBtn) closeGlossarySecondaryBtn.addEventListener('click', closeGlossary);
            if (glossaryModal) glossaryModal.addEventListener('click', (e) => {
                if (e.target === glossaryModal) closeGlossary();
            });

            // Toggle view (chart/table)
            const toggleView = document.getElementById('toggleSeismographView');
            if (toggleView) {
                toggleView.addEventListener('click', toggleSeismographViewMode);
            }
        }

        function applySeismographFilters() {
            if (!window.seismographData) {
                console.warn('No seismograph data available for filtering');
                return;
            }
            
            // Get filter values
            const filters = {
                minMagnitude: parseFloat(document.getElementById('filterMinMagnitude').value),
                minValence: parseFloat(document.getElementById('filterMinValence').value),
                maxValence: parseFloat(document.getElementById('filterMaxValence').value),
                minVolatility: parseFloat(document.getElementById('filterMinVolatility').value)
            };
            
            // Update global filters
            window.seismographFilters = { ...window.seismographFilters, ...filters };
            
            // Re-render tables with filtered data
            const container = document.getElementById('seismographViewContainer');
            if (!container) return;
            
            let html = '';
            
            // Rebuild each table with filtered data
            if (window.seismographData.person_a?.chart?.transitsByDate) {
                const personAName = window.seismographData.person_a?.info?.name || 'Person A';
                html += buildSeismographTableFiltered(personAName, window.seismographData.person_a.chart.transitsByDate, filters);
            }
            
            if (window.seismographData.person_b?.chart?.transitsByDate) {
                const personBName = window.seismographData.person_b?.info?.name || 'Person B';
                html += buildSeismographTableFiltered(personBName, window.seismographData.person_b.chart.transitsByDate, filters);
            }
            
            if (window.seismographData.composite?.transitsByDate) {
                html += buildSeismographTableFiltered('Composite', window.seismographData.composite.transitsByDate, filters);
            }
            
            if (window.seismographData.synastry?.transitsByDate) {
                html += buildSeismographTableFiltered('Synastry Transits', window.seismographData.synastry.transitsByDate, filters);
            }
            
            container.innerHTML = html;
            
            // Also update mobile view
            const mobileContainer = document.getElementById('seismographMobileView');
            if (mobileContainer) {
                let mobileHtml = '';
                
                if (window.seismographData.person_a?.chart?.transitsByDate) {
                    const personAName = window.seismographData.person_a?.info?.name || 'Person A';
                    mobileHtml += buildMobileSeismographCardsFiltered(personAName, window.seismographData.person_a.chart.transitsByDate, filters);
                }
                
                if (window.seismographData.person_b?.chart?.transitsByDate) {
                    const personBName = window.seismographData.person_b?.info?.name || 'Person B';
                    mobileHtml += buildMobileSeismographCardsFiltered(personBName, window.seismographData.person_b.chart.transitsByDate, filters);
                }
                
                if (window.seismographData.composite?.transitsByDate) {
                    mobileHtml += buildMobileSeismographCardsFiltered('Composite', window.seismographData.composite.transitsByDate, filters);
                }
                
                if (window.seismographData.synastry?.transitsByDate) {
                    mobileHtml += buildMobileSeismographCardsFiltered('Synastry Transits', window.seismographData.synastry.transitsByDate, filters);
                }
                
                mobileContainer.innerHTML = mobileHtml;
            }
            
            // Show feedback
            const applyBtn = document.getElementById('applySeismographFilters');
            if (applyBtn) {
                const originalText = applyBtn.textContent;
                applyBtn.textContent = '✅ Applied';
                applyBtn.classList.add('bg-green-600');
                applyBtn.classList.remove('bg-blue-600');
                
                setTimeout(() => {
                    applyBtn.textContent = originalText;
                    applyBtn.classList.remove('bg-green-600');
                    applyBtn.classList.add('bg-blue-600');
                }, 2000);
            }
        }

        function resetSeismographFilters() {
            document.getElementById('filterMinMagnitude').value = 0;
            document.getElementById('filterMinValence').value = -5;
            document.getElementById('filterMaxValence').value = 5;
            document.getElementById('filterMinVolatility').value = 0;
            
            // Update displays
            document.getElementById('filterMinMagnitudeValue').textContent = '0.0';
            document.getElementById('filterMinValenceValue').textContent = '-5.0';
            document.getElementById('filterMaxValenceValue').textContent = '5.0';
            document.getElementById('filterMinVolatilityValue').textContent = '0.0';
        }

        // New dual visualization & render mode cycle =======================================
        function toggleSeismographViewMode() {
            const button = document.getElementById('toggleSeismographView');
            const tableView = document.getElementById('seismographViewContainer');
            const mobileView = document.getElementById('seismographMobileView');
            let chartContainer = document.getElementById('seismographChartContainer');
            if (!button || !tableView || !mobileView) return;
            if (!chartContainer) {
                chartContainer = document.createElement('div');
                chartContainer.id = 'seismographChartContainer';
                chartContainer.className = 'mb-6';
                tableView.parentNode.insertBefore(chartContainer, tableView);
            }
            // Modes: table -> arc -> barometer -> mobile -> table
            const mode = button.getAttribute('data-mode') || 'table';
            const next = mode === 'table' ? 'arc' : mode === 'arc' ? 'barometer' : mode === 'barometer' ? 'mobile' : 'table';
            // Reset visibility
            tableView.classList.add('hidden');
            mobileView.classList.add('hidden');
            chartContainer.classList.add('hidden');
            if (next === 'table') {
                tableView.classList.remove('hidden');
                button.textContent = '🔄 View: Table';
            } else if (next === 'arc') {
                chartContainer.innerHTML = renderSeismographArcCharts();
                chartContainer.classList.remove('hidden');
                button.textContent = '🔄 View: Arc';
            } else if (next === 'barometer') {
                chartContainer.innerHTML = renderBarometerCharts();
                chartContainer.classList.remove('hidden');
                button.textContent = '🔄 View: Barometer';
            } else if (next === 'mobile') {
                mobileView.classList.remove('hidden');
                button.textContent = '🔄 View: Mobile';
            }
            button.setAttribute('data-mode', next);
        }

        function renderSeismographArcCharts() {
            if (!window.seismographData) return '<p>No data.</p>';
            let html = '<div class="space-y-6">';
            if (window.seismographData.person_a?.chart?.transitsByDate) {
                const nm = window.seismographData.person_a?.info?.name || 'Person A';
                html += renderArcChart(nm, window.seismographData.person_a.chart.transitsByDate);
            }
            if (window.seismographData.person_b?.chart?.transitsByDate) {
                const nm = window.seismographData.person_b?.info?.name || 'Person B';
                html += renderArcChart(nm, window.seismographData.person_b.chart.transitsByDate);
            }
            if (window.seismographData.composite?.transitsByDate) {
                html += renderArcChart('Composite', window.seismographData.composite.transitsByDate);
            }
            if (window.seismographData.synastry?.transitsByDate) {
                html += renderArcChart('Synastry Transits', window.seismographData.synastry.transitsByDate);
            }
            html += '</div>';
            return html;
        }

        function renderBarometerCharts() {
            if (!window.seismographData) return '<p>No data.</p>';
            let html = '<div class="space-y-6">';
            if (window.seismographData.person_a?.chart?.transitsByDate) {
                const nm = window.seismographData.person_a?.info?.name || 'Person A';
                html += renderBarometerChart(nm, window.seismographData.person_a.chart.transitsByDate);
            }
            if (window.seismographData.person_b?.chart?.transitsByDate) {
                const nm = window.seismographData.person_b?.info?.name || 'Person B';
                html += renderBarometerChart(nm, window.seismographData.person_b.chart.transitsByDate);
            }
            if (window.seismographData.composite?.transitsByDate) {
                html += renderBarometerChart('Composite', window.seismographData.composite.transitsByDate);
            }
            if (window.seismographData.synastry?.transitsByDate) {
                html += renderBarometerChart('Synastry Transits', window.seismographData.synastry.transitsByDate);
            }
            html += '</div>';
            return html;
        }

        function renderArcChart(title, dailyMap) {
            const dates = Object.keys(dailyMap || {}).sort();
            if (!dates.length) return '';
            const canvasId = `arc-${title.replace(/\s+/g,'-').toLowerCase()}`;
            const html = `<div class="mb-6"><h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} – Macro Arc</h4><div class="bg-gray-800 p-4 rounded border border-gray-600 overflow-x-auto"><canvas id="${canvasId}" width="900" height="260" class="bg-gray-900 rounded" style="min-width: 600px; max-width: 100%;"></canvas></div></div>`;
            setTimeout(()=>drawSeismographArc(canvasId, dailyMap, dates),5);
            return html;
        }

        function renderBarometerChart(title, dailyMap) {
            const dates = Object.keys(dailyMap || {}).sort();
            if (!dates.length) return '';
            // If only a single day, render enriched semantic snapshot instead of generic canvas
            if (dates.length === 1) {
                const d = dates[0];
                const day = dailyMap[d] || {};
                const seismo = day.seismograph || {};
                const magRaw = Number(seismo.magnitude)||0; // original 0..10 scale? earlier we divide by 2 to normalize
                const mag = +(magRaw/2).toFixed(2); // normalized 0..5
                const val = Math.max(-5, Math.min(5, Number(seismo.valence)||0));
                const vol = +(Number(seismo.volatility)||0).toFixed(2);
                const heur = generateBarometerHeuristics(mag, val, vol, day);
                // Color logic based on valence & magnitude
                const color = barometerColorForValence(val, mag);
                // Enhanced gradient with volatility texture
                let gradient;
                if (vol >= 4) {
                    // High volatility: complex scattered gradient 
                    gradient = `radial-gradient(ellipse at 30% 20%, ${color.start} 0%, ${color.end} 45%), linear-gradient(135deg, ${color.start} 0%, ${color.end} 70%, ${color.cap} 100%)`;
                } else if (vol >= 3) {
                    // Medium-high volatility: angular gradient with stops
                    gradient = `linear-gradient(125deg, ${color.start} 0%, ${color.end} 35%, ${color.start} 55%, ${color.end} 70%)`;
                } else if (vol >= 2) {
                    // Variable: enhanced linear with cap
                    gradient = `linear-gradient(135deg, ${color.start} 0%, ${color.end} 60%, ${color.cap} 85%)`;
                } else {
                    // Low volatility: clean linear
                    gradient = `linear-gradient(135deg, ${color.start} 0%, ${color.end} 70%)`;
                }
                const glyphs = heur.glyphs ? `<div class="text-2xl tracking-tight">${heur.glyphs}</div>` : '';
                const annotation = heur.annotation ? `<p class="text-sm italic text-gray-200 mt-2">“${heur.annotation}”</p>` : '';
                const hooks = (day.hooks && Array.isArray(day.hooks) && day.hooks.length) ?
                    `<div class="mt-3 text-xs text-teal-200"><span class="font-semibold text-teal-300">Hook Signature:</span> ${day.hooks.slice(0,5).map(h=>h.label||h.name||h.aspect||'').filter(Boolean).join(' · ')}</div>` : '';
                const scaleConf = (seismo.scaleConfidence!=null) ? `<span class="ml-2 text-[10px] text-gray-400">scale conf ${(+seismo.scaleConfidence).toFixed(2)}</span>` : '';
                return `<div class="mb-6">
                    <h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} – Daily Barometer</h4>
                    <div class="rounded border border-gray-600 overflow-hidden bg-gray-900">
                        <div class="p-4" style="background:${gradient};">
                            <div class="flex flex-col md:flex-row md:items-start gap-4">
                                <div class="flex-1 min-w-[240px]">
                                    <div class="text-xs uppercase tracking-wide text-gray-300 mb-1">${d}</div>
                                    <h5 class="text-xl font-semibold text-gray-50">${heur.title || 'Pattern Snapshot'}${scaleConf}</h5>
                                    ${annotation}
                                    ${glyphs}
                                </div>
                                <div class="grid grid-cols-2 sm:grid-cols-4 gap-3 text-sm flex-none">
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Magnitude</div>
                                        <div class="font-semibold text-gray-100">${mag.toFixed(2)}<span class="text-[11px] text-gray-400"> / 5</span></div>
                                        <div class="text-[10px] text-gray-300">${heur.magnitudeLabel}</div>
                                    </div>
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Valence</div>
                                        <div class="font-semibold ${val<0?'text-rose-300':'text-emerald-300'}">${val.toFixed(2)}</div>
                                        <div class="text-[10px] text-gray-300">${heur.valenceLabel}</div>
                                    </div>
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Volatility</div>
                                        <div class="font-semibold ${vol>3?'text-amber-300':'text-gray-200'}">${vol.toFixed(2)}</div>
                                        <div class="text-[10px] text-gray-300">${heur.volatilityLabel}</div>
                                    </div>
                                    <div class="bg-gray-900/50 backdrop-blur rounded p-2 border border-gray-700">
                                        <div class="text-[10px] uppercase text-gray-400">Signal Tags</div>
                                        <div class="font-semibold text-gray-100">${heur.signalTags || '—'}</div>
                                        <div class="text-[10px] text-gray-300">${heur.signalLabel}</div>
                                    </div>
                                </div>
                            </div>
                            ${hooks}
                            <div class="mt-4 text-[10px] text-gray-300 uppercase tracking-wide">Signal descriptors (geometry-sourced; not narrative)</div>
                        </div>
                    </div>
                </div>`;
            }
            // Multi-day fallback: existing canvas bar chart
            const canvasId = `bar-${title.replace(/\s+/g,'-').toLowerCase()}`;
            const legend = `<div class=\"mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2 text-[10px] text-gray-300\">
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-teal-300 font-semibold\">Magnitude</span><br><span class=\"text-gray-400\">Activation load 0–5</span></div>
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-amber-300 font-semibold\">Valence</span><br><span class=\"text-gray-400\">Ease ↔ Friction -5..+5</span></div>
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-pink-300 font-semibold\">Volatility</span><br><span class=\"text-gray-400\">Stability ↔ Spiking</span></div>
                <div class=\"bg-gray-900/60 rounded p-2 border border-gray-700\"><span class=\"text-gray-200 font-semibold\">Hooks</span><br><span class=\"text-gray-400\">Aspect signatures</span></div>
            </div>`;
            const html = `<div class="mb-6"><h4 class="text-lg font-semibold text-yellow-300 mb-3">${title} – Daily Barometer</h4><div class="bg-gray-800 p-4 rounded border border-gray-600 overflow-x-auto"><canvas id="${canvasId}" width="900" height="260" class="bg-gray-900 rounded" style="min-width: 600px; max-width: 100%;"></canvas>${legend}</div></div>`;
            setTimeout(()=>drawBarometerChart(canvasId, dailyMap, dates),5);
            return html;
        }

        function drawSeismographArc(canvasId, dailyMap, dates){
            const canvas = document.getElementById(canvasId); if(!canvas) return; const ctx = canvas.getContext('2d');
            const W=canvas.width, H=canvas.height; ctx.fillStyle='#111827'; ctx.fillRect(0,0,W,H);
            if(!dates.length) return; const margin={top:20,left:50,right:30,bottom:30};
            const cw=W-margin.left-margin.right, ch=H-margin.top-margin.bottom;
            const points = dates.map(d=>{const day=dailyMap[d]; const raw=day?.seismograph?.magnitude||0; const mag=raw/2; // normalize 0-5
                const val=Math.max(-5,Math.min(5,day?.seismograph?.valence||0)); return {d, mag, val};});
            // Scales
            const xStep = cw/(points.length-1);
            // Background grid (magnitude bands)
            ctx.strokeStyle='#374151'; ctx.lineWidth=1; for(let i=0;i<=5;i++){const y=margin.top+ch-(ch*i/5); ctx.beginPath(); ctx.moveTo(margin.left,y); ctx.lineTo(margin.left+cw,y); ctx.stroke(); ctx.fillStyle='#6b7280'; ctx.font='10px Inter'; ctx.fillText(i.toString(), margin.left-20, y+3); }
            // Valence midline
            const midY = margin.top + ch/2; ctx.strokeStyle='#4b5563'; ctx.beginPath(); ctx.moveTo(margin.left, midY); ctx.lineTo(margin.left+cw, midY); ctx.stroke();
            // Magnitude arc (smoothed line)
            ctx.strokeStyle='#14b8a6'; ctx.lineWidth=2; ctx.beginPath();
            points.forEach((p,i)=>{const x=margin.left+i*xStep; const y=margin.top+ch-(p.mag/5)*ch; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);}); ctx.stroke();
            // Valence drift (overlay thin line)
            ctx.strokeStyle='#fbbf24'; ctx.lineWidth=1.5; ctx.beginPath(); points.forEach((p,i)=>{const x=margin.left+i*xStep; const y=midY-(p.val/5)*(ch/2); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);}); ctx.stroke();
            // Points with annotations
            ctx.font='10px Inter'; points.forEach((p,i)=>{const x=margin.left+i*xStep; const y=margin.top+ch-(p.mag/5)*ch; ctx.fillStyle='#0d9488'; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); if(i%Math.ceil(points.length/12)===0||i===points.length-1){ctx.fillStyle='#94a3b8'; ctx.fillText(p.d, x-20, H-8);} // date labels sparse
                // Valence annotation
                ctx.fillStyle='#fbbf24'; ctx.fillText('V:'+(p.val>=0?'+':'')+p.val.toFixed(1), x-14, y-10); });
            // Legend
            ctx.fillStyle='#14b8a6'; ctx.fillRect(margin.left,5,8,8); ctx.fillStyle='#e5e7eb'; ctx.font='11px Inter'; ctx.fillText('Magnitude (0–5)', margin.left+12,13);
            ctx.fillStyle='#fbbf24'; ctx.fillRect(margin.left+140,5,8,8); ctx.fillStyle='#e5e7eb'; ctx.fillText('Valence Path (-5..+5)', margin.left+154,13);
        }

        function drawBarometerChart(canvasId,dailyMap,dates){
            const canvas=document.getElementById(canvasId); if(!canvas) return; const ctx=canvas.getContext('2d');
            const W=canvas.width,H=canvas.height; ctx.fillStyle='#111827'; ctx.fillRect(0,0,W,H); if(!dates.length) return; const margin={top:15,left:50,right:20,bottom:45};
            const cw=W-margin.left-margin.right, ch=H-margin.top-margin.bottom; const barW=Math.max(4, cw/dates.length - 2);
            const points=dates.map(d=>{const day=dailyMap[d]; const raw=day?.seismograph?.magnitude||0; const mag=raw/2; const val=Math.max(-5,Math.min(5,day?.seismograph?.valence||0)); const vol=day?.seismograph?.volatility||0; return {d,mag,val,vol};});
            // Grid
            ctx.strokeStyle='#374151'; ctx.lineWidth=1; for(let i=0;i<=5;i++){const y=margin.top+ch-(ch*i/5); ctx.beginPath(); ctx.moveTo(margin.left,y); ctx.lineTo(margin.left+cw,y); ctx.stroke(); ctx.fillStyle='#6b7280'; ctx.font='10px Inter'; ctx.fillText(i.toString(), margin.left-18, y+3);} // bars
            // Bars
            points.forEach((p,i)=>{const x=margin.left+i*(barW+2); const h=(p.mag/5)*ch; const y=margin.top+ch-h; // volatility shading (higher vol => pattern)
                const col = barometerColorForValence(p.val, p.mag);
                // base fill gradient
                const g=ctx.createLinearGradient(x,y,x,y+h); g.addColorStop(0,col.start); g.addColorStop(1,col.end); ctx.fillStyle=g; ctx.fillRect(x,y,barW,h);
                // volatility overlay stripes
                if(p.vol>2){ const stripeCount = Math.min(12, 4 + Math.floor(p.vol*2)); ctx.save(); ctx.beginPath(); ctx.rect(x,y,barW,h); ctx.clip(); ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; for(let s=0;s<stripeCount;s++){const sy=y + (h/stripeCount)*s; ctx.beginPath(); ctx.moveTo(x, sy); ctx.lineTo(x+barW, sy + 4); ctx.stroke(); } ctx.restore(); }
                // top cap
                ctx.fillStyle=col.cap; ctx.fillRect(x,y,barW,2);
                if(i%Math.ceil(points.length/10)===0||i===points.length-1){ctx.fillStyle='#94a3b8'; ctx.save(); ctx.translate(x+barW/2, H-8); ctx.rotate(-Math.PI/4); ctx.fillText(p.d, -20,0); ctx.restore();}
                // Valence annotation above bar
                ctx.fillStyle=p.val<0? '#f87171':'#fbbf24'; ctx.font='9px Inter'; ctx.fillText('V:'+(p.val>=0?'+':'')+p.val.toFixed(1), x-2, y-4); });
            // Axes labels
            ctx.fillStyle='#e5e7eb'; ctx.font='11px Inter'; ctx.fillText('Magnitude 0–5 (normalized)', margin.left, 12); ctx.fillText('Valence annotated per bar', margin.left+220, 12);
        }

        // --- Barometer Heuristics & Color Helpers (single-day + multi-day styling) ---
        function barometerColorForValence(val, mag){
            // Returns {start,end,cap} with enhanced emotional shading
            // Extreme negative valence: deep storm/friction colors
            if(val <= -4) return {start:'#4c1d15', end:'#991b1b', cap:'#dc2626'}; // deeper storm-gray to red
            if(val <= -3) return {start:'#581c1c', end:'#b91c1c', cap:'#dc2626'}; // original dark red
            if(val < -1) return {start:'#4c1d1d', end:'#7f1d1d', cap:'#991b1b'};
            if(val > 3) return {start:'#064e3b', end:'#059669', cap:'#10b981'};
            if(val > 1) return {start:'#0f766e', end:'#14b8a6', cap:'#0d9488'};
            return {start:'#334155', end:'#475569', cap:'#64748b'}; // neutral
        }

        // =============================================================================
        // SAFE LEXICON MAPPING FUNCTIONS
        // =============================================================================
        
        // Canonical magnitude vocabulary (neutral intensity only) — Balance Meter
        const MAGNITUDE_TERMS = [
            "Dormant / Baseline",
            "Murmur / Whisper",
            "Pulse / Stirring",
            "Surge / Activation",
            "Convergence / Compression",
            "Maximum Threshold / Structural Overload"
        ];
        
        // Canonical valence vocabulary (directional charge with clear positive/negative distinction)
        const VALENCE_TERMS = ["Collapse", "Grind", "Friction", "Contraction", "Drag", "Neutral", "Lift", "Flow", "Harmony", "Expansion", "Liberation"];
        
        function toMagnitudeTerm(mag) {
            // Assumes magnitude normalized to 0–5 for descriptors
            if (mag < 0.5) return "Dormant / Baseline";           // 0
            if (mag < 1.5) return "Murmur / Whisper";             // 1
            if (mag < 2.5) return "Pulse / Stirring";             // 2
            if (mag < 3.5) return "Surge / Activation";           // 3
            if (mag < 4.5) return "Convergence / Compression";    // 4
            return "Maximum Threshold / Structural Overload";     // 5
        }
        
        function toValenceTerm(val) {
            if (val <= -4.5) return "Collapse";
            if (val <= -3.5) return "Grind";
            if (val <= -2.5) return "Friction";
            if (val <= -1.5) return "Contraction";
            if (val < -0.5) return "Drag";
            if (val < 0.5) return "Neutral";
            if (val < 1.5) return "Lift";
            if (val < 2.5) return "Flow";
            if (val < 3.5) return "Harmony";
            if (val < 4.5) return "Expansion";
            return "Liberation";
        }
        
        // Migration function for legacy terms
        function migrateMagnitudeTerm(term) {
            // Map legacy terms to closest new descriptors
            if (/^Field$/i.test(term)) return "Maximum Threshold / Structural Overload";
            if (/^Quake$/i.test(term)) return "Convergence / Compression";
            // Log migration for provenance tracking
            if (window.lastRunStats) {
                window.lastRunStats.legacy_migrations = window.lastRunStats.legacy_migrations || [];
                window.lastRunStats.legacy_migrations.push({term, migrated_to: /^Field$/i.test(term) ? "Maximum Threshold / Structural Overload" : "Convergence / Compression"});
            }
            return term;
        }
        
        // Safety validation - ban unsafe metaphors in magnitude contexts
        function assertSafeMagnitudePhrase(text) {
            const BANNED_IN_MAG = /\b(storm|quake|disaster|tsunami|crash|catastrophe|earthquake)\b/i;
            if (BANNED_IN_MAG.test(text)) {
                console.error("Unsafe metaphor detected in magnitude context:", text);
                throw new Error("Unsafe metaphor in magnitude context: " + text);
            }
        }
        
        // Validation function to ensure safe lexicon is working correctly
        function validateSafeLexicon() {
            try {
                // Test magnitude terms are all safe
                for (let i = 0; i <= 5; i += 0.5) {
                    const term = toMagnitudeTerm(i);
                    assertSafeMagnitudePhrase(term);
                    if (!MAGNITUDE_TERMS.includes(term)) {
                        throw new Error(`Invalid magnitude term: ${term}`);
                    }
                }
                
                // Test valence terms are properly mapped
                for (let i = -5; i <= 5; i += 0.5) {
                    const term = toValenceTerm(i);
                    if (!VALENCE_TERMS.includes(term)) {
                        throw new Error(`Invalid valence term: ${term}`);
                    }
                }
                
                // Test emoji mapping consistency
                for (let i = -5; i <= 5; i += 0.25) {
                    const emoji = getValenceEmoji(i);
                    const type = getValenceType(i);
                    if (!emoji || !type) {
                        throw new Error(`Missing emoji or type for valence: ${i}`);
                    }
                }
                
                console.log("✅ Safe lexicon validation passed - all terms and emojis mapped correctly");
                return true;
            } catch (error) {
                console.error("❌ Safe lexicon validation failed:", error);
                return false;
            }
        }

        // =============================================================================
        // EMOJI VALENCE LEXICON (Directional charge: positive ↗ / negative ↘)
        // =============================================================================
        
        function getValenceEmoji(val, includeAccessibility = false) {
            const clampedVal = Math.max(-5, Math.min(5, val)); // Always clamp to ±5
            let emoji, label;

            // 🌑 Negative Valence Types (↘)
            if (clampedVal <= -4.5) { emoji = '🌋'; label = 'Pressure / Eruption'; }
            else if (clampedVal <= -3.5) { emoji = '⚔️'; label = 'Friction Clash'; }
            else if (clampedVal <= -2.8) { emoji = '♾️'; label = 'Recursion Pull'; }
            else if (clampedVal <= -2.1) { emoji = '↔️'; label = 'Cross Current'; }
            else if (clampedVal <= -1.6) { emoji = '🧩'; label = 'Fragmentation'; }
            else if (clampedVal <= -1.0) { emoji = '🌫️'; label = 'Fog / Dissolution'; }
            else if (clampedVal <= -0.5) { emoji = '🕳️'; label = 'Entropy Drift'; }
            else if (clampedVal < -0.2)  { emoji = '⏳'; label = 'Saturn Weight'; }
            // 🌗 Neutral range
            else if (clampedVal >= -0.2 && clampedVal <= 0.2) { emoji = '🌗'; label = 'Neutral Field'; }
            // 🌞 Positive Valence Types (↗)
            else if (clampedVal <= 0.8) { emoji = '🌱'; label = 'Fertile Field'; }
            else if (clampedVal <= 1.5) { emoji = '⚖️'; label = 'Integration'; }
            else if (clampedVal <= 2.3) { emoji = '🌊'; label = 'Flow Tide'; }
            else if (clampedVal <= 3.1) { emoji = '✨'; label = 'Harmonic Resonance'; }
            else if (clampedVal <= 3.8) { emoji = '🌈'; label = 'Visionary Spark'; }
            else if (clampedVal <= 4.6) { emoji = '🔥'; label = 'Combustion Clarity'; }
            else if (clampedVal <= 4.9) { emoji = '🦋'; label = 'Liberation / Release'; }
            else { emoji = '💎'; label = 'Expansion Lift'; }

            return includeAccessibility ?
                `<span class="valence-emoji" role="img" aria-label="${label}">${emoji}</span>` :
                emoji;
        }

        function getValenceType(val) {
            const v = Math.max(-5, Math.min(5, val));
            // 🌑 Negative Valence Types
            if (v <= -4.5) return 'Pressure / Eruption';
            if (v <= -3.5) return 'Friction Clash';
            if (v <= -2.8) return 'Recursion Pull';
            if (v <= -2.1) return 'Cross Current';
            if (v <= -1.6) return 'Fragmentation';
            if (v <= -1.0) return 'Fog / Dissolution';
            if (v <= -0.5) return 'Entropy Drift';
            if (v <  -0.2) return 'Saturn Weight';

            // 🌗 Neutral range
            if (v >= -0.2 && v <= 0.2) return 'Neutral Field';

            // 🌞 Positive Valence Types
            if (v <= 0.8) return 'Fertile Field';
            if (v <= 1.5) return 'Integration';
            if (v <= 2.3) return 'Flow Tide';
            if (v <= 3.1) return 'Harmonic Resonance';
            if (v <= 3.8) return 'Visionary Spark';
            if (v <= 4.6) return 'Combustion Clarity';
            if (v <= 4.9) return 'Liberation / Release';
            return 'Expansion Lift';
        }

        // =============================================================================
        // BAROMETER HEURISTICS (Updated with Safe Lexicon)
        // =============================================================================

        function generateBarometerHeuristics(mag,val,vol, day){
            // Magnitude label - using safe lexicon (neutral intensity only)
            let magnitudeLabel = toMagnitudeTerm(mag).toLowerCase();
            assertSafeMagnitudePhrase(magnitudeLabel); // Safety validation
            
            // Valence label - enhanced emoji lexicon with directional charge types
            const valenceEmoji = getValenceEmoji(val);
            const valenceType = getValenceType(val);
            let valenceLabel = `${valenceEmoji} ${valenceType}`;
            
            // Volatility label
            let volatilityLabel = vol>=4? 'scattered / spiking' : vol>=3? 'unstable oscillation' : vol>=2? 'variable' : vol>=1? 'settling' : 'steady';
            // Signal tags & glyphs
            const tags=[]; const glyphs=[];
            if(vol>=3) { tags.push('⚡'); glyphs.push('⚡'); }
            if(val<=-3) { tags.push('☍'); if(!glyphs.includes('☍')) glyphs.push('☍'); }
            if(vol>=3 && val<0) { tags.push('⧖'); if(!glyphs.includes('⧖')) glyphs.push('⧖'); }
            const signalTags = tags.join('');
            // Title heuristics - enhanced for extreme states
            let title;
            if(val<=-4.5 && vol>=3) title='Silence with Teeth';
            else if(val<=-4.5) title='Labor Day Misfire';
            else if(mag>=4 && val<=-3) title='Held in the Pause';
            else if(val<=-4) title='Friction Peak';
            else if(vol>=4 && val<0) title='Diffuse Pulse';
            else if(mag<2 && Math.abs(val)<0.5) title='Low Signal Day';
            else if(mag>=3 && val>2) title='Momentum Window';
            else title='Pattern Snapshot';
            // Annotation (short, geometry-sourced descriptors; not narrative voice)
            let annotation;
            if(title==='Silence with Teeth') annotation='Weight held with no return.';
            else if(title==='Labor Day Misfire') annotation='Systems jam; repair mode engaged.';
            else if(title==='Held in the Pause') annotation='Signal drop. Echo instead of response.';
            else if(title==='Friction Peak') annotation='Contact misfires; compression spike.';
            else if(title==='Diffuse Pulse') annotation='Energy disperses; focus splits.';
            else if(title==='Momentum Window') annotation='Supportive current with lift.';
            else if(title==='Low Signal Day') annotation='Minimal activation; baseline field.';
            return {title, annotation, glyphs: glyphs.join(''), magnitudeLabel, valenceLabel, volatilityLabel, signalTags, signalLabel:'composite flags'};
        }

        // =============================================================================
        // END SEISMOGRAPH FUNCTIONS
        // =============================================================================

                // Re-render hooks only (without round-trip) when filters change
                function rerenderHookMarkdownSection(){
                        if(!latestResultData) return;
                        try {
                            const full = generateMarkdownReport(latestResultData);
                            reportContent.textContent = full;
                        } catch(e){ console.warn('Re-render failed', e); }
                }

        function generateFilename(extension, data) {
            const formData = collectFormData();
            const personA = formData.personA.name.replace(/[^a-zA-Z0-9]/g, '') || 'PersonA';
            const personB = formData.personB?.name?.replace(/[^a-zA-Z0-9]/g, '') || '';
            const mode = formData.context.mode;
            const today = new Date().toISOString().split('T')[0];
            
            let filename = `WovenMap_${personA}`;
            if (personB) filename += `_${personB}`;
            
            // Include date range for transit modes
            if (mode.includes('transits')) {
                const start = formData.transitParams?.startDate || today;
                const end = formData.transitParams?.endDate || start;
                if (start === end) {
                    filename += `_${mode}_${start}`;
                } else {
                    filename += `_${mode}_${start}_to_${end}`;
                }
            } else {
                filename += `_${mode}_${today}`;
            }
            
            return `${filename}.${extension}`;
        }

        function parseCoordinates(coordString) {
            if (!coordString) return { latitude: undefined, longitude: undefined };
            
            coordString = coordString.trim();
            const decimalPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$/;
            const dmsPattern = /(\d+)[°\s]+(\d+)'?\s*([NS]),\s*(\d+)[°\s]+(\d+)'?\s*([EW])/i;

            console.log("Parsing coordinates:", coordString);

            if (decimalPattern.test(coordString)) {
                const [lat, lon] = coordString.split(',').map(s => parseFloat(s.trim()));
                console.log("Parsed decimal coordinates:", { latitude: lat, longitude: lon });
                return { latitude: lat, longitude: lon };
            }

            const dmsMatch = coordString.match(dmsPattern);
            if (dmsMatch) {
                let lat = parseFloat(dmsMatch[1]) + parseFloat(dmsMatch[2]) / 60;
                if (dmsMatch[3].toUpperCase() === 'S') lat = -lat;

                let lon = parseFloat(dmsMatch[4]) + parseFloat(dmsMatch[5]) / 60;
                if (dmsMatch[6].toUpperCase() === 'W') lon = -lon;
                
                console.log("Parsed DMS coordinates:", { latitude: lat, longitude: lon });
                return { latitude: parseFloat(lat.toFixed(4)), longitude: parseFloat(lon.toFixed(4)) };
            }
            
            console.error("Failed to parse coordinates:", coordString);
            // Return undefined if no pattern matches
            return { latitude: undefined, longitude: undefined };
        }

        // --- Form Logic ---

        function validateForm() {
            hideError();
            
            // Mobile debugging - log form data collection
            console.log('=== FORM VALIDATION START ===');
            console.log('User agent:', navigator.userAgent);
            console.log('Screen dimensions:', window.screen.width, 'x', window.screen.height);
            console.log('Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
            
            const modeSel = document.querySelector('input[name="contextMode"]:checked');
            const mode = modeSel ? modeSel.value : (currentContextType === 'weather' ? 'sky_transits' : 'natal_transits');
            const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value;
            const intimacyTier = document.querySelector('input[name="intimacyTier"]:checked')?.value;
            const roleSel = document.getElementById('relationshipRole');
            const roleCustomInput = document.getElementById('relationshipRoleCustom');
            const roleValueRaw = roleSel ? roleSel.value : '';

            // Weather-only: skip personal validation; validate only date range
            if (currentContextType === 'weather') {
                // Validate transit dates only
                const start = transitStartDate.value;
                const end = transitEndDate.value;
                if (!start || !end) {
                    showError('Please enter both start and end dates for planetary weather analysis');
                    return false;
                }
                if (end < start) {
                    showError('End date must be after or equal to start date');
                    return false;
                }
                // Date range + step limits as usual
                const startDate = new Date(start);
                const endDate = new Date(end);
                const daySpan = Math.max(1, Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
                const stepSize = transitStep.value || '1d';
                const stepKey = (stepSize === '7d' || stepSize === 'weekly') ? 'weekly'
                                 : (stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly') ? 'monthly'
                                 : 'daily';
                const limits = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]) || { max: 45, warnRatio: 0.8, label: 'calculations' };
                if (daySpan > limits.max) {
                    const limitsMsg = `Daily=${(window.WOVEN_STEP_LIMITS?.daily?.max)||45} days max, Weekly=${Math.round(((window.WOVEN_STEP_LIMITS?.weekly?.max)||270)/30)} months max, Monthly=${Math.round(((window.WOVEN_STEP_LIMITS?.monthly?.max)||550)/30)} months max`;
                    showError(`Date range of ${daySpan} days exceeds the ${limits.max}-day limit for ${limits.label}. Please shorten the range or use weekly/monthly.`);
                    return false;
                }
                const warningDays = Math.floor(limits.max * (limits.warnRatio || 0.8));
                if (daySpan > warningDays) {
                    const actualSteps = stepSize === '7d' || stepSize === 'weekly' ? Math.ceil(daySpan / 7)
                                       : stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? Math.ceil(daySpan / 30)
                                       : daySpan;
                    const proceed = confirm(`Date range is ${daySpan} days (~${actualSteps} ${limits.label}). This may be slower. Continue?`);
                    if (!proceed) return false;
                }
                return true;
            }

            // Validate Person A
            const nameA = document.getElementById('nameA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();

            // Mobile debugging - log raw values
            console.log('Person A form values:');
            console.log('- Name:', nameA);
            console.log('- Date (raw):', dateA);
            console.log('- Time (raw):', timeA);
            console.log('- Coordinates (raw):', astroA);
            console.log('- Date field type:', document.getElementById('birth_dateA').type);
            console.log('- Date field value:', document.getElementById('birth_dateA').value);

            if (!nameA || !dateA || !timeA || !astroA) {
                console.error('Missing required fields:', { nameA: !!nameA, dateA: !!dateA, timeA: !!timeA, astroA: !!astroA });
                showError('Please fill in all required fields for Person A');
                return false;
            }
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateA)) {
                console.error('Date format validation failed. Expected YYYY-MM-DD, got:', dateA);
                showError('Please enter Person A date in YYYY-MM-DD format');
                return false;
            }
            if (!/^\d{2}:\d{2}$/.test(timeA)) {
                showError('Please enter Person A time in HH:MM format (24-hour)');
                return false;
            }
            const coordsA = parseCoordinates(astroA);
            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                showError('Please enter Person A coordinates in a valid decimal (e.g., 40.01, -75.31) or DMS format (e.g., 40°1\'N, 75°18\'W)');
                return false;
            }

            // Validate Person B if required by mode
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                const nameB = document.getElementById('nameB').value.trim();
                const dateB = document.getElementById('birth_dateB').value.trim();
                const timeB = document.getElementById('birth_timeB').value.trim();
                const astroB = document.getElementById('astroB').value.trim();
                if (!nameB || !dateB || !timeB || !astroB) {
                    showError(`Please fill in all required fields for Person B for ${mode} analysis`);
                    return false;
                }
                if (!/^\d{4}-\d{2}-\d{2}$/.test(dateB)) {
                    showError('Please enter Person B date in YYYY-MM-DD format');
                    return false;
                }
                if (!/^\d{2}:\d{2}$/.test(timeB)) {
                    showError('Please enter Person B time in HH:MM format (24-hour)');
                    return false;
                }
                const coordsB = parseCoordinates(astroB);
                if (coordsB.latitude === undefined || coordsB.longitude === undefined) {
                    showError('Please enter Person B coordinates in a valid decimal or DMS format');
                    return false;
                }
            }

            // Validate transit dates if required by mode (skip for natal_only)
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits') {
                const start = transitStartDate.value;
                const end = transitEndDate.value;
                if (!start || !end) {
                    showError('Please enter both start and end dates for transit analysis');
                    return false;
                }
                if (end < start) {
                    showError('End date must be after or equal to start date');
                    return false;
                }

                // Date range validation with step size awareness
                const startDate = new Date(start);
                const endDate = new Date(end);
                const daySpan = Math.max(1, Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
                const stepSize = transitStep.value || '1d';
                
                // Define maximum ranges based on centralized limits (configurable)
                let maxDays, warningDays, stepDescription;
                const stepKey = (stepSize === '7d' || stepSize === 'weekly') ? 'weekly'
                                 : (stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly') ? 'monthly'
                                 : 'daily';
                const limits = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]) || { max: 45, warnRatio: 0.8, label: 'calculations' };
                maxDays = limits.max;
                warningDays = Math.floor(limits.max * (limits.warnRatio || 0.8));
                stepDescription = limits.label || 'calculations';

                // Hard limit validation
                if (daySpan > maxDays) {
                    const limitsMsg = `Daily=${(window.WOVEN_STEP_LIMITS?.daily?.max)||45} days max, Weekly=${Math.round(((window.WOVEN_STEP_LIMITS?.weekly?.max)||270)/30)} months max, Monthly=${Math.round(((window.WOVEN_STEP_LIMITS?.monthly?.max)||550)/30)} months max`;
                    showError(`Date range of ${daySpan} days exceeds the ${maxDays}-day limit for ${stepDescription}. Please use a shorter range or change the step size to weekly/monthly for longer periods. (API Protection: ${limitsMsg})`);
                    return false;
                }

                // Warning for longer ranges that might be slow
                if (daySpan > warningDays) {
                    const actualSteps = stepSize === '7d' || stepSize === 'weekly' ? Math.ceil(daySpan / 7) :
                                       stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? Math.ceil(daySpan / 30) :
                                       daySpan;
                    
                    const proceed = confirm(
                        `Date range is ${daySpan} days (approximately ${actualSteps} ${stepDescription}).\n\n` +
                        `This may take longer to process and generate a large amount of data.\n\n` +
                        `Consider using:\n` +
                        `• Weekly step size for longer ranges\n` +
                        `• Monthly step size for ranges over 6 months\n\n` +
                        `Continue with current settings?`
                    );
                    if (!proceed) return false;
                }

                // Helpful suggestion for very short ranges with loose step sizes
                if (daySpan <= 7 && (stepSize === '7d' || stepSize === 'weekly')) {
                    const useDailyInstead = confirm(
                        `Your date range is only ${daySpan} days, but you've selected weekly calculations.\n\n` +
                        `For better detail in short ranges, would you like to switch to daily calculations instead?`
                    );
                    if (useDailyInstead) {
                        transitStep.value = '1d';
                    }
                }
            }

            // Validate relocation coordinates if enabled
            if (relocationToggle.checked) {
                const relocationCoords = relocationCoordsInput.value.trim();
                if (!relocationCoords) {
                    showError('Please enter relocation coordinates when overlay is enabled');
                    return false;
                }
                const coordsR = parseCoordinates(relocationCoords);
                if (coordsR.latitude === undefined || coordsR.longitude === undefined) {
                    showError('Please enter valid relocation coordinates in decimal or DMS format');
                    return false;
                }
            }

            // Relationship context validation for synastry/composite modes
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                if (!relationshipType) {
                    showError('Please specify the relationship type for synastry/composite analysis');
                    return false;
                }
                
                // Partner requires intimacy tier
                if (relationshipType === 'partner') {
                    if (!intimacyTier) {
                        showError('Please select an intimacy tier for partner relationships');
                        return false;
                    }
                }
                
                // Family requires role
                if (relationshipType === 'family') {
                    if (!roleValueRaw) {
                        showError('Please specify the family role for family relationships');
                        return false;
                    }
                    if (roleValueRaw === 'other') {
                        const customVal = roleCustomInput?.value?.trim();
                        if (!customVal) {
                            showError('Please provide a custom family role description');
                            return false;
                        }
                    }
                }
                
                // Friend allows optional role but validates if provided
                if (relationshipType === 'friend' && roleValueRaw === 'other') {
                    const customVal = roleCustomInput?.value?.trim();
                    if (!customVal) {
                        showError('Please provide a custom friend role description or select "Other"');
                        return false;
                    }
                }
            }

            // Legacy relationship validation (for existing patterns)
            if (relationshipType === 'partner') {
                if (!intimacyTier) {
                    showError('Select an intimacy tier for partner relationships');
                    return false;
                }
            }
            if (relationshipType && relationshipType !== 'partner') {
                if (roleSel && roleValueRaw === 'other') {
                    const customVal = roleCustomInput?.value?.trim();
                    if (!customVal) {
                        showError('Provide a custom role description');
                        return false;
                    }
                }
            }
            if (relationshipType === 'partner' && roleSel && roleValueRaw) {
                console.warn('Role value ignored for partner type');
            }
            return true;
        }

        // Helper function to determine mode based on active tab
        function getCurrentActiveTabMode() {
            // Check which tab is currently active
            const mirrorTab = document.getElementById('mirrorModeTab');
            const balanceMeterTab = document.getElementById('balanceMeterModeTab');
            
            // Check aria-selected attribute to determine active tab
            if (balanceMeterTab?.getAttribute('aria-selected') === 'true') {
                return 'balance_meter';
            }
            
            // Fallback: check if Balance Meter checkbox is checked (for legacy compatibility)
            if (document.getElementById('balanceMeterMode')?.checked) {
                return 'balance_meter';
            }
            
            // Default to checking context mode radios for relational modes
            const contextModeChecked = document.querySelector('input[name="contextMode"]:checked');
            return contextModeChecked?.value || 'natal_transits';
        }

        function collectFormData() {
            console.log("=== COLLECTING FORM DATA ===");

            // Sky-only: build minimal payload (no natal, no houses/angles)
            if (currentContextType === 'weather') {
                const startDateElement = document.getElementById('transitStartDate');
                const endDateElement = document.getElementById('transitEndDate');
                const stepElement = document.getElementById('transitStep');
                const transitParams = (startDateElement && endDateElement && stepElement) ? {
                    startDate: startDateElement.value,
                    endDate: endDateElement.value,
                    step: stepElement.value || '1d'
                } : null;
                const formData = {
                    context: { mode: 'sky_transits' }
                };
                if (transitParams) formData.transitParams = transitParams;
                console.log('Sky-only payload:', JSON.stringify(formData));
                return formData;
            }
            
            // Person A - Get raw form values first
            const nameA = document.getElementById('nameA').value.trim();
            const cityA = document.getElementById('birth_cityA').value.trim();
            const stateA = document.getElementById('birth_stateA').value.trim();
            const countryA = document.getElementById('birth_countryA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();
            const zodiacA = document.getElementById('zodiacA').value;
            const timezoneA = document.getElementById('offsetA').value;

            console.log("Raw form values for Person A:");
            console.log("- Name:", nameA);
            console.log("- City:", cityA);
            console.log("- State:", stateA);
            console.log("- Country:", countryA);
            console.log("- Date:", dateA);
            console.log("- Time:", timeA);
            console.log("- Coordinates:", astroA);
            console.log("- Zodiac:", zodiacA);
            console.log("- Timezone:", timezoneA);

            // Parse date and time
            if (!dateA || !timeA) {
                console.error("Missing date or time for Person A");
                throw new Error("Date and time are required for Person A");
            }

            const [yearA, monthA, dayA] = dateA.split('-').map(Number);
            const [hourA, minuteA] = timeA.split(':').map(Number);

            console.log("Parsed date/time:", { yearA, monthA, dayA, hourA, minuteA });

            // Parse coordinates
            const coordsA = parseCoordinates(astroA);
            console.log("Parsed coordinates:", coordsA);

            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                console.error("Failed to parse coordinates for Person A");
                throw new Error("Valid coordinates are required for Person A");
            }

            const personA = {
                name: nameA || "Unknown",
                city: cityA || "Unknown",
                nation: countryA || "US",
                year: yearA,
                month: monthA, 
                day: dayA, 
                hour: hourA, 
                minute: minuteA,
                latitude: coordsA.latitude, 
                longitude: coordsA.longitude,
                zodiac_type: zodiacA || "Tropic",
                timezone: timezoneA || "America/New_York"
            };
            
            console.log("Final Person A data:", personA);
            
            // Validate all required fields are present and not undefined
            const requiredFields = ['year', 'month', 'day', 'hour', 'minute', 'name', 'city', 'nation', 'latitude', 'longitude', 'zodiac_type', 'timezone'];
            const missingFields = requiredFields.filter(field => {
                const value = personA[field];
                return value === undefined || value === null || value === "";
            });
            
            if (missingFields.length > 0) {
                console.error("Missing required fields for Person A:", missingFields);
                console.error("Current Person A object:", personA);
                throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
            }

            // Person B - only if fields are filled
            const dateB_val = document.getElementById('birth_dateB').value;
            const timeB_val = document.getElementById('birth_timeB').value.trim();
            const coordsB_val = document.getElementById('astroB').value.trim();
            let personB = null;

            if (dateB_val && timeB_val && coordsB_val) {
                console.log("Processing Person B data...");
                const coordsB = parseCoordinates(coordsB_val);
                if (coordsB.latitude !== undefined && coordsB.longitude !== undefined) {
                    const [yearB, monthB, dayB] = dateB_val.split('-').map(Number);
                    const [hourB, minuteB] = timeB_val.split(':').map(Number);
                    personB = {
                        name: document.getElementById('nameB').value.trim() || "Unknown",
                        city: document.getElementById('birth_cityB').value.trim() || "Unknown",
                        nation: document.getElementById('birth_countryB').value.trim() || "US",
                        year: yearB, 
                        month: monthB, 
                        day: dayB, 
                        hour: hourB, 
                        minute: minuteB,
                        latitude: coordsB.latitude,
                        longitude: coordsB.longitude,
                        zodiac_type: document.getElementById('zodiacB').value || "Tropic",
                        timezone: document.getElementById('offsetB').value || "America/New_York"
                    };
                    console.log("Person B data:", personB);
                }
            }

            const formData = {
                personA,
                personB: personB,
                context: {
                    mode: getCurrentActiveTabMode(),
                    relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value,
                    intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value,
                    contact_channel: document.querySelector('input[name="contactChannel"]:checked')?.value,
                    is_ex_relationship: exRelationshipCheckbox?.checked || false
                }
            };

            // Add relationship_context for synastry/composite modes
            const relType = formData.context.relationship_type;
            const isRelationalMode = formData.context.mode && 
                (formData.context.mode.includes('synastry') || formData.context.mode.includes('composite'));
            
            if (isRelationalMode && relType) {
                const relContext = { 
                    type: relType.toUpperCase() 
                };
                
                // Add required fields based on type
                if (relType === 'partner') {
                    const tier = formData.context.intimacy_tier;
                    if (tier) relContext.intimacy_tier = tier;
                } else if (relType === 'family') {
                    const role = document.getElementById('relationshipRole')?.value;
                    if (role && role !== 'other') relContext.role = role;
                    else if (role === 'other') {
                        const customRole = document.getElementById('relationshipRoleCustom')?.value?.trim();
                        if (customRole) relContext.role = 'Custom';
                    }
                } else if (relType === 'friend') {
                    const role = document.getElementById('relationshipRole')?.value;
                    if (role && role !== 'other') relContext.role = role;
                    else if (role === 'other') {
                        const customRole = document.getElementById('relationshipRoleCustom')?.value?.trim();
                        if (customRole) relContext.role = 'Custom';
                    }
                }
                
                // Ex/Estranged flag (not for friends)
                if (relType !== 'friend' && exRelationshipCheckbox?.checked) {
                    relContext.ex_estranged = true;
                }
                
                // Notes
                const notes = document.getElementById('relationshipNotes')?.value?.trim();
                if (notes) relContext.notes = notes;
                
                formData.relationship_context = relContext;
            }

            if (relocationToggle && relocationToggle.checked) {
                const rawReloc = document.getElementById('relocationCoords').value.trim();
                const parsedReloc = parseLatLonFlexible ? parseLatLonFlexible(rawReloc) : null;
                if (parsedReloc) {
                    formData.relocation = {
                        enabled: true,
                        city: document.getElementById('relocationCity').value.trim(),
                        state: document.getElementById('relocationState').value.trim(),
                        latitude: parsedReloc.lat,
                        longitude: parsedReloc.lon,
                        input: rawReloc,
                        normalized: parsedReloc.normalized,
                        excludePersonB: !(document.getElementById('includePersonBRelocation')?.checked)
                    };
                } else {
                    // Fallback to legacy parseCoordinates if available
                    try {
                        const legacy = parseCoordinates(rawReloc);
                        if (legacy && legacy.latitude !== undefined) {
                            formData.relocation = {
                                enabled: true,
                                city: document.getElementById('relocationCity').value.trim(),
                                state: document.getElementById('relocationState').value.trim(),
                                latitude: legacy.latitude,
                                longitude: legacy.longitude,
                                input: rawReloc,
                                normalized: `${legacy.latitude}, ${legacy.longitude}`,
                                excludePersonB: !(document.getElementById('includePersonBRelocation')?.checked)
                            };
                        } else {
                            formData.relocation = { enabled: true, invalid: true, input: rawReloc };
                        }
                    } catch(e){
                        formData.relocation = { enabled: true, invalid: true, input: rawReloc };
                    }
                }
            } else {
                formData.relocation = { enabled: false };
            }

            const mode = formData.context.mode;
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits' || mode === 'balance_meter') {
                const startDateElement = document.getElementById('transitStartDate');
                const endDateElement = document.getElementById('transitEndDate');
                const stepElement = document.getElementById('transitStep');
                
                console.log('=== FRONTEND TRANSIT DEBUG ===');
                console.log('Transit mode detected (including balance_meter):', mode);
                console.log('Start date element:', startDateElement, 'Value:', startDateElement?.value);
                console.log('End date element:', endDateElement, 'Value:', endDateElement?.value);
                console.log('Step element:', stepElement, 'Value:', stepElement?.value);
                
                if (startDateElement && endDateElement && stepElement) {
                    formData.transitParams = {
                        startDate: startDateElement.value,
                        endDate: endDateElement.value,
                        step: stepElement.value
                    };
                    
                    console.log('Transit data added to form:', formData.transitParams);
                } else {
                    console.log('WARNING: Transit elements not found or missing values');
                }
                console.log('=== END FRONTEND TRANSIT DEBUG ===');
            } else if (mode === 'natal_only') {
                console.log('=== NATAL ONLY MODE ===');
                console.log('Skipping transit parameter collection for natal_only mode');
                // No transit parameters needed for natal_only mode
                console.log('=== END NATAL ONLY MODE ===');
            }

            // Relationship role & notes capture
            const roleSel = document.getElementById('relationshipRole');
            const roleCustom = document.getElementById('relationshipRoleCustom');
            const roleVal = roleSel ? (roleSel.value === 'other' ? (roleCustom?.value?.trim() || '') : roleSel.value) : '';
            const notesVal = document.getElementById('relationshipNotes')?.value?.trim() || '';
            // Backward compatibility: normalize 'child' -> 'offspring'
            formData.context.relationship_role = (roleVal === 'child') ? 'offspring' : roleVal;
            formData.context.relationship_notes = notesVal;
            // Mutual exclusivity & cleanup
            const t = formData.context.relationship_type;
            if (t === 'partner') {
                formData.context.relationship_role = null;
            } else {
                formData.context.intimacy_tier = null;
            }
            if (t === 'friend' && formData.context.is_ex_relationship) {
                formData.context.is_ex_relationship = false; // clear ex for friend
            }
            console.log("=== FINAL FORM DATA ===");
            console.log(JSON.stringify(formData, null, 2));
            return formData;
        }

        // --- Save/Load Functions ---

        function saveChartData() {
            try {
                // Collect all form data
                const chartData = {
                    timestamp: new Date().toISOString(),
                    version: "1.0",
                    contextType: currentContextType,
                    personA: {
                        name: document.getElementById('nameA')?.value || '',
                        birth_city: document.getElementById('birth_cityA')?.value || '',
                        birth_state: document.getElementById('birth_stateA')?.value || '',
                        birth_date: document.getElementById('birth_dateA')?.value || '',
                        birth_time: document.getElementById('birth_timeA')?.value || '',
                        birth_country: document.getElementById('birth_countryA')?.value || '',
                        astro: document.getElementById('astroA')?.value || '',
                        offset: document.getElementById('offsetA')?.value || '',
                        zodiac: document.getElementById('zodiacA')?.value || ''
                    },
                    personB: {
                        name: document.getElementById('nameB')?.value || '',
                        birth_city: document.getElementById('birth_cityB')?.value || '',
                        birth_state: document.getElementById('birth_stateB')?.value || '',
                        birth_date: document.getElementById('birth_dateB')?.value || '',
                        birth_time: document.getElementById('birth_timeB')?.value || '',
                        birth_country: document.getElementById('birth_countryB')?.value || '',
                        astro: document.getElementById('astroB')?.value || '',
                        offset: document.getElementById('offsetB')?.value || '',
                        zodiac: document.getElementById('zodiacB')?.value || ''
                    },
                    relationalContext: {
                        relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value || '',
                        intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value || '',
                        contact_channel: document.querySelector('input[name="contactChannel"]:checked')?.value || '',
                        relationship_role: document.getElementById('relationshipRole')?.value || '',
                        relationship_role_custom: document.getElementById('relationshipRoleCustom')?.value || '',
                        relationship_notes: document.getElementById('relationshipNotes')?.value || '',
                        is_ex_relationship: document.getElementById('exRelationship')?.checked || false
                    },
                    transitParams: {
                        startDate: document.getElementById('transitStartDate')?.value || '',
                        endDate: document.getElementById('transitEndDate')?.value || '',
                        step: document.getElementById('transitStep')?.value || ''
                    },
                    relocation: {
                        enabled: document.getElementById('relocationToggle')?.checked || false,
                        coords: document.getElementById('relocationCoords')?.value || '',
                        includePersonB: document.getElementById('includePersonBRelocation')?.checked || false
                    },
                    contextMode: {
                        solo: document.querySelector('input[name="soloSubtype"]:checked')?.value || '',
                        relational: document.querySelector('input[name="relationalSubtype"]:checked')?.value || ''
                    }
                };

                // Generate filename with names and timestamp
                const nameA = chartData.personA.name || 'PersonA';
                const nameB = chartData.personB.name;
                const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                
                let filename;
                if (nameB && currentContextType === 'relational') {
                    filename = `math_brain_${nameA}_${nameB}_${timestamp}.json`;
                } else {
                    filename = `math_brain_${nameA}_${timestamp}.json`;
                }

                // Create and download file
                const dataStr = JSON.stringify(chartData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // Visual feedback
                const saveBtn = document.getElementById('saveDataBtn');
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '✅ Saved!';
                setTimeout(() => { saveBtn.textContent = originalText; }, 2000);

            } catch (error) {
                console.error('Error saving chart data:', error);
                alert('Error saving chart data: ' + error.message);
            }
        }

        function loadChartData(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const chartData = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!chartData.personA || !chartData.personB) {
                        throw new Error('Invalid chart data format');
                    }

                    // Set a flag to indicate we're loading data (to prevent clearing relationship selections)
                    window.isLoadingChartData = true;

                    // Load Person A data
                    if (chartData.personA) {
                        document.getElementById('nameA').value = chartData.personA.name || '';
                        document.getElementById('birth_cityA').value = chartData.personA.birth_city || '';
                        document.getElementById('birth_stateA').value = chartData.personA.birth_state || '';
                        document.getElementById('birth_dateA').value = chartData.personA.birth_date || '';
                        document.getElementById('birth_timeA').value = chartData.personA.birth_time || '';
                        document.getElementById('birth_countryA').value = chartData.personA.birth_country || '';
                        document.getElementById('astroA').value = chartData.personA.astro || '';
                        if (chartData.personA.offset) document.getElementById('offsetA').value = chartData.personA.offset;
                        if (chartData.personA.zodiac) document.getElementById('zodiacA').value = chartData.personA.zodiac;
                    }

                    // Load Person B data
                    if (chartData.personB) {
                        document.getElementById('nameB').value = chartData.personB.name || '';
                        document.getElementById('birth_cityB').value = chartData.personB.birth_city || '';
                        document.getElementById('birth_stateB').value = chartData.personB.birth_state || '';
                        document.getElementById('birth_dateB').value = chartData.personB.birth_date || '';
                        document.getElementById('birth_timeB').value = chartData.personB.birth_time || '';
                        document.getElementById('birth_countryB').value = chartData.personB.birth_country || '';
                        document.getElementById('astroB').value = chartData.personB.astro || '';
                        if (chartData.personB.offset) document.getElementById('offsetB').value = chartData.personB.offset;
                        if (chartData.personB.zodiac) document.getElementById('zodiacB').value = chartData.personB.zodiac;
                    }

                    // Load context type
                    if (chartData.contextType) {
                        const contextRadio = document.querySelector(`input[name="contextType"][value="${chartData.contextType}"]`);
                        if (contextRadio) {
                            contextRadio.checked = true;
                            updateContextType(chartData.contextType);
                        }
                    }

                    // Load relational context AFTER context type is set
                    setTimeout(() => {
                        if (chartData.relationalContext) {
                            const rel = chartData.relationalContext;
                            
                            // Temporarily enable relationship controls for data loading
                            const relationshipControls = document.querySelectorAll('input[name="relationshipType"], input[name="intimacyTier"], #exRelationship');
                            relationshipControls.forEach(control => {
                                control.disabled = false;
                                if (control.parentElement) {
                                    control.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                                }
                            });
                            
                            if (rel.relationship_type) {
                                const typeRadio = document.querySelector(`input[name="relationshipType"][value="${rel.relationship_type}"]`);
                                if (typeRadio) {
                                    typeRadio.checked = true;
                                    typeRadio.dispatchEvent(new Event('change'));
                                }
                            }
                            if (rel.intimacy_tier) {
                                const tierRadio = document.querySelector(`input[name="intimacyTier"][value="${rel.intimacy_tier}"]`);
                                if (tierRadio) tierRadio.checked = true;
                            }
                            if (rel.contact_channel) {
                                const channelRadio = document.querySelector(`input[name="contactChannel"][value="${rel.contact_channel}"]`);
                                if (channelRadio) channelRadio.checked = true;
                            }
                            if (rel.relationship_role) {
                                const roleSelect = document.getElementById('relationshipRole');
                                if (roleSelect) roleSelect.value = rel.relationship_role;
                            }
                            if (rel.relationship_role_custom) {
                                document.getElementById('relationshipRoleCustom').value = rel.relationship_role_custom;
                            }
                            if (rel.relationship_notes) {
                                document.getElementById('relationshipNotes').value = rel.relationship_notes;
                            }
                            if (rel.is_ex_relationship) {
                                document.getElementById('exRelationship').checked = rel.is_ex_relationship;
                            }
                        }
                        
                        // Clear the loading flag and re-evaluate visibility
                        window.isLoadingChartData = false;
                        if (window.evaluateRelationalContextVisibility) {
                            window.evaluateRelationalContextVisibility();
                        }
                    }, 100);

                    // Load transit params
                    if (chartData.transitParams) {
                        const trans = chartData.transitParams;
                        if (trans.startDate) document.getElementById('transitStartDate').value = trans.startDate;
                        if (trans.endDate) document.getElementById('transitEndDate').value = trans.endDate;
                        if (trans.step) document.getElementById('transitStep').value = trans.step;
                    }

                    // Load relocation
                    if (chartData.relocation) {
                        const reloc = chartData.relocation;
                        if (reloc.enabled) document.getElementById('relocationToggle').checked = true;
                        if (reloc.coords) document.getElementById('relocationCoords').value = reloc.coords;
                        if (reloc.includePersonB) document.getElementById('includePersonBRelocation').checked = true;
                    }

                    // Trigger relational context visibility check
                    if (window.evaluateRelationalContextVisibility) {
                        setTimeout(window.evaluateRelationalContextVisibility, 100);
                    }

                    // Visual feedback
                    const loadBtn = document.getElementById('loadDataBtn');
                    const originalText = loadBtn.textContent;
                    loadBtn.textContent = '✅ Loaded!';
                    setTimeout(() => { loadBtn.textContent = originalText; }, 2000);

                } catch (error) {
                    console.error('Error loading chart data:', error);
                    alert('Error loading chart data: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // --- Health Data Integration Functions ---

        function parseHealthAutoExportJSON(healthData) {
            // Auto-detect & normalize Health Auto Export variants (focus: stateOfMind, HRV, Resting HR, Sleep)
            try {
                if (!healthData || !healthData.data) return {};
                const raw = healthData.data;
                const metrics = {};

                const addMetricPoint = (metricKey, dateISO, value, extra={}) => {
                    if (value == null || isNaN(value)) return;
                    if (!metrics[metricKey]) metrics[metricKey] = [];
                    metrics[metricKey].push({ date: dateISO, value: +value, ...extra });
                };

                const toDateKey = (ts) => {
                    if (!ts) return null;
                    // Accept direct YYYY-MM-DD
                    if (typeof ts === 'string' && ts.length === 10 && /\d{4}-\d{2}-\d{2}/.test(ts)) return ts;
                    // Use Central time to compute calendar day
                    const d = new Date(ts);
                    if (isNaN(d)) return null;
                    try {
                        const fmt = new Intl.DateTimeFormat('en-CA', {
                            timeZone: 'America/Chicago', year: 'numeric', month: '2-digit', day: '2-digit'
                        });
                        return fmt.format(d); // en-CA yields YYYY-MM-DD
                    } catch(_) {
                        // Fallback to local if Intl/timeZone not available
                        const year = d.getFullYear();
                        const m = String(d.getMonth()+1).padStart(2,'0');
                        const day = String(d.getDate()).padStart(2,'0');
                        return `${year}-${m}-${day}`;
                    }
                };

                // 1. State of Mind (mood / emotion) → mood_valence
                if (Array.isArray(raw.stateOfMind)) {
                    const daily = {};
                    raw.stateOfMind.forEach(entry => {
                        const dateKey = toDateKey(entry.start || entry.date || entry.end);
                        if (!dateKey) return;
                        if (!daily[dateKey]) {
                            daily[dateKey] = {
                                totalValence: 0,
                                count: 0,
                                labels: new Set(),
                                associations: new Set(),
                                classifications: {}
                            };
                        }
                        const bucket = daily[dateKey];
                        if (typeof entry.valence === 'number') {
                            bucket.totalValence += entry.valence;
                            bucket.count += 1;
                        }
                        (entry.labels||[]).forEach(l => bucket.labels.add(l));
                        (entry.associations||[]).forEach(a => bucket.associations.add(a));
                        const cls = entry.valenceClassification || 'unclassified';
                        bucket.classifications[cls] = (bucket.classifications[cls]||0)+1;
                    });
                    Object.entries(daily).forEach(([date, aggr]) => {
                        const avg = aggr.count ? aggr.totalValence / aggr.count : null;
                        if (avg != null) {
                            // Determine dominant classification
                            let dominantCls = null, maxC = -1;
                            Object.entries(aggr.classifications).forEach(([cls,c]) => { if (c>maxC){dominantCls=cls;maxC=c;} });
                            addMetricPoint('mood_valence', date, avg, {
                                classification: dominantCls,
                                labels: Array.from(aggr.labels),
                                associations: Array.from(aggr.associations)
                            });
                        }
                    });
                }

                // 2. Generic metrics array (some exports) → expects [{ name, units, data:[{date,value}]}]
                if (Array.isArray(raw.metrics)) {
                    raw.metrics.forEach(metric => {
                        if (!metric || !metric.name || !Array.isArray(metric.data)) return;
                        const keyNorm = metric.name.toLowerCase();
                        let targetKey = null;
                        if (keyNorm.includes('variability') || keyNorm.includes('hrv')) targetKey = 'hrv';
                        else if (keyNorm.includes('rest') && keyNorm.includes('heart')) targetKey = 'resting_hr';
                        else if (keyNorm.includes('sleep')) targetKey = 'sleep_hours';
                        else return; // ignore others for now
                        metric.data.forEach(dp => {
                            const dateKey = toDateKey(dp.date);
                            if (!dateKey) return;
                            let val = dp.value ?? dp.qty;
                            if (val == null) return;
                            if (targetKey === 'sleep_hours' && dp.durationMinutes) {
                                val = dp.durationMinutes / 60;
                            }
                            addMetricPoint(targetKey, dateKey, val, { unit: metric.units });
                        });
                    });
                }

                // 3. Sleep sessions (alternate structure) → sleep_hours
                // Accept keys like sleepSessions / sleep / sleepData
                const sleepContainer = raw.sleepSessions || raw.sleep || raw.sleepData;
                if (Array.isArray(sleepContainer)) {
                    const byDate = {};
                    sleepContainer.forEach(s => {
                        const start = new Date(s.start || s.begin || s.startDate);
                        const end = new Date(s.end || s.finish || s.endDate);
                        if (isNaN(start) || isNaN(end)) return;
                        const durationH = Math.max(0,(end - start) / (1000*60*60));
                        const dateKey = toDateKey(end.toISOString()); // assign to wake day
                        byDate[dateKey] = (byDate[dateKey]||0) + durationH;
                    });
                    Object.entries(byDate).forEach(([date,val]) => addMetricPoint('sleep_hours', date, val));
                }

                return metrics;
            } catch (e) {
                console.error('Error parsing health data:', e);
                throw new Error('Invalid health data format');
            }
        }

        function correlateHealthWithSeismograph(healthData, seismographData) {
            const correlations = [];
            
            try {
                // Group health data by date
                const healthByDate = {};
                Object.keys(healthData).forEach(metricName => {
                    healthData[metricName].forEach(point => {
                        const date = point.date.split('T')[0]; // Get YYYY-MM-DD
                        if (!healthByDate[date]) healthByDate[date] = {};
                        healthByDate[date][metricName] = point.value;
                    });
                });

                // Correlate with seismograph readings
                Object.keys(seismographData).forEach(date => {
                    const seismo = seismographData[date];
                    const health = healthByDate[date];
                    
                    if (health && seismo) {
                        correlations.push({
                            date: date,
                            magnitude: seismo.magnitude || 0,
                            valence: seismo.valence || 0,
                            volatility: seismo.volatility || 0,
                            health: health,
                            correlationScore: calculateCorrelationScore(seismo, health)
                        });
                    }
                });

                return correlations;
            } catch (error) {
                console.error('Error correlating health data:', error);
                return [];
            }
        }

        function calculateCorrelationScore(seismo, health) {
            // Heuristic similarity score (0..1). Future: replace with rolling Pearson across arrays.
            let scoreSum = 0, parts = 0;
            // Mood valence ↔ symbolic valence (directional alignment)
            if (typeof health.mood_valence === 'number' && typeof seismo.valence === 'number') {
                const hv = Math.max(-1, Math.min(1, health.mood_valence)); // already approx -1..+1
                const sv = Math.max(-1, Math.min(1, seismo.valence / 5)); // normalize -5..5 → -1..1
                const alignment = 1 - Math.abs(hv - sv) / 2; // 1 perfect, 0 worst
                scoreSum += alignment; parts++;
            }
            // HRV (if present) ↔ volatility (change sensitivity) – normalized inverse distance
            if (typeof health.hrv === 'number' && typeof seismo.volatility === 'number') {
                const h = Math.min(150, Math.max(0, health.hrv)) / 150; // crude 0..1
                const v = seismo.volatility / 5; // 0..1
                scoreSum += 1 - Math.abs(h - v); parts++;
            }
            // Sleep hours ↔ magnitude dampening (long sleep might appear with lower magnitude)
            if (typeof health.sleep_hours === 'number' && typeof seismo.magnitude === 'number') {
                const sleepN = Math.min(12, Math.max(0, health.sleep_hours)) / 12; // 0..1
                const magN = seismo.magnitude / 5; // 0..1
                // Assume moderate inverse relationship (regulation) – treat closeness to (sleepN + magN ≈ 1) as alignment
                const target = Math.abs((sleepN + magN) - 1);
                scoreSum += 1 - target; parts++;
            }
            return parts ? scoreSum / parts : 0;
        }

        function generateHealthCorrelationTable(correlations) {
            if (!correlations || correlations.length === 0) {
                return "No health data available for correlation analysis.";
            }

            let table = "## Health Data Correlation Analysis\n\n";
            table += "| Date | Magnitude | Valence | Volatility | Health Metrics | Correlation Score |\n";
            table += "|------|-----------|---------|------------|----------------|-------------------|\n";

            correlations.forEach(corr => {
                const healthSummary = Object.keys(corr.health).map(key => 
                    `${key}: ${corr.health[key]}`
                ).join(', ');
                
                table += `| ${corr.date} | ${corr.magnitude.toFixed(2)} | ${corr.valence.toFixed(2)} | ${corr.volatility.toFixed(2)} | ${healthSummary} | ${corr.correlationScore.toFixed(3)} |\n`;
            });

            table += "\n*Correlation scores range from 0 (no correlation) to 1 (perfect correlation)*\n\n";
            return table;
        }

        function loadHealthData(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const healthData = JSON.parse(e.target.result);
                    const parsedMetrics = parseHealthAutoExportJSON(healthData);
                    
                    loadedHealthData = parsedMetrics;
                    const metricKeys = Object.keys(parsedMetrics);
                    const coverageParts = metricKeys.map(k => {
                        const dates = (parsedMetrics[k]||[]).map(p=>p.date).filter(Boolean).sort();
                        if (!dates.length) return `${k}: —`;
                        return `${k}: ${dates[0]} → ${dates[dates.length-1]} (${dates.length}d)`;
                    });
                    const statusMsg = metricKeys.length
                      ? `${metricKeys.length} metrics loaded • ${coverageParts.join(' • ')}`
                      : 'No metrics recognized in file';
                    updateHealthDataStatus(statusMsg);
                    // Build per-date map for quick correlation badges
                    try {
                        const byDate = {};
                        metricKeys.forEach(mk => {
                            (parsedMetrics[mk]||[]).forEach(pt => {
                                const dkey = (pt.date||'').slice(0,10);
                                if (!/^\d{4}-\d{2}-\d{2}$/.test(dkey)) return;
                                if (!byDate[dkey]) byDate[dkey] = {};
                                byDate[dkey][mk] = pt.value;
                            });
                        });
                        window.WM_HEALTH_BY_DATE = byDate;
                    } catch(_) { window.WM_HEALTH_BY_DATE = null; }
                    // Show clear button
                    clearHealthDataBtn.classList.remove('hidden');
                    updateComparativeAvailability();
                    
                } catch (error) {
                    console.error('Error loading health data:', error);
                    alert('Error loading health data: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function clearHealthData() {
            loadedHealthData = null;
            window.WM_HEALTH_BY_DATE = null;
            updateHealthDataStatus("");
            clearHealthDataBtn.classList.add('hidden');
            updateComparativeAvailability();
            
            // Visual feedback
            const clearBtn = clearHealthDataBtn;
            const originalText = clearBtn.textContent;
            clearBtn.textContent = '✅ Cleared!';
            setTimeout(() => { clearBtn.textContent = originalText; }, 2000);
        }

        function updateHealthDataStatus(message, metrics = null) {
            if (message) {
                if (metrics && Object.keys(metrics).length > 0) {
                    const metricsList = Object.keys(metrics).map(key => {
                        const count = metrics[key].length;
                        const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `${displayName} (${count} days)`;
                    }).join(', ');
                    healthDataStatus.innerHTML = `<strong>${message}</strong><br><span class="text-xs text-gray-400">${metricsList}</span>`;
                } else {
                    healthDataStatus.textContent = message;
                }
                healthDataStatus.classList.remove('hidden');
                healthDataStatus.classList.add('text-green-400');
            } else {
                healthDataStatus.classList.add('hidden');
                healthDataStatus.classList.remove('text-green-400');
            }
        }

        // --- Seismograph MD Ingestion ---
        let loadedSeismographData = null; // map of date -> { magnitude, valence, volatility, hooks }

        function loadSeismographMd(file){
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e){
                try {
                    const text = e.target.result;
                    const parsed = (typeof parseSeismographMarkdown === 'function') ? parseSeismographMarkdown(text) : null;
                    if (!parsed || !parsed.map || Object.keys(parsed.map).length === 0){
                        throw new Error('No seismograph table found');
                    }
                    loadedSeismographData = parsed.map;
                    updateSeismoDataStatus(Object.keys(parsed.map).length + ' seismograph days loaded');
                    clearSeismoBtn.classList.remove('hidden');
                    updateComparativeAvailability();
                } catch(err){
                    console.error('Seismograph parse error:', err);
                    alert('Error parsing seismograph markdown: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function clearSeismograph(){
            loadedSeismographData = null;
            updateSeismoDataStatus('');
            clearSeismoBtn.classList.add('hidden');
            updateComparativeAvailability();
            const btn = clearSeismoBtn;
            const originalText = btn.textContent; btn.textContent = '✅ Cleared!';
            setTimeout(()=> btn.textContent = originalText, 2000);
        }

        function updateSeismoDataStatus(message){
            if (message){
                seismoDataStatus.textContent = message;
                seismoDataStatus.classList.remove('hidden');
                seismoDataStatus.classList.add('text-green-400');
            } else {
                seismoDataStatus.classList.add('hidden');
                seismoDataStatus.classList.remove('text-green-400');
            }
        }

        function updateComparativeAvailability(){
            const ready = !!(loadedHealthData && loadedSeismographData);
            if (ready){
                genComparativeBtn.classList.remove('hidden');
                genComparativeBtn.disabled = false;
            } else {
                genComparativeBtn.disabled = true;
                if (loadedHealthData || loadedSeismographData){
                    genComparativeBtn.classList.remove('hidden');
                } else {
                    genComparativeBtn.classList.add('hidden');
                }
            }
        }

        function generateComparativeReport(){
            try {
                if (!loadedHealthData || !loadedSeismographData) {
                    alert('Please load both Health JSON and Seismograph (.md) first.');
                    return;
                }
                if (typeof generateComparativeReportMarkdown !== 'function'){
                    throw new Error('Comparative reporter not available');
                }
                const md = generateComparativeReportMarkdown(loadedSeismographData, loadedHealthData);
                const fname = `comparative_${new Date().toISOString().slice(0,10)}.md`;
                downloadFile(md, fname, 'text/markdown');
                const original = genComparativeBtn.textContent; genComparativeBtn.textContent = '✅ Exported!';
                setTimeout(()=> genComparativeBtn.textContent = original, 2000);
            } catch (e){
                console.error('Comparative export failed:', e);
                alert('Failed to generate comparative report: ' + e.message);
            }
        }

        // Fallback print-to-PDF function
        function printReportAsPDF(markdownReport) {
            // Convert markdown to HTML for printing
            const htmlContent = convertMarkdownToHTML(markdownReport);
            
            // Create a new window for printing
            const printWindow = window.open('', '_blank', 'width=800,height=600');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            
            // Add print-specific styles
            const printStyle = printWindow.document.createElement('style');
            printStyle.textContent = `
                @media print {
                    body { font-size: 11px; line-height: 1.3; }
                    h1, h2, h3 { break-after: avoid; }
                    table { break-inside: avoid; page-break-inside: avoid; }
                    tr { break-inside: avoid; page-break-inside: avoid; }
                }
            `;
            printWindow.document.head.appendChild(printStyle);
            
            // Trigger print dialog
            printWindow.focus();
            printWindow.print();
            
            // Close the window after printing (optional)
            setTimeout(() => {
                printWindow.close();
            }, 1000);
        }

        // Convert markdown to HTML for PDF generation
        function convertMarkdownToHTML(markdown) {
            // Simple markdown to HTML conversion
            let html = markdown
                // Headers
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                // Bold and italic
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                // Links
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
                // Code blocks
                .replace(/```[\s\S]*?```/g, '<pre><code>$&</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Lists
                .replace(/^\- (.*)$/gm, '<li>$1</li>')
                .replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>')
                // Tables (basic support)
                .replace(/\|.*\|/g, (match) => {
                    const cells = match.split('|').filter(cell => cell.trim());
                    return '<tr>' + cells.map(cell => `<td>${cell.trim()}</td>`).join('') + '</tr>';
                })
                .replace(/(<tr>.*<\/tr>)/gs, '<table border="1" style="border-collapse: collapse; width: 100%; margin: 10px 0;">$1</table>')
                // Line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');
            
            // Wrap in basic HTML structure with PDF-friendly styling
            return `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body { 
                            font-family: 'Times New Roman', serif; 
                            line-height: 1.4; 
                            color: #333; 
                            max-width: 100%; 
                            padding: 20px;
                            font-size: 12px;
                        }
                        h1 { color: #2c5aa0; font-size: 18px; margin: 20px 0 10px 0; }
                        h2 { color: #2c5aa0; font-size: 16px; margin: 15px 0 8px 0; }
                        h3 { color: #2c5aa0; font-size: 14px; margin: 12px 0 6px 0; }
                        p { margin: 8px 0; }
                        table { border-collapse: collapse; width: 100%; margin: 10px 0; font-size: 10px; }
                        td, th { border: 1px solid #ccc; padding: 4px; text-align: left; }
                        code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
                        pre { background: #f5f5f5; padding: 10px; border-radius: 5px; overflow-wrap: break-word; }
                        strong { color: #2c5aa0; }
                        .page-break { page-break-before: always; }
                    </style>
                </head>
                <body>
                    <p>${html}</p>
                </body>
                </html>
            `;
        }

        // Populate Mirror/Balance Meter tab content based on result
        function populateTabContent(result, formData, report, hasTransitsMode, hasTransitData) {
            try {
                const balanceWrap = document.getElementById('balanceMeterTabContent');
                if (balanceWrap) {
                    // Clear previous content
                    balanceWrap.innerHTML = '';

                    // If Balance Meter payload exists, render it (mode flag may be missing in some responses)
                    if (result && result.balance_meter) {
                        try {
                            const md = buildBalanceMeterReport(result.balance_meter);
                            // Render as simple preformatted text to preserve Markdown readability
                            const pre = document.createElement('pre');
                            pre.className = 'whitespace-pre-wrap text-sm text-gray-200 bg-gray-900/60 p-4 rounded border border-gray-700';
                            pre.textContent = md;
                            balanceWrap.appendChild(pre);
                        } catch (e) {
                            console.warn('Balance Meter render failed, falling back to JSON view:', e);
                            const pre = document.createElement('pre');
                            pre.className = 'whitespace-pre-wrap text-xs text-gray-300 bg-gray-900/60 p-4 rounded border border-gray-700';
                            pre.textContent = JSON.stringify(result.balance_meter, null, 2);
                            balanceWrap.appendChild(pre);
                        }
                    // No separate seismograph mode; content renders only for Balance Meter
                    } else {
                        balanceWrap.innerHTML = '<p class="text-gray-400 text-sm">No Balance Meter data for this selection.</p>';
                    }
                }
            } catch (e) {
                console.warn('populateTabContent encountered an issue:', e);
            }
        }

        // --- API Call ---

        async function generateReport() {
            totalRowCount = 0; // Reset counter for each report
            WovenMapConfig.debugLog("Generate button clicked");
            
            if (!validateForm()) {
                return;
            }

            WovenMapConfig.debugLog("Form is valid, preparing API request");
            hideError();
            generateBtn.disabled = true;
            loadingIndicator.classList.remove('hidden');
            reportOutput.classList.add('hidden');
            // Hide report action buttons when starting new generation
            document.getElementById('copyReport').classList.add('hidden');
            document.getElementById('downloadReport').classList.add('hidden');
            document.getElementById('downloadPDF').classList.add('hidden');
            document.getElementById('pdfOptions').classList.add('hidden');

            try {
                const formData = collectFormData();
                
                // Log the complete data being sent to API
                console.log("=== SENDING TO API ===");
                console.log("Full form data:", JSON.stringify(formData, null, 2));
                console.log("PersonA structure:", JSON.stringify(formData.personA, null, 2));
                WovenMapConfig.debugLog("Sending data to API", formData);
                
                // Double-check required fields using configuration
                // Skip person validation for sky-only mode
                if (formData?.context?.mode !== 'sky_transits') {
                    const requiredFields = WovenMapConfig.validation.requiredFields.person;
                    const missingFields = requiredFields.filter(field => {
                        const value = formData.personA[field];
                        return value === undefined || value === null || value === "";
                    });
                    if (missingFields.length > 0) {
                        throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
                    }
                }
                
                // Use chunking-aware generation to handle large date ranges
                const result = await generateReportWithChunking(formData);

                // --- Shape Harmonization Shim ---
                (function harmonizeResultShape(r){
                    try {
                        // Synastry: ensure r.synastry.aspects present if nested chart form used
                        if (r.synastry && !r.synastry.aspects && r.synastry.chart?.aspects && Array.isArray(r.synastry.chart.aspects)) {
                            r.synastry.aspects = r.synastry.chart.aspects;
                        }
                        // Composite: some earlier frontend code expects composite.chart.* already; if only composite.aspects given, wrap
                        if (r.composite && !r.composite.chart && r.composite.aspects) {
                            r.composite.chart = { aspects: r.composite.aspects };
                        }
                        // Transit containers: normalize transitsByDate key if only transits present & shaped as date map
                        const maybePromote = (chartObj) => {
                            if (!chartObj || chartObj.transitsByDate) return;
                            if (chartObj.transits && !Array.isArray(chartObj.transits)) {
                                // Heuristic: if it's an object whose keys look like YYYY-MM-DD
                                const keys = Object.keys(chartObj.transits || {});
                                if (keys.length && keys.every(k => /^\d{4}-\d{2}-\d{2}$/.test(k))) {
                                    chartObj.transitsByDate = chartObj.transits; // promote
                                }
                            }
                        };
                        if (r.person_a?.chart) maybePromote(r.person_a.chart);
                        if (r.person_b?.chart) maybePromote(r.person_b.chart);
                        if (r.synastry) maybePromote(r.synastry); // in case synastry transits delivered similarly
                        if (r.composite) maybePromote(r.composite);
                    } catch (e) {
                        console.warn('Shape harmonization encountered an issue:', e);
                    }
                })(result);

                // Store result data for downloads
                latestResultData = result;

                // Generate report based on mode
                let report;
                const activeTabMode = (typeof getCurrentActiveTabMode === 'function') ? getCurrentActiveTabMode() : 'mirror';
                const shouldRenderBalance = Boolean(result.balance_meter) && (result.mode === 'balance_meter' || activeTabMode === 'balance_meter');
                if (shouldRenderBalance) {
                    // Generate Balance Meter report for download/copy/PDF
                    report = buildBalanceMeterReport(result.balance_meter);
                } else {
                    // Generate Mirror report (seismograph auto-appends when transit hooks exist)
                    const displayOptions = {
                        includeExecutiveSummary: false,
                        includeJsonAppendix: false,
                        includeProvenance: false
                    };
                    report = generateMarkdownReport(result, displayOptions);
                }
                
                // Check if we have transit hooks that warrant seismograph auto-append
                const hasTransitsMode = formData.context.mode.includes('transits');
                const hasTransitData = result.person_a?.chart?.transitsByDate || result.person_b?.chart?.transitsByDate || result.composite?.transitsByDate || result.synastry?.transitsByDate;
                
                // Populate all tab content
                populateTabContent(result, formData, report, hasTransitsMode, hasTransitData);
                
                // Handle Balance Meter mode - standalone report focused on triple-channel data
                if (shouldRenderBalance) {
                    console.log('=== BALANCE METER MODE ===');
                    // Switch to Balance Meter tab for standalone mode
                    document.getElementById('balanceMeterModeTab')?.click();
                    // Show Balance Meter report in the main content area
                    reportContent.textContent = report;
                    console.log('=== END BALANCE METER MODE ===');
                } else {
                    // Show Mirror report in the main content area
                    reportContent.textContent = report;
                }
                
                document.getElementById('copyReport').classList.remove('hidden');
                document.getElementById('downloadReport').classList.remove('hidden');
                document.getElementById('downloadPDF').classList.remove('hidden');
                document.getElementById('pdfOptions').classList.remove('hidden');
                updateSeismographTabIndicator();
                
                reportOutput.classList.remove('hidden');

                // Auto-focus + reveal animation so user sees the new report immediately
                try {
                    // Smooth scroll to the report container
                    reportOutput.scrollIntoView({ behavior: 'smooth', block: 'start' });

                    // Apply a transient highlight pulse
                    reportContent.classList.add('ring-2','ring-teal-400/70','shadow-lg');
                    setTimeout(() => {
                        reportContent.classList.add('animate-pulse');
                    }, 80);
                    setTimeout(() => {
                        reportContent.classList.remove('animate-pulse');
                    }, 1400);
                    setTimeout(() => {
                        reportContent.classList.remove('ring-2','ring-teal-400/70','shadow-lg');
                    }, 2000);

                    // Move keyboard focus for accessibility
                    if (reportContent?.setAttribute) {
                        reportContent.setAttribute('tabindex','-1');
                        reportContent.focus({ preventScroll: true });
                    }
                } catch(e) { console.debug('Report reveal UX enhancement skipped', e); }

            } catch (error) {
                console.error('Error generating report:', error);
                showError(`Failed to generate report: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
                loadingIndicator.classList.add('hidden');
            }
        }

        // --- Event Listeners & UI Updates ---

        function setupEventListeners() {
            // Tab switching functionality
            function switchTab(activeTabId, activeContentId) {
                // Hide all tab content
                const allTabContent = ['mirror-content', 'balance-meter-content'];
                allTabContent.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.classList.add('hidden');
                });
                
                // Reset all tab buttons
                const allTabs = ['mirrorModeTab', 'balanceMeterModeTab'];
                allTabs.forEach(id => {
                    const tab = document.getElementById(id);
                    if (tab) {
                        tab.setAttribute('aria-selected', 'false');
                        tab.className = 'px-6 py-2 text-sm font-medium rounded-md bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors duration-200';
                    }
                });
                
                // Activate selected tab
                const activeTab = document.getElementById(activeTabId);
                const activeContent = document.getElementById(activeContentId);
                if (activeTab && activeContent) {
                    activeTab.setAttribute('aria-selected', 'true');
                    activeTab.className = 'px-6 py-2 text-sm font-medium rounded-md bg-teal-600 text-white transition-colors duration-200';
                    activeContent.classList.remove('hidden');
                    
                    // Update mode description
                    const descriptions = {
                        'mirrorModeTab': '<strong class="text-teal-300">Mirror:</strong> Geometry + reflection in one stream. Always includes the full skeletal ledger (angles, houses, hooks) plus the recognition layer. Seismograph trace auto-appends when transit hooks exist.',
                        'balanceMeterModeTab': '<strong class="text-teal-300">Balance Meter:</strong> Triple-channel analysis (Seismograph v1.0, Balance Channel v1.1, SFD v1.2) showing crisis detection, rebalanced perspective, and net support measurement in integrated tables.'
                    };
                    const modeDesc = document.getElementById('modeDescription');
                    if (modeDesc && descriptions[activeTabId]) {
                        modeDesc.innerHTML = descriptions[activeTabId];
                    }
                }
            }
            
            // Tab click handlers
            document.getElementById('mirrorModeTab')?.addEventListener('click', () => {
                switchTab('mirrorModeTab', 'mirror-content');
                updateAppMode('mirror');
            });
            document.getElementById('balanceMeterModeTab')?.addEventListener('click', () => {
                switchTab('balanceMeterModeTab', 'balance-meter-content');
                updateAppMode('balance_meter');
            });
            
            // Main button
            generateBtn.addEventListener('click', generateReport);

            // Monitor Person B fields to show/hide relational context sections
            function checkPersonBFields() {
                const personBName = document.getElementById('nameB');
                const contextModeSection = document.getElementById('context-mode-section');
                const relationalContextSection = document.getElementById('relational-context-section');
                
                if (personBName && contextModeSection && relationalContextSection) {
                    const hasPersonB = personBName.value.trim().length > 0;
                    if (hasPersonB) {
                        // Show proper relational context section
                        relationalContextSection.classList.remove('hidden');
                        // Keep legacy context mode hidden (it's not the right interface)
                        contextModeSection.classList.add('hidden');
                    } else {
                        // Hide both when no Person B
                        contextModeSection.classList.add('hidden');
                        relationalContextSection.classList.add('hidden');
                    }
                }
            }

            // Add event listeners to Person B fields
            const personBFields = ['nameB', 'birth_cityB', 'birth_dateB', 'birth_timeB'];
            personBFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', checkPersonBFields);
                    field.addEventListener('change', checkPersonBFields);
                }
            });

            // Initial check
            checkPersonBFields();

            // Save/Load buttons
            document.getElementById('saveDataBtn').addEventListener('click', saveChartData);
            document.getElementById('loadDataBtn').addEventListener('click', () => {
                document.getElementById('loadDataInput').click();
            });
            document.getElementById('loadDataInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadChartData(e.target.files[0]);
                }
            });

            // Health Data buttons
            document.getElementById('loadHealthDataBtn').addEventListener('click', () => {
                document.getElementById('healthDataInput').click();
            });
            document.getElementById('healthDataInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadHealthData(e.target.files[0]);
                }
            });
            document.getElementById('clearHealthDataBtn').addEventListener('click', clearHealthData);
            
            // Health Data Help Modal
            document.getElementById('healthDataHelpBtn').addEventListener('click', () => {
                document.getElementById('healthDataHelpModal').classList.remove('hidden');
            });
            document.getElementById('closeHealthDataHelp').addEventListener('click', () => {
                document.getElementById('healthDataHelpModal').classList.add('hidden');
            });
            document.getElementById('healthDataHelpModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('healthDataHelpModal')) {
                    document.getElementById('healthDataHelpModal').classList.add('hidden');
                }
            });

            // Modal
            mathBrainInfoBtn.addEventListener('click', () => mathBrainModal.classList.remove('hidden'));
            closeMathBrainModal.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            closeMathBrainModalBottom.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            mathBrainModal.addEventListener('click', (e) => {
                if (e.target === mathBrainModal) mathBrainModal.classList.add('hidden');
            });

            // Copy report
            copyBtn.addEventListener('click', async () => {
                try {
                    // For copy, use enhanced version with executive summary but no JSON appendix (too large)
                    if (latestResultData) {
                        const copyOptions = {
                            includeExecutiveSummary: true,
                            includeJsonAppendix: false,
                            includeProvenance: true
                        };
                        const isBalanceMode = (latestResultData?.mode === 'balance_meter') ||
                                              (typeof getCurrentActiveTabMode === 'function' && getCurrentActiveTabMode() === 'balance_meter') ||
                                              (window.currentAppMode === 'balance_meter');
                        const fullReport = (isBalanceMode && latestResultData.balance_meter)
                            ? buildBalanceMeterReport(latestResultData.balance_meter)
                            : generateMarkdownReport(latestResultData, copyOptions);
                        await navigator.clipboard.writeText(fullReport);
                    } else {
                        await navigator.clipboard.writeText(reportContent.textContent);
                    }
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => { copyBtn.textContent = '📋 Copy Report'; }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            // Download report as markdown file
            document.getElementById('downloadReport').addEventListener('click', () => {
                if (!latestResultData) {
                    showError('No report available for download. Please generate a report first.');
                    return;
                }
                try {
                    console.log('Starting download process...');
                    
                    // For download, include all enhancements
                    const downloadOptions = {
                        includeExecutiveSummary: true,
                        includeJsonAppendix: true,
                        includeProvenance: true
                    };
                    
                    console.log('Generating markdown report...');
                    const isBalanceMode = (latestResultData?.mode === 'balance_meter') ||
                                          (typeof getCurrentActiveTabMode === 'function' && getCurrentActiveTabMode() === 'balance_meter') ||
                                          (window.currentAppMode === 'balance_meter');
                    const fullReport = (isBalanceMode && latestResultData.balance_meter)
                        ? buildBalanceMeterReport(latestResultData.balance_meter)
                        : generateMarkdownReport(latestResultData, downloadOptions);
                    console.log('Markdown report generated successfully, length:', fullReport.length);
                    
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    const person1Name = document.getElementById('nameA').value || 'PersonA';
                    const person2Name = document.getElementById('nameB').value;
                    
                    let filename;
                    if (person2Name) {
                        filename = `report_${person1Name}_${person2Name}_${timestamp}.md`;
                    } else {
                        filename = `report_${person1Name}_${timestamp}.md`;
                    }
                    
                    console.log('Creating blob and download link...');
                    const blob = new Blob([fullReport], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log('Download completed successfully');
                    
                    // Brief visual feedback
                    const btn = document.getElementById('downloadReport');
                    btn.textContent = '✅ Downloaded!';
                    setTimeout(() => { btn.textContent = '📄 Download Report (.md)'; }, 2000);
                    
                    // Safe logging
                    if (typeof logger !== 'undefined') {
                        logger.info('Report downloaded', { filename, size: fullReport.length });
                    } else {
                        console.log('Report downloaded:', { filename, size: fullReport.length });
                    }
                } catch (err) {
                    console.error('Failed to download report: ', err);
                    console.error('Error details:', err.message, err.stack);
                    showError(`Failed to download report: ${err.message}. Please try again.`);
                }
            });

            // Download report as PDF
            document.getElementById('downloadPDF').addEventListener('click', async () => {
                if (!latestResultData) {
                    showError('No report available for download. Please generate a report first.');
                    return;
                }
                try {
                    console.log('Starting PDF download process...');
                    
                    // Generate markdown report for PDF conversion
                    const downloadOptions = {
                        includeExecutiveSummary: true,
                        includeJsonAppendix: false, // Skip JSON for PDF to keep it readable
                        includeProvenance: true
                    };
                    
                    console.log('Generating markdown report for PDF...');
                    const isBalanceMode = (latestResultData?.mode === 'balance_meter') ||
                                          (typeof getCurrentActiveTabMode === 'function' && getCurrentActiveTabMode() === 'balance_meter') ||
                                          (window.currentAppMode === 'balance_meter');
                    const markdownReport = (isBalanceMode && latestResultData.balance_meter)
                        ? buildBalanceMeterReport(latestResultData.balance_meter)
                        : generateMarkdownReport(latestResultData, downloadOptions);
                    
                    // Check if html2pdf is available
                    if (typeof html2pdf === 'undefined') {
                        console.error('html2pdf library not loaded');
                        
                        // Offer print-to-PDF fallback
                        const userWantsPrintFallback = confirm(
                            'PDF generation library not loaded. Would you like to use your browser\'s print function instead?\n\n' +
                            'This will open a print dialog where you can "Save as PDF".'
                        );
                        
                        if (userWantsPrintFallback) {
                            // Use browser print for PDF fallback
                            printReportAsPDF(markdownReport);
                        }
                        return;
                    }
                    
                    // Convert markdown to HTML for PDF generation
                    const htmlContent = convertMarkdownToHTML(markdownReport);
                    
                    // Generate filename
                    const person1Name = document.getElementById('nameA').value || 'PersonA';
                    const person2Name = document.getElementById('nameB').value;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    
                    let filename;
                    if (person2Name) {
                        filename = `WovenMap_${person1Name}_${person2Name}_${timestamp}.pdf`;
                    } else {
                        filename = `WovenMap_${person1Name}_${timestamp}.pdf`;
                    }
                    
                    // Show loading state
                    const btn = document.getElementById('downloadPDF');
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '⏳ Generating PDF...';
                    btn.disabled = true;
                    
                    // Create a temporary element for PDF generation
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlContent;
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.left = '-9999px';
                    tempDiv.style.top = '-9999px';
                    document.body.appendChild(tempDiv);
                    
                    // PDF generation options
                    const options = {
                        margin: [10, 10, 10, 10],
                        filename: filename,
                        image: { type: 'jpeg', quality: 0.98 },
                        html2canvas: { 
                            scale: 2, 
                            useCORS: true,
                            letterRendering: true,
                            allowTaint: false
                        },
                        jsPDF: { 
                            unit: 'mm', 
                            format: 'a4', 
                            orientation: 'portrait',
                            compress: true
                        },
                        pagebreak: { mode: 'avoid-all', before: '.page-break' }
                    };
                    
                    // Generate PDF blob and handle download based on user preference
                    const autoDownload = document.getElementById('autoDownloadPDF').checked;
                    
                    if (autoDownload) {
                        // Force automatic download without browser prompt
                        const pdfBlob = await html2pdf().set(options).from(tempDiv).outputPdf('blob');
                        
                        // Create download link and trigger automatically
                        const url = URL.createObjectURL(pdfBlob);
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = filename;
                        downloadLink.style.display = 'none';
                        
                        // Add to DOM, click, and remove (forces download without prompt in most browsers)
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        
                        // Clean up blob URL
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    } else {
                        // Use html2pdf's built-in save method (may prompt for filename)
                        await html2pdf().set(options).from(tempDiv).save();
                    }
                    
                    // Clean up
                    document.body.removeChild(tempDiv);
                    
                    console.log('PDF download completed successfully');
                    btn.innerHTML = '✅ PDF Downloaded!';
                    setTimeout(() => { 
                        btn.innerHTML = originalText; 
                        btn.disabled = false;
                    }, 2000);
                    
                } catch (err) {
                    console.error('Failed to generate PDF: ', err);
                    showError(`Failed to generate PDF: ${err.message}. Please try again.`);
                    
                    // Reset button state
                    const btn = document.getElementById('downloadPDF');
                    if (btn) {
                        btn.innerHTML = '📑 Download PDF<span class="block text-xs opacity-80">Professional PDF report</span>';
                        btn.disabled = false;
                    }
                }
            });

            // (Removed deprecated markdown download button logic)

            // Seismograph MD wiring
            loadSeismoBtn = document.getElementById('loadSeismoBtn');
            clearSeismoBtn = document.getElementById('clearSeismoBtn');
            seismoMdInput = document.getElementById('seismoMdInput');
            seismoDataStatus = document.getElementById('seismoDataStatus');
            genComparativeBtn = document.getElementById('genComparativeBtn');

            loadSeismoBtn?.addEventListener('click', ()=> seismoMdInput.click());
            seismoMdInput?.addEventListener('change', (e)=>{ if (e.target.files && e.target.files.length) loadSeismographMd(e.target.files[0]); });
            clearSeismoBtn?.addEventListener('click', clearSeismograph);
            genComparativeBtn?.addEventListener('click', generateComparativeReport);

            // Toggle mode help panel
            toggleModeHelp.addEventListener('click', () => {
                const isHidden = modeHelpPanel.classList.contains('hidden');
                modeHelpPanel.classList.toggle('hidden');
                toggleModeHelp.textContent = isHidden ? '🧭 Hide mode guide' : '🧭 What does each mode do?';
            });

            // Prefill today's date for transit dates
            prefillTodayBtn.addEventListener('click', prefillTodayDates);
                // Simple Mode: filter controls suppressed (defaults applied globally)

            // Toggle step size help panel
            stepSizeHelpBtn.addEventListener('click', () => {
                const isHidden = stepSizeHelpPanel.classList.contains('hidden');
                stepSizeHelpPanel.classList.toggle('hidden');
                stepSizeHelpBtn.textContent = isHidden ? '❓ Hide explanation' : '❓ What does this do?';
            });

            // Date range validation with real-time feedback
            function validateDateRange() {
                if (!transitStartDate.value || !transitEndDate.value) return;
                
                const start = new Date(transitStartDate.value);
                const end = new Date(transitEndDate.value);
                const daySpan = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                const stepSize = transitStep.value || '1d';
                
                // Remove existing validation messages
                const existingWarning = document.getElementById('dateRangeWarning');
                const existingInfo = document.getElementById('dateRangeInfo');
                if (existingWarning) existingWarning.remove();
                if (existingInfo) existingInfo.remove();
                
                // Skip validation for same-day ranges
                if (daySpan === 0) return;
                
                let maxDays, warningClass = '', warningText = '';
                const stepKey = (stepSize === '7d' || stepSize === 'weekly') ? 'weekly'
                                 : (stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly') ? 'monthly'
                                 : 'daily';
                const limits = (window.WOVEN_STEP_LIMITS && window.WOVEN_STEP_LIMITS[stepKey]) || { max: 45, warnRatio: 0.8 };
                maxDays = limits.max;
                const warnDays = Math.floor(limits.max * (limits.warnRatio || 0.8));
                const isWeekly = stepKey === 'weekly';
                const isMonthly = stepKey === 'monthly';
                if (daySpan > warnDays) {
                    warningClass = daySpan > maxDays ? 'text-red-400' : 'text-yellow-400';
                    if (daySpan > maxDays) {
                        const hardMsg = isWeekly
                            ? `⚠️ ${daySpan} days exceeds ${(Math.round(maxDays/30*10)/10)}-month limit for weekly calculations`
                            : isMonthly
                            ? `⚠️ ${daySpan} days exceeds ${(Math.round(maxDays/30*10)/10)}-month limit for monthly calculations`
                            : `⚠️ ${daySpan} days exceeds ${maxDays}-day limit for daily calculations`;
                        warningText = hardMsg;
                    } else {
                        const softMsg = isWeekly
                            ? `⚠️ ${daySpan} days is a long range (${Math.ceil(daySpan/7)} weeks)`
                            : isMonthly
                            ? `⚠️ ${daySpan} days is a long range (${Math.ceil(daySpan/30)} months)`
                            : `⚠️ ${daySpan} days is approaching daily limit (${maxDays} days max)`;
                        warningText = softMsg;
                    }
                }
                
                // Show warning if needed
                if (warningText) {
                    const warningDiv = document.createElement('div');
                    warningDiv.id = 'dateRangeWarning';
                    warningDiv.className = `mt-2 text-xs ${warningClass}`;
                    warningDiv.innerHTML = warningText;
                    transitEndDate.parentNode.appendChild(warningDiv);
                }
                
                // Show helpful calculation info for longer ranges
                if (daySpan > 7) {
                    const actualSteps = stepSize === '7d' || stepSize === 'weekly' ? Math.ceil(daySpan / 7) :
                                       stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? Math.ceil(daySpan / 30) :
                                       daySpan;
                    
                    const stepType = stepSize === '7d' || stepSize === 'weekly' ? 'weekly calculations' :
                                    stepSize === '1m' || stepSize === '1mo' || stepSize === 'monthly' ? 'monthly calculations' :
                                    'daily calculations';
                    
                    const infoText = `📊 Will generate ~${actualSteps} ${stepType}`;
                    
                    if (!document.getElementById('dateRangeInfo')) {
                        const infoDiv = document.createElement('div');
                        infoDiv.id = 'dateRangeInfo';
                        infoDiv.className = 'mt-1 text-xs text-teal-300';
                        infoDiv.textContent = infoText;
                        transitEndDate.parentNode.appendChild(infoDiv);
                    } else {
                        document.getElementById('dateRangeInfo').textContent = infoText;
                    }
                } else {
                    const existingInfo = document.getElementById('dateRangeInfo');
                    if (existingInfo) existingInfo.remove();
                }
            }

            // Add listeners for real-time validation
            transitStartDate.addEventListener('change', validateDateRange);
            transitEndDate.addEventListener('change', validateDateRange);
            transitStep.addEventListener('change', validateDateRange);

            // Context mode switching
            document.querySelectorAll('input[name="contextMode"]').forEach(radio => {
                radio.addEventListener('change', updateFormUI);
            });

            // Relocation toggle
            relocationToggle.addEventListener('change', () => {
                relocationFields.classList.toggle('hidden', !relocationToggle.checked);
                updateRelocationPersonBOption();
            });

            // Relational context visibility refinement:
            // Show immediately when relational context type selected. If user returns to solo/weather, hide.
            // While still in relational context, do NOT auto-hide just because Person B fields are blank.
            const personBInputs = ['nameB', 'birth_cityB', 'birth_stateB', 'birth_dateB', 'birth_timeB', 'birth_countryB', 'astroB'];
            function evaluateRelationalContextVisibility(){
                const anyFilled = personBInputs.some(id => document.getElementById(id).value.trim() !== '');
                const relContextSection = document.getElementById('relational-context-section');
                const isPersonBExpanded = document.getElementById('personB-toggle')?.getAttribute('aria-expanded') === 'true';
                const isLoadingData = window.isLoadingChartData || false;
                console.log('[REL VIS] anyFilled:', anyFilled, 'currentContextType:', currentContextType, 'personBExpanded:', isPersonBExpanded, 'isLoadingData:', isLoadingData);
                
                // Show relational context if:
                // 1. We're in relational mode, OR
                // 2. Person B section is expanded, OR  
                // 3. Any Person B field has data
                const shouldShow = currentContextType === 'relational' || isPersonBExpanded || anyFilled;
                const isInRelationalMode = currentContextType === 'relational';
                
                console.log('[REL VIS] shouldShow:', shouldShow, 'isInRelationalMode:', isInRelationalMode, 'reasons:', {
                    relationalMode: currentContextType === 'relational',
                    personBExpanded: isPersonBExpanded, 
                    personBData: anyFilled
                });
                
                if (relContextSection) {
                    const wasHidden = relContextSection.classList.contains('hidden');
                    if (shouldShow) {
                        relContextSection.classList.remove('hidden');
                        console.log('[REL VIS] Showing relational context - reason:', 
                            currentContextType === 'relational' ? 'relational mode' : 
                            isPersonBExpanded ? 'Person B expanded' : 'Person B data entered');
                        if (wasHidden) {
                            console.log('[REL VIS] ✅ Context section was hidden, now shown');
                        }
                        
                        // Enable/disable relationship type controls based on actual relational mode
                        // BUT skip this during data loading to allow restoration
                        if (!isLoadingData) {
                            const relationshipControls = relContextSection.querySelectorAll('input[name="relationshipType"], input[name="intimacyTier"], #exRelationship');
                            relationshipControls.forEach(control => {
                                control.disabled = !isInRelationalMode;
                                if (control.parentElement) {
                                    if (isInRelationalMode) {
                                        control.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                                    } else {
                                        control.parentElement.classList.add('opacity-50', 'cursor-not-allowed');
                                    }
                                }
                            });
                            
                            // Clear selections if not in relational mode (but not during data loading)
                            if (!isInRelationalMode) {
                                clearRelationshipTypeSelections();
                            }
                        }
                        
                    } else {
                        relContextSection.classList.add('hidden');
                        console.log('[REL VIS] ❌ Hiding relational context section');
                        // Only clear selections if not loading data
                        if (!isLoadingData) {
                            clearRelationshipTypeSelections();
                        }
                    }
                } else {
                    console.error('[REL VIS] ⚠️ relational-context-section element not found!');
                }
            }
            // Make function globally accessible
            window.evaluateRelationalContextVisibility = evaluateRelationalContextVisibility;
            
            personBInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', evaluateRelationalContextVisibility);
            });
            // Initial evaluation
            evaluateRelationalContextVisibility();
            
            // Intimacy tier visibility
            function resetRelationalStateFor(type){
                const roleSelect = document.getElementById('relationshipRole');
                const customRoleInput = document.getElementById('relationshipRoleCustom');
                const roleBlock = document.getElementById('relationship-role-block');
                const exRow = document.getElementById('exRelationshipRow');
                const exCb = document.getElementById('exRelationship');
                // Clear any custom visibility
                if (type === 'partner') {
                    if (roleSelect) roleSelect.value='';
                    if (customRoleInput) { customRoleInput.value=''; customRoleInput.classList.add('hidden'); }
                } else { // leaving partner
                    document.querySelectorAll('input[name="intimacyTier"]').forEach(r=> r.checked=false);
                }
                // Hide ex for friend
                if (exRow && exCb) {
                    const hideEx = type === 'friend';
                    exRow.classList.toggle('hidden', hideEx);
                    if (hideEx) exCb.checked = false;
                }
                // Focus first interactive element for accessibility
                if (type === 'partner') {
                    const firstTier = document.querySelector('input[name="intimacyTier"]');
                    firstTier && firstTier.focus();
                } else if (roleBlock && !roleBlock.classList.contains('hidden')) {
                    const firstRole = document.getElementById('relationshipRole');
                    firstRole && firstRole.focus();
                }
            }

            document.querySelectorAll('input[name="relationshipType"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value;
                    console.log('[REL TYPE] Changed to:', relationshipType);
                    if (!relationshipType) return;
                    const isPartner = relationshipType === 'partner';
                    if (intimacyTierDropdown) {
                        intimacyTierDropdown.classList.toggle('hidden', !isPartner);
                        if (!isPartner) {
                            // Clear any previously selected intimacy tiers when leaving partner
                            document.querySelectorAll('input[name="intimacyTier"]').forEach(r=> r.checked=false);
                        }
                    }
                    const roleBlock = document.getElementById('relationship-role-block');
                    const roleSelect = document.getElementById('relationshipRole');
                    const roleCustom = document.getElementById('relationshipRoleCustom');
                    if (roleBlock && roleSelect) {
                        roleSelect.innerHTML = '';
                        if (relationshipType === 'family') {
                            roleBlock.classList.remove('hidden');
                            const familyOptions = [
                                {v:'', l:'Select role (required)'}, 
                                {v:'parent', l:'Parent'}, 
                                {v:'offspring', l:'Offspring'}, 
                                {v:'sibling', l:'Sibling'}, 
                                {v:'cousin', l:'Cousin'}, 
                                {v:'extended', l:'Extended family'}, 
                                {v:'guardian', l:'Guardian'}, 
                                {v:'mentor', l:'Mentor'}, 
                                {v:'other', l:'Other / Custom'}
                            ];
                            familyOptions.forEach(o=>{ const opt=document.createElement('option'); opt.value=o.v; opt.textContent=o.l; roleSelect.appendChild(opt); });
                        } else if (relationshipType === 'friend') {
                            roleBlock.classList.remove('hidden');
                            const friendOptions = [
                                {v:'', l:'(optional)'}, 
                                {v:'acquaintance', l:'Acquaintance'}, 
                                {v:'mentor', l:'Mentor'}, 
                                {v:'other', l:'Other / Custom'}
                            ];
                            friendOptions.forEach(o=>{ const opt=document.createElement('option'); opt.value=o.v; opt.textContent=o.l; roleSelect.appendChild(opt); });
                        } else {
                            roleBlock.classList.add('hidden');
                        }
                        if (roleCustom) roleCustom.classList.add('hidden');
                    }
                    resetRelationalStateFor(relationshipType);
                });
            });
        }

        // =============================================================================
        // NEW UX IMPROVEMENT FUNCTIONS
        // =============================================================================
        
        // Global state for the app mode
        let currentAppMode = 'mirror'; // Always mirror - seismograph is an add-on section
        let currentContextType = 'solo'; // 'solo', 'relational', 'weather'
        
        function updateAppMode(mode) {
            currentAppMode = mode || 'mirror';
            
            // Update tab appearance
            const mirrorTab = document.getElementById('mirrorModeTab');
            const balanceMeterTab = document.getElementById('balanceMeterModeTab');
            const modeDescription = document.getElementById('modeDescription');
            const generateBtn = document.getElementById('generateReport');
            const showWiringBtn = document.getElementById('showWiringBtn');
            
            // Reset all tabs
            [mirrorTab, balanceMeterTab].forEach(tab => {
                if (tab) {
                    tab.classList.remove('bg-teal-600', 'text-white');
                    tab.classList.add('bg-gray-700', 'text-gray-300');
                    tab.setAttribute('aria-selected', 'false');
                }
            });
            
            // Activate the current tab
            const activeTab = currentAppMode === 'balance_meter' ? balanceMeterTab : mirrorTab;
            if (activeTab) {
                activeTab.classList.add('bg-teal-600', 'text-white');
                activeTab.classList.remove('bg-gray-700', 'text-gray-300');
                activeTab.setAttribute('aria-selected', 'true');
            }
            
            // Update description and button text based on mode
            if (currentAppMode === 'balance_meter') {
                if (modeDescription) {
                    modeDescription.innerHTML = '<strong class="text-teal-300">Balance Meter:</strong> Triple-channel analysis (Seismograph v1.0, Balance Channel v1.1, SFD v1.2) showing crisis detection, rebalanced perspective, and net support measurement in integrated tables.';
                }
                if (generateBtn) {
                    generateBtn.textContent = '⚖️ Generate Balance Report';
                }
            } else {
                if (modeDescription) {
                    modeDescription.innerHTML = '<strong class="text-teal-300">Mirror:</strong> Geometry + reflection in one stream. Always includes the full skeletal ledger (angles, houses, hooks) plus the recognition layer. Seismograph trace auto-appends when transit hooks exist.';
                }
                if (generateBtn) {
                    generateBtn.textContent = '✨ Get My Mirror';
                }
            }
            
            if (showWiringBtn) {
                showWiringBtn.style.display = 'inline';
            }
            
            // Auto-populate today's date in Mirror mode
            autoPopulateTodayDates();
            
            updateUIBasedOnMode();
        }

        // --- Seismograph Auto-Append Logic ---
        function checkAndAppendSeismograph() {
            // Seismograph automatically appends to Mirror when transit hooks exist
            if (!latestResultData) return;
            
            const hasTransitData = latestResultData.person_a?.chart?.transitsByDate || 
                                 latestResultData.person_b?.chart?.transitsByDate || 
                                 latestResultData.composite?.transitsByDate || 
                                 latestResultData.synastry?.transitsByDate;
            
            if (hasTransitData) {
                // Check if any day has actual transit hooks
                let hasTransitHooks = false;
                const transitDataSources = [
                    latestResultData.person_a?.chart?.transitsByDate,
                    latestResultData.person_b?.chart?.transitsByDate,
                    latestResultData.composite?.transitsByDate,
                    latestResultData.synastry?.transitsByDate
                ].filter(Boolean);
                
                for (const transitData of transitDataSources) {
                    for (const dayData of Object.values(transitData)) {
                        if ((dayData.hooks || []).some(h => h.kind === 'transit')) {
                            hasTransitHooks = true;
                            break;
                        }
                    }
                    if (hasTransitHooks) break;
                }
                
                if (hasTransitHooks) {
                    // Triple-channel data now accessed via Balance Meter only
                    console.log('✅ Transit hooks detected - Balance Meter triple-channel available');
                } else {
                    console.log('ℹ️ No transit hooks found - Mirror only');
                }
            }
        }

        function updateSeismographTabIndicator() {
            // No separate seismograph tab; indicator not used
            console.log('Seismograph folded into Balance Meter; no tab indicator');
        }
        
        function updateContextType(contextType) {
            currentContextType = contextType;
            console.log('[CTX] Switching contextType ->', contextType);
            
            // Update Weather badge visibility
            const weatherBadge = document.getElementById('weather-badge');
            if (weatherBadge) {
                if (contextType === 'weather') {
                    weatherBadge.classList.remove('hidden');
                } else {
                    weatherBadge.classList.add('hidden');
                }
            }
            
            // Update the legacy context mode for compatibility
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (contextType === 'solo') {
                hidePersonBSection();
                hideRelationalSubtypes();
                hideRelationalContext();
                showSoloSubtypes();
                // Default to current solo subtype or natal_transits
                const soloSubtype = document.querySelector('input[name="soloSubtype"]:checked')?.value || 'natal_transits';
                updateSoloSubtype(soloSubtype);
            } else if (contextType === 'relational') {
                showPersonBSection();
                showRelationalSubtypes();
                showRelationalContext(); // ensure visible
                const rcs = document.getElementById('relational-context-section');
                if (rcs && rcs.classList.contains('hidden')) {
                    console.warn('[CTX] Relational context was hidden unexpectedly; forcing show.');
                    rcs.classList.remove('hidden');
                }
                hideSoloSubtypes();
                // Default to composite for relational
                const relationalSubtype = document.querySelector('input[name="relationalSubtype"]:checked')?.value || 'composite';
                updateRelationalSubtype(relationalSubtype);
                
                // Re-enable relationship type controls when switching to relational mode
                const relationshipControls = document.querySelectorAll('input[name="relationshipType"], input[name="intimacyTier"], #exRelationship');
                relationshipControls.forEach(control => {
                    control.disabled = false;
                    if (control.parentElement) {
                        control.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                });
                
                // Evaluate relational context visibility after switching
                if (window.evaluateRelationalContextVisibility) {
                    setTimeout(window.evaluateRelationalContextVisibility, 100);
                }
            } else if (contextType === 'weather') {
                // Weather only mode - hide person sections
                hidePersonBSection();
                hideRelationalSubtypes();
                hideSoloSubtypes();
                hideRelationalContext();
                // Set to transit-only mode
                contextModeInputs.forEach(input => { input.checked = input.checked && false; });
            }
            
            updateFormUI();
        }
        
        function updateSoloSubtype(subtype) {
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (subtype === 'natal_only') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_only';
                });
            } else if (subtype === 'natal_transits') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_transits';
                });
            }
            
            updateFormUI();
        }
        
        function updateRelationalSubtype(subtype) {
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (subtype === 'synastry') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'synastry_transits';
                });
            } else if (subtype === 'composite') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'composite_transits';
                });
            }
            
            updateFormUI();
        }
        
        function showPersonBSection() {
            const personBToggle = document.getElementById('personB-toggle');
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            
            if (personBToggle && personBDetails) {
                personBToggle.setAttribute('aria-expanded', 'true');
                personBDetails.classList.remove('hidden');
                if (personBChevron) {
                    personBChevron.classList.add('rotate-180');
                }
            }
        }
        
        function hidePersonBSection() {
            const personBToggle = document.getElementById('personB-toggle');
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            
            if (personBToggle && personBDetails) {
                personBToggle.setAttribute('aria-expanded', 'false');
                personBDetails.classList.add('hidden');
                if (personBChevron) {
                    personBChevron.classList.remove('rotate-180');
                }
            }
        }
        
        function showSoloSubtypes() {
            const soloSubtypes = document.getElementById('solo-subtypes');
            if (soloSubtypes) {
                soloSubtypes.classList.remove('hidden');
            }
        }
        
        function hideSoloSubtypes() {
            const soloSubtypes = document.getElementById('solo-subtypes');
            if (soloSubtypes) {
                soloSubtypes.classList.add('hidden');
            }
        }
        
        function showRelationalSubtypes() {
            const relationalSubtypes = document.getElementById('relational-subtypes');
            if (relationalSubtypes) {
                relationalSubtypes.classList.remove('hidden');
            }
        }
        
        function hideRelationalSubtypes() {
            const relationalSubtypes = document.getElementById('relational-subtypes');
            if (relationalSubtypes) {
                relationalSubtypes.classList.add('hidden');
            }
        }
        
        function showRelationalContext() {
            const relationalContext = document.getElementById('relational-context-section');
            if (relationalContext) {
                relationalContext.classList.remove('hidden');
            }
        }
        
        function hideRelationalContext() {
            const relationalContext = document.getElementById('relational-context-section');
            if (relationalContext) {
                relationalContext.classList.add('hidden');
                // Clear relationship type selections when hiding relational context
                clearRelationshipTypeSelections();
            }
        }
        
        function clearRelationshipTypeSelections() {
            // Clear all relationship type radio buttons
            document.querySelectorAll('input[name="relationshipType"]').forEach(radio => {
                radio.checked = false;
            });
            // Clear intimacy tier selections
            document.querySelectorAll('input[name="intimacyTier"]').forEach(radio => {
                radio.checked = false;
            });
            // Clear ex-relationship checkbox
            const exRelCheckbox = document.getElementById('exRelationship');
            if (exRelCheckbox) {
                exRelCheckbox.checked = false;
            }
        }
        
        function autoPopulateTodayDates() {
            const todayStr = getTodayDateString();
            const startDate = document.getElementById('transitStartDate');
            const endDate = document.getElementById('transitEndDate');
            
            if (startDate && endDate) {
                // Only auto-populate if fields are empty
                if (!startDate.value) startDate.value = todayStr;
                if (!endDate.value) endDate.value = todayStr;
            }
        }
        
        function showAdvancedTransitOptions() {
            const advancedOptions = document.getElementById('advanced-transit-options');
            if (advancedOptions) {
                advancedOptions.classList.remove('hidden');
            }
        }
        
        function hideAdvancedTransitOptions() {
            const advancedOptions = document.getElementById('advanced-transit-options');
            if (advancedOptions) {
                advancedOptions.classList.add('hidden');
            }
        }
        
        function updateUIBasedOnMode() {
            const mathBrainBanner = document.querySelector('#context-options .bg-yellow-900');
            
            if (currentAppMode === 'mirror') {
                // Hide Math Brain banner in Mirror mode
                if (mathBrainBanner) {
                    mathBrainBanner.style.display = 'none';
                }
                hideAdvancedTransitOptions();
            }
        }
        
        function togglePersonB() {
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            const personBToggle = document.getElementById('personB-toggle');
            
            if (personBDetails && personBChevron && personBToggle) {
                const isExpanded = personBToggle.getAttribute('aria-expanded') === 'true';
                
                personBToggle.setAttribute('aria-expanded', !isExpanded);
                personBDetails.classList.toggle('hidden');
                personBChevron.classList.toggle('rotate-180');
                
                // If expanding and we're in solo mode, switch to relational
                if (!isExpanded && currentContextType === 'solo') {
                    const relationalRadio = document.querySelector('input[name="contextType"][value="relational"]');
                    if (relationalRadio) {
                        relationalRadio.checked = true;
                        updateContextType('relational');
                    }
                }
                
                // Show relationship context when Person B is expanded in any relational mode
                if (!isExpanded && (currentContextType === 'relational' || 
                    ['synastry_transits', 'composite_transits'].includes(document.querySelector('input[name="contextMode"]:checked')?.value))) {
                    showRelationalContext();
                }
                
                // Update form UI to enable/disable Person B based on expansion state
                updateFormUI();
                
                // Evaluate relational context visibility when Person B is toggled
                setTimeout(() => {
                    const evaluateFunc = window.evaluateRelationalContextVisibility;
                    if (evaluateFunc) evaluateFunc();
                }, 50);
            }
        }
        
        function toggleRelocation() {
            const relocationDetails = document.getElementById('relocation-details');
            const relocationChevron = document.getElementById('relocation-chevron');
            const relocationToggle = document.getElementById('relocationToggle');
            const relocationHeader = document.getElementById('relocation-toggle-header');
            
            if (relocationDetails && relocationChevron && relocationHeader) {
                const isExpanded = relocationHeader.getAttribute('aria-expanded') === 'true';
                
                relocationHeader.setAttribute('aria-expanded', !isExpanded);
                relocationDetails.classList.toggle('hidden');
                relocationChevron.classList.toggle('rotate-180');
                
                // Also toggle the checkbox
                if (relocationToggle) {
                    relocationToggle.checked = !isExpanded;
                }
            }
        }
        
        function setupProgressiveDisclosureEventListeners() {
            // Mirror mode (only mode now - seismograph auto-appends)
            const mirrorTab = document.getElementById('mirrorModeTab');
            
            if (mirrorTab) {
                mirrorTab.addEventListener('click', () => updateAppMode('mirror'));
            }
            
            // Context type selection
            document.querySelectorAll('input[name="contextType"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateContextType(e.target.value));
            });
            
            // Solo subtypes
            document.querySelectorAll('input[name="soloSubtype"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateSoloSubtype(e.target.value));
            });
            
            // Relational subtypes
            document.querySelectorAll('input[name="relationalSubtype"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateRelationalSubtype(e.target.value));
            });
            
            // Person B toggle
            const personBToggle = document.getElementById('personB-toggle');
            if (personBToggle) {
                personBToggle.addEventListener('click', togglePersonB);
                personBToggle.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        togglePersonB();
                    }
                });
            }
            
            // Relocation toggle
            const relocationHeader = document.getElementById('relocation-toggle-header');
            if (relocationHeader) {
                relocationHeader.addEventListener('click', toggleRelocation);
                relocationHeader.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleRelocation();
                    }
                });
            }
            const relocationToggleElInline = document.getElementById('relocationToggle');
            if (relocationToggleElInline){
                relocationToggleElInline.addEventListener('change', updateRelocationNote);
            }
            
            // Today default button
            const todayDefaultBtn = document.getElementById('todayDefault');
            if (todayDefaultBtn) {
                todayDefaultBtn.addEventListener('click', () => {
                    const todayStr = getTodayDateString();
                    document.getElementById('transitStartDate').value = todayStr;
                    document.getElementById('transitEndDate').value = todayStr;
                    
                    // Visual feedback
                    todayDefaultBtn.textContent = '✅ Set to Today';
                    setTimeout(() => {
                        todayDefaultBtn.textContent = '📅 Use Today';
                    }, 2000);
                });
            }
            
            // Expand transit options button
            const expandTransitBtn = document.getElementById('expandTransitOptions');
            if (expandTransitBtn) {
                expandTransitBtn.addEventListener('click', () => {
                    const advancedOptions = document.getElementById('advanced-transit-options');
                    if (advancedOptions) {
                        const isHidden = advancedOptions.classList.contains('hidden');
                        advancedOptions.classList.toggle('hidden');
                        expandTransitBtn.textContent = isHidden ? '⚙️ Hide Options' : '⚙️ More Options';
                    }
                });
            }
            
            // Context help toggle
            const contextHelpBtn = document.getElementById('context-help-btn');
            const contextHelpPanel = document.getElementById('context-help-panel');
            if (contextHelpBtn && contextHelpPanel) {
                contextHelpBtn.addEventListener('click', () => {
                    const isHidden = contextHelpPanel.classList.contains('hidden');
                    contextHelpPanel.classList.toggle('hidden');
                    contextHelpBtn.textContent = isHidden ? '🧭 Hide Guide' : '🧭 Context Guide';
                });
            }
            
            // Show Wiring button (scroll to geometry section)
            const showWiringBtn = document.getElementById('showWiringBtn');
            if (showWiringBtn) {
                showWiringBtn.addEventListener('click', () => {
                    // Ensure we're in Mirror mode (geometry always embedded now)
                    if (currentAppMode !== 'mirror') updateAppMode('mirror');
                    // Scroll to report section and optionally highlight geometry skeleton heading
                    const reportSection = document.getElementById('reportOutput');
                    if (reportSection && !reportSection.classList.contains('hidden')) {
                        reportSection.scrollIntoView({ behavior: 'smooth' });
                        const geomHeader = reportSection.querySelector('h2, h1');
                        if (geomHeader) {
                            geomHeader.classList.add('ring-2','ring-teal-400','ring-offset-2','ring-offset-gray-900');
                            setTimeout(()=>geomHeader.classList.remove('ring-2','ring-teal-400','ring-offset-2','ring-offset-gray-900'),1800);
                        }
                    }
                });
            }
        }
        
        // =============================================================================
        // END NEW UX IMPROVEMENT FUNCTIONS
        // =============================================================================

        // ---------- Relocation Defaults & Persistence (Panama City baseline) ----------
        const DEFAULT_RELOC = { city: 'Panama City', state: 'FL', coords: "30°10'N, 85°40'W" };
        const RELOC_PREF_KEY = 'wm_pref_default_reloc_enabled';
        const DMS_RE = /^\s*([0-9]{1,3})\s*[°]?\s*([0-9]{1,2})?\s*['′]?\s*([0-9]{1,2}(?:\.\d+)?)?\s*([NnSs])\s*,?\s*([0-9]{1,3})\s*[°]?\s*([0-9]{1,2})?\s*['′]?\s*([0-9]{1,2}(?:\.\d+)?)?\s*([EeWw])\s*$/;
        const DEC_RE = /^\s*(-?\d{1,3}(?:\.\d+)?)\s*,\s*(-?\d{1,3}(?:\.\d+)?)\s*$/;
        function dmsToDec(d,m,s,h){const sign=/[SsWw]/.test(h)?-1:1;return sign*(+d+(+(m||0))/60+(+(s||0))/3600);}        
        function parseLatLonFlexible(input){
            if(!input) return null;
            const m1 = DEC_RE.exec(input); if(m1){ const lat=+m1[1], lon=+m1[2];
                return (isFinite(lat)&&isFinite(lon)&&Math.abs(lat)<=90&&Math.abs(lon)<=180)
                  ? {lat, lon, normalized:`${lat.toFixed(6)}, ${lon.toFixed(6)}`} : null; }
            const cleaned = input.replace(/°|º/g,'°').replace(/’|′/g,"'");
            const m2 = DMS_RE.exec(cleaned); if(m2){ const lat=dmsToDec(m2[1],m2[2],m2[3],m2[4]); const lon=dmsToDec(m2[5],m2[6],m2[7],m2[8]);
                return (isFinite(lat)&&isFinite(lon)) ? {lat, lon, normalized:`${lat.toFixed(6)}, ${lon.toFixed(6)}`} : null; }
            return null;
        }
        function attachCoordValidator(inputId, hintId){
            const el=document.getElementById(inputId), hint=document.getElementById(hintId);
            if(!el||!hint) return; 
            el.addEventListener('blur', ()=>{ const v=el.value.trim(); if(!v){ hint.textContent=''; hint.className='mt-1 text-xs'; return; }
                const ok=parseLatLonFlexible(v); if(ok){ hint.textContent=`✓ Normalized: ${ok.normalized}`; hint.className='mt-1 text-xs text-teal-300'; }
                else { hint.textContent='Invalid. Use "lat, lon" (e.g., 30.1667, -85.6667) or DMS (30°10\'N, 85°40\'W).'; hint.className='mt-1 text-xs text-red-400'; }
            });
        }
        function applyRelocDefaults(openSection=true){
            const t=document.getElementById('relocationToggle');
            const city=document.getElementById('relocationCity');
            const st=document.getElementById('relocationState');
            const c=document.getElementById('relocationCoords');
            if(!t||!city||!st||!c) return; 
            city.value=DEFAULT_RELOC.city; st.value=DEFAULT_RELOC.state; c.value=DEFAULT_RELOC.coords; t.checked=true;
            if(openSection){
                document.getElementById('relocation-details')?.classList.remove('hidden');
                document.getElementById('relocation-toggle-header')?.setAttribute('aria-expanded','true');
            }
            c.dispatchEvent(new Event('blur'));
            updateRelocationNote();
        }
        function wireUseDefaultRelocButton(){
            const btn=document.getElementById('useDefaultRelocation');
            if(!btn) return; btn.addEventListener('click', ()=> applyRelocDefaults(true));
        }
        function loadRelocPref(){ return localStorage.getItem(RELOC_PREF_KEY)==='1'; }
        function saveRelocPref(v){ localStorage.setItem(RELOC_PREF_KEY, v?'1':'0'); }
        function updateRelocationNote(){
            const note = document.getElementById('relocation-default-note');
            const toggle = document.getElementById('relocationToggle');
            if(!note || !toggle) return;
            if(toggle.checked){
                note.textContent = 'Relocation overlay ACTIVE using current values (modify city/coords as needed).';
                note.className='mb-4 text-xs text-teal-300';
            } else {
                note.textContent = "Panama City, FL (30°10'N, 85°40'W) is pre-filled as a suggested relocation reference. It is NOT applied until you enable the checkbox.";
                note.className='mb-4 text-xs text-gray-500 italic';
            }
        }


        function updateFormUI() {
            const modeSel = document.querySelector('input[name="contextMode"]:checked');
            const mode = modeSel ? modeSel.value : (currentContextType === 'weather' ? 'sky_transits' : 'natal_transits');
            console.log('[UPDATE UI] Current mode:', mode);

            const isNatalOnly = mode === 'natal_only';
            const isNatal = mode === 'natal_transits';
            const isSynastryTransits = mode === 'synastry_transits';
            const isCompositeTransits = mode === 'composite_transits';
            
            console.log('[UPDATE UI] Mode analysis:', { isNatalOnly, isNatal, isSynastryTransits, isCompositeTransits });
            
            // Person B should be enabled for relational context OR when manually expanded
            const isRelationalContext = currentContextType === 'relational';
            const isPersonBExpanded = document.getElementById('personB-toggle')?.getAttribute('aria-expanded') === 'true';
            const showPersonB = isRelationalContext || isPersonBExpanded || (!isNatalOnly && !isNatal);
            // Visual dim only when not active; keep header clickable to allow expansion
            personBCard.style.opacity = showPersonB ? '1' : '0.5';
            // Never fully disable pointer events on the whole card (so header can always be clicked)
            personBCard.style.pointerEvents = 'auto';
            // Instead, disable the form controls inside when not active
            const personBInputs = personBCard.querySelectorAll('input, select, button:not(#personB-toggle)');
            personBInputs.forEach(el => {
                if (el.id === 'personB-toggle') return; // safeguard
                if (!showPersonB) {
                    el.setAttribute('disabled','disabled');
                    el.classList.add('cursor-not-allowed','opacity-70');
                } else {
                    el.removeAttribute('disabled');
                    el.classList.remove('cursor-not-allowed','opacity-70');
                }
            });

            const showTransitFields = !isNatalOnly; // Show transit fields for all modes except natal_only
            console.log('[UPDATE UI] Transit fields:', { showTransitFields, isNatalOnly, transitDateFields: !!transitDateFields });
            
            if (transitDateFields) {
                transitDateFields.style.display = showTransitFields ? 'block' : 'none';
                console.log('[UPDATE UI] ✅ Transit fields display set to:', showTransitFields ? 'block' : 'none');
                
                // Debug parent visibility
                const parent = transitDateFields.parentElement;
                const grandParent = parent?.parentElement;
                console.log('[UPDATE UI] Parent visibility check:', {
                    parentId: parent?.id || 'no-id',
                    parentClasses: parent?.className || '',
                    parentDisplay: parent ? getComputedStyle(parent).display : 'not found',
                    grandParentId: grandParent?.id || 'no-id', 
                    grandParentClasses: grandParent?.className || '',
                    grandParentDisplay: grandParent ? getComputedStyle(grandParent).display : 'not found'
                });
            } else {
                console.error('[UPDATE UI] ❌ transitDateFields element not found!');
            }

            // CRITICAL: Relocation overlay available for ALL chart modes (natal_only and transit modes)
            // Relocation is about geometric foundation shift, not timing - affects natal architecture context
            const showRelocation = currentContextType !== 'weather';
            if (relocationSection) relocationSection.style.display = showRelocation ? 'block' : 'none';

            // Hide Person A card entirely in weather mode (no natal)
            const personACard = document.getElementById('personA-card');
            if (personACard) {
                if (currentContextType === 'weather') personACard.classList.add('hidden');
                else personACard.classList.remove('hidden');
            }
            
            // Update Person B relocation option visibility
            updateRelocationPersonBOption();
            
            // Show/hide relational context section based on whether this is a relational mode
            const isRelationalMode = isSynastryTransits || isCompositeTransits;
            if (isRelationalMode || currentContextType === 'relational') {
                showRelationalContext();
            } else {
                hideRelationalContext();
            }
        }
        
        function updateRelocationPersonBOption() {
            const mode = document.querySelector('input[name="contextMode"]:checked').value;
            const showPersonB = mode !== 'natal';
            const relocationEnabled = relocationToggle && relocationToggle.checked;
            
            // Show the Person B relocation option only if Person B is present and relocation is enabled
            if (relocationPersonBOption) {
                if (showPersonB && relocationEnabled) {
                    relocationPersonBOption.classList.remove('hidden');
                } else {
                    relocationPersonBOption.classList.add('hidden');
                }
            }
        }

        // Initial UI setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Legacy deep-link normalization (?mode=geometry -> mirror#geometry-skeleton)
            try {
                const params = new URLSearchParams(location.search);
                const legacyMode = params.get('mode');
                if (legacyMode === 'geometry') {
                    // Replace state without adding history entry
                    const newUrl = location.pathname + '?mode=mirror#geometry-skeleton';
                    history.replaceState({}, '', newUrl);
                    // Defer scroll until after first render
                    setTimeout(()=>{
                        const anchor = document.getElementById('geometry-skeleton') || document.querySelector('[id="geometry-skeleton"]');
                        anchor && anchor.scrollIntoView({behavior:'smooth', block:'start'});
                    }, 1200);
                }
            } catch(e){ console.warn('Deep-link normalization failed', e); }
            // DOM Elements assignment
            generateBtn = document.getElementById('generateReport');
            loadingIndicator = document.getElementById('loadingIndicator');
            errorDisplay = document.getElementById('errorDisplay');
            errorMessage = document.getElementById('errorMessage');
            reportOutput = document.getElementById('reportOutput');
            reportContent = document.getElementById('reportContent');
            copyBtn = document.getElementById('copyReport');
            downloadReportBtn = document.getElementById('downloadReport');
            mathBrainInfoBtn = document.getElementById('math-brain-info-btn');
            mathBrainModal = document.getElementById('math-brain-modal');
            closeMathBrainModal = document.getElementById('close-math-brain-modal');
            closeMathBrainModalBottom = document.getElementById('close-math-brain-modal-bottom');
            relocationToggle = document.getElementById('relocationToggle');
            relocationFields = document.getElementById('relocationFields');
            transitDateFields = document.getElementById('quick-transit-section'); // The actual transit section, not the legacy hidden one
            personBCard = document.getElementById('personB-card');
            relocationSection = document.getElementById('relocation-section');

            // Raw data toggle functionality
            const toggleRawDataBtn = document.getElementById('toggleRawData');
            const hideRawDataBtn = document.getElementById('hideRawData');
            const rawDataSection = document.getElementById('rawDataSection');
            
            if (toggleRawDataBtn && hideRawDataBtn && rawDataSection) {
                toggleRawDataBtn.addEventListener('click', () => {
                    rawDataSection.classList.remove('hidden');
                    toggleRawDataBtn.style.display = 'none';
                });
                
                hideRawDataBtn.addEventListener('click', () => {
                    rawDataSection.classList.add('hidden');
                    toggleRawDataBtn.style.display = 'inline';
                });
            }
            relationalContextSection = document.getElementById('relational-context-section');
            intimacyTierDropdown = document.getElementById('intimacy-tier-dropdown');
            exRelationshipCheckbox = document.getElementById('exRelationship');
            relocationPersonBOption = document.getElementById('relocationPersonBOption');
            includePersonBRelocationEl = document.getElementById('includePersonBRelocation');
            transitStartDate = document.getElementById('transitStartDate');
            transitEndDate = document.getElementById('transitEndDate');
            transitStep = document.getElementById('transitStep');
            relocationCoordsInput = document.getElementById('relocationCoords');
            
            // Health Data UI elements
            loadHealthDataBtn = document.getElementById('loadHealthDataBtn');
            clearHealthDataBtn = document.getElementById('clearHealthDataBtn');
            healthDataInput = document.getElementById('healthDataInput');
            healthDataStatus = document.getElementById('healthDataStatus');
            toggleModeHelp = document.getElementById('toggle-mode-help');
            modeHelpPanel = document.getElementById('mode-help-panel');
            prefillTodayBtn = document.getElementById('prefillToday');
            stepSizeHelpBtn = document.getElementById('stepSizeHelp');
            stepSizeHelpPanel = document.getElementById('stepSizeHelpPanel');
            // Sync help copy with configured limits
            try {
                const panel = stepSizeHelpPanel;
                if (panel) {
                    const paras = Array.from(panel.querySelectorAll('p'));
                    const apiProt = paras.find(p => /API Protection/i.test(p.textContent||''));
                    const dMax = (window.WOVEN_STEP_LIMITS?.daily?.max)||45;
                    const wMax = (window.WOVEN_STEP_LIMITS?.weekly?.max)||270;
                    const mMax = (window.WOVEN_STEP_LIMITS?.monthly?.max)||550;
                    const wMonths = Math.round(wMax/30);
                    const mMonths = Math.round(mMax/30);
                    if (apiProt) {
                        apiProt.innerHTML = `<b>API Protection</b>: Configured limits — Daily=${dMax} days max, Weekly=${wMonths} months max, Monthly=${mMonths} months max.`;
                    }
                }
            } catch(e){ console.warn('Could not refresh Step Size help copy', e); }
            // Relationship role custom field toggle (delegated)
            document.addEventListener('change', (e)=>{
                if (e.target && e.target.id === 'relationshipRole') {
                    const roleCustom = document.getElementById('relationshipRoleCustom');
                    roleCustom && roleCustom.classList.toggle('hidden', e.target.value !== 'other');
                }
            });

            console.log("DOM elements assigned:", {
                generateBtn: !!generateBtn,
                loadingIndicator: !!loadingIndicator,
                errorDisplay: !!errorDisplay,
                transitStartDate: !!transitStartDate,
                transitEndDate: !!transitEndDate,
                transitStep: !!transitStep,
                relocationCoordsInput: !!relocationCoordsInput,
                seismoMdInput: !!document.getElementById('seismoMdInput'),
                genComparativeBtn: !!document.getElementById('genComparativeBtn'),
                relocationSection: !!relocationSection
            });

            // Developer hint: override step limits from console if desired
            try {
                console.info('Step limits in use:', window.WOVEN_STEP_LIMITS);
                console.info('To override limits in this browser, run:', "localStorage.setItem('wm_step_limits_override', JSON.stringify({daily:{max:60,warnRatio:0.85},weekly:{max:360},monthly:{max:720}})); location.reload();");
            } catch(_) {}

            setupEventListeners();
            setupProgressiveDisclosureEventListeners(); // New UX improvement functions
            
            updateFormUI();
            
            // Relocation default wiring & persistence
            // Ensure hint container exists
            if(document.getElementById('relocationCoords') && !document.getElementById('relocationCoordsError')){
                const hint=document.createElement('div'); hint.id='relocationCoordsError'; hint.className='mt-1 text-xs'; hint.setAttribute('aria-live','polite');
                document.getElementById('relocationCoords').parentNode.appendChild(hint);
            }
            attachCoordValidator('relocationCoords','relocationCoordsError');
            wireUseDefaultRelocButton();
            if(loadRelocPref()) { applyRelocDefaults(false); }
            // Add persistence checkbox inside details if not present
            const details = document.getElementById('relocation-details');
            if(details && !document.getElementById('alwaysUseDefaultReloc')){
                const wrap=document.createElement('label');
                wrap.className='mt-3 flex items-center gap-2 text-sm';
                wrap.innerHTML='<input id="alwaysUseDefaultReloc" type="checkbox" class="h-4 w-4"> Always use Panama City by default';
                details.appendChild(wrap);
                const cb=document.getElementById('alwaysUseDefaultReloc');
                cb.checked=loadRelocPref();
                cb.addEventListener('change',e=> saveRelocPref(e.target.checked));
            }
            // Header quick button
            const relocQuickBtn = document.getElementById('relocQuickBtn');
            const relocToggleEl = document.getElementById('relocationToggle');
            if (relocQuickBtn){
                // Only apply defaults when user clicks; show neutral visual otherwise
                relocQuickBtn.addEventListener('click', ()=>{
                    applyRelocDefaults(true);
                    document.getElementById('relocation-section')?.scrollIntoView({behavior:'smooth', block:'start'});
                    if (relocQuickBtn) { relocQuickBtn.setAttribute('aria-pressed','true'); relocQuickBtn.classList.add('bg-teal-600','text-white'); }
                });
                // Sync visual state with checkbox
                if (relocToggleEl) {
                    const syncQuickBtn = () => {
                        const checked = !!relocToggleEl.checked;
                        relocQuickBtn.setAttribute('aria-pressed', checked ? 'true' : 'false');
                        if (checked) { relocQuickBtn.classList.add('bg-teal-600','text-white'); }
                        else { relocQuickBtn.classList.remove('bg-teal-600','text-white'); }
                        updateRelocationNote();
                    };
                    relocToggleEl.addEventListener('change', syncQuickBtn);
                    // initial sync
                    syncQuickBtn();
                }
            }
            // Initial note state if not already updated
            updateRelocationNote();

            // Initialize with Mirror mode
            updateAppMode('mirror');
            updateContextType('solo');
            
            // Auto-prefill transit dates with today for convenience
            const todayStr = getTodayDateString();
            if (transitStartDate && transitEndDate) {
                transitStartDate.value = todayStr;
                transitEndDate.value = todayStr;
            }
            
            // Initial check for intimacy tier
            const isPartner = document.querySelector('input[name="relationshipType"]:checked')?.value === 'partner';
            intimacyTierDropdown.classList.toggle('hidden', !isPartner);
            
            // Mobile-specific initialization
            initializeMobileSupport();
            
            // Validate safe lexicon implementation
            validateSafeLexicon();
        });
        
        // Mobile support initialization
        function initializeMobileSupport() {
            console.log('Initializing mobile support...');
            
            // Check if we're on a mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isSmallScreen = window.innerWidth <= 768;
            
            console.log('Mobile detection:', { isMobile, isSmallScreen, userAgent: navigator.userAgent });
            
            if (isMobile || isSmallScreen) {
                // Add mobile class to body for additional styling hooks
                document.body.classList.add('mobile-device');
                
                // Fix date inputs on mobile
                const dateInputs = document.querySelectorAll('input[type="date"]');
                dateInputs.forEach(input => {
                    // Ensure proper date format handling
                    input.addEventListener('input', function(e) {
                        console.log('Date input changed:', e.target.id, 'value:', e.target.value);
                        
                        // Validate the date format
                        if (e.target.value && !/^\d{4}-\d{2}-\d{2}$/.test(e.target.value)) {
                            console.warn('Date format issue detected:', e.target.value);
                            // Try to convert common formats
                            if (e.target.value.includes('/')) {
                                const parts = e.target.value.split('/');
                                if (parts.length === 3) {
                                    // Assume MM/DD/YYYY format and convert to YYYY-MM-DD
                                    const month = parts[0].padStart(2, '0');
                                    const day = parts[1].padStart(2, '0');
                                    const year = parts[2];
                                    const isoDate = `${year}-${month}-${day}`;
                                    console.log('Converting date format:', e.target.value, 'to', isoDate);
                                    e.target.value = isoDate;
                                }
                            }
                        }
                    });
                    
                    // Prevent iOS zoom on focus
                    input.addEventListener('focus', function(e) {
                        console.log('Date input focused:', e.target.id);
                        e.target.style.fontSize = '16px';
                    });
                });
                
                // Also handle time inputs
                const timeInputs = document.querySelectorAll('input[type="time"]');
                timeInputs.forEach(input => {
                    input.addEventListener('focus', function(e) {
                        e.target.style.fontSize = '16px';
                    });
                });
                
                // Handle text inputs that might become date inputs on mobile
                const textInputs = document.querySelectorAll('input[type="text"]');
                textInputs.forEach(input => {
                    input.addEventListener('focus', function(e) {
                        e.target.style.fontSize = '16px';
                    });
                });
                
                console.log('Mobile support initialized');
            }
        }
    </script>
</body>
</html>

    <!DOCTYPE html>
    <!-- COPILOT_GUIDE: CLEAR MIRROR DOWNSTREAM ONLY
     - Math Brain payload is geometry-only. Do NOT generate narrative (Clear Mirror) here.
     - Never emit keys named field, voice, or map back to serverless layer.
     - Provide RAVEN_NUDGE + Mirror flags so downstream Poetic Brain (Raven Calder) can translate FIELD → MAP → VOICE.
     - Use hooks (≤2° preference), seismograph (magnitude, valence, volatility, scaling_strategy/confidence), retrograde flags, and True/Mean Node distinctions.
     - Timezone baseline preference: America/Chicago (Central). Emit TZ check hints; do not auto-correct silently.
     - Add Mini Glossary + Raven Checklist at footer for non-Raven consumers.
     - TODO[RAVEN]: Read seismograph scaling to nuance stability vs emergent signal.
     - TODO[RAVEN]: If multiple retrograde_involved hooks, surface a "revision/recursion" nuance.
  
        === STYLE NOTE: TERMINOLOGY LAYERING (Woven Map) ===
        Purpose: Prevent collapse into mechanistic language ("wiring"). Prefer mythic metaphors by layer:
            1. Natal / Personality Context → "Reveal the Weave" (structural identity, natal pattern coherence)
            2. Transit (daily / short-term) → "Trace the Threads" (live activations tugged or loosening)
            3. Transit Aggregation / Macro Pressure → "Currents" / "Seismograph" (pressure states, symbolic weather, volatility)
        Raven Calder (Poetic Brain) alone produces narrative/interpretation. Math Brain supplies geometry + nudges only.
        If NOT Raven Calder GPT:
            - Auto-append Mini Glossary footer.
            - Reinforce role distinction: "Math Brain finds the coordinates; Poetic Brain translates the weave."
        ================================================
    -->
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Woven Map Math Brain - Pure Astrological Geometry</title>
        <link href="dist/output.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <style>
            body { font-family: 'Inter', sans-serif; }
            ::-webkit-scrollbar { width: 8px; }
            ::-webkit-scrollbar-track { background: #1a202c; }
            ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
            ::-webkit-scrollbar-thumb:hover { background: #718096; }
            .animate-fade-in-out { animation: fadeInOut 8s ease-in-out forwards; }
            @keyframes fadeInOut { 0%, 100% { opacity: 0; transform: translateY(-20px); } 10%, 90% { opacity: 1; transform: translateY(0); } }
            .bg-gray-750 { background-color: #334155; }
            
            /* Mobile-specific fixes for date inputs and form elements */
            @media (max-width: 768px) {
                /* Fix date input styling on mobile */
                input[type="date"] {
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    background-color: #374151 !important;
                    color: #ffffff !important;
                    border: 1px solid #4b5563 !important;
                    padding: 0.5rem !important;
                    border-radius: 0.375rem !important;
                    font-size: 16px; /* Prevents zoom on iOS */
                    text-align: left !important;
                }
                
                /* Ensure date input text is visible */
                input[type="date"]::-webkit-datetime-edit-text,
                input[type="date"]::-webkit-datetime-edit-month-field,
                input[type="date"]::-webkit-datetime-edit-day-field,
                input[type="date"]::-webkit-datetime-edit-year-field {
                    color: #ffffff;
                }
                
                /* Style the date picker button */
                input[type="date"]::-webkit-calendar-picker-indicator {
                    background-color: #ffffff;
                    border-radius: 3px;
                    cursor: pointer;
                    opacity: 0.8;
                }
                
                input[type="date"]::-webkit-calendar-picker-indicator:hover {
                    opacity: 1;
                }
                
                /* Prevent zoom on all form inputs on iOS */
                input, select, textarea {
                    font-size: 16px !important;
                }
                
                /* Fix time input styling */
                input[type="time"] {
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    background-color: #374151 !important;
                    color: #ffffff !important;
                    border: 1px solid #4b5563 !important;
                    text-align: left !important;
                }
                
                /* Ensure mobile viewport doesn't zoom on input focus */
                input:focus, select:focus, textarea:focus {
                    font-size: 16px !important;
                }
            }
            
            /* General date input improvements for all devices */
            input[type="date"]:invalid {
                color: #ffffff;
            }
            
            input[type="date"]:valid {
                color: #ffffff;
            }
            
            /* Fallback for browsers that don't support color-scheme */
            input[type="date"] {
                color-scheme: dark;
            }
            
            /* Mobile tap target improvements */
            @media (max-width: 768px) {
                /* Increase radio button and checkbox sizes for easier tapping */
                input[type="radio"], input[type="checkbox"] {
                    min-width: 20px;
                    min-height: 20px;
                    margin-right: 12px;
                }
                
                /* Ensure labels are easily tappable */
                label {
                    min-height: 44px;
                    display: flex;
                    align-items: center;
                    cursor: pointer;
                }
                
                /* Increase button sizes */
                button {
                    min-height: 44px;
                    padding: 12px 16px;
                }
                
                /* Collapse verbose help by default */
                #stepSizeHelpPanel,
                #context-help-panel {
                    display: none;
                }
                
                /* Tab buttons should be larger on mobile */
                #mirrorModeTab,
                #geometryModeTab {
                    min-height: 48px;
                    padding: 12px 24px;
                }
            }
        </style>
    </head>
<body class="bg-gray-900 text-gray-200">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Woven Map Math Brain</h1>
            <p class="text-gray-400 mt-2 flex items-center justify-center gap-2">Pure Astrological Geometry Computation
                <button id="math-brain-info-btn" class="ml-2 text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                    What is Math Brain? (Glossary)
                </button>
            </p>
            
            <!-- Mirror/Geometry Tab Switch -->
            <div class="mt-6 mb-4">
                <div class="flex justify-center">
                    <div class="bg-gray-800 p-1 rounded-lg border border-gray-600 inline-flex" role="tablist" aria-label="Output Mode">
                        <button id="mirrorModeTab" type="button" role="tab" aria-selected="true" aria-controls="mirror-content" 
                                class="px-6 py-2 text-sm font-medium rounded-md bg-teal-600 text-white transition-colors duration-200" 
                                data-mode="mirror">
                            Mirror
                        </button>
                        <button id="geometryModeTab" type="button" role="tab" aria-selected="false" aria-controls="geometry-content"
                                class="px-6 py-2 text-sm font-medium rounded-md text-gray-300 hover:text-white transition-colors duration-200" 
                                data-mode="geometry">
                            Geometry
                        </button>
                    </div>
                </div>
                <div class="mt-2 text-xs text-gray-400 text-center">
                    <span id="modeDescription">
                        <strong class="text-teal-300">Mirror:</strong> The land seen in reflection—how the shapes form an image when two charts touch. 
                        <strong class="text-gray-300">Geometry:</strong> The surveyor's ledger—exact measurements without story.
                    </span>
                </div>
            </div>
        </header>

        <!-- Glossary Modal -->
        <div id="math-brain-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 hidden">
          <div class="bg-gray-900 rounded-lg shadow-xl max-w-lg w-full p-6 relative border border-teal-500">
            <button id="close-math-brain-modal" class="absolute top-2 right-2 text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            <h2 class="text-xl font-bold text-teal-300 mb-2">Math Brain & Poetic Brain: The Woven Map Framework</h2>
            <p class="text-sm text-gray-200 mb-3">
              <b>Math Brain</b>: computes planetary positions, aspects, house placements. Outputs geometry, no meaning.<br>
              <b>Poetic Brain</b>: translates geometry into felt/narrative language. Diagnostic, not predictive.<br>
              <b>TL;DR</b>: Math Brain finds the coordinates. Poetic Brain speaks the language you can feel.
            </p>
            <h3 class="text-teal-200 font-semibold mt-4 mb-1">Glossary</h3>
            <ul class="text-xs text-gray-300 space-y-1 max-h-48 overflow-y-auto pr-2">
              <li><b>FIELD → MAP → VOICE</b>: FIELD = energetic climate, MAP = geometry, VOICE = felt reflection.</li>
              <li><b>Recognition-First Principle</b>: Choose diagnostic mode based on real question, not technical curiosity.</li>
              <li><b>Context Modes</b>: Natal (single person), Synastry (interaction), Transit (current pressure), Composite (relationship entity).</li>
              <li><b>Ping</b>: Recognized resonance between chart and experience.</li>
              <li><b>SST</b>: Falsifiability filter. WB = Within Boundary, ABE = At Boundary Edge, OSR = Outside Symbolic Range.</li>
              <li><b>Echo Loop</b>: Dyadic cycle under 1° orb.</li>
              <li><b>REF</b>: Relational Echo Field, macro-pattern resonance between two charts.</li>
              <li><b>Intimacy Tier</b>: P1 = Platonic, P2 = FWB, P3 = Romantic.</li>
              <li><b>Clear Mirror</b>: Testable, non-mystical phrasing.</li>
              <li><b>29° Crisis Node</b>: Planet at 29°, volatility.</li>
              <li><b>Symbolic Weather Overlay</b>: Current transits as energetic "weather".</li>
              <li><b>Paradox Line</b>: Internal contradiction.</li>
            </ul>
            <div class="mt-4 text-right">
              <button id="close-math-brain-modal-bottom" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-1 px-4 rounded">Close</button>
            </div>
          </div>
        </div>

        <main>
            <!-- Person A & B Cards -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div id="personA-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <div class="flex items-center justify-between mb-4 border-b border-gray-700 pb-2">
                        <h2 class="text-2xl font-semibold text-white">Person A / Natal Chart</h2>
                        <div class="flex items-center gap-2">
                            <button id="relocQuickBtn" type="button" aria-pressed="false" class="text-xs px-3 py-1 rounded-full border border-gray-600 text-gray-300 hover:bg-gray-700/20 transition-colors" title="Apply Panama City relocation overlay">Reloc: Panama City</button>
                        </div>
                    </div>
                    <div class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="text" id="nameA" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="DH Cross">
                            <input type="text" id="birth_cityA" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="Bryn Mawr">
                            <input type="text" id="birth_stateA" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="PA">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <input type="date" id="birth_dateA" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="1973-07-24">
                            <input type="text" id="birth_timeA" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="14:30">
                            <select id="offsetA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <option value="America/Chicago" selected>Central (Chicago)</option>
                                <option value="America/New_York">Eastern (New York)</option>
                                <option value="America/Denver">Mountain (Denver)</option>
                                <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                <option value="America/Anchorage">Alaska</option>
                                <option value="Pacific/Honolulu">Hawaii</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="text" id="birth_countryA" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="US">
                            <select id="zodiacA" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <option value="Tropic">Tropic</option>
                                <option value="Sidereal">Sidereal</option>
                            </select>
                        </div>
                        <div>
                            <label for="astroA" class="block mb-1 text-sm font-medium text-gray-300">Birth Coordinates</label>
                            <input type="text" id="astroA" placeholder="e.g., 40°1'N, 75°18'W or 40.01, -75.31" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="40°1'N, 75°18'W">
                        </div>
                    </div>
                </div>
                
                <!-- Person B Card with Progressive Disclosure -->
                <div id="personB-card" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <!-- Person B Toggle Header -->
                    <div id="personB-toggle" class="flex items-center justify-between mb-4 cursor-pointer hover:bg-gray-750 p-2 -m-2 rounded transition-colors" role="button" tabindex="0" aria-expanded="false" aria-controls="personB-details">
                        <h2 class="text-2xl font-semibold text-white border-b border-gray-700 pb-2 border-b-0 pb-0">Person B (Optional)</h2>
                        <svg id="personB-chevron" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                    
                    <!-- Person B Details (collapsible) -->
                    <div id="personB-details" class="hidden">
                        <div class="border-b border-gray-700 mb-4"></div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <input type="text" id="nameB" placeholder="Name" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_cityB" placeholder="Birth City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_stateB" placeholder="Birth State/Prov" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <input type="date" id="birth_dateB" placeholder="Birth Date (YYYY-MM-DD)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <input type="text" id="birth_timeB" placeholder="Time (24h HH:MM)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <select id="offsetB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                    <option value="America/New_York">Eastern (New York)</option>
                                    <option value="America/Chicago">Central (Chicago)</option>
                                    <option value="America/Denver">Mountain (Denver)</option>
                                    <option value="America/Los_Angeles">Pacific (Los Angeles)</option>
                                    <option value="America/Anchorage">Alaska</option>
                                    <option value="Pacific/Honolulu">Hawaii</option>
                                </select>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <input type="text" id="birth_countryB" placeholder="Country (2-letter)" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                <select id="zodiacB" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                                    <option value="Tropic">Tropic</option>
                                    <option value="Sidereal">Sidereal</option>
                                </select>
                            </div>
                            <div>
                               <label for="astroB" class="block mb-1 text-sm font-medium text-gray-300">Birth Coordinates</label>
                               <input type="text" id="astroB" placeholder="e.g., 30.16, -85.66" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            </div>
                            <button id="pasteAstroB" class="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded text-sm">
                              Paste AstroSeek Data
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Gate: Simplified Selection -->
            <div id="context-gate-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold text-white">What do you want to explore?</h2>
                    <button id="context-help-btn" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 Context Guide
                    </button>
                </div>
                
                <!-- Context Help Panel (initially hidden) -->
                <div id="context-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Context Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Solo →</span>
                            <div class="text-gray-300">
                                <div>Your individual astrological architecture and current transits. <em>"What's my inner landscape and how is today pressing on it?"</em></div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Relational →</span>
                            <div class="text-gray-300">
                                <div>How two people activate each other, plus current pressures on the dynamic. <em>"What's happening between us?"</em></div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-20 text-teal-400 font-medium flex-shrink-0">Weather →</span>
                            <div class="text-gray-300">
                                <div>Current planetary pressures without personal chart context. <em>"What's the energetic weather right now?"</em></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity.
                        </p>
                    </div>
                </div>
                
                <div id="context-selection" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <label class="flex items-center p-4 border border-gray-600 rounded-lg hover:border-teal-500 transition-colors cursor-pointer">
                        <input type="radio" name="contextType" value="solo" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                        <div>
                            <div class="text-white font-medium">Solo</div>
                            <div class="text-gray-400 text-sm">Your chart analysis</div>
                        </div>
                    </label>
                    <label class="flex items-center p-4 border border-gray-600 rounded-lg hover:border-teal-500 transition-colors cursor-pointer">
                        <input type="radio" name="contextType" value="relational" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                        <div>
                            <div class="text-white font-medium">Relational</div>
                            <div class="text-gray-400 text-sm">Two people + current pressures</div>
                        </div>
                    </label>
                    <label class="flex items-center p-4 border border-gray-600 rounded-lg hover:border-teal-500 transition-colors cursor-pointer">
                        <input type="radio" name="contextType" value="weather" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                        <div>
                            <div class="text-white font-medium">Weather Only</div>
                            <div class="text-gray-400 text-sm">Current planetary patterns</div>
                        </div>
                    </label>
                </div>
                
                <!-- Solo Subtype Selection (initially visible for solo mode) -->
                <div id="solo-subtypes" class="mt-4 p-4 bg-gray-750 rounded-lg border border-gray-600">
                    <h3 class="text-sm font-medium text-white mb-3">What type of solo analysis?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="soloSubtype" value="natal_only" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white text-sm">Chart Only</div>
                                <div class="text-gray-400 text-xs">Foundational natal architecture</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="soloSubtype" value="natal_transits" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                            <div>
                                <div class="text-white text-sm">Chart + Transits</div>
                                <div class="text-gray-400 text-xs">Your chart + current pressures</div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <!-- Relational Subtype Selection (initially hidden) -->
                <div id="relational-subtypes" class="hidden mt-4 p-4 bg-gray-750 rounded-lg border border-gray-600">
                    <h3 class="text-sm font-medium text-white mb-3">What type of relational analysis?</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationalSubtype" value="synastry" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white text-sm">Synastry + Transits</div>
                                <div class="text-gray-400 text-xs">Laying two old maps on top of each other—where rivers line up, where mountains clash</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationalSubtype" value="composite" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                            <div>
                                <div class="text-white text-sm">Composite + Transits</div>
                                <div class="text-gray-400 text-xs">Sketching a third map from the overlap—what country appears when you travel together</div>
                            </div>
                        </label>
                    </div>
                    
                    <!-- Relational Mode Explanation -->
                    <div class="mt-4 p-3 bg-gray-800 rounded-lg border border-gray-600">
                        <div class="text-xs text-gray-300 space-y-2">
                            <div>
                                <strong class="text-teal-300">Synastry</strong> is like laying two old maps on top of each other to see where the rivers line up and where the mountains clash. It shows where each of you naturally flows toward or grinds against the other.
                            </div>
                            <div>
                                <strong class="text-teal-300">Composite</strong> is more like sketching a third map out of the overlap—what kind of country appears when you travel together, even if only for a short spell. That land isn't yours alone or theirs alone; it only exists when the two maps are laid together.
                            </div>
                            <div class="text-gray-400 italic mt-2">
                                Remember: The mirror does not mean the journey is happening—only that, if the two paths touch, this is what the water would show.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Mode Section (legacy - will be hidden and auto-updated) -->
            <div id="context-mode-section" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8 border border-teal-500">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-semibold text-white">Context Mode</h2>
                    <button id="toggle-mode-help" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">
                        🧭 What does each mode do?
                    </button>
                </div>
                
                <!-- Symbolic Purpose Guide (initially hidden) -->
                <div id="mode-help-panel" class="hidden mb-6 p-4 bg-gray-750 rounded-lg border border-teal-600">
                    <h3 class="text-lg font-semibold text-teal-300 mb-3">🧭 What Does Each Mode Do?</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Natal+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current planetary pressure on individual chart. <em>"How is today pressing on me?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: If a date range is added, the system checks for all periods of exact or near-exact pressure between those dates—not just today.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Comp+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current pressure on the shared field. <em>"How is today pressing on our connection?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: Adding a date range means the system maps every significant pressure on the connection during that window. Results are limited to that span.</div>
                            </div>
                        </div>
                        <div class="flex items-start">
                            <span class="inline-block w-24 text-teal-400 font-medium flex-shrink-0">Syn+Trans →</span>
                            <div class="text-gray-300">
                                <div>Maps current pressure on relational dynamics. <em>"How is today pressing on our interaction?"</em></div>
                                <div class="text-xs text-gray-400 mt-1 italic">Date Range: With a date range, the system searches for all windows where relational tension or harmony becomes active during the specified time frame.</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-gray-800 rounded border border-gray-600">
                        <p class="text-xs text-gray-400">
                            <strong class="text-teal-300">Recognition-First Principle:</strong> Choose based on your real question, not technical curiosity. 
                            Each mode serves a specific diagnostic purpose within the FIELD → MAP → VOICE framework.
                        </p>
                        <p class="text-xs text-gray-400 mt-2">
                            <strong class="text-teal-300">Date Range Effect:</strong> Adding a date range turns a "today" reading into a scan for all matching patterns over that period, revealing pressure windows and thresholds—not just a snapshot.
                        </p>
                    </div>
                </div>
                
            <!-- Progressive Disclosure Sections -->
            
            <!-- Transit Date Range with Progressive Disclosure -->
            <div id="optional-details-section" class="space-y-6">
                
                <!-- Quick Transit Settings (Mirror Mode Default) -->
                <div id="quick-transit-section" class="bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold text-white">Date Range</h2>
                        <div class="flex items-center gap-4">
                            <button id="todayDefault" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded text-sm transition-colors">
                                📅 Use Today
                            </button>
                            <button id="expandTransitOptions" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                                ⚙️ More Options
                            </button>
                        </div>
                    </div>
                    
                    <!-- Simple Date Inputs -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="transitStartDate" class="block text-gray-300 font-medium mb-1">Start Date:</label>
                            <input type="date" id="transitStartDate" name="transitStartDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" required>
                        </div>
                        <div>
                            <label for="transitEndDate" class="block text-gray-300 font-medium mb-1">End Date:</label>
                            <input type="date" id="transitEndDate" name="transitEndDate" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" required>
                        </div>
                    </div>
                    
                    <!-- Advanced Transit Options (initially hidden) -->
                    <div id="advanced-transit-options" class="hidden mt-4 pt-4 border-t border-gray-700">
                        <div class="flex justify-between items-center mb-2">
                            <label for="transitStep" class="block text-gray-300 font-medium">Step Size:</label>
                            <button id="stepSizeHelp" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                                ❓ What does this do?
                            </button>
                        </div>
                        <select id="transitStep" name="transitStep" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600">
                            <option value="1d">Daily (1 day intervals)</option>
                            <option value="7d">Weekly (7 day intervals)</option>
                            <option value="1m">Monthly (1 month intervals)</option>
                        </select>
                        <!-- Step Size Help Panel (initially hidden) -->
                        <div id="stepSizeHelpPanel" class="hidden mt-2 p-3 bg-gray-750 rounded-lg border border-teal-600 text-sm">
                            <h4 class="text-teal-300 font-semibold mb-2">📊 Step Size Explained</h4>
                            <p class="text-gray-200 mb-2">Step size controls how frequently transit calculations are performed within your date range:</p>
                            <ul class="text-gray-300 space-y-1 ml-4">
                                <li><b>Daily</b>: Calculate transits for every single day (most detailed, slower for long ranges)</li>
                                <li><b>Weekly</b>: Calculate transits every 7 days (good balance for monthly+ ranges)</li>
                                <li><b>Monthly</b>: Calculate transits once per month (fastest, good for yearly overviews)</li>
                            </ul>
                            <p class="text-yellow-200 mt-2 text-xs"><b>Tip</b>: For quick current checks, use "Daily" with today's date. For longer ranges (months/years), "Weekly" or "Monthly" will be faster.</p>
                        </div>
                    </div>
                </div>

                <!-- Relocation Overlay with Progressive Disclosure -->
                <div id="relocation-section" class="bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-600">
                    <div class="flex items-center justify-between cursor-pointer hover:bg-gray-750 p-2 -m-2 rounded transition-colors" 
                         id="relocation-toggle-header" role="button" tabindex="0" aria-expanded="false" aria-controls="relocation-details">
                        <div class="flex items-center">
                            <input type="checkbox" id="relocationToggle" class="mr-3 h-5 w-5 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <h3 class="text-lg font-medium text-white">Relocation Overlay</h3>
                                <p class="text-xs text-gray-400">How place tilts the lens of your chart - same planets, different stage</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button id="useDefaultRelocation" type="button" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none">Use my default</button>
                            <svg id="relocation-chevron" class="w-5 h-5 text-gray-400 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- Relocation Details (collapsible) -->
                    <div id="relocation-details" class="hidden">
                        <p id="relocation-default-note" class="mb-4 text-xs text-gray-500 italic">
                            Panama City, FL (30°10'N, 85°40'W) is pre-filled as a suggested relocation reference. It is NOT applied until you enable the checkbox.
                        </p>
                        <div class="mt-4 pt-4 border-t border-gray-700 space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label for="relocationCity" class="block mb-1 text-sm font-medium text-gray-300">Relocation City</label>
                                    <input type="text" id="relocationCity" placeholder="e.g., Panama City" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="Panama City">
                                </div>
                                <div>
                                    <label for="relocationState" class="block mb-1 text-sm font-medium text-gray-300">State/Province</label>
                                    <input type="text" id="relocationState" placeholder="e.g., FL" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="FL">
                                </div>
                            </div>
                            
                            <div>
                                <label for="relocationCoords" class="block mb-1 text-sm font-medium text-gray-300">
                                    Relocation Coordinates
                                    <span class="text-xs text-gray-500">(Required for overlay calculations)</span>
                                </label>
                                <input type="text" id="relocationCoords" placeholder="e.g., 30°10'N, 85°40'W or 34.0522, -118.2437" class="w-full bg-gray-700 text-white rounded-md p-2 border border-gray-600" value="30°10'N, 85°40'W">
                                <div class="mt-1 text-xs text-gray-500">
                                    <strong class="text-gray-400">Supported formats:</strong>
                                    <br>• <strong>Astroseek format:</strong> "30°10'N, 85°40'W" (degrees/minutes with direction)
                                    <br>• <strong>Decimal degrees:</strong> "40.7128, -74.0060" (positive = N/E, negative = S/W)
                                    <br>• Get coordinates from <a href="https://astroseek.com/astrology-birth-chart-calculator-map" target="_blank" class="text-teal-400 underline">Astroseek</a> or Google Maps
                                </div>
                                
                                <!-- Validation Error for Relocation Coords -->
                                <div id="relocationCoordsError" class="hidden mt-1 text-xs text-red-400">
                                    Please enter valid coordinates in format: latitude, longitude
                                </div>
                            </div>
                            
                            <div class="bg-gray-750 p-3 rounded border border-gray-600">
                                <h4 class="text-sm font-medium text-teal-300 mb-2">How Relocation Works:</h4>
                                <ul class="text-xs text-gray-400 space-y-1">
                                    <li>• <strong class="text-gray-300">Same birth chart, different stage set</strong> - planets and aspects unchanged</li>
                                    <li>• <strong class="text-gray-300">Houses and angles shift</strong> - where your patterns get expressed in daily life</li>
                                    <li>• <strong class="text-gray-300">Tectonic, not weather</strong> - foundational context shift, not timing</li>
                                    <li>• <strong class="text-gray-300">Diagnostic value</strong> - shows where natal pressures plug into new ground</li>
                                </ul>
                                <div class="mt-2 p-2 bg-gray-800 rounded border border-gray-600">
                                    <p class="text-xs text-teal-300">
                                        <strong>Example:</strong> Sun in 12th (private) → Sun at Midheaven (public stage). 
                                        Same solar nature, different life domain where it gets expressed.
                                    </p>
                                </div>
                            </div>
                            
                            <!-- Person B Relocation Option (only visible when Person B is present) -->
                            <div id="relocationPersonBOption" class="hidden">
                                <div class="flex items-center p-3 bg-gray-750 rounded border border-gray-600">
                                    <input type="checkbox" id="includePersonBRelocation" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                                    <label for="includePersonBRelocation" class="text-gray-300 font-medium">
                                        Also relocate Person B to same location
                                        <span class="text-xs text-gray-500 block">
                                            <strong>Default:</strong> Only Person A gets relocated. <br>
                                            <strong>Check this if:</strong> Person B is also in the same relocation city. <br>
                                            <strong>Leave unchecked if:</strong> Person B remains in their birth location.
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Legacy hidden sections for compatibility -->
            <div class="hidden">
                <div id="context-toggle" class="flex items-center mb-4">
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_only" class="mr-2">
                        <span class="text-gray-300">Natal Chart Only</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="natal_transits" class="mr-2" checked>
                        <span class="text-gray-300">Natal Chart + Transits</span>
                    </label>
                    <label class="flex items-center mr-4">
                        <input type="radio" name="contextMode" value="composite_transits" class="mr-2">
                        <span class="text-gray-300">Composite + Transits</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="contextMode" value="synastry_transits" class="mr-2">
                        <span class="text-gray-300">Synastry + Transits</span>
                    </label>
                </div>
                
                <!-- Legacy transit fields for compatibility -->
                <div id="transit-date-range-fields" class="mb-6 hidden">
                  <div class="flex justify-between items-center mb-2">
                    <label for="transitStartDate" class="block text-gray-300 font-medium">Transit Start Date (YYYY-MM-DD):</label>
                    <button id="prefillToday" class="text-xs text-teal-300 underline hover:text-teal-400 focus:outline-none" type="button">
                        📅 Use Today for Quick Check
                    </button>
                  </div>
                </div>
            </div>
                
                <!-- Additional Context Options -->
                <div id="context-options" class="space-y-4">
                    <div class="bg-yellow-900 border border-yellow-700 text-yellow-100 px-4 py-3 rounded mb-4">
                        <div class="flex">
                            <div class="flex-shrink-0">
                                <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <div class="ml-3">
                                <h3 class="text-sm font-medium">Math Brain Protocol Active</h3>
                                <div class="mt-2 text-sm">
                                    This panel computes geometry only. Interpretation lives in the Mirror.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            </div>

            <!-- Relational Context Section (conditional visibility) - moved from hidden context-mode-section -->
            <div id="relational-context-section" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg border border-teal-500" role="region" aria-labelledby="relational-context-heading">
                <h2 id="relational-context-heading" class="text-xl font-semibold mb-4 text-white">Relational Context</h2>
                <p class="text-gray-400 text-sm mb-4">Detected potential dynamics:</p>
                <ul id="context-readout" class="list-disc list-inside space-y-2 mb-4 text-gray-300"></ul>
                <div id="relationship-type-query">
                    <p class="text-lg font-medium text-white mb-2">How would you categorize this connection?</p>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="partner" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Partner</div>
                                <div class="text-gray-400 text-xs">Romantic / undefined-intimate</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="friend" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Friend / Colleague</div>
                                <div class="text-gray-400 text-xs">Friend or colleague</div>
                            </div>
                        </label>
                        <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                            <input type="radio" name="relationshipType" value="family" class="mr-3 h-4 w-4 text-teal-600 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                            <div>
                                <div class="text-white font-medium">Family Member</div>
                                <div class="text-gray-400 text-xs">Family member</div>
                            </div>
                        </label>
                    </div>
                    <div id="exRelationshipRow" class="mt-4 pt-3 border-t border-gray-600">
                        <label class="flex items-center p-2 hover:bg-gray-750 rounded cursor-pointer">
                            <input type="checkbox" id="exRelationship" class="mr-3 h-4 w-4 text-red-400 focus:ring-red-500 border-gray-600 rounded bg-gray-700">
                            <span class="text-gray-300">Ex or Estranged</span>
                            <span class="text-xs text-gray-500 ml-2">(not valid for Friend/Colleague)</span>
                        </label>
                    </div>
                    <!-- Relationship Role (conditional) -->
                    <div id="relationship-role-block" class="mt-4 hidden" aria-live="polite">
                        <label for="relationshipRole" class="block text-sm font-medium text-gray-300">
                            Relationship Role 
                            <span class="text-xs text-gray-400">(Person B relative to A)</span>
                        </label>
                        <select id="relationshipRole" class="mt-1 w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-sm"></select>
                        <input id="relationshipRoleCustom" placeholder="Custom role (e.g., half-brother, stepmother)" class="mt-2 w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-sm hidden" />
                        <div class="mt-2">
                            <label for="relationshipNotes" class="block text-xs font-medium text-gray-400">Relationship Notes (optional)</label>
                            <textarea id="relationshipNotes" rows="2" class="w-full bg-gray-700 text-white rounded p-2 border border-gray-600 text-xs" placeholder="Any clarifying context (e.g., estranged, adopted)"></textarea>
                        </div>
                    </div>
                    <div id="intimacy-tier-dropdown" class="mt-4 hidden">
                        <p class="text-md font-medium text-white mb-2">Select intimacy tier (required for Partner):</p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P1" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P1 – Platonic</div>
                                    <div class="text-gray-400 text-xs">No sexual/romantic expectations</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P2" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P2 – FWB</div>
                                    <div class="text-gray-400 text-xs">Sexual, no romantic commitment</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P3" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P3 – Situationship</div>
                                    <div class="text-gray-400 text-xs">Fluid rules/expectations</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P4" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P4 – Low-commitment</div>
                                    <div class="text-gray-400 text-xs">Uneven investment, minimal care</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P5a" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P5a – Committed</div>
                                    <div class="text-gray-400 text-xs">Romantic + sexual</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-pink-500 transition-colors cursor-pointer">
                                <input type="radio" name="intimacyTier" value="P5b" class="mr-3 h-4 w-4 text-pink-400 focus:ring-pink-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">P5b – Committed</div>
                                    <div class="text-gray-400 text-xs">Romantic, no sexual</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Contact Channel Toggle -->
                    <div class="mt-6 p-4 bg-gray-750 rounded-lg border border-gray-600">
                        <p class="text-md font-medium text-white mb-3">Contact Channel:</p>
                        <p class="text-xs text-gray-400 mb-4">Is this an active relationship channel (currently exchanging), or a dormant one (not currently exchanging)?</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                                <input type="radio" name="contactChannel" value="live" class="mr-3 h-4 w-4 text-teal-400 focus:ring-teal-500 border-gray-600 rounded bg-gray-700" checked>
                                <div>
                                    <div class="text-white text-sm">🟢 Live</div>
                                    <div class="text-gray-400 text-xs">Currently in contact / active exchange</div>
                                </div>
                            </label>
                            <label class="flex items-center p-3 border border-gray-600 rounded hover:border-teal-500 transition-colors cursor-pointer">
                                <input type="radio" name="contactChannel" value="latent" class="mr-3 h-4 w-4 text-teal-400 focus:ring-teal-500 border-gray-600 rounded bg-gray-700">
                                <div>
                                    <div class="text-white text-sm">⚫ Latent</div>
                                    <div class="text-gray-400 text-xs">Not currently in contact / no active exchange</div>
                                </div>
                            </label>
                        </div>
                        <div class="mt-3 p-2 bg-gray-800 rounded text-xs text-gray-300">
                            <strong class="text-teal-300">Live:</strong> Enables interaction overlays ("when A does this, B may respond...") <br>
                            <strong class="text-teal-300">Latent:</strong> Parallel weather only (side-by-side individual readings)
                        </div>
                    </div>
                </div>
            </div>

            <!-- Generate Button -->
            <div class="text-center mb-8">
                <button id="generateReport" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    Get My Mirror
                </button>
                <div class="mt-3">
                    <button id="showWiringBtn" class="text-teal-300 underline hover:text-teal-400 text-sm transition-colors duration-200">
                        Show Wiring
                    </button>
                </div>
            </div>

            <!-- Save/Load Controls -->
            <div class="text-center mb-6">
                <div class="flex justify-center gap-3 mb-2">
                    <button id="saveDataBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                        💾 Save Chart Data
                    </button>
                    <button id="loadDataBtn" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded text-sm transition-colors duration-200">
                        📂 Load Chart Data
                    </button>
                </div>
                <input type="file" id="loadDataInput" accept=".json" class="hidden">
                <p class="text-xs text-gray-500">Save Person A & B data to reload later</p>
            </div>

            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="hidden text-center mb-8">
                <div class="inline-flex items-center px-4 py-2 font-semibold leading-6 text-sm shadow rounded-md text-white bg-teal-600 transition ease-in-out duration-150">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Computing Astrological Geometry...
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorDisplay" class="hidden bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded mb-8">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium">Error computing geometry</h3>
                        <div id="errorMessage" class="mt-2 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Report Output -->
            <div id="reportOutput" class="hidden bg-gray-800 p-6 rounded-lg shadow-lg">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-white">Pure Astrological Geometry</h2>
                    <div class="flex gap-2">
                        <button id="downloadMarkdown" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded text-sm">
                            📄 Save Chart Data
                        </button>
                        <button id="downloadReport" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded text-sm hidden">
                            📄 Download Report (.md)
                        </button>
                        <button id="copyReport" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded text-sm hidden">
                            📋 Copy Report
                        </button>
                    </div>
                </div>
                                <!-- Simple Mode: Hook / Aspect Filter Controls intentionally hidden (retained for future advanced mode) -->
                                <div id="hookFilters" class="hidden"></div>
                <div id="reportContent" class="text-gray-200 whitespace-pre-wrap font-mono text-sm bg-gray-900 p-4 rounded border border-gray-700 overflow-auto max-h-96">
                </div>
            </div>
        </main>

        <footer class="text-center text-gray-500 text-sm mt-12">
            <p>&copy; 2024 Woven Map Report Generator. Math Brain + Poetic Brain Framework.</p>
        </footer>
    </div>

    <script src="config.js"></script>
    <script>
// --- Global row counter for report summary ---
let totalRowCount = 0;
// UI Filter State (persist across renders)
// Simple Mode defaults (no user toggles rendered)
window.WOVEN_UI_FILTERS = { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };

// Universal context reference for browser/server compatibility
const WOVEN_GLOBAL = (typeof globalThis !== 'undefined') ? globalThis : (typeof window !== 'undefined' ? window : {});

// --- Helper for lean/legacy aspect/transit row keys ---
function rowNamesAndOrb(r) {
    const transit = r.transit_body ?? r.p1_name ?? r.planet_a ?? '—';
    const natal   = r.natal_target ?? r.p2_name ?? r.planet_b ?? '—';
    const aspect  = r.aspect ?? r.aspect_name ?? r.name ?? '—';
    let orb = r.orb;
    if (!Number.isFinite(orb)) orb = Number(r.orbit);
    if (!Number.isFinite(orb)) orb = null;
    return { transit, natal, aspect, orb };
}
// --- Dual-read helpers for natal/synastry aspects ---
function nameA(r){ return r.p1_name ?? (legacyTouch('natal/synastry:p1_name'), r.planet_a) ?? r.transit_body ?? '—'; }
function nameB(r){ return r.p2_name ?? (legacyTouch('natal/synastry:p2_name'), r.planet_b) ?? r.natal_target ?? '—'; }
function aspectA(r){ return r.aspect ?? (legacyTouch('natal/synastry:aspect_name'), r.aspect_name) ?? '—'; }
function orbA(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('natal/synastry:orbit/diff'), (r.orbit ?? r.diff)); }

function formatAspectRow(r){
    const A = nameA(r), B = nameB(r), asp = aspectA(r);
    const o = orbA(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// --- Global legacy usage telemetry ---
window.WM_LEGACY_HITS = 0;
function legacyTouch(tag){ 
    window.WM_LEGACY_HITS++; 
    console.warn(`[LEGACY] used: ${tag}`); 
}

function nameT(r){ return r.transit_body ?? (legacyTouch('p1_name'), r.p1_name); }
function nameN(r){ return r.natal_target ?? (legacyTouch('p2_name'), r.p2_name); }
function aspectT(r){ return r.aspect ?? (legacyTouch('aspect_name'), r.aspect_name); }
function orbT(r){ return (typeof r.orb === 'number') ? r.orb 
                 : (legacyTouch('orbit/diff'), (r.orbit ?? r.diff)); }

function formatTransitRow(r){
    const A = nameT(r), B = nameN(r), asp = aspectT(r);
    const o = orbT(r);
    if (!A || !B || !asp || o === undefined || o === null || isNaN(o) || !Number.isFinite(+o)) return null;
    return `**${A}** ${asp} **${B}** (${(+o).toFixed(1)}°)`;
}
// ---- aspect math (for fallback orb) ----
const ASPECTS = { conjunction:0, sextile:60, square:90, trine:120, opposition:180,
    quincunx:150, quintile:72, biquintile:144, 'semi-square':45, semisquare:45, sesquiquadrate:135 };
function degNorm(d){ let x=d%360; return x<0?x+360:x; }
function sep(a,b){ const d=Math.abs(degNorm(a)-degNorm(b)); return d>180?360-d:d; }
function computeOrbFromLongitudes(lon1, lon2, aspectName){
    if(!Number.isFinite(lon1) || !Number.isFinite(lon2)) return null;
    const exact = ASPECTS[(aspectName||'').toLowerCase()];
    if(!Number.isFinite(exact)) return null;
    return Math.abs(sep(lon1, lon2) - exact);
}
function bandOrb(orb){ if(!Number.isFinite(orb)) return 'wide';
    if(orb<=1) return 'tight'; if(orb<=3) return 'close'; if(orb<=6) return 'medium'; return 'wide';
}
function valenceHint(aspect){
    const a=(aspect||'').toLowerCase();
    if(['square','opposition','sesquiquadrate','semisquare','semi-square','quincunx'].includes(a)) return 'hot';
    if(['trine','sextile','quintile','biquintile'].includes(a)) return 'cool';
    return 'neutral_to_hot';
}

// ---- normalizers that accept any shape ----
function normalizeTransitRow(row){
    if (row && row.transit_body && row.natal_target) {
        const aspect = row.aspect || row.aspect_name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.transit_lon, row.natal_lon, aspect);
        return {
            transit_body: row.transit_body,
            natal_target: row.natal_target,
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.transit_lon ?? null,
            natal_lon: row.natal_lon ?? null,
            transit_house: row.transit_house ?? null,
            natal_house: row.natal_house ?? null,
            transit_is_retrograde: !!row.transit_is_retrograde,
            natal_is_retrograde: !!row.natal_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.planet_a || row.planet_b)) {
        const aspect = row.aspect_name || row.aspect || row.type || '';
        let orb = Number.isFinite(row.orbit) ? row.orbit
                        : Number.isFinite(row.orb) ? row.orb
                        : computeOrbFromLongitudes(row.abs_pos_a, row.abs_pos_b, aspect);
        return {
            transit_body: row.planet_a || '—',
            natal_target: row.planet_b || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.abs_pos_a ?? null,
            natal_lon: row.abs_pos_b ?? null,
            transit_house: row.p1_house ?? row.house1 ?? null,
            natal_house: row.p2_house ?? row.house2 ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    if (row && (row.p1_name || row.p2_name)) {
        const aspect = row.aspect || row.name || row.type || '';
        let orb = Number.isFinite(row.orb) ? row.orb
                        : Number.isFinite(row.orbit) ? row.orbit
                        : computeOrbFromLongitudes(row.p1_abs_pos, row.p2_abs_pos, aspect);
        return {
            transit_body: row.p1_name || '—',
            natal_target: row.p2_name || '—',
            aspect,
            orb: Number.isFinite(orb) ? +orb.toFixed(2) : null,
            transit_lon: row.p1_abs_pos ?? null,
            natal_lon: row.p2_abs_pos ?? null,
            transit_house: row.p1_house ?? null,
            natal_house: row.p2_house ?? null,
            transit_is_retrograde: !!row.p1_is_retrograde,
            natal_is_retrograde: !!row.p2_is_retrograde,
            orb_band: bandOrb(orb),
            valence_hint: valenceHint(aspect)
        };
    }
    return null;
}
function normalizeTransitBlock(block){
    if (Array.isArray(block)) {
        return block.map(normalizeTransitRow).filter(Boolean);
    }
    if (block && block.chart && Array.isArray(block.chart.aspects)) {
        return block.chart.aspects.map(normalizeTransitRow).filter(Boolean);
    }
    return [];
}
function renderTransitDay(dateStr, items){
    const rows = normalizeTransitBlock(items);
    if (!Array.isArray(rows) || rows.length === 0) return `<h4>${dateStr}</h4><p><em>No computed aspects.</em></p>`;
    const lines = rows.map(r => {
        const orbTxt = (r && typeof r.orb === 'number' && Number.isFinite(r.orb)) ? `${r.orb.toFixed(2)}°` : '—';
        return `• <strong>${r.transit_body}</strong> ${r.aspect} <strong>${r.natal_target}</strong> (${orbTxt}, ${r.orb_band}, ${r.valence_hint})`;
    });
    return `<h4>${dateStr}</h4><ul><li>${lines.join("</li><li>")}</li></ul>`;
}
        // Global UI element references
    let generateBtn, loadingIndicator, errorDisplay, errorMessage, reportOutput, reportContent, copyBtn, downloadMarkdownBtn, downloadReportBtn, mathBrainInfoBtn, mathBrainModal, closeMathBrainModal, closeMathBrainModalBottom, relocationToggle, relocationFields, transitDateFields, personBCard, relocationSection, relationalContextSection, intimacyTierDropdown, toggleModeHelp, modeHelpPanel, prefillTodayBtn, stepSizeHelpBtn, stepSizeHelpPanel, exRelationshipCheckbox, relocationPersonBOption, includePersonBRelocationEl, transitStartDate, transitEndDate, transitStep, relocationCoordsInput;

        // Defensive check for window/globalThis
        if (typeof window === 'undefined') {
            console.warn('window is not defined; running in non-browser context');
        }

        // Store the latest result data for downloads
        let latestResultData = null;

        // --- Utility Functions ---

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
            reportOutput.classList.add('hidden');
            // Hide report action buttons when showing error
            document.getElementById('copyReport').classList.add('hidden');
            document.getElementById('downloadReport').classList.add('hidden');
        }

        function hideError() {
            errorDisplay.classList.add('hidden');
        }

        // Helper function to get opposite zodiac sign for South Node calculation
        function getOppositeSign(sign) {
            const opposites = {
                'Ari': 'Lib', 'Tau': 'Sco', 'Gem': 'Sag', 'Can': 'Cap',
                'Leo': 'Aqu', 'Vir': 'Pis', 'Lib': 'Ari', 'Sco': 'Tau',
                'Sag': 'Gem', 'Cap': 'Can', 'Aqu': 'Leo', 'Pis': 'Vir'
            };
            return opposites[sign] || sign;
        }

        // Helper function to check if any house cusps are available in chart data
        function hasAnyHouseCusps(chart) {
            const houseKeys = [
                'first_house', 'second_house', 'third_house', 'fourth_house',
                'fifth_house', 'sixth_house', 'seventh_house', 'eighth_house', 
                'ninth_house', 'tenth_house', 'eleventh_house', 'twelfth_house'
            ];
            return houseKeys.some(key => chart[key] && chart[key].sign && chart[key].position !== undefined);
        }

        // Reusable function to render natal chart data for any person
        function renderNatalChartData(chart, personName) {
            let md = '';
            
            try {
                // Chart Angles - only show if available
                if (chart.asc || chart.ascendant) {
                    md += `### Chart Angles\n\n`;
                    const asc = chart.asc || chart.ascendant;
                    const mc = chart.mc || chart.midheaven;
                    const dsc = chart.dsc || chart.descendant;
                    const ic = chart.ic || chart.imum_coeli;
                    
                    if (asc && asc.sign && asc.position !== undefined) {
                        md += `- **Ascendant (ASC)**: ${asc.sign} ${asc.position.toFixed(2)}°\n`;
                    }
                    if (mc && mc.sign && mc.position !== undefined) {
                        md += `- **Midheaven (MC)**: ${mc.sign} ${mc.position.toFixed(2)}°\n`;
                    }
                    if (dsc && dsc.sign && dsc.position !== undefined) {
                        md += `- **Descendant (DSC)**: ${dsc.sign} ${dsc.position.toFixed(2)}°\n`;
                    }
                    if (ic && ic.sign && ic.position !== undefined) {
                        md += `- **Imum Coeli (IC)**: ${ic.sign} ${ic.position.toFixed(2)}°\n`;
                    }
                    md += `\n`;
                }
                
                // Natal Planet Positions  
                md += `### Natal Planet Positions\n\n`;
                
                // Core planets in standard order
                const planets = [
                    { key: 'sun', name: 'Sun' },
                    { key: 'moon', name: 'Moon' },
                    { key: 'mercury', name: 'Mercury' },
                    { key: 'venus', name: 'Venus' },
                    { key: 'mars', name: 'Mars' },
                    { key: 'jupiter', name: 'Jupiter' },
                    { key: 'saturn', name: 'Saturn' },
                    { key: 'uranus', name: 'Uranus' },
                    { key: 'neptune', name: 'Neptune' },
                    { key: 'pluto', name: 'Pluto' },
                    { key: 'chiron', name: 'Chiron' }
                ];
                
                planets.forEach(planet => {
                    const planetData = chart[planet.key];
                    if (planetData && planetData.sign && planetData.position !== undefined) {
                        const house = planetData.house || 'Unknown';
                        const retrograde = planetData.retrograde ? ' ℞' : '';
                        md += `- **${planet.name}**: ${planetData.sign} ${planetData.position.toFixed(2)}° (House ${house})${retrograde}\n`;
                    }
                });
                
                // Lunar Nodes if available - prioritize true_node over mean_node for accuracy
                const northNode = chart.true_node || chart.mean_node || chart.north_node;
                if (northNode && northNode.sign && northNode.position !== undefined) {
                    md += `\n### Lunar Nodes\n\n`;
                    const house = northNode.house || 'Unknown';
                    const nodeType = chart.true_node ? 'True' : chart.mean_node ? 'Mean' : '';
                    md += `- **North Node${nodeType ? ` (${nodeType})` : ''}**: ${northNode.sign} ${northNode.position.toFixed(2)}° (House ${house})\n`;
                    
                    // South Node is opposite North Node
                    const southNodePos = (northNode.position + 180) % 360;
                    const southNodeSign = getOppositeSign(northNode.sign);
                    if (southNodeSign) {
                        md += `- **South Node${nodeType ? ` (${nodeType})` : ''}**: ${southNodeSign} ${southNodePos.toFixed(2)}°\n`;
                    }
                }
                
                // House Cusps if available - check all 12 houses
                if (hasAnyHouseCusps(chart)) {
                    md += `\n### House Cusps\n\n`;
                    const houses = [
                        { key: 'first_house', name: '1st House', description: 'Identity, Stance' },
                        { key: 'second_house', name: '2nd House', description: 'Resource, Security' },
                        { key: 'third_house', name: '3rd House', description: 'Exchange, Signals' },
                        { key: 'fourth_house', name: '4th House', description: 'Root, Anchor' },
                        { key: 'fifth_house', name: '5th House', description: 'Creative, Expression' },
                        { key: 'sixth_house', name: '6th House', description: 'Craft, Rhythm' },
                        { key: 'seventh_house', name: '7th House', description: 'Relational, Mirror' },
                        { key: 'eighth_house', name: '8th House', description: 'Depth, Crossing' },
                        { key: 'ninth_house', name: '9th House', description: 'Horizon, Philosophy' },
                        { key: 'tenth_house', name: '10th House', description: 'Apex, Projection' },
                        { key: 'eleventh_house', name: '11th House', description: 'Network, Belonging' },
                        { key: 'twelfth_house', name: '12th House', description: 'Dream, Spirit' }
                    ];
                    
                    houses.forEach(house => {
                        const houseData = chart[house.key];
                        if (houseData && houseData.sign && houseData.position !== undefined) {
                            md += `- **${house.name}**: ${houseData.sign} ${houseData.position.toFixed(2)}° (${house.description})\n`;
                        }
                    });
                }
                
                md += `\n`;
            } catch (error) {
                console.log(`Error rendering ${personName} natal chart data:`, error);
                md += `*Natal chart data available but could not be displayed due to formatting.*\n\n`;
            }
            
            return md;
        }

        // --- Date Utility Functions ---

        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function prefillTodayDates() {
            const todayStr = getTodayDateString();
            document.getElementById('transitStartDate').value = todayStr;
            document.getElementById('transitEndDate').value = todayStr;
            
            // Brief visual feedback
            prefillTodayBtn.textContent = '✅ Set to Today';
            setTimeout(() => { 
                prefillTodayBtn.textContent = '📅 Use Today for Quick Check'; 
            }, 2000);
        }

        // --- Download Functions ---

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        function generateMarkdownReport(data) {
            // MATH BRAIN COMPLIANCE (PROTOCOL LAYER 1: GEOMETRY ONLY):
            // - Output pure astrological geometry with provenance tracking
            // - Include RAVEN_NUDGE for downstream Poetic Brain (Raven Calder) processing
            // - Layer separation: GEOMETRY ONLY → Clear Mirror → Poetic Codex
            // - NO narrative, interpretation, or advice generation here
            // - Protocol compliance: mirror_ready flags, rejections taxonomy, scaling confidence
            
            const formData = collectFormData();
            const currentDate = new Date().toISOString().split('T')[0];
            // Prefer authoritative server-returned details if present (may include normalization/zodiac defaults)
            const personA = (data.person_a && data.person_a.details) ? data.person_a.details : formData.personA;
            const personB = (data.person_b && data.person_b.details) ? data.person_b.details : formData.personB;
            const mode = formData.context.mode;
            
            // Protocol Layer Headers
            let md = `# Woven Map System Report\n\n`;
            md += `## Protocol Layer 1: Geometry Only\n\n`;
            md += `**Generated**: ${currentDate}\n`;
            md += `**Context Mode**: ${mode.replace(/_/g, ' ').toUpperCase()}\n`;
            md += `**Schema**: ${data.schema || 'WM-Chart-1.0'}\n`;
            md += `**Math Brain Version**: ${(data.provenance?.math_brain_version)||'0.x'}\n`;
            md += `**Ephemeris Source**: ${data.provenance?.ephemeris_source || 'AstrologerAPI-v4'}\n`;
            md += `**Mirror Status**: ${data.mirror_ready ? 'Ready for downstream processing' : 'Incomplete'}\n`;
            md += `**Contract**: ${data.contract || 'clear-mirror/1.2'}\n\n`;
            
            // Critical Protocol Reminder
            md += `> **Math Brain Role**: Symbolic scaffolding engine providing pure geometry.\n`;
            md += `> **Boundary**: No narrative, prediction, or interpretation. Mirror, not mandate.\n`;
            md += `> **Next Layer**: Clear Mirror translation via Poetic Brain (Raven Calder).\n\n`;
            
            // RAVEN_NUDGE Section (Protocol Requirement)
            md += `### RAVEN_NUDGE (Downstream Processing Guidance)\n\n`;
            md += `**Protocol Flow**: FIELD → MAP → VOICE translation required\n`;
            md += `**Sources Required**: Poetic Codex • FIELD_MAP_VOICE rules • Hook Stack • Seismograph Protocol\n`;
            md += `**Geometry Flags**: `;
            
            // Add specific flags based on data analysis
            const geometryFlags = [];
            let nodeTypes = new Set();
            let retrogradeCount = 0;
            let scaleConfidenceIssues = false;
            let hasDispersedInfluence = false;
            
            // Analyze the data for specific flags
            if (data.person_a?.chart?.transitsByDate) {
                const firstDay = Object.values(data.person_a.chart.transitsByDate)[0];
                if (firstDay?.retrograde_aspects?.length >= 2) {
                    geometryFlags.push('retrograde recursion');
                    retrogradeCount = firstDay.retrograde_aspects.length;
                }
                if (firstDay?.seismograph?.scaleConfidence < 0.7) {
                    geometryFlags.push('low scale confidence');
                    scaleConfidenceIssues = true;
                }
                if (firstDay?.hooks?.length === 0) {
                    geometryFlags.push('dispersed influence');
                    hasDispersedInfluence = true;
                }
                
                // Check for node types in hooks and aspects
                const allAspects = [...(firstDay.hooks || []), ...(firstDay.filtered_aspects || [])];
                allAspects.forEach(a => {
                    if (a.p1_name?.includes('True_Node') || a.p2_name?.includes('True_Node')) nodeTypes.add('True Node');
                    if (a.p1_name?.includes('Mean_Node') || a.p2_name?.includes('Mean_Node')) nodeTypes.add('Mean Node');
                });
            }
            
            // Check synastry/composite for additional patterns
            if (data.synastry?.aspects) {
                const tightAspects = data.synastry.aspects.filter(a => Math.abs(a.orbit) <= 1);
                if (tightAspects.length >= 2) geometryFlags.push('echo loop formation');
            }
            
            md += geometryFlags.length ? geometryFlags.join(' • ') : 'standard geometry';
            md += `\n`;
            
            md += `**Node Distinction**: `;
            if (nodeTypes.size > 0) {
                md += Array.from(nodeTypes).join(' and ') + ' present';
                if (nodeTypes.has('True Node') && nodeTypes.has('Mean Node')) {
                    md += ' — prefer True Node precision for tight orbs';
                }
            } else {
                md += 'Standard node handling (True Node preferred)';
            }
            md += `\n`;
            
            md += `**Timezone Check**: Target America/Chicago (Central) — Current: ${personA.timezone} ${personA.timezone === 'America/Chicago' ? '✓' : '⚠ Normalize required'}\n`;
            md += `**Falsifiability**: All outputs must pass "Does this land?" test\n`;
            md += `**Agency Reinforcement**: Every output must preserve client autonomy\n`;
            
            // Add specific processing alerts
            if (retrogradeCount >= 2 || scaleConfidenceIssues || hasDispersedInfluence || nodeTypes.size > 1) {
                md += `**Processing Alerts**:\n`;
                if (retrogradeCount >= 2) md += `- ${retrogradeCount} retrograde aspects detected → internal revision themes likely\n`;
                if (scaleConfidenceIssues) md += `- Scale confidence below threshold → caution framing advised\n`;
                if (hasDispersedInfluence) md += `- No tight hooks → background stability or dispersed pattern\n`;
                if (nodeTypes.size > 1) md += `- Multiple node types present → ensure precision consistency\n`;
            }
            md += `\n`;
            
            // Range and Context
            if (formData.transitParams?.startDate && formData.transitParams?.endDate) {
                const stepMap = { '1d':'Daily', 'daily':'Daily', '7d':'Weekly', 'weekly':'Weekly', '1m':'Monthly', '1mo':'Monthly', 'monthly':'Monthly' };
                const rawStep = formData.transitParams.step || 'daily';
                const stepHuman = stepMap[rawStep] || rawStep;
                const startDate = new Date(formData.transitParams.startDate);
                const endDate = new Date(formData.transitParams.endDate);
                const daySpan = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
                
                md += `**Temporal Scope**: ${formData.transitParams.startDate} → ${formData.transitParams.endDate}\n`;
                md += `**Step Resolution**: ${stepHuman} (${daySpan} day span)\n`;
                md += `**Protocol Check**: ${daySpan <= 30 ? '✓ Within 30-day safety limit' : '⚠ Exceeds recommended span'}\n\n`;
            }

            // Subject Details (FIELD Layer)
            md += `## Subject Details — Reveal the Weave\n\n`;
            md += `### Primary Subject: ${personA.name}\n\n`;
            md += `- **Birth Date**: ${personA.year}-${String(personA.month).padStart(2, '0')}-${String(personA.day).padStart(2, '0')}\n`;
            md += `- **Birth Time**: ${String(personA.hour).padStart(2, '0')}:${String(personA.minute).padStart(2, '0')}\n`;
            md += `- **Location**: ${personA.city}, ${personA.nation}\n`;
            md += `- **Coordinates**: ${personA.latitude}, ${personA.longitude}\n`;
            md += `- **Timezone**: ${personA.timezone}\n`;
            md += `- **Zodiac Type**: ${personA.zodiac_type}\n\n`;
            md += `**TZ Check (Person A)**: expected \`America/Chicago\` (Central).\n`;
            md += `**Observed**: \`${personA.timezone}\` → ${personA.timezone === 'America/Chicago' ? 'OK' : '⚠ Normalize before mirroring'}\n\n`;

            // Secondary Subject Details (if present)
                        if (personB) {
                md += `### Secondary Subject: ${personB.name}\n\n`;
                md += `- **Birth Date**: ${personB.year}-${String(personB.month).padStart(2, '0')}-${String(personB.day).padStart(2, '0')}\n`;
                md += `- **Birth Time**: ${String(personB.hour).padStart(2, '0')}:${String(personB.minute).padStart(2, '0')}\n`;
                md += `- **Location**: ${personB.city}, ${personB.nation}\n`;
                md += `- **Coordinates**: ${personB.latitude}, ${personB.longitude}\n`;
                md += `- **Timezone**: ${personB.timezone}\n`;
                md += `- **Zodiac Type**: ${personB.zodiac_type}\n\n`;

                                const relRole = formData.context.relationship_role;
                                const relNotes = formData.context.relationship_notes;
                                if (relRole || relNotes) {
                                    md += `- **Relationship Role**: ${relRole || 'unspecified'}${relNotes? ` — ${relNotes}`:''}\n\n`;
                                }

                // Relationship Context (if present)
                if (formData.context.relationship_type) {
                    md += `## Relationship Context\n\n`;
                    md += `- **Type**: ${formData.context.relationship_type}`;
                    if (formData.context.is_ex_relationship) {
                        md += ` (ex - no longer active)`;
                    }
                    md += `\n`;
                    if (formData.context.intimacy_tier) {
                        md += `- **Intimacy Tier**: ${formData.context.intimacy_tier}\n`;
                    }
                    if (formData.context.contact_channel) {
                        md += `- **Contact Channel**: ${formData.context.contact_channel === 'live' ? '🟢 Live (active exchange)' : '⚫ Latent (dormant channel)'}\n`;
                    }
                    md += `\n`;
                }
            }

            // Relocation (if present)
            if (data.relocation_a && data.relocation_a.status === 'OK') {
                md += `## Relocation Overlay\n\n`;
                md += `- **Location**: ${formData.relocation?.city || 'Unknown'}\n`;
                md += `- **Coordinates**: ${formData.relocation?.latitude}, ${formData.relocation?.longitude}\n`;
                
                if (data.relocation_b && data.relocation_b.status === 'OK') {
                    md += `- **Scope**: Both Person A and Person B relocated\n`;
                } else if (formData.relocation?.excludePersonB) {
                    md += `- **Scope**: Only Person A relocated (Person B excluded)\n`;
                } else {
                    md += `- **Scope**: Person A relocated\n`;
                }
                md += `\n`;
            }

            // Natal Chart Geometry (Structural Identity Patterns)
            if (data.person_a?.chart && (data.person_a.chart.status === 'OK' || data.person_a.chart.sun)) {
                md += `## ${personA.name} Natal Geometry — Structural Weave\n\n`;
                
                // The chart data can be in different structures depending on API endpoint used
                const chart = data.person_a.chart.data || data.person_a.chart;
                md += renderNatalChartData(chart, personA.name);
            }

            if (data.person_b?.chart && (data.person_b.chart.status === 'OK' || data.person_b.chart.sun)) {
                md += `## ${personB.name} Natal Geometry — Structural Weave\n\n`;
                
                // The chart data can be in different structures depending on API endpoint used
                const chart = data.person_b.chart.data || data.person_b.chart;
                md += renderNatalChartData(chart, personB.name);
            }

            // Relocation Chart Summaries (if present)
            if (data.relocation_a?.status === 'OK') {
                md += `## ${personA.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_a.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            if (data.relocation_b?.status === 'OK') {
                md += `## ${personB.name} Relocated Chart Summary\n\n`;
                const chart = data.relocation_b.data.subject;
                md += `- **Relocated Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Composite Chart Summary (if present)
            if (data.composite?.chart?.status === 'OK') {
                md += `## Composite Chart Summary\n\n`;
                const chart = data.composite.chart.data.subject;
                md += `- **Ascendant**: ${chart.ascendant.sign} ${chart.ascendant.position.toFixed(2)}°\n`;
                md += `- **Sun**: ${chart.sun.sign} ${chart.sun.position.toFixed(2)}° (${chart.sun.house})\n`;
                md += `- **Moon**: ${chart.moon.sign} ${chart.moon.position.toFixed(2)}° (${chart.moon.house})\n`;
                md += `- **Mercury**: ${chart.mercury.sign} ${chart.mercury.position.toFixed(2)}° (${chart.mercury.house})${chart.mercury.retrograde ? ' ℞' : ''}\n`;
                md += `- **Venus**: ${chart.venus.sign} ${chart.venus.position.toFixed(2)}° (${chart.venus.house})${chart.venus.retrograde ? ' ℞' : ''}\n`;
                md += `- **Mars**: ${chart.mars.sign} ${chart.mars.position.toFixed(2)}° (${chart.mars.house})${chart.mars.retrograde ? ' ℞' : ''}\n\n`;
            }

            // Aspects Summary
            if (data.person_a?.chart?.aspects && data.person_a.chart.aspects.length > 0) {
                md += `## Person A Major Aspects\n\n`;
                data.person_a.chart.aspects.slice(0, 10).forEach(aspect => {
                    // Dual-read for orb field
                    const orb = (Number.isFinite(aspect.orb) ? aspect.orb :
                                 Number.isFinite(aspect.orbit) ? aspect.orbit :
                                 Number.isFinite(aspect.diff) ? aspect.diff : null);
                    const p1 = aspect.p1_name || aspect.planet_a || aspect.transit_body || '—';
                    const p2 = aspect.p2_name || aspect.planet_b || aspect.natal_target || '—';
                    const asp = aspect.aspect || aspect.aspect_name || aspect.name || '—';
                    md += `- **${p1}** ${asp} **${p2}** (${orb !== null ? orb.toFixed(1) : '—'}° orb)\n`;
                });
                md += `\n`;
            }

            if (data.synastry?.aspects && data.synastry.aspects.length > 0) {
                md += `## Relational Echo Field Analysis\n\n`;
                md += `### Bidirectional Aspect Inventory\n\n`;
                md += `> **Protocol**: Each aspect rendered from both A→B and B→A perspectives for narrative reflection generation\n`;
                md += `> **Echo Loop Detection**: Aspects within ±3° orb creating self-reinforcing dynamics\n`;
                md += `> **Attribution Rule**: PersonA vs PersonB explicit — no generic "they" or "both" until confirmed\n\n`;
                
                // Group aspects by orb ranges for Echo Loop analysis
                const tight = data.synastry.aspects.filter(a => Math.abs(a.orbit) <= 1);
                const echoRange = data.synastry.aspects.filter(a => Math.abs(a.orbit) > 1 && Math.abs(a.orbit) <= 3);
                const background = data.synastry.aspects.filter(a => Math.abs(a.orbit) > 3 && Math.abs(a.orbit) <= 6);
                
                if (tight.length > 0) {
                    md += `**Echo Loops (≤1° orb) — ${tight.length} aspects:**\n\n`;
                    tight.forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        const aspectCode = `EL-${String(index + 1).padStart(2, '0')}`;
                        md += `- **${aspectCode}**: ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                        md += `  - **Direction**: ${aspect.p1_name} (${initiator}) → ${aspect.p2_name} (${receiver})\n`;
                        md += `  - **Reciprocal**: ${aspect.p2_name} (${receiver}) ← ${aspect.p1_name} (${initiator})\n`;
                    });
                    md += `\n`;
                }
                
                if (echoRange.length > 0) {
                    md += `**Relational Echo Field (1-3° orb) — ${echoRange.length} aspects:**\n\n`;
                    echoRange.forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        const aspectCode = `REF-${String(index + 1).padStart(2, '0')}`;
                        md += `- **${aspectCode}**: ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                    });
                    md += `\n`;
                }
                
                if (background.length > 0) {
                    md += `**Background Geometry (3-6° orb) — ${background.length} aspects:**\n\n`;
                    background.slice(0, 10).forEach((aspect, index) => {
                        const initiator = aspect.p1_owner === personA.name ? personA.name : personB.name;
                        const receiver = aspect.p2_owner === personA.name ? personA.name : personB.name;
                        md += `- ${initiator} ${aspect.p1_name} ${aspect.aspect} ${receiver} ${aspect.p2_name} (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                    });
                    if (background.length > 10) md += `... (${background.length - 10} additional background aspects)\n`;
                    md += `\n`;
                }
                
                // REF Detection and Polarity Code Assignment
                if (tight.length >= 2 || (tight.length >= 1 && echoRange.length >= 1)) {
                    md += `**REF Macro Structure Detection**:\n`;
                    md += `- **Echo Loop Count**: ${tight.length}\n`;
                    md += `- **Echo Field Count**: ${echoRange.length}\n`;
                    md += `- **Convergence Threshold**: ${tight.length >= 2 ? 'Met' : 'Partial'}\n`;
                    
                    // Generate provisional polarity codes based on aspect types
                    const aspectTypes = [...tight, ...echoRange.slice(0, 2)].map(a => a.aspect.toLowerCase());
                    const hasHard = aspectTypes.some(a => ['square', 'opposition'].includes(a));
                    const hasSoft = aspectTypes.some(a => ['trine', 'sextile'].includes(a));
                    const hasConjunction = aspectTypes.some(a => a === 'conjunction');
                    
                    let polarityHint = '';
                    if (hasHard && hasConjunction) polarityHint = 'F21 (Frictional Attraction)';
                    else if (hasHard && hasSoft) polarityHint = 'M15 (Mixed Tension)';
                    else if (hasConjunction && hasSoft) polarityHint = 'H12 (Harmonic Blend)';
                    else if (hasHard) polarityHint = 'C18 (Challenge Dynamic)';
                    else if (hasSoft) polarityHint = 'E09 (Ease Flow)';
                    else polarityHint = 'TBD (Complex Pattern)';
                    
                    md += `- **Provisional Polarity Code**: ${polarityHint} — requires MAP layer confirmation\n`;
                    md += `- **Attribution**: ${personA.name} ↔ ${personB.name} (bidirectional analysis required)\n\n`;
                }
            }

            // Composite Field Dynamics (if present)
            if (data.composite?.chart?.aspects && data.composite.chart.aspects.length > 0) {
                md += `## Composite Field Dynamics — Shared Structural Patterns\n\n`;
                md += `### Composite Chart Aspects\n\n`;
                md += `> **Protocol**: Composite represents shared field dynamics, not individual attribution\n\n`;
                data.composite.chart.aspects.slice(0, 15).forEach(aspect => {
                    md += `- **${aspect.p1_name}** ${aspect.aspect} **${aspect.p2_name}** (${Math.abs(aspect.orbit).toFixed(1)}° orb)\n`;
                });
                md += `\n`;
            }

            // Protocol Compliance Reminder
            md += `## Protocol Compliance Check\n\n`;
            md += `> **Geometry Layer Complete**: Calculations and aspect patterns documented\n`;
            md += `> **Boundary Maintained**: No narrative, prediction, or interpretation included\n`;
            md += `> **Next Required**: Clear Mirror translation via Poetic Brain (Raven Calder)\n`;
            md += `> **Contract**: mirror-ready geometry with appropriate nudges provided\n\n`;

            // Transit Analysis (if mode includes transits and is not natal_only)
            if (mode.includes('_transits') && mode !== 'natal_only') {
                const transitStartDate = formData.transitParams?.startDate;
                const transitEndDate = formData.transitParams?.endDate;
                
                console.log('=== MARKDOWN TRANSIT DEBUG ===');
                console.log('Transit mode detected in markdown generation:', mode);
                console.log('Transit dates from form:', transitStartDate, 'to', transitEndDate);
                console.log('Data object keys:', Object.keys(data));
                console.log('Person A has transitsByDate?', !!data.person_a?.chart?.transitsByDate);
                console.log('Person B has transitsByDate?', !!data.person_b?.chart?.transitsByDate);
                
                if (data.person_a?.chart?.transitsByDate) {
                    console.log('Person A transit dates available:', Object.keys(data.person_a.chart.transitsByDate));
                }
                if (data.person_b?.chart?.transitsByDate) {
                    console.log('Person B transit dates available:', Object.keys(data.person_b.chart.transitsByDate));
                }
                
                md += `## Protocol Layer 2: Live Activations — Trace the Threads\n\n`;
                md += `**Temporal Scope**: ${transitStartDate} to ${transitEndDate}\n`;
                md += `**Purpose**: Identify active tugging patterns and symbolic weather overlays\n`;
                md += `**Processing**: Seismograph aggregation with magnitude, valence, volatility metrics\n\n`;

                                // --- New Unified Hook / Seismograph Renderer ---
                                const ui = window.WOVEN_UI_FILTERS || { tightOnly:true, showMinor:false, showHarmonic:false, showSelf:false };
                
                                const NAME_MAP = { Medium_Coeli:'Midheaven (MC)', MC:'Midheaven (MC)', Mean_Node:'North Node', Mean_South_Node:'South Node', Mean_Lilith:'Lilith' };
                                const labelName = n => NAME_MAP[n] || n;
                                const aspectGlyph = a => ({conjunction:'☌', opposition:'☍', square:'□', trine:'△', sextile:'✧'})[a] || a;
                                                function hookLine(h){
                                                    let orbVal = h._orb??h.orb; 
                                                    const sign = (typeof orbVal==='number' && orbVal<0)? -1:1;
                                                    const absOrb = (typeof orbVal==='number')? Math.abs(orbVal): orbVal;
                                                    const exact = (typeof absOrb==='number' && absOrb<=0.2) ? '★ ' : '';
                                                    // Phase arrow: if approaching flag supplied else derive from sign (negative = separating) fallback
                                                    let phaseArrow = '';
                                                    if (h.approaching === true) phaseArrow = '↑'; else if (h.approaching === false) phaseArrow = '↓'; else phaseArrow = (sign>0? '↑':'↓');
                                                    return `${exact}${labelName(h.p1_display||h.p1_name)} ${aspectGlyph(h._aspect||h.aspect)} ${labelName(h.p2_display||h.p2_name)} — ${(absOrb)?.toFixed ? absOrb.toFixed(1): '—'}° ${phaseArrow}`.trim();
                                                }
                                function classifyClient(a){
                                    const cls = a._class || a.class || ''; // major, minor, harmonic
                                    if (cls==='major') return 'Major';
                                    if (cls==='minor') return 'Minor';
                                    if (cls==='harmonic') return 'Harmonic';
                                    return 'Other';
                                }
                                function passClientFilters(a){
                                    const orb = a._orb ?? a.orb;
                                    const tight = typeof orb==='number' && orb<=2;
                                    const cls = a._class;
                                    const isMinor = cls==='minor';
                                    const isHarm = cls==='harmonic';
                                    const isSelf = a.p1_name===a.p2_name;
                                    if (ui.tightOnly && !tight) return false;
                                    if (!ui.showMinor && isMinor) return false;
                                    if (!ui.showHarmonic && isHarm) return false;
                                    if (!ui.showSelf && isSelf) return false;
                                    return true;
                                }
                                                function deriveCounts(filteredList){
                                                    const counts = { majors_tight:0, majors_loose:0, minors:0, harmonics:0, self_aspects:0 };
                                                    filteredList.forEach(a=>{
                                                        const orb = a._orb??a.orb??99;
                                                        const isSelf = a.p1_name===a.p2_name;
                                                        if (isSelf) counts.self_aspects++;
                                                        if (a._class==='major') { if (orb<=2) counts.majors_tight++; else counts.majors_loose++; }
                                                        else if (a._class==='minor') counts.minors++; else if (a._class==='harmonic') counts.harmonics++;
                                                    });
                                                    return counts;
                                                }
                                                // Hook pruning utilities
                                                function pruneHooks(list){
                                                    if(!Array.isArray(list)) return [];
                                                    const ORB_CAPS = { luminary:6, planet:4, point:3 }; // tightened hook layer caps
                                                    function bodyClass(n){
                                                        const name = (n||'').toLowerCase();
                                                        if (['sun','moon'].includes(name)) return 'luminary';
                                                        if (['ascendant','midheaven','mc','ic','north node','south node','node','lilith','chiron'].includes(name)) return 'point';
                                                        return 'planet';
                                                    }
                                                    // Filter by orb caps
                                                    const capped = list.filter(a=>{
                                                        const orb = Math.abs(a._orb??a.orb??99);
                                                        const aClass = bodyClass(a.p1_name);
                                                        const bClass = bodyClass(a.p2_name);
                                                        const cap = Math.min( ORB_CAPS[aClass]||5, ORB_CAPS[bClass]||5 );
                                                        return orb <= cap;
                                                    });
                                                    // Diversity: limit max 2 entries per symbolic point (Node/Lilith/Chiron) and 2 per identical pair signature
                                                    const pointNames = new Set(['north node','south node','node','lilith','chiron']);
                                                    const pointCounts = {}; const pairCounts = {};
                                                    const diversified = [];
                                                    for (const h of capped.sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; return (Math.abs(a._orb??a.orb??99)) - (Math.abs(b._orb??b.orb??99)); })) {
                                                        const aName=(h.p1_name||'').toLowerCase();
                                                        const bName=(h.p2_name||'').toLowerCase();
                                                        const pairKey = [aName,bName].sort().join('_');
                                                        const involvesPoint = pointNames.has(aName)||pointNames.has(bName);
                                                        if (involvesPoint){
                                                            pointCounts[aName] = pointCounts[aName]||0;
                                                            pointCounts[bName] = pointCounts[bName]||0;
                                                        }
                                                        pairCounts[pairKey] = pairCounts[pairKey]||0;
                                                        if (involvesPoint){
                                                            const totalPointHits = (pointCounts[aName]||0)+(pointCounts[bName]||0);
                                                            if (totalPointHits >=4) continue; // roughly 2 each combined ceiling
                                                        }
                                                        if (pairCounts[pairKey] >=2) continue;
                                                        // accept
                                                        diversified.push(h);
                                                        if (pointNames.has(aName)) pointCounts[aName]++;
                                                        if (pointNames.has(bName)) pointCounts[bName]++;
                                                        pairCounts[pairKey]++;
                                                        if (diversified.length>=8) break; // cap hooks shown
                                                    }
                                                    return diversified;
                                                }
                                                function buildDaySection(date, day){
                                                    if(!day) return '';
                                                    // Hooks sort tie-break by smaller orb
                                                    const rawHooksSorted = (day.hooks?.slice()||[]).sort((a,b)=>{
                                                        const wDiff = (b._weight||0) - (a._weight||0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        const oa = Math.abs(a._orb??a.orb??99); const ob = Math.abs(b._orb??b.orb??99); return oa - ob;
                                                    });
                                                    const hooks = pruneHooks(rawHooksSorted);
                                                    const filteredAll = (day.filtered_aspects||[]).filter(passClientFilters);
                                                    const counts = deriveCounts(filteredAll);
                                                    // Invariant check (debug only)
                                                    if ((counts.majors_tight + counts.majors_loose + counts.minors + counts.harmonics + counts.self_aspects) !== filteredAll.length){
                                                        console.warn('Count invariant mismatch', date, counts, filteredAll.length);
                                                    }
                                                    let summaryLine = `${date} — Majors: ${counts.majors_tight + counts.majors_loose} (tight ${counts.majors_tight}, loose ${counts.majors_loose}) · Minors: ${counts.minors} · Harmonics: ${counts.harmonics}`;
                                                    let out = `<details><summary>${summaryLine}</summary>\n\n`;
                                                    out += `**Hooks** (orb caps applied; diversity filtered${rawHooksSorted.length>hooks.length?`, ${rawHooksSorted.length-hooks.length} suppressed`:''})\n`;
                                                    hooks.forEach(h=> out += `- ${hookLine(h)}\n`);
                                                    if (!hooks.length) out += `- —\n`;
                                                    out += `\n**Filtered aspects (${filteredAll.length})**  *Loose majors (>6°) omitted from hooks*\n`;
                                                    filteredAll.forEach(a=>{
                                                        const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                        out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt}) — ${classifyClient(a)}\n`;
                                                    });
                                                    if (Array.isArray(day.aspects) && day.aspects.length){
                                                        out += `\n<details><summary>Full list (raw ${day.aspects.length})</summary>\n\n`;
                                                        day.aspects.slice(0,40).forEach(a=>{
                                                            const orb = a._orb??a.orb??a.orbit; const orbTxt = (typeof orb==='number')? orb.toFixed(1)+'°':'—';
                                                            out += `- ${labelName(a.p1_display||a.p1_name)} ${aspectGlyph(a._aspect||a.aspect)} ${labelName(a.p2_display||a.p2_name)} (${orbTxt})\n`;
                                                        });
                                                        if (day.aspects.length>40) out += `... (${day.aspects.length-40} more)\n`;
                                                        out += `</details>\n`;
                                                    }
                                                    out += `\n</details>\n\n`;
                                                    return out;
                                                }

                                                // REMOVED: FIELD/MAP/VOICE Translation Bridge
                                                // Math Brain Compliance: This function violated protocol by generating interpretive content.
                                                // FIELD → MAP → VOICE translation is exclusively handled by downstream Poetic Brain (Raven Calder).
                                                // Math Brain outputs geometry only with appropriate nudges for downstream processing.
                                                
                                                // Enhanced buildSummaryTable with three-tier protocol structure
                                                function buildEnhancedSummaryTable(title, dailyMap) {
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    
                                                    // Determine context layer based on title content for proper mythic metaphors
                                                    let contextLayer = 'Trace the Threads'; // Default for transits
                                                    if (title.toLowerCase().includes('composite')) {
                                                        contextLayer = 'Currents + Seismograph';
                                                    }
                                                    
                                                    let out = `## ${title} — ${contextLayer}\n\n`;
                                                    out += `> **Math Brain Protocol**: Geometry Only • Mirror-ready for downstream Poetic Brain (Raven Calder)\n`;
                                                    out += `> **Layer**: Symbolic scaffolding for MAP → VOICE translation\n\n`;
                                                    
                                                    dates.forEach(d => {
                                                        const day = dailyMap[d];
                                                        const mag = (day.seismograph?.magnitude || 0).toFixed(2);
                                                        const val = Math.max(-5, Math.min(5, day.seismograph?.valence || 0)).toFixed(2);
                                                        const vol = (day.seismograph?.volatility || 0).toFixed(2);
                                                        const trend = day.valence_trend || 0;
                                                        const trendArrow = trend > 0.5 ? ' ↗' : trend < -0.5 ? ' ↘' : '';
                                                        const scaleConf = day.seismograph?.scaleConfidence?.toFixed(3) || '—';
                                                        
                                                        // 1. Seismograph Readout (pure geometry)
                                                        out += `### ${d} — Seismograph Readout\n`;
                                                        out += `**Magnitude:** ${mag} • **Valence:** ${val}${trendArrow} • **Volatility:** ${vol} • **Scale Confidence:** ${scaleConf}\n\n`;
                                                        
                                                        // 2. Top Hooks (geometry with retrograde flags)
                                                        const filteredHooks = applyStrictOrbCaps(day.hooks || []);
                                                        const topHooks = filteredHooks.slice(0, 5);
                                                        
                                                        out += `**Geometry Hooks** _(orb caps applied)_:\n`;
                                                        if (topHooks.length === 0) {
                                                            out += `- No hooks within protocol orb caps\n`;
                                                        } else {
                                                            topHooks.forEach(h => {
                                                                const retroSymbol = (h.p1_retrograde ? '℞' : '') + (h.p2_retrograde ? '℞' : '');
                                                                const weightFlag = h._weight >= 0.8 ? ' ●' : h._weight >= 0.5 ? ' ◐' : '';
                                                                out += `- ${hookLine(h)}${retroSymbol ? ' ' + retroSymbol : ''}${weightFlag}\n`;
                                                            });
                                                        }
                                                        
                                                        // 3. Retrograde Recursion Band (if ≥2 retrograde aspects per protocol)
                                                        const retrogradeAspects = day.retrograde_aspects || [];
                                                        if (retrogradeAspects.length >= 2) {
                                                            out += `\n**Retrograde Recursion Pattern** _(${retrogradeAspects.length} aspects)_:\n`;
                                                            retrogradeAspects.slice(0, 4).forEach(a => {
                                                                const orb = Math.abs(a._orb || a.orb || 0).toFixed(1);
                                                                const body1 = (a.p1_retrograde ? '℞' : '') + labelName(a.p1_name);
                                                                const body2 = (a.p2_retrograde ? '℞' : '') + labelName(a.p2_name);
                                                                out += `- ${body1} ${aspectGlyph(a._aspect)} ${body2} (${orb}°)\n`;
                                                            });
                                                            if (retrogradeAspects.length > 4) out += `- ... (${retrogradeAspects.length - 4} more)\n`;
                                                        }
                                                        
                                                        // 4. Protocol Nudges for Downstream Processing
                                                        out += `\n**Raven Processing Nudges:**\n`;
                                                        if (mag >= 6 && vol >= 3) {
                                                            out += `- High magnitude + volatility → Pressure-state mirroring required\n`;
                                                        }
                                                        if (Math.abs(val) >= 3) {
                                                            out += `- Significant valence (${val}) → Tension-direction clarity needed\n`;
                                                        }
                                                        if (retrogradeAspects.length >= 2) {
                                                            out += `- Retrograde recursion → Internal revision themes indicated\n`;
                                                        }
                                                        if (scaleConf !== '—' && parseFloat(scaleConf) < 0.7) {
                                                            out += `- Low scale confidence → Caution framing advised\n`;
                                                        }
                                                        if (topHooks.length === 0) {
                                                            out += `- No hooks → Background stability or dispersed influence pattern\n`;
                                                        }
                                                        
                                                        // 5. Raw Aspect Inventory with Rejection Taxonomy (collapsible)
                                                        const allAspects = day.filtered_aspects || [];
                                                        const rejections = day.rejections || [];
                                                        
                                                        if (allAspects.length > 0 || rejections.length > 0) {
                                                            out += `\n<details><summary>Aspect Processing Summary — ${allAspects.length} accepted, ${rejections.length} rejected</summary>\n\n`;
                                                            
                                                            if (allAspects.length > 0) {
                                                                out += `**Accepted Aspects (${allAspects.length}):**\n`;
                                                                allAspects.forEach(a => {
                                                                    const orb = Math.abs(a._orb || a.orb || 0).toFixed(1);
                                                                    const retroFlag = (a.p1_retrograde || a.p2_retrograde) ? ' ℞' : '';
                                                                    const classFlag = a._class ? ` [${a._class}]` : '';
                                                                    const weightFlag = a._weight ? ` w=${a._weight.toFixed(2)}` : '';
                                                                    out += `- ${labelName(a.p1_name)} ${aspectGlyph(a._aspect)} ${labelName(a.p2_name)} (${orb}°)${retroFlag}${classFlag}${weightFlag}\n`;
                                                                });
                                                            }
                                                            
                                                            if (rejections.length > 0) {
                                                                out += `\n**Rejection Taxonomy (${rejections.length}):**\n`;
                                                                const rejectionGroups = {};
                                                                rejections.forEach(r => {
                                                                    if (!rejectionGroups[r.reason]) rejectionGroups[r.reason] = [];
                                                                    rejectionGroups[r.reason].push(r);
                                                                });
                                                                
                                                                Object.entries(rejectionGroups).forEach(([reason, items]) => {
                                                                    out += `- **${reason}** (${items.length}): `;
                                                                    const samples = items.slice(0, 3).map(r => `${r.aspect} (${Math.abs(r.orb || 0).toFixed(1)}°)`);
                                                                    out += samples.join(', ');
                                                                    if (items.length > 3) out += `, +${items.length - 3} more`;
                                                                    out += `\n`;
                                                                });
                                                            }
                                                            
                                                            out += `\n</details>\n\n`;
                                                        }
                                                        
                                                        out += `---\n\n`;
                                                    });
                                                    
                                                    // Add scaling strategy summary
                                                    const sampleDay = Object.values(dailyMap)[0];
                                                    if (sampleDay?.seismograph?.scalingStrategy) {
                                                        out += `**Scaling Protocol**: ${sampleDay.seismograph.scalingStrategy}`;
                                                        if (sampleDay.seismograph.scaleConfidence !== undefined) {
                                                            const confidence = sampleDay.seismograph.scaleConfidence;
                                                            const n = Math.round(confidence * 14);
                                                            out += ` (${n}/14 day window, confidence=${confidence.toFixed(3)})`;
                                                        }
                                                        out += `\n\n`;
                                                    }
                                                    
                                                    return out;
                                                }
                                                
                                                // Apply strict orb caps for Top Hooks
                                                function applyStrictOrbCaps(hooks) {
                                                    const ORB_CAPS = { luminary: 6, planet: 4, point: 3 };
                                                    
                                                    function getBodyType(name) {
                                                        const n = (name || '').toLowerCase();
                                                        if (['sun', 'moon'].includes(n)) return 'luminary';
                                                        if (['ascendant', 'midheaven', 'mc', 'ic', 'north node', 'south node', 'lilith', 'chiron'].includes(n)) return 'point';
                                                        return 'planet';
                                                    }
                                                    
                                                    return hooks.filter(h => {
                                                        const orb = Math.abs(h._orb || h.orb || 99);
                                                        const type1 = getBodyType(h.p1_name);
                                                        const type2 = getBodyType(h.p2_name);
                                                        const cap = Math.min(ORB_CAPS[type1] || 5, ORB_CAPS[type2] || 5);
                                                        return orb <= cap;
                                                    }).sort((a, b) => {
                                                        // Sort by weight, then by orb tightness
                                                        const wDiff = (b._weight || 0) - (a._weight || 0);
                                                        if (Math.abs(wDiff) > 1e-6) return wDiff;
                                                        return Math.abs(a._orb || a.orb || 99) - Math.abs(b._orb || b.orb || 99);
                                                    });
                                                }

                                                function buildSummaryTable(title, dailyMap){
                                                    const dates = Object.keys(dailyMap||{}).sort();
                                                    if (!dates.length) return '';
                                                    const single = dates.length===1;
                                                    let out = `## ${title} — Seismograph ${single?'(Daily Range)':'(Range)'}\n\n| Date | Magnitude | Valence | Volatility | Top Hooks |\n|------|-----------:|--------:|-----------:|-----------|\n`;
                                                    dates.forEach(d=>{
                                                        const day = dailyMap[d];
                                                        // Limit to top 3 hooks by weight desc w/ tie-break
                                                        const hooks = (day.hooks||[]).slice().sort((a,b)=>{ const w=(b._weight||0)-(a._weight||0); if (Math.abs(w)>1e-6) return w; const oa=a._orb??a.orb??99; const ob=b._orb??b.orb??99; return oa-ob; }).slice(0,3);
                                                        const peak = hooks.map(h=> hookLine(h)).join(', ');
                                                        const rawVal = (day.seismograph?.valence??0);
                                                        const clampedVal = Math.max(-5, Math.min(5, rawVal));
                                                        out += `| ${d} | ${(day.seismograph?.magnitude??0).toFixed(2)} | ${clampedVal.toFixed(2)} | ${(day.seismograph?.volatility??0).toFixed(2)} | ${peak.replace(/\|/g,'\\|') || '—'} |\n`;
                                                    });
                                                    out += `\nMagnitude=aggregate charge (0–10 est), Valence=net tension (−=friction, +=ease), Volatility=dispersion of charge.\n`;
                                                    
                                                    // Add confidence scaling information if available
                                                    const sampleDay = Object.values(dailyMap)[0];
                                                    if (sampleDay?.seismograph?.scaleConfidence !== undefined) {
                                                        const confidence = sampleDay.seismograph.scaleConfidence;
                                                        const n = Math.round(confidence * 14);
                                                        out += `Scaling: blended (n=${n}, confidence=${confidence})\n`;
                                                    }
                                                    
                                                    out += `\n`;
                                                    return out;
                                                }
                
                                md += `### Daily Seismograph Readouts\n\n`;
                                if (data.person_a?.chart?.transitsByDate) md += buildEnhancedSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildEnhancedSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildEnhancedSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Legacy Table View\n`;
                                if (data.person_a?.chart?.transitsByDate) md += buildSummaryTable(`${personA.name}`, data.person_a.chart.transitsByDate);
                                if (data.person_b?.chart?.transitsByDate) md += buildSummaryTable(`${personB.name}${data.person_b?.implicit_dual_transits?' (implicit dual)':''}`, data.person_b.chart.transitsByDate);
                                if (data.composite?.transitsByDate) md += buildSummaryTable(`Composite Field`, data.composite.transitsByDate);
                
                                md += `\n## Daily Hooks\n\n_Orb shows absolute degrees. Phase: ↑ applying (tightening) · ↓ separating (widening). Hook layer caps: ≤6° luminaries, ≤4° planets, ≤3° points; broader orbs remain in Raw._\n`;
                                if (data.person_a?.chart?.transitsByDate){
                                    Object.keys(data.person_a.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_a.chart.transitsByDate[d]); });
                                }
                                if (data.person_b?.chart?.transitsByDate){
                                    Object.keys(data.person_b.chart.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.person_b.chart.transitsByDate[d]); });
                                }
                                if (data.composite?.transitsByDate){
                                    Object.keys(data.composite.transitsByDate).sort().forEach(d=>{ md += buildDaySection(d, data.composite.transitsByDate[d]); });
                                }
                
                console.log('=== END MARKDOWN TRANSIT DEBUG ===');

                // Synastry Transits (transits to synastry aspects)
                if (mode.includes('synastry') && data.synastry?.transitsByDate) {
                    md += `### Synastry Transit Activations\n\n`;
                    const synastryTransits = data.synastry.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(synastryTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = synastryTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_owner ? `${transit.p2_owner} ${transit.p2_name}` : (transit.p2_name ?? "?");
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant synastry transit activations in the specified date range.\n\n`;
                    }
                }

                // Composite Transits (for composite modes)
                if (mode.includes('composite') && data.composite?.transitsByDate) {
                    md += `### Composite Chart Transits\n\n`;
                    const compositeTransits = data.composite.transitsByDate;
                    
                    // Filter transits within date range
                    const relevantDates = Object.keys(compositeTransits).filter(date => {
                        return date >= formData.transitParams.startDate && date <= formData.transitParams.endDate;
                    }).sort();
                    
                    if (relevantDates.length > 0) {
                        relevantDates.forEach(date => {
                            md += `#### ${date}\n\n`;
                            const dailyData = compositeTransits[date];
                            const transitsForDate = dailyData?.aspects || dailyData || []; // Handle both new and old structure
                            if (Array.isArray(transitsForDate)) {
                                transitsForDate.forEach(transit => {
                                    const bodyA = transit.p1_name ?? "?";
                                    const bodyB = transit.p2_name ?? "?";
                                    const aspect = transit.aspect ?? transit.aspect_name ?? "?";
                                    const orb = transit.orbit ?? transit.orb ?? 0;
                                    if (bodyA && bodyB && aspect && orb !== undefined && orb !== null && !isNaN(orb)) {
                                        md += `- **${bodyA}** ${aspect} **${bodyB}** (${Math.abs(orb).toFixed(1)}° orb)\n`;
                                    }
                                });
                            }
                            md += `\n`;
                        });
                    } else {
                        md += `No significant composite transits in the specified date range.\n\n`;
                    }
                }
            }

            // Footer: Protocol Compliance & Safety Requirements
            const isRavenConsumer = data.raven_consumer === 'RAVEN_CALDER_GPT';
            
            md += `## Safety & Hygiene Protocol\n\n`;
            
            // Agency Clause (Required by Protocol)
            md += `### Agency Reinforcement (Required)\n\n`;
            md += `**Agency Statement**: This geometric analysis provides symbolic weather patterns, not deterministic outcomes. `;
            md += `You remain the author of your choices and the validator of any resonance. `;
            md += `The map supports your agency—it never overrides it. If something doesn't land, it doesn't count.\n\n`;
            
            // Temporal and Rate Limits
            md += `### Protocol Limits\n\n`;
            md += `- **Max Date Span**: 30 days per request (current: ${formData.transitParams ? Math.ceil((new Date(formData.transitParams.endDate) - new Date(formData.transitParams.startDate)) / (1000 * 60 * 60 * 24)) : 'N/A'} days)\n`;
            md += `- **Rate Limits**: 50 transit requests per day per user\n`;
            md += `- **Narrative Hygiene**: No deterministic or fatalistic language permitted\n`;
            md += `- **Falsifiability**: All outputs subject to "Does this land?" validation\n\n`;
            
            // Glossary for non-Raven consumers
            if (!isRavenConsumer) {
                md += `## Symbolic Glossary (for Non-Raven GPT Consumers)\n\n`;
                md += `| Term | Definition |\n`;
                md += `|------|------------|\n`;
                md += `| **Weave** | Structural identity patterns revealed through natal geometry |\n`;
                md += `| **Threads** | Live activation patterns through transiting aspects |\n`;
                md += `| **Currents** | Macro pressure states from seismograph aggregation |\n`;
                md += `| **Seismograph** | Two-axis symbolic measurement: Magnitude (X), Valence (Y), Volatility Index |\n`;
                md += `| **Echo Loop** | Bidirectional aspect within ±3° orb creating reinforcing relational dynamic |\n`;
                md += `| **REF** | Relational Echo Field — macro structure from converging Echo Loops |\n`;
                md += `| **Hook** | Salient daily aspect for focused attention (strict orb caps applied) |\n`;
                md += `| **Recursion Band** | Retrograde aspect pattern indicating internal revision themes |\n\n`;
                
                md += `### System Role Clarity\n\n`;
                md += `- **Math Brain**: Finds coordinates, measures angles, provides geometric scaffolding\n`;
                md += `- **Poetic Brain (Raven Calder)**: Translates geometry into felt language and mirrors\n`;
                md += `- **User**: Validates resonance, maintains agency, decides what lands\n\n`;
            }
            
            // Raven Processing Checklist
            md += `### Raven Calder Processing Checklist\n\n`;
            md += `**Required Sources**: `;
            md += `☐ Poetic Codex • ☐ FIELD_MAP_VOICE rules • ☐ Hook Stack protocols • ☐ Seismograph guidelines\n\n`;
            md += `**Geometry Verification**: `;
            md += `☐ Retrograde flags applied • ☐ True/Mean Node distinctions noted • ☐ Coordinates normalized • ☐ Timezone validated\n\n`;
            md += `**Protocol Compliance**: `;
            md += `☐ Recognition-first approach • ☐ SST taxonomy respected • ☐ Falsifiability maintained • ☐ Agency preserved\n\n`;
            md += `**Output Standards**: `;
            md += `☐ Mirror not mandate • ☐ No prediction claims • ☐ Testable reflections • ☐ Clear boundary maintenance\n\n`;
            
            md += `---\n\n`;
            md += `*Generated by Woven Map Math Brain — Pure Geometric Scaffolding Engine*\n`;
            md += `*Contract: clear-mirror/1.2 • Protocol: FIELD → MAP → VOICE • Version: ${(data.provenance?.math_brain_version)||'0.x'}*`;

            return md;
        }

                // Re-render hooks only (without round-trip) when filters change
                function rerenderHookMarkdownSection(){
                        if(!latestResultData) return;
                        try {
                            const full = generateMarkdownReport(latestResultData);
                            reportContent.textContent = full;
                        } catch(e){ console.warn('Re-render failed', e); }
                }

        function generateFilename(extension, data) {
            const formData = collectFormData();
            const personA = formData.personA.name.replace(/[^a-zA-Z0-9]/g, '');
            const personB = formData.personB?.name?.replace(/[^a-zA-Z0-9]/g, '') || '';
            const mode = formData.context.mode;
            const date = new Date().toISOString().split('T')[0];
            
            let filename = `WovenMap_${personA}`;
            if (personB) {
                filename += `_${personB}`;
            }
            filename += `_${mode}_${date}.${extension}`;
            
            return filename;
        }

        function parseCoordinates(coordString) {
            if (!coordString) return { latitude: undefined, longitude: undefined };
            
            coordString = coordString.trim();
            const decimalPattern = /^-?\d+\.?\d*,\s*-?\d+\.?\d*$/;
            const dmsPattern = /(\d+)[°\s]+(\d+)'?\s*([NS]),\s*(\d+)[°\s]+(\d+)'?\s*([EW])/i;

            console.log("Parsing coordinates:", coordString);

            if (decimalPattern.test(coordString)) {
                const [lat, lon] = coordString.split(',').map(s => parseFloat(s.trim()));
                console.log("Parsed decimal coordinates:", { latitude: lat, longitude: lon });
                return { latitude: lat, longitude: lon };
            }

            const dmsMatch = coordString.match(dmsPattern);
            if (dmsMatch) {
                let lat = parseFloat(dmsMatch[1]) + parseFloat(dmsMatch[2]) / 60;
                if (dmsMatch[3].toUpperCase() === 'S') lat = -lat;

                let lon = parseFloat(dmsMatch[4]) + parseFloat(dmsMatch[5]) / 60;
                if (dmsMatch[6].toUpperCase() === 'W') lon = -lon;
                
                console.log("Parsed DMS coordinates:", { latitude: lat, longitude: lon });
                return { latitude: parseFloat(lat.toFixed(4)), longitude: parseFloat(lon.toFixed(4)) };
            }
            
            console.error("Failed to parse coordinates:", coordString);
            // Return undefined if no pattern matches
            return { latitude: undefined, longitude: undefined };
        }

        // --- Form Logic ---

        function validateForm() {
            hideError();
            
            // Mobile debugging - log form data collection
            console.log('=== FORM VALIDATION START ===');
            console.log('User agent:', navigator.userAgent);
            console.log('Screen dimensions:', window.screen.width, 'x', window.screen.height);
            console.log('Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
            
            const mode = document.querySelector('input[name="contextMode"]:checked').value;
            const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value;
            const intimacyTier = document.querySelector('input[name="intimacyTier"]:checked')?.value;
            const roleSel = document.getElementById('relationshipRole');
            const roleCustomInput = document.getElementById('relationshipRoleCustom');
            const roleValueRaw = roleSel ? roleSel.value : '';

            // Validate Person A
            const nameA = document.getElementById('nameA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();

            // Mobile debugging - log raw values
            console.log('Person A form values:');
            console.log('- Name:', nameA);
            console.log('- Date (raw):', dateA);
            console.log('- Time (raw):', timeA);
            console.log('- Coordinates (raw):', astroA);
            console.log('- Date field type:', document.getElementById('birth_dateA').type);
            console.log('- Date field value:', document.getElementById('birth_dateA').value);

            if (!nameA || !dateA || !timeA || !astroA) {
                console.error('Missing required fields:', { nameA: !!nameA, dateA: !!dateA, timeA: !!timeA, astroA: !!astroA });
                showError('Please fill in all required fields for Person A');
                return false;
            }
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateA)) {
                console.error('Date format validation failed. Expected YYYY-MM-DD, got:', dateA);
                showError('Please enter Person A date in YYYY-MM-DD format');
                return false;
            }
            if (!/^\d{2}:\d{2}$/.test(timeA)) {
                showError('Please enter Person A time in HH:MM format (24-hour)');
                return false;
            }
            const coordsA = parseCoordinates(astroA);
            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                showError('Please enter Person A coordinates in a valid decimal (e.g., 40.01, -75.31) or DMS format (e.g., 40°1\'N, 75°18\'W)');
                return false;
            }

            // Validate Person B if required by mode
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                const nameB = document.getElementById('nameB').value.trim();
                const dateB = document.getElementById('birth_dateB').value.trim();
                const timeB = document.getElementById('birth_timeB').value.trim();
                const astroB = document.getElementById('astroB').value.trim();
                if (!nameB || !dateB || !timeB || !astroB) {
                    showError(`Please fill in all required fields for Person B for ${mode} analysis`);
                    return false;
                }
                if (!/^\d{4}-\d{2}-\d{2}$/.test(dateB)) {
                    showError('Please enter Person B date in YYYY-MM-DD format');
                    return false;
                }
                if (!/^\d{2}:\d{2}$/.test(timeB)) {
                    showError('Please enter Person B time in HH:MM format (24-hour)');
                    return false;
                }
                const coordsB = parseCoordinates(astroB);
                if (coordsB.latitude === undefined || coordsB.longitude === undefined) {
                    showError('Please enter Person B coordinates in a valid decimal or DMS format');
                    return false;
                }
            }

            // Validate transit dates if required by mode (skip for natal_only)
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits') {
                const start = transitStartDate.value;
                const end = transitEndDate.value;
                if (!start || !end) {
                    showError('Please enter both start and end dates for transit analysis');
                    return false;
                }
                if (end < start) {
                    showError('End date must be after or equal to start date');
                    return false;
                }
            }

            // Validate relocation coordinates if enabled
            if (relocationToggle.checked) {
                const relocationCoords = relocationCoordsInput.value.trim();
                if (!relocationCoords) {
                    showError('Please enter relocation coordinates when overlay is enabled');
                    return false;
                }
                const coordsR = parseCoordinates(relocationCoords);
                if (coordsR.latitude === undefined || coordsR.longitude === undefined) {
                    showError('Please enter valid relocation coordinates in decimal or DMS format');
                    return false;
                }
            }

            // Relationship context validation for synastry/composite modes
            if (mode === 'synastry_transits' || mode === 'composite_transits') {
                if (!relationshipType) {
                    showError('Please specify the relationship type for synastry/composite analysis');
                    return false;
                }
                
                // Partner requires intimacy tier
                if (relationshipType === 'partner') {
                    if (!intimacyTier) {
                        showError('Please select an intimacy tier for partner relationships');
                        return false;
                    }
                }
                
                // Family requires role
                if (relationshipType === 'family') {
                    if (!roleValueRaw) {
                        showError('Please specify the family role for family relationships');
                        return false;
                    }
                    if (roleValueRaw === 'other') {
                        const customVal = roleCustomInput?.value?.trim();
                        if (!customVal) {
                            showError('Please provide a custom family role description');
                            return false;
                        }
                    }
                }
                
                // Friend allows optional role but validates if provided
                if (relationshipType === 'friend' && roleValueRaw === 'other') {
                    const customVal = roleCustomInput?.value?.trim();
                    if (!customVal) {
                        showError('Please provide a custom friend role description or select "Other"');
                        return false;
                    }
                }
            }

            // Legacy relationship validation (for existing patterns)
            if (relationshipType === 'partner') {
                if (!intimacyTier) {
                    showError('Select an intimacy tier for partner relationships');
                    return false;
                }
            }
            if (relationshipType && relationshipType !== 'partner') {
                if (roleSel && roleValueRaw === 'other') {
                    const customVal = roleCustomInput?.value?.trim();
                    if (!customVal) {
                        showError('Provide a custom role description');
                        return false;
                    }
                }
            }
            if (relationshipType === 'partner' && roleSel && roleValueRaw) {
                console.warn('Role value ignored for partner type');
            }
            return true;
        }

        function collectFormData() {
            console.log("=== COLLECTING FORM DATA ===");
            
            // Person A - Get raw form values first
            const nameA = document.getElementById('nameA').value.trim();
            const cityA = document.getElementById('birth_cityA').value.trim();
            const stateA = document.getElementById('birth_stateA').value.trim();
            const countryA = document.getElementById('birth_countryA').value.trim();
            const dateA = document.getElementById('birth_dateA').value.trim();
            const timeA = document.getElementById('birth_timeA').value.trim();
            const astroA = document.getElementById('astroA').value.trim();
            const zodiacA = document.getElementById('zodiacA').value;
            const timezoneA = document.getElementById('offsetA').value;

            console.log("Raw form values for Person A:");
            console.log("- Name:", nameA);
            console.log("- City:", cityA);
            console.log("- State:", stateA);
            console.log("- Country:", countryA);
            console.log("- Date:", dateA);
            console.log("- Time:", timeA);
            console.log("- Coordinates:", astroA);
            console.log("- Zodiac:", zodiacA);
            console.log("- Timezone:", timezoneA);

            // Parse date and time
            if (!dateA || !timeA) {
                console.error("Missing date or time for Person A");
                throw new Error("Date and time are required for Person A");
            }

            const [yearA, monthA, dayA] = dateA.split('-').map(Number);
            const [hourA, minuteA] = timeA.split(':').map(Number);

            console.log("Parsed date/time:", { yearA, monthA, dayA, hourA, minuteA });

            // Parse coordinates
            const coordsA = parseCoordinates(astroA);
            console.log("Parsed coordinates:", coordsA);

            if (coordsA.latitude === undefined || coordsA.longitude === undefined) {
                console.error("Failed to parse coordinates for Person A");
                throw new Error("Valid coordinates are required for Person A");
            }

            const personA = {
                name: nameA || "Unknown",
                city: cityA || "Unknown",
                nation: countryA || "US",
                year: yearA,
                month: monthA, 
                day: dayA, 
                hour: hourA, 
                minute: minuteA,
                latitude: coordsA.latitude, 
                longitude: coordsA.longitude,
                zodiac_type: zodiacA || "Tropic",
                timezone: timezoneA || "America/New_York"
            };
            
            console.log("Final Person A data:", personA);
            
            // Validate all required fields are present and not undefined
            const requiredFields = ['year', 'month', 'day', 'hour', 'minute', 'name', 'city', 'nation', 'latitude', 'longitude', 'zodiac_type', 'timezone'];
            const missingFields = requiredFields.filter(field => {
                const value = personA[field];
                return value === undefined || value === null || value === "";
            });
            
            if (missingFields.length > 0) {
                console.error("Missing required fields for Person A:", missingFields);
                console.error("Current Person A object:", personA);
                throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
            }

            // Person B - only if fields are filled
            const dateB_val = document.getElementById('birth_dateB').value;
            const timeB_val = document.getElementById('birth_timeB').value.trim();
            const coordsB_val = document.getElementById('astroB').value.trim();
            let personB = null;

            if (dateB_val && timeB_val && coordsB_val) {
                console.log("Processing Person B data...");
                const coordsB = parseCoordinates(coordsB_val);
                if (coordsB.latitude !== undefined && coordsB.longitude !== undefined) {
                    const [yearB, monthB, dayB] = dateB_val.split('-').map(Number);
                    const [hourB, minuteB] = timeB_val.split(':').map(Number);
                    personB = {
                        name: document.getElementById('nameB').value.trim() || "Unknown",
                        city: document.getElementById('birth_cityB').value.trim() || "Unknown",
                        nation: document.getElementById('birth_countryB').value.trim() || "US",
                        year: yearB, 
                        month: monthB, 
                        day: dayB, 
                        hour: hourB, 
                        minute: minuteB,
                        latitude: coordsB.latitude,
                        longitude: coordsB.longitude,
                        zodiac_type: document.getElementById('zodiacB').value || "Tropic",
                        timezone: document.getElementById('offsetB').value || "America/New_York"
                    };
                    console.log("Person B data:", personB);
                }
            }

            const formData = {
                personA,
                personB: personB,
                context: {
                    mode: document.querySelector('input[name="contextMode"]:checked').value,
                    relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value,
                    intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value,
                    contact_channel: document.querySelector('input[name="contactChannel"]:checked')?.value,
                    is_ex_relationship: exRelationshipCheckbox?.checked || false
                }
            };

            // Add relationship_context for synastry/composite modes
            const relType = formData.context.relationship_type;
            const isRelationalMode = formData.context.mode && 
                (formData.context.mode.includes('synastry') || formData.context.mode.includes('composite'));
            
            if (isRelationalMode && relType) {
                const relContext = { 
                    type: relType.toUpperCase() 
                };
                
                // Add required fields based on type
                if (relType === 'partner') {
                    const tier = formData.context.intimacy_tier;
                    if (tier) relContext.intimacy_tier = tier;
                } else if (relType === 'family') {
                    const role = document.getElementById('relationshipRole')?.value;
                    if (role && role !== 'other') relContext.role = role;
                    else if (role === 'other') {
                        const customRole = document.getElementById('relationshipRoleCustom')?.value?.trim();
                        if (customRole) relContext.role = 'Custom';
                    }
                } else if (relType === 'friend') {
                    const role = document.getElementById('relationshipRole')?.value;
                    if (role && role !== 'other') relContext.role = role;
                    else if (role === 'other') {
                        const customRole = document.getElementById('relationshipRoleCustom')?.value?.trim();
                        if (customRole) relContext.role = 'Custom';
                    }
                }
                
                // Ex/Estranged flag (not for friends)
                if (relType !== 'friend' && exRelationshipCheckbox?.checked) {
                    relContext.ex_estranged = true;
                }
                
                // Notes
                const notes = document.getElementById('relationshipNotes')?.value?.trim();
                if (notes) relContext.notes = notes;
                
                formData.relationship_context = relContext;
            }

            if (relocationToggle && relocationToggle.checked) {
                const rawReloc = document.getElementById('relocationCoords').value.trim();
                const parsedReloc = parseLatLonFlexible ? parseLatLonFlexible(rawReloc) : null;
                if (parsedReloc) {
                    formData.relocation = {
                        enabled: true,
                        city: document.getElementById('relocationCity').value.trim(),
                        state: document.getElementById('relocationState').value.trim(),
                        latitude: parsedReloc.lat,
                        longitude: parsedReloc.lon,
                        input: rawReloc,
                        normalized: parsedReloc.normalized,
                        excludePersonB: !(document.getElementById('includePersonBRelocation')?.checked)
                    };
                } else {
                    // Fallback to legacy parseCoordinates if available
                    try {
                        const legacy = parseCoordinates(rawReloc);
                        if (legacy && legacy.latitude !== undefined) {
                            formData.relocation = {
                                enabled: true,
                                city: document.getElementById('relocationCity').value.trim(),
                                state: document.getElementById('relocationState').value.trim(),
                                latitude: legacy.latitude,
                                longitude: legacy.longitude,
                                input: rawReloc,
                                normalized: `${legacy.latitude}, ${legacy.longitude}`,
                                excludePersonB: !(document.getElementById('includePersonBRelocation')?.checked)
                            };
                        } else {
                            formData.relocation = { enabled: true, invalid: true, input: rawReloc };
                        }
                    } catch(e){
                        formData.relocation = { enabled: true, invalid: true, input: rawReloc };
                    }
                }
            } else {
                formData.relocation = { enabled: false };
            }

            const mode = formData.context.mode;
            if (mode === 'natal_transits' || mode === 'synastry_transits' || mode === 'composite_transits') {
                const startDateElement = document.getElementById('transitStartDate');
                const endDateElement = document.getElementById('transitEndDate');
                const stepElement = document.getElementById('transitStep');
                
                console.log('=== FRONTEND TRANSIT DEBUG ===');
                console.log('Transit mode detected:', mode);
                console.log('Start date element:', startDateElement, 'Value:', startDateElement?.value);
                console.log('End date element:', endDateElement, 'Value:', endDateElement?.value);
                console.log('Step element:', stepElement, 'Value:', stepElement?.value);
                
                if (startDateElement && endDateElement && stepElement) {
                    formData.transitParams = {
                        startDate: startDateElement.value,
                        endDate: endDateElement.value,
                        step: stepElement.value
                    };
                    
                    console.log('Transit data added to form:', formData.transitParams);
                } else {
                    console.log('WARNING: Transit elements not found or missing values');
                }
                console.log('=== END FRONTEND TRANSIT DEBUG ===');
            } else if (mode === 'natal_only') {
                console.log('=== NATAL ONLY MODE ===');
                console.log('Skipping transit parameter collection for natal_only mode');
                // No transit parameters needed for natal_only mode
                console.log('=== END NATAL ONLY MODE ===');
            }

            // Relationship role & notes capture
            const roleSel = document.getElementById('relationshipRole');
            const roleCustom = document.getElementById('relationshipRoleCustom');
            const roleVal = roleSel ? (roleSel.value === 'other' ? (roleCustom?.value?.trim() || '') : roleSel.value) : '';
            const notesVal = document.getElementById('relationshipNotes')?.value?.trim() || '';
            // Backward compatibility: normalize 'child' -> 'offspring'
            formData.context.relationship_role = (roleVal === 'child') ? 'offspring' : roleVal;
            formData.context.relationship_notes = notesVal;
            // Mutual exclusivity & cleanup
            const t = formData.context.relationship_type;
            if (t === 'partner') {
                formData.context.relationship_role = null;
            } else {
                formData.context.intimacy_tier = null;
            }
            if (t === 'friend' && formData.context.is_ex_relationship) {
                formData.context.is_ex_relationship = false; // clear ex for friend
            }
            console.log("=== FINAL FORM DATA ===");
            console.log(JSON.stringify(formData, null, 2));
            return formData;
        }

        // --- Save/Load Functions ---

        function saveChartData() {
            try {
                // Collect all form data
                const chartData = {
                    timestamp: new Date().toISOString(),
                    version: "1.0",
                    contextType: currentContextType,
                    personA: {
                        name: document.getElementById('nameA')?.value || '',
                        birth_city: document.getElementById('birth_cityA')?.value || '',
                        birth_state: document.getElementById('birth_stateA')?.value || '',
                        birth_date: document.getElementById('birth_dateA')?.value || '',
                        birth_time: document.getElementById('birth_timeA')?.value || '',
                        birth_country: document.getElementById('birth_countryA')?.value || '',
                        astro: document.getElementById('astroA')?.value || '',
                        offset: document.getElementById('offsetA')?.value || '',
                        zodiac: document.getElementById('zodiacA')?.value || ''
                    },
                    personB: {
                        name: document.getElementById('nameB')?.value || '',
                        birth_city: document.getElementById('birth_cityB')?.value || '',
                        birth_state: document.getElementById('birth_stateB')?.value || '',
                        birth_date: document.getElementById('birth_dateB')?.value || '',
                        birth_time: document.getElementById('birth_timeB')?.value || '',
                        birth_country: document.getElementById('birth_countryB')?.value || '',
                        astro: document.getElementById('astroB')?.value || '',
                        offset: document.getElementById('offsetB')?.value || '',
                        zodiac: document.getElementById('zodiacB')?.value || ''
                    },
                    relationalContext: {
                        relationship_type: document.querySelector('input[name="relationshipType"]:checked')?.value || '',
                        intimacy_tier: document.querySelector('input[name="intimacyTier"]:checked')?.value || '',
                        contact_channel: document.querySelector('input[name="contactChannel"]:checked')?.value || '',
                        relationship_role: document.getElementById('relationshipRole')?.value || '',
                        relationship_role_custom: document.getElementById('relationshipRoleCustom')?.value || '',
                        relationship_notes: document.getElementById('relationshipNotes')?.value || '',
                        is_ex_relationship: document.getElementById('exRelationship')?.checked || false
                    },
                    transitParams: {
                        startDate: document.getElementById('transitStartDate')?.value || '',
                        endDate: document.getElementById('transitEndDate')?.value || '',
                        step: document.getElementById('transitStep')?.value || ''
                    },
                    relocation: {
                        enabled: document.getElementById('relocationToggle')?.checked || false,
                        coords: document.getElementById('relocationCoords')?.value || '',
                        includePersonB: document.getElementById('includePersonBRelocation')?.checked || false
                    },
                    contextMode: {
                        solo: document.querySelector('input[name="soloSubtype"]:checked')?.value || '',
                        relational: document.querySelector('input[name="relationalSubtype"]:checked')?.value || ''
                    }
                };

                // Generate filename with names and timestamp
                const nameA = chartData.personA.name || 'PersonA';
                const nameB = chartData.personB.name || 'PersonB';
                const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                const filename = `chart_${nameA}_${nameB}_${timestamp}.json`;

                // Create and download file
                const dataStr = JSON.stringify(chartData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // Visual feedback
                const saveBtn = document.getElementById('saveDataBtn');
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '✅ Saved!';
                setTimeout(() => { saveBtn.textContent = originalText; }, 2000);

            } catch (error) {
                console.error('Error saving chart data:', error);
                alert('Error saving chart data: ' + error.message);
            }
        }

        function loadChartData(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const chartData = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!chartData.personA || !chartData.personB) {
                        throw new Error('Invalid chart data format');
                    }

                    // Load Person A data
                    if (chartData.personA) {
                        document.getElementById('nameA').value = chartData.personA.name || '';
                        document.getElementById('birth_cityA').value = chartData.personA.birth_city || '';
                        document.getElementById('birth_stateA').value = chartData.personA.birth_state || '';
                        document.getElementById('birth_dateA').value = chartData.personA.birth_date || '';
                        document.getElementById('birth_timeA').value = chartData.personA.birth_time || '';
                        document.getElementById('birth_countryA').value = chartData.personA.birth_country || '';
                        document.getElementById('astroA').value = chartData.personA.astro || '';
                        if (chartData.personA.offset) document.getElementById('offsetA').value = chartData.personA.offset;
                        if (chartData.personA.zodiac) document.getElementById('zodiacA').value = chartData.personA.zodiac;
                    }

                    // Load Person B data
                    if (chartData.personB) {
                        document.getElementById('nameB').value = chartData.personB.name || '';
                        document.getElementById('birth_cityB').value = chartData.personB.birth_city || '';
                        document.getElementById('birth_stateB').value = chartData.personB.birth_state || '';
                        document.getElementById('birth_dateB').value = chartData.personB.birth_date || '';
                        document.getElementById('birth_timeB').value = chartData.personB.birth_time || '';
                        document.getElementById('birth_countryB').value = chartData.personB.birth_country || '';
                        document.getElementById('astroB').value = chartData.personB.astro || '';
                        if (chartData.personB.offset) document.getElementById('offsetB').value = chartData.personB.offset;
                        if (chartData.personB.zodiac) document.getElementById('zodiacB').value = chartData.personB.zodiac;
                    }

                    // Load context type
                    if (chartData.contextType) {
                        const contextRadio = document.querySelector(`input[name="contextType"][value="${chartData.contextType}"]`);
                        if (contextRadio) {
                            contextRadio.checked = true;
                            updateContextType(chartData.contextType);
                        }
                    }

                    // Load relational context
                    if (chartData.relationalContext) {
                        const rel = chartData.relationalContext;
                        if (rel.relationship_type) {
                            const typeRadio = document.querySelector(`input[name="relationshipType"][value="${rel.relationship_type}"]`);
                            if (typeRadio) {
                                typeRadio.checked = true;
                                typeRadio.dispatchEvent(new Event('change'));
                            }
                        }
                        if (rel.intimacy_tier) {
                            const tierRadio = document.querySelector(`input[name="intimacyTier"][value="${rel.intimacy_tier}"]`);
                            if (tierRadio) tierRadio.checked = true;
                        }
                        if (rel.contact_channel) {
                            const channelRadio = document.querySelector(`input[name="contactChannel"][value="${rel.contact_channel}"]`);
                            if (channelRadio) channelRadio.checked = true;
                        }
                        if (rel.relationship_role) {
                            const roleSelect = document.getElementById('relationshipRole');
                            if (roleSelect) roleSelect.value = rel.relationship_role;
                        }
                        if (rel.relationship_role_custom) {
                            document.getElementById('relationshipRoleCustom').value = rel.relationship_role_custom;
                        }
                        if (rel.relationship_notes) {
                            document.getElementById('relationshipNotes').value = rel.relationship_notes;
                        }
                        if (rel.is_ex_relationship) {
                            document.getElementById('exRelationship').checked = rel.is_ex_relationship;
                        }
                    }

                    // Load transit params
                    if (chartData.transitParams) {
                        const trans = chartData.transitParams;
                        if (trans.startDate) document.getElementById('transitStartDate').value = trans.startDate;
                        if (trans.endDate) document.getElementById('transitEndDate').value = trans.endDate;
                        if (trans.step) document.getElementById('transitStep').value = trans.step;
                    }

                    // Load relocation
                    if (chartData.relocation) {
                        const reloc = chartData.relocation;
                        if (reloc.enabled) document.getElementById('relocationToggle').checked = true;
                        if (reloc.coords) document.getElementById('relocationCoords').value = reloc.coords;
                        if (reloc.includePersonB) document.getElementById('includePersonBRelocation').checked = true;
                    }

                    // Trigger relational context visibility check
                    if (window.evaluateRelationalContextVisibility) {
                        setTimeout(window.evaluateRelationalContextVisibility, 100);
                    }

                    // Visual feedback
                    const loadBtn = document.getElementById('loadDataBtn');
                    const originalText = loadBtn.textContent;
                    loadBtn.textContent = '✅ Loaded!';
                    setTimeout(() => { loadBtn.textContent = originalText; }, 2000);

                } catch (error) {
                    console.error('Error loading chart data:', error);
                    alert('Error loading chart data: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // --- API Call ---

        async function generateReport() {
            totalRowCount = 0; // Reset counter for each report
            WovenMapConfig.debugLog("Generate button clicked");
            
            if (!validateForm()) {
                return;
            }

            WovenMapConfig.debugLog("Form is valid, preparing API request");
            hideError();
            generateBtn.disabled = true;
            loadingIndicator.classList.remove('hidden');
            reportOutput.classList.add('hidden');
            // Hide report action buttons when starting new generation
            document.getElementById('copyReport').classList.add('hidden');
            document.getElementById('downloadReport').classList.add('hidden');

            try {
                const formData = collectFormData();
                
                // Log the complete data being sent to API
                console.log("=== SENDING TO API ===");
                console.log("Full form data:", JSON.stringify(formData, null, 2));
                console.log("PersonA structure:", JSON.stringify(formData.personA, null, 2));
                WovenMapConfig.debugLog("Sending data to API", formData);
                
                // Double-check required fields using configuration
                const requiredFields = WovenMapConfig.validation.requiredFields.person;
                const missingFields = requiredFields.filter(field => {
                    const value = formData.personA[field];
                    return value === undefined || value === null || value === "";
                });
                
                if (missingFields.length > 0) {
                    throw new Error(`Missing required fields for Person A: ${missingFields.join(', ')}`);
                }
                
                const apiEndpoint = WovenMapConfig.getApiEndpoint('astrologyMathBrain');
                WovenMapConfig.debugLog(`Sending API request to ${apiEndpoint}`);
                
                // --- Robust fetch with AbortController (native fetch ignores custom timeout property) ---
                const timeoutMs = (WovenMapConfig?.api?.timeout && Number.isFinite(+WovenMapConfig.api.timeout)) ? +WovenMapConfig.api.timeout : 30000;
                const controller = new AbortController();
                const timeoutHandle = setTimeout(() => {
                    controller.abort();
                }, timeoutMs);

                let response;
                try {
                    response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(formData),
                        signal: controller.signal
                    });
                } catch (fetchErr) {
                    if (fetchErr.name === 'AbortError') {
                        throw new Error(`Request timed out after ${Math.round(timeoutMs/1000)}s (network slow or server overloaded)`);
                    }
                    throw fetchErr;
                } finally {
                    clearTimeout(timeoutHandle);
                }

                if (!response.ok) {
                    const errorBody = await response.text();
                    let errorMessage = `HTTP error! status: ${response.status}`;
                    try {
                        // Try to parse as JSON to get a more specific error message
                        const errorJson = JSON.parse(errorBody);
                        if (errorJson.error) {
                           errorMessage += ` - ${errorJson.error}`;
                           if(errorJson.missing) {
                             errorMessage += ` (Missing: ${errorJson.missing.join(', ')})`;
                           }
                        } else {
                           errorMessage += ` - ${errorBody}`;
                        }
                    } catch (e) {
                        // If not JSON, just use the text body
                        errorMessage += ` - ${errorBody}`;
                    }
                    throw new Error(errorMessage);
                }

                let result;
                try {
                    result = await response.json();
                } catch (parseErr) {
                    throw new Error('Failed to parse JSON response from server');
                }
                if (result.error) {
                    throw new Error(result.error);
                }

                // --- Shape Harmonization Shim ---
                (function harmonizeResultShape(r){
                    try {
                        // Synastry: ensure r.synastry.aspects present if nested chart form used
                        if (r.synastry && !r.synastry.aspects && r.synastry.chart?.aspects && Array.isArray(r.synastry.chart.aspects)) {
                            r.synastry.aspects = r.synastry.chart.aspects;
                        }
                        // Composite: some earlier frontend code expects composite.chart.* already; if only composite.aspects given, wrap
                        if (r.composite && !r.composite.chart && r.composite.aspects) {
                            r.composite.chart = { aspects: r.composite.aspects };
                        }
                        // Transit containers: normalize transitsByDate key if only transits present & shaped as date map
                        const maybePromote = (chartObj) => {
                            if (!chartObj || chartObj.transitsByDate) return;
                            if (chartObj.transits && !Array.isArray(chartObj.transits)) {
                                // Heuristic: if it's an object whose keys look like YYYY-MM-DD
                                const keys = Object.keys(chartObj.transits || {});
                                if (keys.length && keys.every(k => /^\d{4}-\d{2}-\d{2}$/.test(k))) {
                                    chartObj.transitsByDate = chartObj.transits; // promote
                                }
                            }
                        };
                        if (r.person_a?.chart) maybePromote(r.person_a.chart);
                        if (r.person_b?.chart) maybePromote(r.person_b.chart);
                        if (r.synastry) maybePromote(r.synastry); // in case synastry transits delivered similarly
                        if (r.composite) maybePromote(r.composite);
                    } catch (e) {
                        console.warn('Shape harmonization encountered an issue:', e);
                    }
                })(result);

                // Store result data for downloads
                latestResultData = result;

                // Generate human-readable Markdown report
                const report = generateMarkdownReport(result);
                
                // Debug: Log the actual data structure to understand transit availability
                console.log('=== DEBUGGING TRANSIT DATA ===');
                console.log('Full result structure:', Object.keys(result));
                if (result.person_a?.chart) {
                    console.log('Person A chart keys:', Object.keys(result.person_a.chart));
                    console.log('Person A has transits?', !!result.person_a.chart.transits);
                    console.log('Person A has transitsByDate?', !!result.person_a.chart.transitsByDate);
                    if (result.person_a.chart.transits) {
                        console.log('Person A transits sample:', result.person_a.chart.transits.slice(0, 2));
                    }
                }
                if (result.synastry) {
                    console.log('Synastry keys:', Object.keys(result.synastry));
                    console.log('Synastry has transits?', !!result.synastry.transits);
                    console.log('Synastry has transitsByDate?', !!result.synastry.transitsByDate);
                }
                console.log('=== END TRANSIT DEBUG ===');
                
                reportContent.textContent = report;
                reportOutput.classList.remove('hidden');
                
                // Show copy and download report buttons when report is generated
                document.getElementById('copyReport').classList.remove('hidden');
                document.getElementById('downloadReport').classList.remove('hidden');

            } catch (error) {
                console.error('Error generating report:', error);
                showError(`Failed to generate report: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
                loadingIndicator.classList.add('hidden');
            }
        }

        // --- Event Listeners & UI Updates ---

        function setupEventListeners() {
            // Main button
            generateBtn.addEventListener('click', generateReport);

            // Save/Load buttons
            document.getElementById('saveDataBtn').addEventListener('click', saveChartData);
            document.getElementById('loadDataBtn').addEventListener('click', () => {
                document.getElementById('loadDataInput').click();
            });
            document.getElementById('loadDataInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadChartData(e.target.files[0]);
                }
            });

            // Modal
            mathBrainInfoBtn.addEventListener('click', () => mathBrainModal.classList.remove('hidden'));
            closeMathBrainModal.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            closeMathBrainModalBottom.addEventListener('click', () => mathBrainModal.classList.add('hidden'));
            mathBrainModal.addEventListener('click', (e) => {
                if (e.target === mathBrainModal) mathBrainModal.classList.add('hidden');
            });

            // Copy report
            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(reportContent.textContent);
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => { copyBtn.textContent = '📋 Copy Report'; }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            // Download report as markdown file
            document.getElementById('downloadReport').addEventListener('click', () => {
                if (!reportContent.textContent) {
                    showError('No report available for download. Please generate a report first.');
                    return;
                }
                try {
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    const person1Name = document.getElementById('person1-name').value || 'Person1';
                    const person2Name = document.getElementById('person2-name').value;
                    
                    let filename;
                    if (person2Name) {
                        filename = `report_${person1Name}_${person2Name}_${timestamp}.md`;
                    } else {
                        filename = `report_${person1Name}_${timestamp}.md`;
                    }
                    
                    const blob = new Blob([reportContent.textContent], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Brief visual feedback
                    const btn = document.getElementById('downloadReport');
                    btn.textContent = '✅ Downloaded!';
                    setTimeout(() => { btn.textContent = '📄 Download Report (.md)'; }, 2000);
                    
                    logger.info('Report downloaded', { filename, size: reportContent.textContent.length });
                } catch (err) {
                    console.error('Failed to download report: ', err);
                    showError('Failed to download report. Please try again.');
                }
            });

            // Download Markdown
            downloadMarkdownBtn.addEventListener('click', () => {
                if (!latestResultData) {
                    showError('No data available for download. Please generate a report first.');
                    return;
                }
                try {
                    const markdownContent = generateMarkdownReport(latestResultData);
                    const filename = generateFilename('md', latestResultData);
                    downloadFile(markdownContent, filename, 'text/markdown');
                    
                    // Brief visual feedback
                    downloadMarkdownBtn.textContent = '✅ Saved!';
                    setTimeout(() => { downloadMarkdownBtn.textContent = '📄 Save Chart Data'; }, 2000);
                } catch (error) {
                    console.error('Download error:', error);
                    showError('Failed to generate markdown download: ' + error.message);
                }
            });

            // Toggle mode help panel
            toggleModeHelp.addEventListener('click', () => {
                const isHidden = modeHelpPanel.classList.contains('hidden');
                modeHelpPanel.classList.toggle('hidden');
                toggleModeHelp.textContent = isHidden ? '🧭 Hide mode guide' : '🧭 What does each mode do?';
            });

            // Prefill today's date for transit dates
            prefillTodayBtn.addEventListener('click', prefillTodayDates);
                // Simple Mode: filter controls suppressed (defaults applied globally)

            // Toggle step size help panel
            stepSizeHelpBtn.addEventListener('click', () => {
                const isHidden = stepSizeHelpPanel.classList.contains('hidden');
                stepSizeHelpPanel.classList.toggle('hidden');
                stepSizeHelpBtn.textContent = isHidden ? '❓ Hide explanation' : '❓ What does this do?';
            });

            // Context mode switching
            document.querySelectorAll('input[name="contextMode"]').forEach(radio => {
                radio.addEventListener('change', updateFormUI);
            });

            // Relocation toggle
            relocationToggle.addEventListener('change', () => {
                relocationFields.classList.toggle('hidden', !relocationToggle.checked);
                updateRelocationPersonBOption();
            });

            // Relational context visibility refinement:
            // Show immediately when relational context type selected. If user returns to solo/weather, hide.
            // While still in relational context, do NOT auto-hide just because Person B fields are blank.
            const personBInputs = ['nameB', 'birth_cityB', 'birth_stateB', 'birth_dateB', 'birth_timeB', 'birth_countryB', 'astroB'];
            function evaluateRelationalContextVisibility(){
                const anyFilled = personBInputs.some(id => document.getElementById(id).value.trim() !== '');
                const relContextSection = document.getElementById('relational-context-section');
                const isPersonBExpanded = document.getElementById('personB-toggle')?.getAttribute('aria-expanded') === 'true';
                console.log('[REL VIS] anyFilled:', anyFilled, 'currentContextType:', currentContextType, 'personBExpanded:', isPersonBExpanded);
                
                // Show relational context if:
                // 1. We're in relational mode, OR
                // 2. Person B section is expanded, OR  
                // 3. Any Person B field has data
                const shouldShow = currentContextType === 'relational' || isPersonBExpanded || anyFilled;
                
                console.log('[REL VIS] shouldShow:', shouldShow, 'reasons:', {
                    relationalMode: currentContextType === 'relational',
                    personBExpanded: isPersonBExpanded, 
                    personBData: anyFilled
                });
                
                if (relContextSection) {
                    const wasHidden = relContextSection.classList.contains('hidden');
                    if (shouldShow) {
                        relContextSection.classList.remove('hidden');
                        console.log('[REL VIS] Showing relational context - reason:', 
                            currentContextType === 'relational' ? 'relational mode' : 
                            isPersonBExpanded ? 'Person B expanded' : 'Person B data entered');
                        if (wasHidden) {
                            console.log('[REL VIS] ✅ Context section was hidden, now shown');
                        }
                    } else {
                        relContextSection.classList.add('hidden');
                        console.log('[REL VIS] ❌ Hiding relational context section');
                    }
                } else {
                    console.error('[REL VIS] ⚠️ relational-context-section element not found!');
                }
            }
            // Make function globally accessible
            window.evaluateRelationalContextVisibility = evaluateRelationalContextVisibility;
            
            personBInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', evaluateRelationalContextVisibility);
            });
            // Initial evaluation
            evaluateRelationalContextVisibility();
            
            // Intimacy tier visibility
            function resetRelationalStateFor(type){
                const roleSelect = document.getElementById('relationshipRole');
                const customRoleInput = document.getElementById('relationshipRoleCustom');
                const roleBlock = document.getElementById('relationship-role-block');
                const exRow = document.getElementById('exRelationshipRow');
                const exCb = document.getElementById('exRelationship');
                // Clear any custom visibility
                if (type === 'partner') {
                    if (roleSelect) roleSelect.value='';
                    if (customRoleInput) { customRoleInput.value=''; customRoleInput.classList.add('hidden'); }
                } else { // leaving partner
                    document.querySelectorAll('input[name="intimacyTier"]').forEach(r=> r.checked=false);
                }
                // Hide ex for friend
                if (exRow && exCb) {
                    const hideEx = type === 'friend';
                    exRow.classList.toggle('hidden', hideEx);
                    if (hideEx) exCb.checked = false;
                }
                // Focus first interactive element for accessibility
                if (type === 'partner') {
                    const firstTier = document.querySelector('input[name="intimacyTier"]');
                    firstTier && firstTier.focus();
                } else if (roleBlock && !roleBlock.classList.contains('hidden')) {
                    const firstRole = document.getElementById('relationshipRole');
                    firstRole && firstRole.focus();
                }
            }

            document.querySelectorAll('input[name="relationshipType"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    const relationshipType = document.querySelector('input[name="relationshipType"]:checked')?.value;
                    console.log('[REL TYPE] Changed to:', relationshipType);
                    if (!relationshipType) return;
                    const isPartner = relationshipType === 'partner';
                    if (intimacyTierDropdown) {
                        intimacyTierDropdown.classList.toggle('hidden', !isPartner);
                        if (!isPartner) {
                            // Clear any previously selected intimacy tiers when leaving partner
                            document.querySelectorAll('input[name="intimacyTier"]').forEach(r=> r.checked=false);
                        }
                    }
                    const roleBlock = document.getElementById('relationship-role-block');
                    const roleSelect = document.getElementById('relationshipRole');
                    const roleCustom = document.getElementById('relationshipRoleCustom');
                    if (roleBlock && roleSelect) {
                        roleSelect.innerHTML = '';
                        if (relationshipType === 'family') {
                            roleBlock.classList.remove('hidden');
                            const familyOptions = [
                                {v:'', l:'Select role (required)'}, 
                                {v:'parent', l:'Parent'}, 
                                {v:'offspring', l:'Offspring'}, 
                                {v:'sibling', l:'Sibling'}, 
                                {v:'cousin', l:'Cousin'}, 
                                {v:'extended', l:'Extended family'}, 
                                {v:'guardian', l:'Guardian'}, 
                                {v:'mentor', l:'Mentor'}, 
                                {v:'other', l:'Other / Custom'}
                            ];
                            familyOptions.forEach(o=>{ const opt=document.createElement('option'); opt.value=o.v; opt.textContent=o.l; roleSelect.appendChild(opt); });
                        } else if (relationshipType === 'friend') {
                            roleBlock.classList.remove('hidden');
                            const friendOptions = [
                                {v:'', l:'(optional)'}, 
                                {v:'acquaintance', l:'Acquaintance'}, 
                                {v:'mentor', l:'Mentor'}, 
                                {v:'other', l:'Other / Custom'}
                            ];
                            friendOptions.forEach(o=>{ const opt=document.createElement('option'); opt.value=o.v; opt.textContent=o.l; roleSelect.appendChild(opt); });
                        } else {
                            roleBlock.classList.add('hidden');
                        }
                        if (roleCustom) roleCustom.classList.add('hidden');
                    }
                    resetRelationalStateFor(relationshipType);
                });
            });
        }

        // =============================================================================
        // NEW UX IMPROVEMENT FUNCTIONS
        // =============================================================================
        
        // Global state for the app mode
        let currentAppMode = 'mirror'; // 'mirror' or 'geometry'
        let currentContextType = 'solo'; // 'solo', 'relational', 'weather'
        
        function updateAppMode(mode) {
            currentAppMode = mode;
            
            // Update tab appearance
            const mirrorTab = document.getElementById('mirrorModeTab');
            const geometryTab = document.getElementById('geometryModeTab');
            const modeDescription = document.getElementById('modeDescription');
            const generateBtn = document.getElementById('generateReport');
            const showWiringBtn = document.getElementById('showWiringBtn');
            
            if (mode === 'mirror') {
                mirrorTab.classList.add('bg-teal-600', 'text-white');
                mirrorTab.classList.remove('text-gray-300');
                mirrorTab.setAttribute('aria-selected', 'true');
                
                geometryTab.classList.remove('bg-teal-600', 'text-white');
                geometryTab.classList.add('text-gray-300');
                geometryTab.setAttribute('aria-selected', 'false');
                
                modeDescription.innerHTML = '<strong class="text-teal-300">Mirror:</strong> The land seen in reflection—how the shapes form an image when charts touch. The water shows what appears when two paths meet.';
                generateBtn.textContent = 'Get My Mirror';
                showWiringBtn.style.display = 'inline';
                
                // Auto-populate today's date in Mirror mode
                autoPopulateTodayDates();
                
            } else if (mode === 'geometry') {
                geometryTab.classList.add('bg-teal-600', 'text-white');
                geometryTab.classList.remove('text-gray-300');
                geometryTab.setAttribute('aria-selected', 'true');
                
                mirrorTab.classList.remove('bg-teal-600', 'text-white');
                mirrorTab.classList.add('text-gray-300');
                mirrorTab.setAttribute('aria-selected', 'false');
                
                modeDescription.innerHTML = '<strong class="text-teal-300">Geometry:</strong> The skeleton of the land—numbers, distances, angles. Silent and exact, measuring rods and compass marks.';
                generateBtn.textContent = 'Compute Geometry';
                showWiringBtn.style.display = 'none';
                
                // Show advanced options in Geometry mode
                showAdvancedTransitOptions();
            }
            
            updateUIBasedOnMode();
        }
        
        function updateContextType(contextType) {
            currentContextType = contextType;
            console.log('[CTX] Switching contextType ->', contextType);
            
            // Update the legacy context mode for compatibility
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (contextType === 'solo') {
                hidePersonBSection();
                hideRelationalSubtypes();
                hideRelationalContext();
                showSoloSubtypes();
                // Default to current solo subtype or natal_transits
                const soloSubtype = document.querySelector('input[name="soloSubtype"]:checked')?.value || 'natal_transits';
                updateSoloSubtype(soloSubtype);
            } else if (contextType === 'relational') {
                showPersonBSection();
                showRelationalSubtypes();
                showRelationalContext(); // ensure visible
                const rcs = document.getElementById('relational-context-section');
                if (rcs && rcs.classList.contains('hidden')) {
                    console.warn('[CTX] Relational context was hidden unexpectedly; forcing show.');
                    rcs.classList.remove('hidden');
                }
                hideSoloSubtypes();
                // Default to composite for relational
                const relationalSubtype = document.querySelector('input[name="relationalSubtype"]:checked')?.value || 'composite';
                updateRelationalSubtype(relationalSubtype);
                
                // Evaluate relational context visibility after switching
                if (window.evaluateRelationalContextVisibility) {
                    setTimeout(window.evaluateRelationalContextVisibility, 100);
                }
            } else if (contextType === 'weather') {
                // Weather only mode - hide person sections
                hidePersonBSection();
                hideRelationalSubtypes();
                hideSoloSubtypes();
                hideRelationalContext();
                // Set to transit-only mode
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_transits'; // Use natal_transits but hide person data
                });
            }
            
            updateFormUI();
        }
        
        function updateSoloSubtype(subtype) {
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (subtype === 'natal_only') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_only';
                });
            } else if (subtype === 'natal_transits') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'natal_transits';
                });
            }
            
            updateFormUI();
        }
        
        function updateRelationalSubtype(subtype) {
            const contextModeInputs = document.querySelectorAll('input[name="contextMode"]');
            
            if (subtype === 'synastry') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'synastry_transits';
                });
            } else if (subtype === 'composite') {
                contextModeInputs.forEach(input => {
                    input.checked = input.value === 'composite_transits';
                });
            }
            
            updateFormUI();
        }
        
        function showPersonBSection() {
            const personBToggle = document.getElementById('personB-toggle');
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            
            if (personBToggle && personBDetails) {
                personBToggle.setAttribute('aria-expanded', 'true');
                personBDetails.classList.remove('hidden');
                if (personBChevron) {
                    personBChevron.classList.add('rotate-180');
                }
            }
        }
        
        function hidePersonBSection() {
            const personBToggle = document.getElementById('personB-toggle');
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            
            if (personBToggle && personBDetails) {
                personBToggle.setAttribute('aria-expanded', 'false');
                personBDetails.classList.add('hidden');
                if (personBChevron) {
                    personBChevron.classList.remove('rotate-180');
                }
            }
        }
        
        function showSoloSubtypes() {
            const soloSubtypes = document.getElementById('solo-subtypes');
            if (soloSubtypes) {
                soloSubtypes.classList.remove('hidden');
            }
        }
        
        function hideSoloSubtypes() {
            const soloSubtypes = document.getElementById('solo-subtypes');
            if (soloSubtypes) {
                soloSubtypes.classList.add('hidden');
            }
        }
        
        function showRelationalSubtypes() {
            const relationalSubtypes = document.getElementById('relational-subtypes');
            if (relationalSubtypes) {
                relationalSubtypes.classList.remove('hidden');
            }
        }
        
        function hideRelationalSubtypes() {
            const relationalSubtypes = document.getElementById('relational-subtypes');
            if (relationalSubtypes) {
                relationalSubtypes.classList.add('hidden');
            }
        }
        
        function showRelationalContext() {
            const relationalContext = document.getElementById('relational-context-section');
            if (relationalContext) {
                relationalContext.classList.remove('hidden');
            }
        }
        
        function hideRelationalContext() {
            const relationalContext = document.getElementById('relational-context-section');
            if (relationalContext) {
                relationalContext.classList.add('hidden');
            }
        }
        
        function autoPopulateTodayDates() {
            const todayStr = getTodayDateString();
            const startDate = document.getElementById('transitStartDate');
            const endDate = document.getElementById('transitEndDate');
            
            if (startDate && endDate) {
                // Only auto-populate if fields are empty
                if (!startDate.value) startDate.value = todayStr;
                if (!endDate.value) endDate.value = todayStr;
            }
        }
        
        function showAdvancedTransitOptions() {
            const advancedOptions = document.getElementById('advanced-transit-options');
            if (advancedOptions) {
                advancedOptions.classList.remove('hidden');
            }
        }
        
        function hideAdvancedTransitOptions() {
            const advancedOptions = document.getElementById('advanced-transit-options');
            if (advancedOptions) {
                advancedOptions.classList.add('hidden');
            }
        }
        
        function updateUIBasedOnMode() {
            const mathBrainBanner = document.querySelector('#context-options .bg-yellow-900');
            
            if (currentAppMode === 'mirror') {
                // Hide Math Brain banner in Mirror mode
                if (mathBrainBanner) {
                    mathBrainBanner.style.display = 'none';
                }
                hideAdvancedTransitOptions();
            } else if (currentAppMode === 'geometry') {
                // Show Math Brain banner in Geometry mode
                if (mathBrainBanner) {
                    mathBrainBanner.style.display = 'block';
                }
                showAdvancedTransitOptions();
            }
        }
        
        function togglePersonB() {
            const personBDetails = document.getElementById('personB-details');
            const personBChevron = document.getElementById('personB-chevron');
            const personBToggle = document.getElementById('personB-toggle');
            
            if (personBDetails && personBChevron && personBToggle) {
                const isExpanded = personBToggle.getAttribute('aria-expanded') === 'true';
                
                personBToggle.setAttribute('aria-expanded', !isExpanded);
                personBDetails.classList.toggle('hidden');
                personBChevron.classList.toggle('rotate-180');
                
                // If expanding and we're in solo mode, switch to relational
                if (!isExpanded && currentContextType === 'solo') {
                    const relationalRadio = document.querySelector('input[name="contextType"][value="relational"]');
                    if (relationalRadio) {
                        relationalRadio.checked = true;
                        updateContextType('relational');
                    }
                }
                
                // Show relationship context when Person B is expanded in any relational mode
                if (!isExpanded && (currentContextType === 'relational' || 
                    ['synastry_transits', 'composite_transits'].includes(document.querySelector('input[name="contextMode"]:checked')?.value))) {
                    showRelationalContext();
                }
                
                // Update form UI to enable/disable Person B based on expansion state
                updateFormUI();
                
                // Evaluate relational context visibility when Person B is toggled
                setTimeout(() => {
                    const evaluateFunc = window.evaluateRelationalContextVisibility;
                    if (evaluateFunc) evaluateFunc();
                }, 50);
            }
        }
        
        function toggleRelocation() {
            const relocationDetails = document.getElementById('relocation-details');
            const relocationChevron = document.getElementById('relocation-chevron');
            const relocationToggle = document.getElementById('relocationToggle');
            const relocationHeader = document.getElementById('relocation-toggle-header');
            
            if (relocationDetails && relocationChevron && relocationHeader) {
                const isExpanded = relocationHeader.getAttribute('aria-expanded') === 'true';
                
                relocationHeader.setAttribute('aria-expanded', !isExpanded);
                relocationDetails.classList.toggle('hidden');
                relocationChevron.classList.toggle('rotate-180');
                
                // Also toggle the checkbox
                if (relocationToggle) {
                    relocationToggle.checked = !isExpanded;
                }
            }
        }
        
        function setupProgressiveDisclosureEventListeners() {
            // Mirror/Geometry tabs
            const mirrorTab = document.getElementById('mirrorModeTab');
            const geometryTab = document.getElementById('geometryModeTab');
            
            if (mirrorTab) {
                mirrorTab.addEventListener('click', () => updateAppMode('mirror'));
            }
            if (geometryTab) {
                geometryTab.addEventListener('click', () => updateAppMode('geometry'));
            }
            
            // Context type selection
            document.querySelectorAll('input[name="contextType"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateContextType(e.target.value));
            });
            
            // Solo subtypes
            document.querySelectorAll('input[name="soloSubtype"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateSoloSubtype(e.target.value));
            });
            
            // Relational subtypes
            document.querySelectorAll('input[name="relationalSubtype"]').forEach(radio => {
                radio.addEventListener('change', (e) => updateRelationalSubtype(e.target.value));
            });
            
            // Person B toggle
            const personBToggle = document.getElementById('personB-toggle');
            if (personBToggle) {
                personBToggle.addEventListener('click', togglePersonB);
                personBToggle.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        togglePersonB();
                    }
                });
            }
            
            // Relocation toggle
            const relocationHeader = document.getElementById('relocation-toggle-header');
            if (relocationHeader) {
                relocationHeader.addEventListener('click', toggleRelocation);
                relocationHeader.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleRelocation();
                    }
                });
            }
            const relocationToggleElInline = document.getElementById('relocationToggle');
            if (relocationToggleElInline){
                relocationToggleElInline.addEventListener('change', updateRelocationNote);
            }
            
            // Today default button
            const todayDefaultBtn = document.getElementById('todayDefault');
            if (todayDefaultBtn) {
                todayDefaultBtn.addEventListener('click', () => {
                    const todayStr = getTodayDateString();
                    document.getElementById('transitStartDate').value = todayStr;
                    document.getElementById('transitEndDate').value = todayStr;
                    
                    // Visual feedback
                    todayDefaultBtn.textContent = '✅ Set to Today';
                    setTimeout(() => {
                        todayDefaultBtn.textContent = '📅 Use Today';
                    }, 2000);
                });
            }
            
            // Expand transit options button
            const expandTransitBtn = document.getElementById('expandTransitOptions');
            if (expandTransitBtn) {
                expandTransitBtn.addEventListener('click', () => {
                    const advancedOptions = document.getElementById('advanced-transit-options');
                    if (advancedOptions) {
                        const isHidden = advancedOptions.classList.contains('hidden');
                        advancedOptions.classList.toggle('hidden');
                        expandTransitBtn.textContent = isHidden ? '⚙️ Hide Options' : '⚙️ More Options';
                    }
                });
            }
            
            // Context help toggle
            const contextHelpBtn = document.getElementById('context-help-btn');
            const contextHelpPanel = document.getElementById('context-help-panel');
            if (contextHelpBtn && contextHelpPanel) {
                contextHelpBtn.addEventListener('click', () => {
                    const isHidden = contextHelpPanel.classList.contains('hidden');
                    contextHelpPanel.classList.toggle('hidden');
                    contextHelpBtn.textContent = isHidden ? '🧭 Hide Guide' : '🧭 Context Guide';
                });
            }
            
            // Show Wiring button (scroll to geometry section)
            const showWiringBtn = document.getElementById('showWiringBtn');
            if (showWiringBtn) {
                showWiringBtn.addEventListener('click', () => {
                    // Switch to geometry mode and scroll to report section
                    updateAppMode('geometry');
                    
                    // Scroll to report section if it exists
                    const reportSection = document.getElementById('reportOutput');
                    if (reportSection && !reportSection.classList.contains('hidden')) {
                        reportSection.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }
        }
        
        // =============================================================================
        // END NEW UX IMPROVEMENT FUNCTIONS
        // =============================================================================

        // ---------- Relocation Defaults & Persistence (Panama City baseline) ----------
        const DEFAULT_RELOC = { city: 'Panama City', state: 'FL', coords: "30°10'N, 85°40'W" };
        const RELOC_PREF_KEY = 'wm_pref_default_reloc_enabled';
        const DMS_RE = /^\s*([0-9]{1,3})\s*[°]?\s*([0-9]{1,2})?\s*['′]?\s*([0-9]{1,2}(?:\.\d+)?)?\s*([NnSs])\s*,?\s*([0-9]{1,3})\s*[°]?\s*([0-9]{1,2})?\s*['′]?\s*([0-9]{1,2}(?:\.\d+)?)?\s*([EeWw])\s*$/;
        const DEC_RE = /^\s*(-?\d{1,3}(?:\.\d+)?)\s*,\s*(-?\d{1,3}(?:\.\d+)?)\s*$/;
        function dmsToDec(d,m,s,h){const sign=/[SsWw]/.test(h)?-1:1;return sign*(+d+(+(m||0))/60+(+(s||0))/3600);}        
        function parseLatLonFlexible(input){
            if(!input) return null;
            const m1 = DEC_RE.exec(input); if(m1){ const lat=+m1[1], lon=+m1[2];
                return (isFinite(lat)&&isFinite(lon)&&Math.abs(lat)<=90&&Math.abs(lon)<=180)
                  ? {lat, lon, normalized:`${lat.toFixed(6)}, ${lon.toFixed(6)}`} : null; }
            const cleaned = input.replace(/°|º/g,'°').replace(/’|′/g,"'");
            const m2 = DMS_RE.exec(cleaned); if(m2){ const lat=dmsToDec(m2[1],m2[2],m2[3],m2[4]); const lon=dmsToDec(m2[5],m2[6],m2[7],m2[8]);
                return (isFinite(lat)&&isFinite(lon)) ? {lat, lon, normalized:`${lat.toFixed(6)}, ${lon.toFixed(6)}`} : null; }
            return null;
        }
        function attachCoordValidator(inputId, hintId){
            const el=document.getElementById(inputId), hint=document.getElementById(hintId);
            if(!el||!hint) return; 
            el.addEventListener('blur', ()=>{ const v=el.value.trim(); if(!v){ hint.textContent=''; hint.className='mt-1 text-xs'; return; }
                const ok=parseLatLonFlexible(v); if(ok){ hint.textContent=`✓ Normalized: ${ok.normalized}`; hint.className='mt-1 text-xs text-teal-300'; }
                else { hint.textContent='Invalid. Use "lat, lon" (e.g., 30.1667, -85.6667) or DMS (30°10\'N, 85°40\'W).'; hint.className='mt-1 text-xs text-red-400'; }
            });
        }
        function applyRelocDefaults(openSection=true){
            const t=document.getElementById('relocationToggle');
            const city=document.getElementById('relocationCity');
            const st=document.getElementById('relocationState');
            const c=document.getElementById('relocationCoords');
            if(!t||!city||!st||!c) return; 
            city.value=DEFAULT_RELOC.city; st.value=DEFAULT_RELOC.state; c.value=DEFAULT_RELOC.coords; t.checked=true;
            if(openSection){
                document.getElementById('relocation-details')?.classList.remove('hidden');
                document.getElementById('relocation-toggle-header')?.setAttribute('aria-expanded','true');
            }
            c.dispatchEvent(new Event('blur'));
            updateRelocationNote();
        }
        function wireUseDefaultRelocButton(){
            const btn=document.getElementById('useDefaultRelocation');
            if(!btn) return; btn.addEventListener('click', ()=> applyRelocDefaults(true));
        }
        function loadRelocPref(){ return localStorage.getItem(RELOC_PREF_KEY)==='1'; }
        function saveRelocPref(v){ localStorage.setItem(RELOC_PREF_KEY, v?'1':'0'); }
        function updateRelocationNote(){
            const note = document.getElementById('relocation-default-note');
            const toggle = document.getElementById('relocationToggle');
            if(!note || !toggle) return;
            if(toggle.checked){
                note.textContent = 'Relocation overlay ACTIVE using current values (modify city/coords as needed).';
                note.className='mb-4 text-xs text-teal-300';
            } else {
                note.textContent = "Panama City, FL (30°10'N, 85°40'W) is pre-filled as a suggested relocation reference. It is NOT applied until you enable the checkbox.";
                note.className='mb-4 text-xs text-gray-500 italic';
            }
        }


        function updateFormUI() {
            const mode = document.querySelector('input[name="contextMode"]:checked').value;
            console.log('[UPDATE UI] Current mode:', mode);

            const isNatalOnly = mode === 'natal_only';
            const isNatal = mode === 'natal_transits';
            const isSynastryTransits = mode === 'synastry_transits';
            const isCompositeTransits = mode === 'composite_transits';
            
            console.log('[UPDATE UI] Mode analysis:', { isNatalOnly, isNatal, isSynastryTransits, isCompositeTransits });
            
            // Person B should be enabled for relational context OR when manually expanded
            const isRelationalContext = currentContextType === 'relational';
            const isPersonBExpanded = document.getElementById('personB-toggle')?.getAttribute('aria-expanded') === 'true';
            const showPersonB = isRelationalContext || isPersonBExpanded || (!isNatalOnly && !isNatal);
            // Visual dim only when not active; keep header clickable to allow expansion
            personBCard.style.opacity = showPersonB ? '1' : '0.5';
            // Never fully disable pointer events on the whole card (so header can always be clicked)
            personBCard.style.pointerEvents = 'auto';
            // Instead, disable the form controls inside when not active
            const personBInputs = personBCard.querySelectorAll('input, select, button:not(#personB-toggle)');
            personBInputs.forEach(el => {
                if (el.id === 'personB-toggle') return; // safeguard
                if (!showPersonB) {
                    el.setAttribute('disabled','disabled');
                    el.classList.add('cursor-not-allowed','opacity-70');
                } else {
                    el.removeAttribute('disabled');
                    el.classList.remove('cursor-not-allowed','opacity-70');
                }
            });

            const showTransitFields = !isNatalOnly; // Show transit fields for all modes except natal_only
            console.log('[UPDATE UI] Transit fields:', { showTransitFields, isNatalOnly, transitDateFields: !!transitDateFields });
            
            if (transitDateFields) {
                transitDateFields.style.display = showTransitFields ? 'block' : 'none';
                console.log('[UPDATE UI] ✅ Transit fields display set to:', showTransitFields ? 'block' : 'none');
                
                // Debug parent visibility
                const parent = transitDateFields.parentElement;
                const grandParent = parent?.parentElement;
                console.log('[UPDATE UI] Parent visibility check:', {
                    parentId: parent?.id || 'no-id',
                    parentClasses: parent?.className || '',
                    parentDisplay: parent ? getComputedStyle(parent).display : 'not found',
                    grandParentId: grandParent?.id || 'no-id', 
                    grandParentClasses: grandParent?.className || '',
                    grandParentDisplay: grandParent ? getComputedStyle(grandParent).display : 'not found'
                });
            } else {
                console.error('[UPDATE UI] ❌ transitDateFields element not found!');
            }

            // CRITICAL: Relocation overlay available for ALL chart modes (natal_only and transit modes)
            // Relocation is about geometric foundation shift, not timing - affects natal architecture context
            const showRelocation = true; // Always show relocation - foundational architectural overlay
            if (relocationSection) relocationSection.style.display = showRelocation ? 'block' : 'none';
            
            // Update Person B relocation option visibility
            updateRelocationPersonBOption();
            
            // Show/hide relational context section based on whether this is a relational mode
            const isRelationalMode = isSynastryTransits || isCompositeTransits;
            if (isRelationalMode || currentContextType === 'relational') {
                showRelationalContext();
            } else {
                hideRelationalContext();
            }
        }
        
        function updateRelocationPersonBOption() {
            const mode = document.querySelector('input[name="contextMode"]:checked').value;
            const showPersonB = mode !== 'natal';
            const relocationEnabled = relocationToggle && relocationToggle.checked;
            
            // Show the Person B relocation option only if Person B is present and relocation is enabled
            if (relocationPersonBOption) {
                if (showPersonB && relocationEnabled) {
                    relocationPersonBOption.classList.remove('hidden');
                } else {
                    relocationPersonBOption.classList.add('hidden');
                }
            }
        }

        // Initial UI setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements assignment
            generateBtn = document.getElementById('generateReport');
            loadingIndicator = document.getElementById('loadingIndicator');
            errorDisplay = document.getElementById('errorDisplay');
            errorMessage = document.getElementById('errorMessage');
            reportOutput = document.getElementById('reportOutput');
            reportContent = document.getElementById('reportContent');
            copyBtn = document.getElementById('copyReport');
            downloadMarkdownBtn = document.getElementById('downloadMarkdown');
            downloadReportBtn = document.getElementById('downloadReport');
            mathBrainInfoBtn = document.getElementById('math-brain-info-btn');
            mathBrainModal = document.getElementById('math-brain-modal');
            closeMathBrainModal = document.getElementById('close-math-brain-modal');
            closeMathBrainModalBottom = document.getElementById('close-math-brain-modal-bottom');
            relocationToggle = document.getElementById('relocationToggle');
            relocationFields = document.getElementById('relocationFields');
            transitDateFields = document.getElementById('quick-transit-section'); // The actual transit section, not the legacy hidden one
            personBCard = document.getElementById('personB-card');
            relocationSection = document.getElementById('relocation-section');
            relationalContextSection = document.getElementById('relational-context-section');
            intimacyTierDropdown = document.getElementById('intimacy-tier-dropdown');
            exRelationshipCheckbox = document.getElementById('exRelationship');
            relocationPersonBOption = document.getElementById('relocationPersonBOption');
            includePersonBRelocationEl = document.getElementById('includePersonBRelocation');
            transitStartDate = document.getElementById('transitStartDate');
            transitEndDate = document.getElementById('transitEndDate');
            transitStep = document.getElementById('transitStep');
            relocationCoordsInput = document.getElementById('relocationCoords');
            toggleModeHelp = document.getElementById('toggle-mode-help');
            modeHelpPanel = document.getElementById('mode-help-panel');
            prefillTodayBtn = document.getElementById('prefillToday');
            stepSizeHelpBtn = document.getElementById('stepSizeHelp');
            stepSizeHelpPanel = document.getElementById('stepSizeHelpPanel');
            // Relationship role custom field toggle (delegated)
            document.addEventListener('change', (e)=>{
                if (e.target && e.target.id === 'relationshipRole') {
                    const roleCustom = document.getElementById('relationshipRoleCustom');
                    roleCustom && roleCustom.classList.toggle('hidden', e.target.value !== 'other');
                }
            });

            console.log("DOM elements assigned:", {
                generateBtn: !!generateBtn,
                loadingIndicator: !!loadingIndicator,
                errorDisplay: !!errorDisplay,
                transitStartDate: !!transitStartDate,
                transitEndDate: !!transitEndDate,
                transitStep: !!transitStep,
                relocationCoordsInput: !!relocationCoordsInput,
                relocationSection: !!relocationSection
            });

            setupEventListeners();
            setupProgressiveDisclosureEventListeners(); // New UX improvement functions
            
            updateFormUI();
            
            // Relocation default wiring & persistence
            // Ensure hint container exists
            if(document.getElementById('relocationCoords') && !document.getElementById('relocationCoordsError')){
                const hint=document.createElement('div'); hint.id='relocationCoordsError'; hint.className='mt-1 text-xs'; hint.setAttribute('aria-live','polite');
                document.getElementById('relocationCoords').parentNode.appendChild(hint);
            }
            attachCoordValidator('relocationCoords','relocationCoordsError');
            wireUseDefaultRelocButton();
            if(loadRelocPref()) { applyRelocDefaults(false); }
            // Add persistence checkbox inside details if not present
            const details = document.getElementById('relocation-details');
            if(details && !document.getElementById('alwaysUseDefaultReloc')){
                const wrap=document.createElement('label');
                wrap.className='mt-3 flex items-center gap-2 text-sm';
                wrap.innerHTML='<input id="alwaysUseDefaultReloc" type="checkbox" class="h-4 w-4"> Always use Panama City by default';
                details.appendChild(wrap);
                const cb=document.getElementById('alwaysUseDefaultReloc');
                cb.checked=loadRelocPref();
                cb.addEventListener('change',e=> saveRelocPref(e.target.checked));
            }
            // Header quick button
            const relocQuickBtn = document.getElementById('relocQuickBtn');
            const relocToggleEl = document.getElementById('relocationToggle');
            if (relocQuickBtn){
                // Only apply defaults when user clicks; show neutral visual otherwise
                relocQuickBtn.addEventListener('click', ()=>{
                    applyRelocDefaults(true);
                    document.getElementById('relocation-section')?.scrollIntoView({behavior:'smooth', block:'start'});
                    if (relocQuickBtn) { relocQuickBtn.setAttribute('aria-pressed','true'); relocQuickBtn.classList.add('bg-teal-600','text-white'); }
                });
                // Sync visual state with checkbox
                if (relocToggleEl) {
                    const syncQuickBtn = () => {
                        const checked = !!relocToggleEl.checked;
                        relocQuickBtn.setAttribute('aria-pressed', checked ? 'true' : 'false');
                        if (checked) { relocQuickBtn.classList.add('bg-teal-600','text-white'); }
                        else { relocQuickBtn.classList.remove('bg-teal-600','text-white'); }
                        updateRelocationNote();
                    };
                    relocToggleEl.addEventListener('change', syncQuickBtn);
                    // initial sync
                    syncQuickBtn();
                }
            }
            // Initial note state if not already updated
            updateRelocationNote();

            // Initialize with Mirror mode
            updateAppMode('mirror');
            updateContextType('solo');
            
            // Auto-prefill transit dates with today for convenience
            const todayStr = getTodayDateString();
            if (transitStartDate && transitEndDate) {
                transitStartDate.value = todayStr;
                transitEndDate.value = todayStr;
            }
            
            // Initial check for intimacy tier
            const isPartner = document.querySelector('input[name="relationshipType"]:checked')?.value === 'partner';
            intimacyTierDropdown.classList.toggle('hidden', !isPartner);
            
            // Mobile-specific initialization
            initializeMobileSupport();
        });
        
        // Mobile support initialization
        function initializeMobileSupport() {
            console.log('Initializing mobile support...');
            
            // Check if we're on a mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isSmallScreen = window.innerWidth <= 768;
            
            console.log('Mobile detection:', { isMobile, isSmallScreen, userAgent: navigator.userAgent });
            
            if (isMobile || isSmallScreen) {
                // Add mobile class to body for additional styling hooks
                document.body.classList.add('mobile-device');
                
                // Fix date inputs on mobile
                const dateInputs = document.querySelectorAll('input[type="date"]');
                dateInputs.forEach(input => {
                    // Ensure proper date format handling
                    input.addEventListener('input', function(e) {
                        console.log('Date input changed:', e.target.id, 'value:', e.target.value);
                        
                        // Validate the date format
                        if (e.target.value && !/^\d{4}-\d{2}-\d{2}$/.test(e.target.value)) {
                            console.warn('Date format issue detected:', e.target.value);
                            // Try to convert common formats
                            if (e.target.value.includes('/')) {
                                const parts = e.target.value.split('/');
                                if (parts.length === 3) {
                                    // Assume MM/DD/YYYY format and convert to YYYY-MM-DD
                                    const month = parts[0].padStart(2, '0');
                                    const day = parts[1].padStart(2, '0');
                                    const year = parts[2];
                                    const isoDate = `${year}-${month}-${day}`;
                                    console.log('Converting date format:', e.target.value, 'to', isoDate);
                                    e.target.value = isoDate;
                                }
                            }
                        }
                    });
                    
                    // Prevent iOS zoom on focus
                    input.addEventListener('focus', function(e) {
                        console.log('Date input focused:', e.target.id);
                        e.target.style.fontSize = '16px';
                    });
                });
                
                // Also handle time inputs
                const timeInputs = document.querySelectorAll('input[type="time"]');
                timeInputs.forEach(input => {
                    input.addEventListener('focus', function(e) {
                        e.target.style.fontSize = '16px';
                    });
                });
                
                // Handle text inputs that might become date inputs on mobile
                const textInputs = document.querySelectorAll('input[type="text"]');
                textInputs.forEach(input => {
                    input.addEventListener('focus', function(e) {
                        e.target.style.fontSize = '16px';
                    });
                });
                
                console.log('Mobile support initialized');
            }
        }
    </script>
</body>
</html>
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/astrology-mathbrain/route";
exports.ids = ["app/api/astrology-mathbrain/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fastrology-mathbrain%2Froute&page=%2Fapi%2Fastrology-mathbrain%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fastrology-mathbrain%2Froute.ts&appDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fastrology-mathbrain%2Froute&page=%2Fapi%2Fastrology-mathbrain%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fastrology-mathbrain%2Froute.ts&appDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _home_runner_work_WovenWebApp_WovenWebApp_app_api_astrology_mathbrain_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/astrology-mathbrain/route.ts */ \"(rsc)/./app/api/astrology-mathbrain/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/astrology-mathbrain/route\",\n        pathname: \"/api/astrology-mathbrain\",\n        filename: \"route\",\n        bundlePath: \"app/api/astrology-mathbrain/route\"\n    },\n    resolvedPagePath: \"/home/runner/work/WovenWebApp/WovenWebApp/app/api/astrology-mathbrain/route.ts\",\n    nextConfigOutput,\n    userland: _home_runner_work_WovenWebApp_WovenWebApp_app_api_astrology_mathbrain_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/astrology-mathbrain/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhc3Ryb2xvZ3ktbWF0aGJyYWluJTJGcm91dGUmcGFnZT0lMkZhcGklMkZhc3Ryb2xvZ3ktbWF0aGJyYWluJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYXN0cm9sb2d5LW1hdGhicmFpbiUyRnJvdXRlLnRzJmFwcERpcj0lMkZob21lJTJGcnVubmVyJTJGd29yayUyRldvdmVuV2ViQXBwJTJGV292ZW5XZWJBcHAlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRmhvbWUlMkZydW5uZXIlMkZ3b3JrJTJGV292ZW5XZWJBcHAlMkZXb3ZlbldlYkFwcCZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDOEI7QUFDM0c7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Zlbi13ZWItYXBwLz8xOWUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL1dvdmVuV2ViQXBwL1dvdmVuV2ViQXBwL2FwcC9hcGkvYXN0cm9sb2d5LW1hdGhicmFpbi9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvYXN0cm9sb2d5LW1hdGhicmFpbi9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2FzdHJvbG9neS1tYXRoYnJhaW5cIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2FzdHJvbG9neS1tYXRoYnJhaW4vcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvaG9tZS9ydW5uZXIvd29yay9Xb3ZlbldlYkFwcC9Xb3ZlbldlYkFwcC9hcHAvYXBpL2FzdHJvbG9neS1tYXRoYnJhaW4vcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2FzdHJvbG9neS1tYXRoYnJhaW4vcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fastrology-mathbrain%2Froute&page=%2Fapi%2Fastrology-mathbrain%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fastrology-mathbrain%2Froute.ts&appDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/astrology-mathbrain/route.ts":
/*!**********************************************!*\
  !*** ./app/api/astrology-mathbrain/route.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// Reuse the legacy math brain implementation directly\nconst mathBrainFunction = __webpack_require__(/*! ../../../lib/server/astrology-mathbrain.js */ \"(rsc)/./lib/server/astrology-mathbrain.js\");\nasync function GET(request) {\n    // Convert Next.js request to Netlify event format\n    const url = new URL(request.url);\n    // Convert headers\n    const headers = {};\n    request.headers.forEach((value, key)=>{\n        headers[key] = value;\n    });\n    const event = {\n        httpMethod: \"GET\",\n        queryStringParameters: Object.fromEntries(url.searchParams),\n        headers,\n        body: null,\n        path: url.pathname,\n        pathParameters: null,\n        requestContext: {},\n        resource: \"\",\n        stageVariables: null,\n        isBase64Encoded: false\n    };\n    const context = {\n        callbackWaitsForEmptyEventLoop: false,\n        functionName: \"astrology-mathbrain\",\n        functionVersion: \"$LATEST\",\n        invokedFunctionArn: \"\",\n        memoryLimitInMB: \"1024\",\n        awsRequestId: (0,crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID)(),\n        logGroupName: \"\",\n        logStreamName: \"\",\n        getRemainingTimeInMillis: ()=>30000\n    };\n    try {\n        const result = await mathBrainFunction.handler(event, context);\n        return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(result.body, {\n            status: result.statusCode,\n            headers: new Headers(result.headers || {})\n        });\n    } catch (error) {\n        console.error(\"Astrology MathBrain API error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Internal server error\",\n            code: \"ASTROLOGY_API_ERROR\"\n        }, {\n            status: 500\n        });\n    }\n}\nasync function POST(request) {\n    try {\n        const raw = await request.json().catch(()=>null);\n        // Transform subjectA/subjectB/transits/houses shape → function input\n        function mapHouseSystem(h) {\n            if (!h) return undefined;\n            const name = String(h).toLowerCase();\n            const map = {\n                placidus: \"P\",\n                whole_sign: \"W\",\n                wholesign: \"W\",\n                \"whole sign\": \"W\",\n                regiomontanus: \"R\",\n                koch: \"K\",\n                campanus: \"C\",\n                equal: \"E\"\n            };\n            return map[name] || h;\n        }\n        const pickNation = (subject, birth)=>{\n            return subject?.nation || birth?.nation || subject?.country || birth?.country || subject?.country_code || birth?.country_code || subject?.nation_code || undefined;\n        };\n        const body = function transform(input) {\n            if (!input || !input.subjectA && !input.subjectB) return JSON.stringify(input ?? {});\n            const a = input.subjectA || {};\n            const b = input.subjectB || null;\n            const birthA = a.birth || {};\n            const birthB = b?.birth || {};\n            const toPerson = (name, subject, birth, local)=>({\n                    name,\n                    year: parseInt(birth.date?.split(\"-\")[0] || birth.year, 10),\n                    month: parseInt(birth.date?.split(\"-\")[1] || birth.month, 10),\n                    day: parseInt(birth.date?.split(\"-\")[2] || birth.day, 10),\n                    hour: parseInt((birth.time || \"\").split(\":\")[0] || birth.hour, 10),\n                    minute: parseInt((birth.time || \"\").split(\":\")[1] || birth.minute, 10),\n                    latitude: birth.lat ?? birth.latitude ?? subject?.latitude,\n                    longitude: birth.lon ?? birth.lng ?? birth.longitude ?? subject?.longitude,\n                    timezone: birth.tz ?? birth.timezone ?? subject?.timezone,\n                    city: birth.city || subject?.city,\n                    state: birth.state || subject?.state,\n                    nation: pickNation(subject, birth),\n                    ...local ? {\n                        A_local: local,\n                        B_local: local\n                    } : {}\n                });\n            const personA = toPerson(a.name, a, birthA, a.A_local);\n            const personB = b ? toPerson(b.name, b, birthB, b.B_local) : undefined;\n            const tx = input.transits || {};\n            const window = tx.from && tx.to ? {\n                start: tx.from,\n                end: tx.to,\n                step: tx.step || \"daily\"\n            } : undefined;\n            const houses = mapHouseSystem(input.houses);\n            const out = {\n                personA,\n                ...personB ? {\n                    personB\n                } : {},\n                ...window ? {\n                    window\n                } : {},\n                context: {\n                    mode: (()=>{\n                        const rt = String(input.report_type || \"\").toLowerCase();\n                        if (rt.includes(\"synastry_transits\")) return \"synastry_transits\";\n                        if (rt.includes(\"synastry\")) return \"synastry\";\n                        if (rt.includes(\"balance_meter\")) return \"balance_meter\";\n                        return input.context?.mode || \"mirror\";\n                    })()\n                },\n                relocation_mode: input.relocation_mode,\n                orbs_profile: input.orbs_profile,\n                ...houses ? {\n                    houses_system_identifier: houses\n                } : {}\n            };\n            if (input.relationship_context || input.relationshipContext) {\n                out.relationship_context = input.relationship_context || input.relationshipContext;\n            }\n            return JSON.stringify(out);\n        }(raw);\n        // Convert Next.js request to Netlify event format\n        const url = new URL(request.url);\n        // Convert headers\n        const headers = {};\n        request.headers.forEach((value, key)=>{\n            headers[key] = value;\n        });\n        const event = {\n            httpMethod: \"POST\",\n            queryStringParameters: Object.fromEntries(url.searchParams),\n            headers,\n            body,\n            path: url.pathname,\n            pathParameters: null,\n            requestContext: {},\n            resource: \"\",\n            stageVariables: null,\n            isBase64Encoded: false\n        };\n        const context = {\n            callbackWaitsForEmptyEventLoop: false,\n            functionName: \"astrology-mathbrain\",\n            functionVersion: \"$LATEST\",\n            invokedFunctionArn: \"\",\n            memoryLimitInMB: \"1024\",\n            awsRequestId: (0,crypto__WEBPACK_IMPORTED_MODULE_1__.randomUUID)(),\n            logGroupName: \"\",\n            logStreamName: \"\",\n            getRemainingTimeInMillis: ()=>30000\n        };\n        const result = await mathBrainFunction.handler(event, context);\n        return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(result.body, {\n            status: result.statusCode,\n            headers: new Headers(result.headers || {})\n        });\n    } catch (error) {\n        console.error(\"Astrology MathBrain API error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Internal server error\",\n            code: \"ASTROLOGY_API_ERROR\"\n        }, {\n            status: 500\n        });\n    }\n}\nasync function OPTIONS(request) {\n    const headers = {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Headers\": \"Content-Type\",\n        \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\"\n    };\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(\"\", {\n        status: 200,\n        headers: new Headers(headers)\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2FzdHJvbG9neS1tYXRoYnJhaW4vcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdEO0FBQ3BCO0FBRXBDLHNEQUFzRDtBQUN0RCxNQUFNRSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBRTNCLGVBQWVDLElBQUlDLE9BQW9CO0lBQzVDLGtEQUFrRDtJQUNsRCxNQUFNQyxNQUFNLElBQUlDLElBQUlGLFFBQVFDLEdBQUc7SUFFL0Isa0JBQWtCO0lBQ2xCLE1BQU1FLFVBQWtDLENBQUM7SUFDekNILFFBQVFHLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLE9BQU9DO1FBQzlCSCxPQUFPLENBQUNHLElBQUksR0FBR0Q7SUFDakI7SUFFQSxNQUFNRSxRQUFRO1FBQ1pDLFlBQVk7UUFDWkMsdUJBQXVCQyxPQUFPQyxXQUFXLENBQUNWLElBQUlXLFlBQVk7UUFDMURUO1FBQ0FVLE1BQU07UUFDTkMsTUFBTWIsSUFBSWMsUUFBUTtRQUNsQkMsZ0JBQWdCO1FBQ2hCQyxnQkFBZ0IsQ0FBQztRQUNqQkMsVUFBVTtRQUNWQyxnQkFBZ0I7UUFDaEJDLGlCQUFpQjtJQUNuQjtJQUVBLE1BQU1DLFVBQVU7UUFDZEMsZ0NBQWdDO1FBQ2hDQyxjQUFjO1FBQ2RDLGlCQUFpQjtRQUNqQkMsb0JBQW9CO1FBQ3BCQyxpQkFBaUI7UUFDbkJDLGNBQWMvQixrREFBVUE7UUFDdEJnQyxjQUFjO1FBQ2RDLGVBQWU7UUFDZkMsMEJBQTBCLElBQU07SUFDbEM7SUFFQSxJQUFJO1FBQ0YsTUFBTUMsU0FBUyxNQUFNbEMsa0JBQWtCbUMsT0FBTyxDQUFDekIsT0FBT2M7UUFFdEQsT0FBTyxJQUFJMUIscURBQVlBLENBQUNvQyxPQUFPbEIsSUFBSSxFQUFFO1lBQ25Db0IsUUFBUUYsT0FBT0csVUFBVTtZQUN6Qi9CLFNBQVMsSUFBSWdDLFFBQVFKLE9BQU81QixPQUFPLElBQUksQ0FBQztRQUMxQztJQUNGLEVBQUUsT0FBT2lDLE9BQVk7UUFDbkJDLFFBQVFELEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE9BQU96QyxxREFBWUEsQ0FBQzJDLElBQUksQ0FBQztZQUN2QkMsU0FBUztZQUNUSCxPQUFPO1lBQ1BJLE1BQU07UUFDUixHQUFHO1lBQUVQLFFBQVE7UUFBSTtJQUNuQjtBQUNGO0FBRU8sZUFBZVEsS0FBS3pDLE9BQW9CO0lBQzdDLElBQUk7UUFDRixNQUFNMEMsTUFBTSxNQUFNMUMsUUFBUXNDLElBQUksR0FBR0ssS0FBSyxDQUFDLElBQU07UUFDN0MscUVBQXFFO1FBQ3JFLFNBQVNDLGVBQWVDLENBQW1CO1lBQ3pDLElBQUcsQ0FBQ0EsR0FBRyxPQUFPQztZQUNkLE1BQU1DLE9BQU9DLE9BQU9ILEdBQUdJLFdBQVc7WUFDbEMsTUFBTUMsTUFBNkI7Z0JBQ2pDQyxVQUFVO2dCQUFLQyxZQUFZO2dCQUFLQyxXQUFXO2dCQUFLLGNBQWM7Z0JBQUtDLGVBQWU7Z0JBQUtDLE1BQU07Z0JBQUtDLFVBQVU7Z0JBQUtDLE9BQU87WUFDMUg7WUFDQSxPQUFPUCxHQUFHLENBQUNILEtBQUssSUFBSUY7UUFDdEI7UUFDQSxNQUFNYSxhQUFhLENBQUNDLFNBQWNDO1lBQ2hDLE9BQU9ELFNBQVNFLFVBQVVELE9BQU9DLFVBQVVGLFNBQVNHLFdBQVdGLE9BQU9FLFdBQVdILFNBQVNJLGdCQUFnQkgsT0FBT0csZ0JBQWdCSixTQUFTSyxlQUFlbEI7UUFDM0o7UUFDQSxNQUFNakMsT0FBTyxTQUFVb0QsVUFBVUMsS0FBUztZQUN4QyxJQUFHLENBQUNBLFNBQVUsQ0FBQ0EsTUFBTUMsUUFBUSxJQUFJLENBQUNELE1BQU1FLFFBQVEsRUFBRyxPQUFPQyxLQUFLQyxTQUFTLENBQUNKLFNBQVMsQ0FBQztZQUNuRixNQUFNSyxJQUFJTCxNQUFNQyxRQUFRLElBQUksQ0FBQztZQUM3QixNQUFNSyxJQUFJTixNQUFNRSxRQUFRLElBQUk7WUFDNUIsTUFBTUssU0FBU0YsRUFBRVgsS0FBSyxJQUFJLENBQUM7WUFDM0IsTUFBTWMsU0FBU0YsR0FBR1osU0FBUyxDQUFDO1lBQzVCLE1BQU1lLFdBQVcsQ0FBQzVCLE1BQWFZLFNBQWFDLE9BQVdnQixRQUFhO29CQUNsRTdCO29CQUNBOEIsTUFBTUMsU0FBU2xCLE1BQU1tQixJQUFJLEVBQUVDLE1BQU0sSUFBSSxDQUFDLEVBQUUsSUFBRXBCLE1BQU1pQixJQUFJLEVBQUM7b0JBQ3JESSxPQUFPSCxTQUFTbEIsTUFBTW1CLElBQUksRUFBRUMsTUFBTSxJQUFJLENBQUMsRUFBRSxJQUFFcEIsTUFBTXFCLEtBQUssRUFBQztvQkFDdkRDLEtBQUtKLFNBQVNsQixNQUFNbUIsSUFBSSxFQUFFQyxNQUFNLElBQUksQ0FBQyxFQUFFLElBQUVwQixNQUFNc0IsR0FBRyxFQUFDO29CQUNuREMsTUFBTUwsU0FBUyxDQUFDbEIsTUFBTXdCLElBQUksSUFBRSxFQUFDLEVBQUdKLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFFcEIsTUFBTXVCLElBQUksRUFBQztvQkFDMURFLFFBQVFQLFNBQVMsQ0FBQ2xCLE1BQU13QixJQUFJLElBQUUsRUFBQyxFQUFHSixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBRXBCLE1BQU15QixNQUFNLEVBQUM7b0JBQzlEQyxVQUFVMUIsTUFBTTJCLEdBQUcsSUFBSTNCLE1BQU0wQixRQUFRLElBQUkzQixTQUFTMkI7b0JBQ2xERSxXQUFXNUIsTUFBTTZCLEdBQUcsSUFBSTdCLE1BQU04QixHQUFHLElBQUk5QixNQUFNNEIsU0FBUyxJQUFJN0IsU0FBUzZCO29CQUNqRUcsVUFBVS9CLE1BQU1nQyxFQUFFLElBQUloQyxNQUFNK0IsUUFBUSxJQUFJaEMsU0FBU2dDO29CQUNqREUsTUFBTWpDLE1BQU1pQyxJQUFJLElBQUlsQyxTQUFTa0M7b0JBQzdCQyxPQUFPbEMsTUFBTWtDLEtBQUssSUFBSW5DLFNBQVNtQztvQkFDL0JqQyxRQUFRSCxXQUFXQyxTQUFTQztvQkFDNUIsR0FBSWdCLFFBQVE7d0JBQUVtQixTQUFTbkI7d0JBQU9vQixTQUFTcEI7b0JBQU0sSUFBSSxDQUFDLENBQUM7Z0JBQ3JEO1lBQ0EsTUFBTXFCLFVBQVV0QixTQUFTSixFQUFFeEIsSUFBSSxFQUFFd0IsR0FBR0UsUUFBUUYsRUFBRXdCLE9BQU87WUFDckQsTUFBTUcsVUFBVTFCLElBQUlHLFNBQVNILEVBQUV6QixJQUFJLEVBQUV5QixHQUFHRSxRQUFRRixFQUFFd0IsT0FBTyxJQUFJbEQ7WUFDN0QsTUFBTXFELEtBQUtqQyxNQUFNa0MsUUFBUSxJQUFJLENBQUM7WUFDOUIsTUFBTUMsU0FBU0YsR0FBR0csSUFBSSxJQUFJSCxHQUFHSSxFQUFFLEdBQUc7Z0JBQUVDLE9BQU9MLEdBQUdHLElBQUk7Z0JBQUVHLEtBQUtOLEdBQUdJLEVBQUU7Z0JBQUVHLE1BQU1QLEdBQUdPLElBQUksSUFBSTtZQUFRLElBQUk1RDtZQUM3RixNQUFNNkQsU0FBUy9ELGVBQWVzQixNQUFNeUMsTUFBTTtZQUMxQyxNQUFNQyxNQUFVO2dCQUNkWDtnQkFDQSxHQUFJQyxVQUFVO29CQUFFQTtnQkFBUSxJQUFJLENBQUMsQ0FBQztnQkFDOUIsR0FBSUcsU0FBUztvQkFBRUE7Z0JBQU8sSUFBSSxDQUFDLENBQUM7Z0JBQzVCaEYsU0FBUztvQkFBRXdGLE1BQU0sQ0FBQzt3QkFDaEIsTUFBTUMsS0FBSzlELE9BQU9rQixNQUFNNkMsV0FBVyxJQUFFLElBQUk5RCxXQUFXO3dCQUNwRCxJQUFJNkQsR0FBR0UsUUFBUSxDQUFDLHNCQUFzQixPQUFPO3dCQUM3QyxJQUFJRixHQUFHRSxRQUFRLENBQUMsYUFBYSxPQUFPO3dCQUNwQyxJQUFJRixHQUFHRSxRQUFRLENBQUMsa0JBQWtCLE9BQU87d0JBQ3pDLE9BQVE5QyxNQUFNN0MsT0FBTyxFQUFFd0YsUUFBUTtvQkFDakM7Z0JBQUs7Z0JBQ0xJLGlCQUFpQi9DLE1BQU0rQyxlQUFlO2dCQUN0Q0MsY0FBY2hELE1BQU1nRCxZQUFZO2dCQUNoQyxHQUFJUCxTQUFTO29CQUFFUSwwQkFBMEJSO2dCQUFPLElBQUksQ0FBQyxDQUFDO1lBQ3hEO1lBQ0EsSUFBSXpDLE1BQU1rRCxvQkFBb0IsSUFBSWxELE1BQU1tRCxtQkFBbUIsRUFBRTtnQkFDM0RULElBQUlRLG9CQUFvQixHQUFHbEQsTUFBTWtELG9CQUFvQixJQUFJbEQsTUFBTW1ELG1CQUFtQjtZQUNwRjtZQUNBLE9BQU9oRCxLQUFLQyxTQUFTLENBQUNzQztRQUN4QixFQUFHbEU7UUFFSCxrREFBa0Q7UUFDbEQsTUFBTXpDLE1BQU0sSUFBSUMsSUFBSUYsUUFBUUMsR0FBRztRQUUvQixrQkFBa0I7UUFDbEIsTUFBTUUsVUFBa0MsQ0FBQztRQUN6Q0gsUUFBUUcsT0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsT0FBT0M7WUFDOUJILE9BQU8sQ0FBQ0csSUFBSSxHQUFHRDtRQUNqQjtRQUVBLE1BQU1FLFFBQVE7WUFDWkMsWUFBWTtZQUNaQyx1QkFBdUJDLE9BQU9DLFdBQVcsQ0FBQ1YsSUFBSVcsWUFBWTtZQUMxRFQ7WUFDQVU7WUFDQUMsTUFBTWIsSUFBSWMsUUFBUTtZQUNsQkMsZ0JBQWdCO1lBQ2hCQyxnQkFBZ0IsQ0FBQztZQUNqQkMsVUFBVTtZQUNWQyxnQkFBZ0I7WUFDaEJDLGlCQUFpQjtRQUNuQjtRQUVBLE1BQU1DLFVBQVU7WUFDZEMsZ0NBQWdDO1lBQ2hDQyxjQUFjO1lBQ2RDLGlCQUFpQjtZQUNqQkMsb0JBQW9CO1lBQ3BCQyxpQkFBaUI7WUFDckJDLGNBQWMvQixrREFBVUE7WUFDcEJnQyxjQUFjO1lBQ2RDLGVBQWU7WUFDZkMsMEJBQTBCLElBQU07UUFDbEM7UUFFQSxNQUFNQyxTQUFTLE1BQU1sQyxrQkFBa0JtQyxPQUFPLENBQUN6QixPQUFPYztRQUV0RCxPQUFPLElBQUkxQixxREFBWUEsQ0FBQ29DLE9BQU9sQixJQUFJLEVBQUU7WUFDbkNvQixRQUFRRixPQUFPRyxVQUFVO1lBQ3pCL0IsU0FBUyxJQUFJZ0MsUUFBUUosT0FBTzVCLE9BQU8sSUFBSSxDQUFDO1FBQzFDO0lBQ0YsRUFBRSxPQUFPaUMsT0FBWTtRQUNuQkMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsT0FBT3pDLHFEQUFZQSxDQUFDMkMsSUFBSSxDQUFDO1lBQ3ZCQyxTQUFTO1lBQ1RILE9BQU87WUFDUEksTUFBTTtRQUNSLEdBQUc7WUFBRVAsUUFBUTtRQUFJO0lBQ25CO0FBQ0Y7QUFFTyxlQUFlcUYsUUFBUXRILE9BQW9CO0lBQ2hELE1BQU1HLFVBQVU7UUFDZCwrQkFBK0I7UUFDL0IsZ0NBQWdDO1FBQ2hDLGdDQUFnQztJQUNsQztJQUVBLE9BQU8sSUFBSVIscURBQVlBLENBQUMsSUFBSTtRQUMxQnNDLFFBQVE7UUFDUjlCLFNBQVMsSUFBSWdDLFFBQVFoQztJQUN2QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd292ZW4td2ViLWFwcC8uL2FwcC9hcGkvYXN0cm9sb2d5LW1hdGhicmFpbi9yb3V0ZS50cz8xZTMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcblxuLy8gUmV1c2UgdGhlIGxlZ2FjeSBtYXRoIGJyYWluIGltcGxlbWVudGF0aW9uIGRpcmVjdGx5XG5jb25zdCBtYXRoQnJhaW5GdW5jdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2ZXIvYXN0cm9sb2d5LW1hdGhicmFpbi5qcycpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIC8vIENvbnZlcnQgTmV4dC5qcyByZXF1ZXN0IHRvIE5ldGxpZnkgZXZlbnQgZm9ybWF0XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBcbiAgLy8gQ29udmVydCBoZWFkZXJzXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIFxuICBjb25zdCBldmVudCA9IHtcbiAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnM6IE9iamVjdC5mcm9tRW50cmllcyh1cmwuc2VhcmNoUGFyYW1zKSxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHk6IG51bGwsXG4gICAgcGF0aDogdXJsLnBhdGhuYW1lLFxuICAgIHBhdGhQYXJhbWV0ZXJzOiBudWxsLFxuICAgIHJlcXVlc3RDb250ZXh0OiB7fSxcbiAgICByZXNvdXJjZTogJycsXG4gICAgc3RhZ2VWYXJpYWJsZXM6IG51bGwsXG4gICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZVxuICB9O1xuXG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgY2FsbGJhY2tXYWl0c0ZvckVtcHR5RXZlbnRMb29wOiBmYWxzZSxcbiAgICBmdW5jdGlvbk5hbWU6ICdhc3Ryb2xvZ3ktbWF0aGJyYWluJyxcbiAgICBmdW5jdGlvblZlcnNpb246ICckTEFURVNUJyxcbiAgICBpbnZva2VkRnVuY3Rpb25Bcm46ICcnLFxuICAgIG1lbW9yeUxpbWl0SW5NQjogJzEwMjQnLFxuICBhd3NSZXF1ZXN0SWQ6IHJhbmRvbVVVSUQoKSxcbiAgICBsb2dHcm91cE5hbWU6ICcnLFxuICAgIGxvZ1N0cmVhbU5hbWU6ICcnLFxuICAgIGdldFJlbWFpbmluZ1RpbWVJbk1pbGxpczogKCkgPT4gMzAwMDBcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1hdGhCcmFpbkZ1bmN0aW9uLmhhbmRsZXIoZXZlbnQsIGNvbnRleHQpO1xuICAgIFxuICAgIHJldHVybiBuZXcgTmV4dFJlc3BvbnNlKHJlc3VsdC5ib2R5LCB7XG4gICAgICBzdGF0dXM6IHJlc3VsdC5zdGF0dXNDb2RlLFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMocmVzdWx0LmhlYWRlcnMgfHwge30pXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBc3Ryb2xvZ3kgTWF0aEJyYWluIEFQSSBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLFxuICAgICAgY29kZTogJ0FTVFJPTE9HWV9BUElfRVJST1InXG4gICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGF3YWl0IHJlcXVlc3QuanNvbigpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgIC8vIFRyYW5zZm9ybSBzdWJqZWN0QS9zdWJqZWN0Qi90cmFuc2l0cy9ob3VzZXMgc2hhcGUg4oaSIGZ1bmN0aW9uIGlucHV0XG4gICAgZnVuY3Rpb24gbWFwSG91c2VTeXN0ZW0oaDogc3RyaW5nfHVuZGVmaW5lZCl7XG4gICAgICBpZighaCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IG5hbWUgPSBTdHJpbmcoaCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IG1hcDogUmVjb3JkPHN0cmluZyxzdHJpbmc+ID0ge1xuICAgICAgICBwbGFjaWR1czogJ1AnLCB3aG9sZV9zaWduOiAnVycsIHdob2xlc2lnbjogJ1cnLCAnd2hvbGUgc2lnbic6ICdXJywgcmVnaW9tb250YW51czogJ1InLCBrb2NoOiAnSycsIGNhbXBhbnVzOiAnQycsIGVxdWFsOiAnRSdcbiAgICAgIH0gYXMgYW55O1xuICAgICAgcmV0dXJuIG1hcFtuYW1lXSB8fCBoO1xuICAgIH1cbiAgICBjb25zdCBwaWNrTmF0aW9uID0gKHN1YmplY3Q6IGFueSwgYmlydGg6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIHN1YmplY3Q/Lm5hdGlvbiB8fCBiaXJ0aD8ubmF0aW9uIHx8IHN1YmplY3Q/LmNvdW50cnkgfHwgYmlydGg/LmNvdW50cnkgfHwgc3ViamVjdD8uY291bnRyeV9jb2RlIHx8IGJpcnRoPy5jb3VudHJ5X2NvZGUgfHwgc3ViamVjdD8ubmF0aW9uX2NvZGUgfHwgdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3QgYm9keSA9IChmdW5jdGlvbiB0cmFuc2Zvcm0oaW5wdXQ6YW55KXtcbiAgICAgIGlmKCFpbnB1dCB8fCAoIWlucHV0LnN1YmplY3RBICYmICFpbnB1dC5zdWJqZWN0QikpIHJldHVybiBKU09OLnN0cmluZ2lmeShpbnB1dCA/PyB7fSk7XG4gICAgICBjb25zdCBhID0gaW5wdXQuc3ViamVjdEEgfHwge307XG4gICAgICBjb25zdCBiID0gaW5wdXQuc3ViamVjdEIgfHwgbnVsbDtcbiAgICAgIGNvbnN0IGJpcnRoQSA9IGEuYmlydGggfHwge307XG4gICAgICBjb25zdCBiaXJ0aEIgPSBiPy5iaXJ0aCB8fCB7fTtcbiAgICAgIGNvbnN0IHRvUGVyc29uID0gKG5hbWU6c3RyaW5nLCBzdWJqZWN0OmFueSwgYmlydGg6YW55LCBsb2NhbDphbnkpPT4oe1xuICAgICAgICBuYW1lLFxuICAgICAgICB5ZWFyOiBwYXJzZUludChiaXJ0aC5kYXRlPy5zcGxpdCgnLScpWzBdfHxiaXJ0aC55ZWFyLDEwKSxcbiAgICAgICAgbW9udGg6IHBhcnNlSW50KGJpcnRoLmRhdGU/LnNwbGl0KCctJylbMV18fGJpcnRoLm1vbnRoLDEwKSxcbiAgICAgICAgZGF5OiBwYXJzZUludChiaXJ0aC5kYXRlPy5zcGxpdCgnLScpWzJdfHxiaXJ0aC5kYXksMTApLFxuICAgICAgICBob3VyOiBwYXJzZUludCgoYmlydGgudGltZXx8JycpLnNwbGl0KCc6JylbMF18fGJpcnRoLmhvdXIsMTApLFxuICAgICAgICBtaW51dGU6IHBhcnNlSW50KChiaXJ0aC50aW1lfHwnJykuc3BsaXQoJzonKVsxXXx8YmlydGgubWludXRlLDEwKSxcbiAgICAgICAgbGF0aXR1ZGU6IGJpcnRoLmxhdCA/PyBiaXJ0aC5sYXRpdHVkZSA/PyBzdWJqZWN0Py5sYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlOiBiaXJ0aC5sb24gPz8gYmlydGgubG5nID8/IGJpcnRoLmxvbmdpdHVkZSA/PyBzdWJqZWN0Py5sb25naXR1ZGUsXG4gICAgICAgIHRpbWV6b25lOiBiaXJ0aC50eiA/PyBiaXJ0aC50aW1lem9uZSA/PyBzdWJqZWN0Py50aW1lem9uZSxcbiAgICAgICAgY2l0eTogYmlydGguY2l0eSB8fCBzdWJqZWN0Py5jaXR5LFxuICAgICAgICBzdGF0ZTogYmlydGguc3RhdGUgfHwgc3ViamVjdD8uc3RhdGUsXG4gICAgICAgIG5hdGlvbjogcGlja05hdGlvbihzdWJqZWN0LCBiaXJ0aCksXG4gICAgICAgIC4uLihsb2NhbCA/IHsgQV9sb2NhbDogbG9jYWwsIEJfbG9jYWw6IGxvY2FsIH0gOiB7fSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGVyc29uQSA9IHRvUGVyc29uKGEubmFtZSwgYSwgYmlydGhBLCBhLkFfbG9jYWwpO1xuICAgICAgY29uc3QgcGVyc29uQiA9IGIgPyB0b1BlcnNvbihiLm5hbWUsIGIsIGJpcnRoQiwgYi5CX2xvY2FsKSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHR4ID0gaW5wdXQudHJhbnNpdHMgfHwge307XG4gICAgICBjb25zdCB3aW5kb3cgPSB0eC5mcm9tICYmIHR4LnRvID8geyBzdGFydDogdHguZnJvbSwgZW5kOiB0eC50bywgc3RlcDogdHguc3RlcCB8fCAnZGFpbHknIH0gOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBob3VzZXMgPSBtYXBIb3VzZVN5c3RlbShpbnB1dC5ob3VzZXMpO1xuICAgICAgY29uc3Qgb3V0OmFueSA9IHtcbiAgICAgICAgcGVyc29uQSxcbiAgICAgICAgLi4uKHBlcnNvbkIgPyB7IHBlcnNvbkIgfSA6IHt9KSxcbiAgICAgICAgLi4uKHdpbmRvdyA/IHsgd2luZG93IH0gOiB7fSksXG4gICAgICAgIGNvbnRleHQ6IHsgbW9kZTogKCgpPT57XG4gICAgICAgICAgY29uc3QgcnQgPSBTdHJpbmcoaW5wdXQucmVwb3J0X3R5cGV8fCcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChydC5pbmNsdWRlcygnc3luYXN0cnlfdHJhbnNpdHMnKSkgcmV0dXJuICdzeW5hc3RyeV90cmFuc2l0cyc7XG4gICAgICAgICAgaWYgKHJ0LmluY2x1ZGVzKCdzeW5hc3RyeScpKSByZXR1cm4gJ3N5bmFzdHJ5JztcbiAgICAgICAgICBpZiAocnQuaW5jbHVkZXMoJ2JhbGFuY2VfbWV0ZXInKSkgcmV0dXJuICdiYWxhbmNlX21ldGVyJztcbiAgICAgICAgICByZXR1cm4gKGlucHV0LmNvbnRleHQ/Lm1vZGUgfHwgJ21pcnJvcicpO1xuICAgICAgICB9KSgpIH0sXG4gICAgICAgIHJlbG9jYXRpb25fbW9kZTogaW5wdXQucmVsb2NhdGlvbl9tb2RlLFxuICAgICAgICBvcmJzX3Byb2ZpbGU6IGlucHV0Lm9yYnNfcHJvZmlsZSxcbiAgICAgICAgLi4uKGhvdXNlcyA/IHsgaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyOiBob3VzZXMgfSA6IHt9KVxuICAgICAgfTtcbiAgICAgIGlmIChpbnB1dC5yZWxhdGlvbnNoaXBfY29udGV4dCB8fCBpbnB1dC5yZWxhdGlvbnNoaXBDb250ZXh0KSB7XG4gICAgICAgIG91dC5yZWxhdGlvbnNoaXBfY29udGV4dCA9IGlucHV0LnJlbGF0aW9uc2hpcF9jb250ZXh0IHx8IGlucHV0LnJlbGF0aW9uc2hpcENvbnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3V0KTtcbiAgICB9KShyYXcpO1xuICAgIFxuICAgIC8vIENvbnZlcnQgTmV4dC5qcyByZXF1ZXN0IHRvIE5ldGxpZnkgZXZlbnQgZm9ybWF0XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgXG4gICAgLy8gQ29udmVydCBoZWFkZXJzXG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHVybC5zZWFyY2hQYXJhbXMpLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgICBwYXRoOiB1cmwucGF0aG5hbWUsXG4gICAgICBwYXRoUGFyYW1ldGVyczogbnVsbCxcbiAgICAgIHJlcXVlc3RDb250ZXh0OiB7fSxcbiAgICAgIHJlc291cmNlOiAnJyxcbiAgICAgIHN0YWdlVmFyaWFibGVzOiBudWxsLFxuICAgICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY2FsbGJhY2tXYWl0c0ZvckVtcHR5RXZlbnRMb29wOiBmYWxzZSxcbiAgICAgIGZ1bmN0aW9uTmFtZTogJ2FzdHJvbG9neS1tYXRoYnJhaW4nLFxuICAgICAgZnVuY3Rpb25WZXJzaW9uOiAnJExBVEVTVCcsXG4gICAgICBpbnZva2VkRnVuY3Rpb25Bcm46ICcnLFxuICAgICAgbWVtb3J5TGltaXRJbk1COiAnMTAyNCcsXG4gIGF3c1JlcXVlc3RJZDogcmFuZG9tVVVJRCgpLFxuICAgICAgbG9nR3JvdXBOYW1lOiAnJyxcbiAgICAgIGxvZ1N0cmVhbU5hbWU6ICcnLFxuICAgICAgZ2V0UmVtYWluaW5nVGltZUluTWlsbGlzOiAoKSA9PiAzMDAwMFxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtYXRoQnJhaW5GdW5jdGlvbi5oYW5kbGVyKGV2ZW50LCBjb250ZXh0KTtcbiAgICBcbiAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShyZXN1bHQuYm9keSwge1xuICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHJlc3VsdC5oZWFkZXJzIHx8IHt9KVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignQXN0cm9sb2d5IE1hdGhCcmFpbiBBUEkgZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyxcbiAgICAgIGNvZGU6ICdBU1RST0xPR1lfQVBJX0VSUk9SJ1xuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIE9QVElPTlMocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZScsXG4gICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnOiAnR0VULCBQT1NULCBPUFRJT05TJ1xuICB9O1xuICBcbiAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UoJycsIHsgXG4gICAgc3RhdHVzOiAyMDAsIFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMgYXMgYW55KVxuICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJyYW5kb21VVUlEIiwibWF0aEJyYWluRnVuY3Rpb24iLCJyZXF1aXJlIiwiR0VUIiwicmVxdWVzdCIsInVybCIsIlVSTCIsImhlYWRlcnMiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJldmVudCIsImh0dHBNZXRob2QiLCJxdWVyeVN0cmluZ1BhcmFtZXRlcnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInNlYXJjaFBhcmFtcyIsImJvZHkiLCJwYXRoIiwicGF0aG5hbWUiLCJwYXRoUGFyYW1ldGVycyIsInJlcXVlc3RDb250ZXh0IiwicmVzb3VyY2UiLCJzdGFnZVZhcmlhYmxlcyIsImlzQmFzZTY0RW5jb2RlZCIsImNvbnRleHQiLCJjYWxsYmFja1dhaXRzRm9yRW1wdHlFdmVudExvb3AiLCJmdW5jdGlvbk5hbWUiLCJmdW5jdGlvblZlcnNpb24iLCJpbnZva2VkRnVuY3Rpb25Bcm4iLCJtZW1vcnlMaW1pdEluTUIiLCJhd3NSZXF1ZXN0SWQiLCJsb2dHcm91cE5hbWUiLCJsb2dTdHJlYW1OYW1lIiwiZ2V0UmVtYWluaW5nVGltZUluTWlsbGlzIiwicmVzdWx0IiwiaGFuZGxlciIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJIZWFkZXJzIiwiZXJyb3IiLCJjb25zb2xlIiwianNvbiIsInN1Y2Nlc3MiLCJjb2RlIiwiUE9TVCIsInJhdyIsImNhdGNoIiwibWFwSG91c2VTeXN0ZW0iLCJoIiwidW5kZWZpbmVkIiwibmFtZSIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwibWFwIiwicGxhY2lkdXMiLCJ3aG9sZV9zaWduIiwid2hvbGVzaWduIiwicmVnaW9tb250YW51cyIsImtvY2giLCJjYW1wYW51cyIsImVxdWFsIiwicGlja05hdGlvbiIsInN1YmplY3QiLCJiaXJ0aCIsIm5hdGlvbiIsImNvdW50cnkiLCJjb3VudHJ5X2NvZGUiLCJuYXRpb25fY29kZSIsInRyYW5zZm9ybSIsImlucHV0Iiwic3ViamVjdEEiLCJzdWJqZWN0QiIsIkpTT04iLCJzdHJpbmdpZnkiLCJhIiwiYiIsImJpcnRoQSIsImJpcnRoQiIsInRvUGVyc29uIiwibG9jYWwiLCJ5ZWFyIiwicGFyc2VJbnQiLCJkYXRlIiwic3BsaXQiLCJtb250aCIsImRheSIsImhvdXIiLCJ0aW1lIiwibWludXRlIiwibGF0aXR1ZGUiLCJsYXQiLCJsb25naXR1ZGUiLCJsb24iLCJsbmciLCJ0aW1lem9uZSIsInR6IiwiY2l0eSIsInN0YXRlIiwiQV9sb2NhbCIsIkJfbG9jYWwiLCJwZXJzb25BIiwicGVyc29uQiIsInR4IiwidHJhbnNpdHMiLCJ3aW5kb3ciLCJmcm9tIiwidG8iLCJzdGFydCIsImVuZCIsInN0ZXAiLCJob3VzZXMiLCJvdXQiLCJtb2RlIiwicnQiLCJyZXBvcnRfdHlwZSIsImluY2x1ZGVzIiwicmVsb2NhdGlvbl9tb2RlIiwib3Jic19wcm9maWxlIiwiaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyIiwicmVsYXRpb25zaGlwX2NvbnRleHQiLCJyZWxhdGlvbnNoaXBDb250ZXh0IiwiT1BUSU9OUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/astrology-mathbrain/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/server/astrology-mathbrain.js":
/*!*******************************************!*\
  !*** ./lib/server/astrology-mathbrain.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// This code is a consolidated and cleaned version of the provided Javascript for interacting with the Astrologer API.\n// It is ready to be used as a serverless function handler (e.g., in a Node.js environment).\n\nconst { aggregate } = __webpack_require__(/*! ../../src/seismograph */ \"(rsc)/./src/seismograph.js\");\nconst { _internals: seismoInternals } = __webpack_require__(/*! ../../src/seismograph */ \"(rsc)/./src/seismograph.js\");\nconst { computeSFD, computeBalanceValence } = __webpack_require__(/*! ../../src/balance-meter */ \"(rsc)/./src/balance-meter.js\");\nconst API_BASE_URL = \"https://astrologer.p.rapidapi.com\";\nconst API_ENDPOINTS = {\n    BIRTH_CHART: `${API_BASE_URL}/api/v4/birth-chart`,\n    NATAL_ASPECTS_DATA: `${API_BASE_URL}/api/v4/natal-aspects-data`,\n    SYNASTRY_CHART: `${API_BASE_URL}/api/v4/synastry-chart`,\n    TRANSIT_CHART: `${API_BASE_URL}/api/v4/transit-chart`,\n    TRANSIT_ASPECTS: `${API_BASE_URL}/api/v4/transit-aspects-data`,\n    SYNASTRY_ASPECTS: `${API_BASE_URL}/api/v4/synastry-aspects-data`,\n    BIRTH_DATA: `${API_BASE_URL}/api/v4/birth-data`,\n    NOW: `${API_BASE_URL}/api/v4/now`,\n    COMPOSITE_ASPECTS: `${API_BASE_URL}/api/v4/composite-aspects-data`\n};\n// Simplified logging utility to avoid external dependencies\nconst { mapT2NAspects } = __webpack_require__(/*! ../../src/raven-lite-mapper */ \"(rsc)/./src/raven-lite-mapper.js\");\nconst { composeWovenMapReport } = __webpack_require__(/*! ../../src/reporters/woven-map-composer */ \"(rsc)/./src/reporters/woven-map-composer.js\");\nconst logger = {\n    log: (...args)=>console.log(`[LOG]`, ...args),\n    info: (...args)=>console.info(`[INFO]`, ...args),\n    warn: (...args)=>console.warn(`[WARN]`, ...args),\n    error: (...args)=>console.error(`[ERROR]`, ...args),\n    debug: (...args)=>process.env.LOG_LEVEL === \"debug\" && console.debug(`[DEBUG]`, ...args)\n};\n// --- DATA-ONLY HELPERS (drop-in) ---\nfunction stripGraphicsDeep(obj) {\n    if (!obj || typeof obj !== \"object\") return obj;\n    const kill = new Set([\n        \"wheel\",\n        \"svg\",\n        \"image\",\n        \"images\",\n        \"chart_image\",\n        \"graphical\",\n        \"png\",\n        \"jpg\",\n        \"jpeg\",\n        \"pdf\",\n        \"wheel_url\",\n        \"image_url\",\n        \"chartUrl\",\n        \"rendered_svg\",\n        \"rendered_png\"\n    ]);\n    if (Array.isArray(obj)) return obj.map(stripGraphicsDeep);\n    const out = {};\n    for (const [k, v] of Object.entries(obj)){\n        if (kill.has(k)) continue;\n        if (v && typeof v === \"object\") {\n            out[k] = stripGraphicsDeep(v);\n        } else {\n            out[k] = v;\n        }\n    }\n    return out;\n}\n// Provenance constants\nconst MATH_BRAIN_VERSION = \"0.2.1\"; // Single source of truth for version\nconst EPHEMERIS_SOURCE = \"AstrologerAPI-v4\";\nconst CALIBRATION_BOUNDARY = \"2025-09-05\";\nfunction normalizeStep(step) {\n    const s = String(step || \"\").toLowerCase();\n    if ([\n        \"daily\",\n        \"weekly\",\n        \"monthly\"\n    ].includes(s)) return s;\n    if (s === \"1d\") return \"daily\";\n    if (s === \"7d\") return \"weekly\";\n    if (s === \"1m\" || s === \"1mo\" || s === \"monthly\") return \"monthly\";\n    return \"daily\";\n}\n// Timezone normalization for common aliases and US/* forms\nfunction normalizeTimezone(tz) {\n    if (!tz || typeof tz !== \"string\") return tz;\n    const t = tz.trim();\n    const map = {\n        // US area aliases\n        \"US/Eastern\": \"America/New_York\",\n        \"US/Central\": \"America/Chicago\",\n        \"US/Mountain\": \"America/Denver\",\n        \"US/Pacific\": \"America/Los_Angeles\",\n        \"US/Arizona\": \"America/Phoenix\",\n        \"US/Alaska\": \"America/Anchorage\",\n        \"US/Hawaii\": \"Pacific/Honolulu\",\n        \"US/East-Indiana\": \"America/Indiana/Indianapolis\",\n        // Abbreviations (best-effort; DST not inferred, but upstream only needs IANA ID)\n        \"EST\": \"America/New_York\",\n        \"EDT\": \"America/New_York\",\n        \"CST\": \"America/Chicago\",\n        \"CDT\": \"America/Chicago\",\n        \"MST\": \"America/Denver\",\n        \"MDT\": \"America/Denver\",\n        \"PST\": \"America/Los_Angeles\",\n        \"PDT\": \"America/Los_Angeles\",\n        \"AKST\": \"America/Anchorage\",\n        \"AKDT\": \"America/Anchorage\",\n        \"HST\": \"Pacific/Honolulu\"\n    };\n    return map[t] || t;\n}\n// Derive time provenance for a subject based on presence of hour/minute\nfunction deriveTimeMeta(subject) {\n    const h = subject?.hour;\n    const m = subject?.minute;\n    const known = h !== undefined && h !== null && m !== undefined && m !== null;\n    const pad2 = (n)=>String(n).padStart(2, \"0\");\n    return {\n        birth_time_known: !!known,\n        time_precision: known ? \"exact\" : \"unknown\",\n        effective_time_used: known ? `${pad2(h)}:${pad2(m)}` : undefined\n    };\n}\n// Canonicalize an incoming time policy token\nfunction canonicalizeTimePolicy(raw) {\n    if (!raw) return \"user_provided\";\n    const t = String(raw).trim().toLowerCase();\n    if (t === \"planetary_only\" || t === \"planetary-only\" || t === \"planetary\") return \"planetary_only\";\n    if (t === \"whole_sign\" || t === \"whole-sign\" || t === \"wholesign\" || t === \"whole\") return \"whole_sign\";\n    if (t === \"sensitivity_scan\" || t === \"sensitivity-scan\" || t === \"scan\") return \"sensitivity_scan\";\n    return \"user_provided\";\n}\n// Derive time provenance but honor explicit time_policy when birth time is unknown\nfunction deriveTimeMetaWithPolicy(subject, timePolicy) {\n    const base = deriveTimeMeta(subject);\n    const unknown = !base.birth_time_known;\n    if (!unknown) return base;\n    const policy = canonicalizeTimePolicy(timePolicy);\n    if (policy === \"planetary_only\") {\n        return {\n            birth_time_known: false,\n            time_precision: \"unknown\",\n            effective_time_used: undefined\n        };\n    }\n    if (policy === \"whole_sign\") {\n        return {\n            birth_time_known: false,\n            time_precision: \"noon_fallback\",\n            effective_time_used: \"12:00\"\n        };\n    }\n    if (policy === \"sensitivity_scan\") {\n        return {\n            birth_time_known: false,\n            time_precision: \"range_scan\",\n            effective_time_used: undefined\n        };\n    }\n    return base;\n}\nfunction validateSubjectLean(s = {}) {\n    const req = [\n        \"year\",\n        \"month\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"latitude\",\n        \"longitude\"\n    ];\n    const missing = req.filter((k)=>s[k] === undefined || s[k] === null || s[k] === \"\");\n    return {\n        isValid: missing.length === 0,\n        message: missing.length ? `Missing: ${missing.join(\", \")}` : \"ok\"\n    };\n}\n// --- Helper Functions ---\n/**\n * Parses coordinate strings in various formats (DMS, decimal)\n * Accepts: \"40°1'N, 75°18'W\", \"40° 1' N, 75° 18' W\", optional seconds and unicode primes.\n * @param {string} coordString - Coordinate string.\n * @returns {{lat: number, lon: number}|null} Parsed coordinates or null\n */ function parseCoordinates(coordString) {\n    if (!coordString || typeof coordString !== \"string\") return null;\n    // Normalize common unicode variants\n    let s = coordString.trim().replace(/º/g, \"\\xb0\") // alt degree symbol\n    .replace(/[’′]/g, \"'\") // prime to apostrophe\n    .replace(/[”″]/g, '\"'); // double prime to quote\n    // Flexible DMS pattern with optional minutes/seconds and spaces\n    // Groups: 1=latDeg,2=latMin?,3=latSec?,4=latHem,5=lonDeg,6=lonMin?,7=lonSec?,8=lonHem\n    const DMS = /^\\s*(\\d{1,3})(?:\\s*°\\s*(\\d{1,2})(?:['\"]?\\s*([\\d.]+))?)?\\s*([NS])\\s*,\\s*(\\d{1,3})(?:\\s*°\\s*(\\d{1,2})(?:['\"]?\\s*([\\d.]+))?)?\\s*([EW])\\s*$/i;\n    const m = DMS.exec(s);\n    if (m) {\n        const dmsToDec = (d, m, sec, hem)=>{\n            const deg = parseInt(d, 10) || 0;\n            const min = parseInt(m || \"0\", 10) || 0;\n            const secF = parseFloat(sec || \"0\") || 0;\n            let val = deg + min / 60 + secF / 3600;\n            if (/S|W/i.test(hem)) val *= -1;\n            return val;\n        };\n        const lat = dmsToDec(m[1], m[2], m[3], m[4]);\n        const lon = dmsToDec(m[5], m[6], m[7], m[8]);\n        if (isFinite(lat) && isFinite(lon) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {\n            logger.info(\"Parsed DMS coordinates\", {\n                input: coordString,\n                output: {\n                    lat,\n                    lon\n                }\n            });\n            return {\n                lat,\n                lon\n            };\n        }\n    }\n    // Decimal fallback: \"40.0167, -75.3000\"\n    const DEC = /^\\s*(-?\\d+(?:\\.\\d+)?)\\s*,\\s*(-?\\d+(?:\\.\\d+)?)\\s*$/;\n    const d = DEC.exec(s);\n    if (d) {\n        const lat = parseFloat(d[1]);\n        const lon = parseFloat(d[2]);\n        if (isFinite(lat) && isFinite(lon) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {\n            return {\n                lat,\n                lon\n            };\n        }\n    }\n    return null;\n}\n/**\n * Builds standard headers for API requests.\n * @returns {Object} Headers object.\n * @throws {Error} if the RapidAPI key is not configured.\n */ function buildHeaders() {\n    const key = process.env.RAPIDAPI_KEY;\n    if (!key) {\n        throw new Error(\"RAPIDAPI_KEY environment variable is not configured.\");\n    }\n    return {\n        \"content-type\": \"application/json\",\n        \"x-rapidapi-key\": key,\n        \"x-rapidapi-host\": \"astrologer.p.rapidapi.com\"\n    };\n}\n/**\n * Validates a subject object for all required fields.\n * @param {Object} subject - The subject data to validate.\n * @returns {{isValid: boolean, message: string}}\n */ function validateSubject(subject) {\n    const baseReq = [\n        \"year\",\n        \"month\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"name\",\n        \"zodiac_type\"\n    ];\n    const baseMissing = baseReq.filter((f)=>subject[f] === undefined || subject[f] === null || subject[f] === \"\");\n    // Accept either coords-mode OR city-mode\n    const hasCoords = typeof subject.latitude === \"number\" && typeof subject.longitude === \"number\" && !!subject.timezone;\n    const hasCity = !!(subject.city && subject.nation);\n    const okMode = hasCoords || hasCity;\n    const modeMsg = okMode ? \"\" : \"coords(lat,lon,timezone) OR city,nation required\";\n    const missingMsg = baseMissing.length ? `Missing: ${baseMissing.join(\", \")}` : \"\";\n    return {\n        isValid: baseMissing.length === 0 && okMode,\n        message: [\n            missingMsg,\n            modeMsg\n        ].filter(Boolean).join(\"; \") || \"ok\"\n    };\n}\n/**\n * Normalizes subject data from various input formats to the API's `SubjectModel`.\n * @param {Object} data - Raw subject data.\n * @returns {Object} Normalized subject model.\n */ function normalizeSubjectData(data) {\n    if (!data || typeof data !== \"object\") return {};\n    const normalized = {\n        name: data.name || \"Subject\",\n        year: data.year,\n        month: data.month,\n        day: data.day,\n        hour: data.hour,\n        minute: data.minute,\n        city: data.city,\n        nation: data.nation,\n        latitude: data.latitude ?? data.lat,\n        longitude: data.longitude ?? data.lon ?? data.lng,\n        timezone: normalizeTimezone(data.timezone || data.tz_str),\n        zodiac_type: data.zodiac_type || data.zodiac || \"Tropic\"\n    };\n    // Convert legacy fields\n    if (data.date) {\n        const [m, d, y] = data.date.split(\"-\").map(Number);\n        normalized.year = normalized.year || y;\n        normalized.month = normalized.month || m;\n        normalized.day = normalized.day || d;\n    }\n    if (data.time) {\n        const [h, min] = data.time.split(\":\").map(Number);\n        normalized.hour = normalized.hour || h;\n        normalized.minute = normalized.minute || min;\n    }\n    // Support birth_date / birth_time aliases\n    if (data.birth_date && (!normalized.year || !normalized.month || !normalized.day)) {\n        try {\n            const [y, m, d] = String(data.birth_date).split(\"-\").map(Number);\n            if (y && m && d) {\n                normalized.year = y;\n                normalized.month = m;\n                normalized.day = d;\n            }\n        } catch (_) {}\n    }\n    if (data.birth_time && (!normalized.hour || !normalized.minute)) {\n        try {\n            const [h, min] = String(data.birth_time).split(\":\").map(Number);\n            if (h !== undefined && min !== undefined) {\n                normalized.hour = h;\n                normalized.minute = min;\n            }\n        } catch (_) {}\n    }\n    // City / Country aliases\n    if (!normalized.city) {\n        normalized.city = data.birth_city || data.city_name || data.town || normalized.city;\n    }\n    if (!normalized.nation) {\n        normalized.nation = data.birth_country || data.country || data.country_code || normalized.nation;\n    }\n    // Timezone aliases\n    if (!normalized.timezone) {\n        normalized.timezone = normalizeTimezone(data.offset || data.tz || data.tzid || data.time_zone || normalized.timezone);\n    }\n    if (data.coordinates) {\n        const [lat, lng] = data.coordinates.split(\",\").map((s)=>parseFloat(s.trim()));\n        normalized.latitude = normalized.latitude || lat;\n        normalized.longitude = normalized.longitude || lng;\n    }\n    // Handle coordinate parsing using the enhanced parseCoordinates function\n    if (!normalized.latitude || !normalized.longitude) {\n        // Check various field names for coordinate data\n        const coordFields = [\n            \"astro\",\n            \"coords\",\n            \"coordinate\",\n            \"coord\",\n            \"location\"\n        ];\n        let coordString = null;\n        for (const field of coordFields){\n            if (data[field] && typeof data[field] === \"string\") {\n                coordString = data[field];\n                break;\n            }\n        }\n        // If we found a coordinate string, parse it\n        if (coordString) {\n            try {\n                const parsed = parseCoordinates(coordString);\n                if (parsed && parsed.lat !== undefined && parsed.lon !== undefined) {\n                    normalized.latitude = normalized.latitude ?? parsed.lat;\n                    normalized.longitude = normalized.longitude ?? parsed.lon;\n                    logger.info(\"Coordinate parsing successful\", {\n                        input: coordString,\n                        output: {\n                            lat: parsed.lat,\n                            lon: parsed.lon\n                        }\n                    });\n                } else {\n                    logger.warn(\"Coordinate parsing failed\", {\n                        input: coordString\n                    });\n                }\n            } catch (error) {\n                logger.error(\"Coordinate parsing error\", {\n                    error: error.message,\n                    input: coordString\n                });\n            }\n        }\n    }\n    // If lat/lon are still strings, try to parse them individually\n    if (typeof normalized.latitude === \"string\" || typeof normalized.longitude === \"string\") {\n        try {\n            const coordString = `${normalized.latitude},${normalized.longitude}`;\n            const parsed = parseCoordinates(coordString);\n            if (parsed && parsed.lat !== undefined && parsed.lon !== undefined) {\n                normalized.latitude = parsed.lat;\n                normalized.longitude = parsed.lon;\n                logger.info(\"Individual coordinate parsing successful\", {\n                    input: coordString,\n                    output: {\n                        lat: parsed.lat,\n                        lon: parsed.lon\n                    }\n                });\n            }\n        } catch (error) {\n            logger.error(\"Individual coordinate parsing error\", {\n                error: error.message,\n                lat: normalized.latitude,\n                lon: normalized.longitude\n            });\n        }\n    }\n    return normalized;\n}\n/**\n * Convert internal normalized subject shape to Astrologer API Subject Model.\n * Internal uses latitude, longitude, timezone; API expects lat, lng, tz_str.\n * Keeps core birth fields and optional houses_system_identifier.\n * @param {Object} s - Internal subject\n * @param {Object} pass - Optional pass-through config (may include houses_system_identifier)\n * @returns {Object} API SubjectModel\n */ function subjectToAPI(s = {}, pass = {}) {\n    if (!s) return {};\n    const hasCoords = (typeof s.latitude === \"number\" || typeof s.lat === \"number\") && (typeof s.longitude === \"number\" || typeof s.lon === \"number\" || typeof s.lng === \"number\") && (s.timezone || s.tz_str);\n    const hasCity = !!(s.city && s.nation);\n    const tzNorm = normalizeTimezone(s.timezone || s.tz_str);\n    const apiSubject = {\n        name: s.name,\n        year: s.year,\n        month: s.month,\n        day: s.day,\n        hour: s.hour,\n        minute: s.minute,\n        zodiac_type: s.zodiac_type || \"Tropic\"\n    };\n    // Send coordinates if available (API expects lat/lng/tz_str field names)\n    const includeCoords = hasCoords && !pass.force_city_mode && !pass.suppress_coords;\n    if (includeCoords) {\n        apiSubject.lat = s.latitude ?? s.lat;\n        apiSubject.lng = s.longitude ?? s.lon ?? s.lng;\n        apiSubject.tz_str = tzNorm;\n    }\n    // Send city/nation when requested or when coords are absent\n    // Notes: Some natal endpoints validate presence of city field even if lat/lng/tz provided.\n    // pass.require_city forces inclusion alongside coords; we avoid adding geonames_username\n    // when coords are present to reduce resolver ambiguity.\n    const wantCity = hasCity && (pass.require_city || !includeCoords);\n    if (wantCity) {\n        apiSubject.city = s.state ? `${s.city}, ${s.state}` : s.city;\n        apiSubject.nation = s.nation;\n        // Only include geonames_username when operating in pure city mode (no coords) unless explicitly forced\n        if ((!includeCoords || pass.force_city_mode) && process.env.GEONAMES_USERNAME && !pass?.suppress_geonames) {\n            apiSubject.geonames_username = process.env.GEONAMES_USERNAME;\n        }\n    }\n    const hsys = s.houses_system_identifier || pass.houses_system_identifier;\n    if (hsys) apiSubject.houses_system_identifier = hsys;\n    return apiSubject;\n}\n// Helper: call natal endpoints with formation fallback\nasync function callNatal(endpoint, subject, headers, pass = {}, description = \"Natal call\") {\n    const canUseGeo = !!process.env.GEONAMES_USERNAME && !!(subject.city && subject.nation);\n    if (canUseGeo) {\n        // Attempt 1: city + GeoNames (preferred per integration notes)\n        const payloadCityWithGeo = {\n            subject: subjectToAPI(subject, {\n                ...pass,\n                require_city: true,\n                force_city_mode: true,\n                suppress_coords: true,\n                suppress_geonames: false\n            })\n        };\n        try {\n            return await apiCallWithRetry(endpoint, {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify(payloadCityWithGeo)\n            }, `${description} (city+geonames)`);\n        } catch (e0) {\n        // Fall through to coords-only\n        }\n    }\n    // Attempt 2: coords-only (no city, no geonames)\n    const payloadCoords = {\n        subject: subjectToAPI(subject, {\n            ...pass,\n            require_city: false,\n            force_city_mode: false,\n            suppress_geonames: true\n        })\n    };\n    try {\n        return await apiCallWithRetry(endpoint, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(payloadCoords)\n        }, description);\n    } catch (e1) {\n        const canTryCity = !!(subject.city && subject.nation);\n        const is4xx = e1 && e1.code === \"CLIENT_ERROR\" && e1.status >= 400 && e1.status < 500;\n        if (!is4xx || !canTryCity) throw e1;\n        // Attempt 3: city-only without GeoNames (for providers that accept free-text city)\n        const payloadCityNoGeo = {\n            subject: subjectToAPI(subject, {\n                ...pass,\n                require_city: true,\n                force_city_mode: true,\n                suppress_coords: true,\n                suppress_geonames: true\n            })\n        };\n        return await apiCallWithRetry(endpoint, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(payloadCityNoGeo)\n        }, `${description} (city-only)`);\n    }\n}\n// ---- Aspect Filtering & Hook Extraction (refined) ----\n// Aspect classes\nconst ASPECT_CLASS = {\n    major: new Set([\n        \"conjunction\",\n        \"opposition\",\n        \"square\",\n        \"trine\",\n        \"sextile\"\n    ]),\n    minor: new Set([\n        \"quincunx\",\n        \"sesquiquadrate\",\n        \"semi-square\",\n        \"semi-sextile\"\n    ]),\n    harmonic: new Set([\n        \"quintile\",\n        \"biquintile\"\n    ])\n};\n// Orb caps by aspect (geometry constraint) — aligned to spec\nconst ASPECT_ORB_CAPS = {\n    conjunction: 8,\n    opposition: 8,\n    square: 7,\n    trine: 7,\n    sextile: 5,\n    quincunx: 3,\n    sesquiquadrate: 3,\n    \"semi-square\": 2,\n    \"semi-sextile\": 2,\n    quintile: 2,\n    biquintile: 2\n};\n// Orb caps by body class (slower bodies tolerate larger orbs for the same structural salience)\nconst BODY_CLASS_CAPS = {\n    luminary: 12,\n    personal: 8,\n    social: 7,\n    outer: 6,\n    angle: 8,\n    point: 5,\n    other: 6\n};\nconst RETURN_BODIES = new Set([\n    \"Saturn\",\n    \"Jupiter\",\n    \"Chiron\",\n    \"Mean_Node\",\n    \"Mean_South_Node\",\n    \"True_Node\",\n    \"True_South_Node\"\n]);\nconst POINT_BODIES = new Set([\n    \"Ascendant\",\n    \"Medium_Coeli\",\n    \"Descendant\",\n    \"Imum_Coeli\",\n    \"Mean_Node\",\n    \"True_Node\",\n    \"Mean_South_Node\",\n    \"True_South_Node\",\n    \"Chiron\",\n    \"Mean_Lilith\"\n]); // Ensure True nodes & all angles included\nfunction classifyAspectName(name) {\n    if (ASPECT_CLASS.major.has(name)) return \"major\";\n    if (ASPECT_CLASS.minor.has(name)) return \"minor\";\n    if (ASPECT_CLASS.harmonic.has(name)) return \"harmonic\";\n    return \"other\";\n}\n// Hard-cap adjustments\nconst PERSONAL_SET = new Set([\n    \"Sun\",\n    \"Moon\",\n    \"Mercury\",\n    \"Venus\",\n    \"Mars\"\n]);\nconst OUTER_SET = new Set([\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n    \"Pluto\"\n]);\nfunction adjustOrbCapForSpecials(baseCap, p1, p2) {\n    let cap = baseCap;\n    if (p1 === \"Moon\" || p2 === \"Moon\") cap += 1; // Moon +1°\n    const outerPersonal = OUTER_SET.has(p1) && PERSONAL_SET.has(p2) || OUTER_SET.has(p2) && PERSONAL_SET.has(p1);\n    if (outerPersonal) cap -= 1; // Outer → personal −1°\n    if (cap < 1) cap = 1;\n    return cap;\n}\nfunction bodyClass(name) {\n    switch(name){\n        case \"Sun\":\n        case \"Moon\":\n            return \"luminary\";\n        case \"Mercury\":\n        case \"Venus\":\n        case \"Mars\":\n            return \"personal\";\n        case \"Jupiter\":\n        case \"Saturn\":\n            return \"social\";\n        case \"Uranus\":\n        case \"Neptune\":\n        case \"Pluto\":\n            return \"outer\";\n        case \"Ascendant\":\n        case \"Medium_Coeli\":\n        case \"Descendant\":\n        case \"Imum_Coeli\":\n            return \"angle\";\n        case \"Chiron\":\n        case \"Mean_Node\":\n        case \"True_Node\":\n        case \"Mean_South_Node\":\n        case \"True_South_Node\":\n        case \"Mean_Lilith\":\n            return \"point\";\n        default:\n            return \"other\";\n    }\n}\nfunction displayBodyName(raw) {\n    const map = {\n        \"Medium_Coeli\": \"MC\",\n        \"Imum_Coeli\": \"IC\",\n        \"Mean_Node\": \"North Node\",\n        \"Mean_South_Node\": \"South Node\",\n        \"True_Node\": \"North Node (True)\",\n        \"True_South_Node\": \"South Node (True)\",\n        \"Mean_Lilith\": \"Lilith\"\n    };\n    return map[raw] || raw;\n}\nfunction weightAspect(a) {\n    const base = a._class === \"major\" ? 1.0 : a._class === \"minor\" ? 0.55 : a._class === \"harmonic\" ? 0.45 : 0.4;\n    const aspectCap = ASPECT_ORB_CAPS[a._aspect] || 6;\n    const classCapTransit = BODY_CLASS_CAPS[bodyClass(a.p1_name)] || 6;\n    const classCapNatal = BODY_CLASS_CAPS[bodyClass(a.p2_name)] || 6;\n    let effectiveCap = Math.min(aspectCap, Math.max(classCapTransit, classCapNatal));\n    effectiveCap = adjustOrbCapForSpecials(effectiveCap, a.p1_name, a.p2_name);\n    const tightness = a._orb != null ? Math.max(0, 1 - a._orb / effectiveCap) : 0;\n    const lumOrAngle = a.p1_isLuminary || a.p2_isLuminary || a.p1_isAngle || a.p2_isAngle ? 1.15 : 1.0;\n    return +(base * tightness * lumOrAngle).toFixed(4);\n}\nfunction enrichDailyAspects(rawList) {\n    if (!Array.isArray(rawList)) return {\n        raw: [],\n        filtered: [],\n        hooks: [],\n        rejections: [],\n        counts: {\n            raw: 0,\n            filtered: 0,\n            hooks: 0\n        }\n    };\n    const enriched = [];\n    const rejections = [];\n    for (const a of rawList){\n        const aspectName = (a.aspect || \"\").toLowerCase();\n        const orb = typeof a.orbit === \"number\" ? a.orbit : typeof a.orb === \"number\" ? a.orb : null;\n        const p1 = a.p1_name;\n        const p2 = a.p2_name;\n        const sameBody = p1 === p2;\n        const cls = classifyAspectName(aspectName);\n        const p1Class = bodyClass(p1);\n        const p2Class = bodyClass(p2);\n        const aspectCap = ASPECT_ORB_CAPS[aspectName] || 6;\n        const classCap = Math.max(BODY_CLASS_CAPS[p1Class] || 6, BODY_CLASS_CAPS[p2Class] || 6);\n        let effectiveCap = Math.min(aspectCap, classCap);\n        effectiveCap = adjustOrbCapForSpecials(effectiveCap, p1, p2);\n        let dropReason = \"\";\n        if (sameBody) {\n            if (![\n                \"conjunction\",\n                \"opposition\"\n            ].includes(aspectName)) dropReason = \"OUT_OF_CAP\"; // treat non-return self aspect as out-of-scope\n            else if (!(RETURN_BODIES.has(p1) || [\n                \"Sun\",\n                \"Moon\"\n            ].includes(p1))) dropReason = \"OUT_OF_CAP\";\n        }\n        if (!dropReason && orb != null && orb > effectiveCap) dropReason = \"OUT_OF_CAP\";\n        const rec = {\n            ...a,\n            _aspect: aspectName,\n            _orb: orb,\n            _class: cls,\n            _sameBody: sameBody,\n            p1_display: displayBodyName(p1),\n            p2_display: displayBodyName(p2),\n            p1_isLuminary: [\n                \"Sun\",\n                \"Moon\"\n            ].includes(p1),\n            p2_isLuminary: [\n                \"Sun\",\n                \"Moon\"\n            ].includes(p2),\n            p1_isAngle: [\n                \"Ascendant\",\n                \"Medium_Coeli\",\n                \"Descendant\",\n                \"Imum_Coeli\"\n            ].includes(p1),\n            p2_isAngle: [\n                \"Ascendant\",\n                \"Medium_Coeli\",\n                \"Descendant\",\n                \"Imum_Coeli\"\n            ].includes(p2),\n            p1_class: p1Class,\n            p2_class: p2Class,\n            effective_cap: effectiveCap\n        };\n        if (dropReason) {\n            rejections.push({\n                aspect: `${p1} ${aspectName} ${p2}`,\n                reason: dropReason,\n                orb\n            });\n        } else {\n            rec._weight = weightAspect(rec);\n            enriched.push(rec);\n        }\n    }\n    // Post-weight filtering for weak weight\n    const strong = [];\n    for (const r of enriched){\n        if ((r._weight || 0) < 0.15) {\n            rejections.push({\n                aspect: `${r.p1_name} ${r._aspect} ${r.p2_name}`,\n                reason: \"WEAK_WEIGHT\",\n                orb: r._orb\n            });\n        } else strong.push(r);\n    }\n    // Diversity & duplicate pair filtering\n    const pairSeen = new Set();\n    const primaryCounts = new Map(); // luminary + angle dominance guard\n    const filtered = [];\n    for (const r of strong){\n        const pairKey = [\n            r.p1_name,\n            r.p2_name\n        ].sort().join(\"|\") + \"|\" + r._aspect;\n        if (pairSeen.has(pairKey)) {\n            rejections.push({\n                aspect: `${r.p1_name} ${r._aspect} ${r.p2_name}`,\n                reason: \"DUPLICATE_PAIR\",\n                orb: r._orb\n            });\n            continue;\n        }\n        pairSeen.add(pairKey);\n        const primaries = [];\n        if (r.p1_isLuminary || r.p1_isAngle) primaries.push(r.p1_name);\n        if (r.p2_isLuminary || r.p2_isAngle) primaries.push(r.p2_name);\n        let primaryDup = false;\n        for (const p of primaries){\n            const c = (primaryCounts.get(p) || 0) + 1;\n            primaryCounts.set(p, c);\n            if (c > 3) {\n                primaryDup = true;\n            }\n        }\n        if (primaryDup) {\n            rejections.push({\n                aspect: `${r.p1_name} ${r._aspect} ${r.p2_name}`,\n                reason: \"PRIMARY_DUP\",\n                orb: r._orb\n            });\n            continue;\n        }\n        filtered.push(r);\n    }\n    // Hook selection prioritisation\n    const hookCandidates = filtered.filter((a)=>{\n        const orb = a._orb != null ? a._orb : 6.01;\n        const isExact = orb <= 0.5;\n        const isTight = orb <= 1.5;\n        const isLum = a.p1_isLuminary || a.p2_isLuminary;\n        const isAngle = a.p1_isAngle || a.p2_isAngle;\n        const isNodeChiron = [\n            \"Mean_Node\",\n            \"Mean_South_Node\",\n            \"Chiron\"\n        ].includes(a.p1_name) || [\n            \"Mean_Node\",\n            \"Mean_South_Node\",\n            \"Chiron\"\n        ].includes(a.p2_name);\n        if (isExact) return true;\n        if (isLum && orb <= 3) return true;\n        if (isAngle && orb <= 2.5) return true;\n        if (isNodeChiron && orb <= 2) return true;\n        if (a._class === \"major\" && isTight) return true;\n        return false;\n    });\n    const hooks = (hookCandidates.length ? hookCandidates : filtered.slice(0, 8)).slice().sort((a, b)=>{\n        const oa = a._orb ?? 6.01;\n        const ob = b._orb ?? 6.01;\n        const ea = oa <= 0.5;\n        const eb = ob <= 0.5;\n        if (ea !== eb) return ea ? -1 : 1;\n        const la = a.p1_isLuminary || a.p2_isLuminary;\n        const lb = b.p1_isLuminary || b.p2_isLuminary;\n        if (la !== lb) return la ? -1 : 1;\n        if (oa !== ob) return oa - ob;\n        return (b._weight || 0) - (a._weight || 0);\n    }).slice(0, 12);\n    return {\n        raw: rawList,\n        filtered,\n        hooks,\n        rejections,\n        counts: {\n            raw: rawList.length,\n            filtered: filtered.length,\n            hooks: hooks.length,\n            rejected: rejections.length\n        }\n    };\n}\n// Canonicalize incoming mode tokens: trim, uppercase, replace spaces/dashes with single underscore, collapse repeats\nfunction canonicalizeMode(raw) {\n    if (!raw) return \"\";\n    return raw.toString().trim().replace(/[-\\s]+/g, \"_\").replace(/__+/g, \"_\").toUpperCase();\n}\n// Build field-by-field validation map for strict subject requirements\nconst STRICT_REQUIRED_FIELDS = [\n    \"year\",\n    \"month\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"name\",\n    \"zodiac_type\"\n];\nfunction validateSubjectStrictWithMap(subject) {\n    const errors = {};\n    STRICT_REQUIRED_FIELDS.forEach((f)=>{\n        if (subject[f] === undefined || subject[f] === null || subject[f] === \"\") {\n            errors[f] = \"Missing or empty\";\n        }\n    });\n    return {\n        isValid: Object.keys(errors).length === 0,\n        errors\n    };\n}\n/**\n * Robustly calls an API endpoint with retry logic and error handling.\n * @param {string} url - The API endpoint URL.\n * @param {Object} options - Fetch options.\n * @param {string} operation - A description for logging.\n * @param {number} maxRetries - Max retry attempts.\n * @returns {Promise<Object>} The parsed JSON response.\n */ async function apiCallWithRetry(url, options, operation, maxRetries = 2) {\n    for(let attempt = 1; attempt <= maxRetries; attempt++){\n        try {\n            logger.debug(`API call attempt ${attempt}/${maxRetries} for ${operation}`);\n            const response = await fetch(url, options);\n            if (!response.ok) {\n                if (response.status >= 400 && response.status < 500 && response.status !== 429) {\n                    // Capture status + body once\n                    const status = response.status;\n                    let rawText = \"\";\n                    try {\n                        rawText = await response.text();\n                    } catch  {\n                        rawText = \"Unable to read response body\";\n                    }\n                    let parsedMessage = rawText;\n                    try {\n                        const j = JSON.parse(rawText);\n                        if (j.message) parsedMessage = j.message;\n                    } catch (_) {}\n                    // Special handling for auth/subscription issues\n                    if (status === 401 || status === 403) {\n                        const hint = parsedMessage && /not subscribed|unauthorized|invalid api key|api key is invalid/i.test(parsedMessage) ? \"Verify RAPIDAPI_KEY, subscription plan, and that the key matches this API.\" : \"Authentication / subscription issue likely.\";\n                        logger.error(\"RapidAPI auth/subscription error\", {\n                            status,\n                            operation,\n                            parsedMessage,\n                            hint\n                        });\n                        const err = new Error(`RapidAPI access denied (${status}): ${parsedMessage}. ${hint}`);\n                        err.code = \"RAPIDAPI_SUBSCRIPTION\";\n                        err.status = status;\n                        err.raw = rawText.slice(0, 1200);\n                        throw err;\n                    }\n                    logger.error(\"Client error (non-retryable)\", {\n                        status,\n                        operation,\n                        url,\n                        body: rawText.slice(0, 1200)\n                    });\n                    const err = new Error(`Client error ${status} for ${operation}`);\n                    err.code = \"CLIENT_ERROR\";\n                    err.status = status;\n                    err.raw = rawText.slice(0, 1200);\n                    throw err;\n                }\n                logger.warn(`API call failed with status ${response.status}. Retrying...`);\n                throw new Error(`Server error: ${response.status}`);\n            }\n            return response.json();\n        } catch (error) {\n            if (attempt === maxRetries || error.message.includes(\"Non-retryable\")) {\n                logger.error(`Failed after ${attempt} attempts: ${error.message}`, {\n                    url,\n                    operation,\n                    code: error.code,\n                    status: error.status\n                });\n                if (error.code === \"RAPIDAPI_SUBSCRIPTION\") throw error; // surface directly\n                if (error.code === \"CLIENT_ERROR\") throw error;\n                const err = new Error(`Service temporarily unavailable. Please try again later.`);\n                err.code = \"UPSTREAM_TEMPORARY\";\n                throw err;\n            }\n            const delay = Math.pow(2, attempt) * 100 + Math.random() * 100; // Exponential backoff\n            await new Promise((res)=>setTimeout(res, delay));\n        }\n    }\n}\n// --- Transit helpers ---\n// Coordinate parsing (supports DMS \"30°10'N\" and decimal)\nfunction parseCoordinate(val) {\n    if (typeof val === \"number\") return val;\n    if (typeof val !== \"string\") return null;\n    const dec = val.trim();\n    if (/^-?\\d+(?:\\.\\d+)?$/.test(dec)) return parseFloat(dec);\n    // DMS pattern e.g., 30°10'15\"N or 30°10'N\n    const dms = /^\\s*(\\d{1,3})[^0-9]+(\\d{1,2})?(?:[^0-9]+(\\d{1,2}(?:\\.\\d+)?))?\\s*([NnSsEeWw])\\s*$/.exec(dec);\n    if (dms) {\n        const d = +dms[1];\n        const m = dms[2] ? +dms[2] : 0;\n        const s = dms[3] ? +dms[3] : 0;\n        const hemi = dms[4];\n        const sign = /[SsWw]/.test(hemi) ? -1 : 1;\n        return sign * (d + m / 60 + s / 3600);\n    }\n    return null;\n}\nasync function getTransits(subject, transitParams, headers, pass = {}) {\n    if (!transitParams || !transitParams.startDate || !transitParams.endDate) return {};\n    const { buildWindowSamples } = __webpack_require__(/*! ../../lib/time-sampling */ \"(rsc)/./lib/time-sampling.js\");\n    const transitsByDate = {};\n    const retroFlagsByDate = {}; // body -> retro boolean per date\n    const provenanceByDate = {}; // per-day endpoint + formation provenance\n    // Determine sampling timezone: prefer subject.timezone, else UTC\n    const ianaTz = subject?.timezone || \"UTC\";\n    const step = normalizeStep(transitParams.step || \"daily\");\n    const samples = buildWindowSamples({\n        start: transitParams.startDate,\n        end: transitParams.endDate,\n        step\n    }, ianaTz);\n    const promises = [];\n    // Helper: ensure coords/tz from city using GeoNames when needed\n    async function ensureCoords(s) {\n        if (!s) return s;\n        const hasCoords = typeof s.latitude === \"number\" && typeof s.longitude === \"number\" && !!s.timezone;\n        if (hasCoords) return s;\n        if (s.city && s.nation) {\n            try {\n                const r = await geoResolve({\n                    city: s.city,\n                    state: s.state,\n                    nation: s.nation\n                });\n                if (r && typeof r.lat === \"number\" && typeof r.lon === \"number\") {\n                    return {\n                        ...s,\n                        latitude: r.lat,\n                        longitude: r.lon,\n                        timezone: normalizeTimezone(r.tz || s.timezone || \"UTC\")\n                    };\n                }\n            } catch (e) {\n                logger.warn(\"ensureCoords geoResolve failed\", e.message);\n            }\n        }\n        return {\n            ...s,\n            latitude: s.latitude ?? 51.48,\n            longitude: s.longitude ?? 0,\n            timezone: normalizeTimezone(s.timezone || \"UTC\")\n        };\n    }\n    // Determine a consistent formation approach up-front for the entire window\n    // Rule: if coords+tz present, use coords-only for all days; else use city-mode (with optional geonames_username)\n    const preferCoords = (typeof subject.latitude === \"number\" || typeof subject.lat === \"number\") && (typeof subject.longitude === \"number\" || typeof subject.lon === \"number\" || typeof subject.lng === \"number\") && !!(subject.timezone || subject.tz_str);\n    for (const sampleIso of samples){\n        const dt = new Date(sampleIso);\n        const dateString = sampleIso.slice(0, 10); // YYYY-MM-DD\n        // Transit instant: prefer city mode; fallback to coords resolved\n        const transit_subject = await async function() {\n            const base = {\n                year: dt.getUTCFullYear(),\n                month: dt.getUTCMonth() + 1,\n                day: dt.getUTCDate(),\n                hour: dt.getUTCHours(),\n                minute: dt.getUTCMinutes(),\n                zodiac_type: \"Tropic\"\n            };\n            if (preferCoords) {\n                const s = await ensureCoords(subject);\n                return {\n                    ...base,\n                    latitude: s.latitude,\n                    longitude: s.longitude,\n                    timezone: \"UTC\"\n                };\n            }\n            const cityField = subject.state ? `${subject.city}, ${subject.state}` : subject.city;\n            const t = {\n                ...base,\n                city: cityField,\n                nation: subject.nation\n            };\n            if (process.env.GEONAMES_USERNAME) t.geonames_username = process.env.GEONAMES_USERNAME;\n            return t;\n        }();\n        // Include configuration parameters for which planets to include\n        const payload = {\n            first_subject: subjectToAPI(subject, pass),\n            transit_subject: subjectToAPI(transit_subject, pass),\n            ...pass // Include active_points, active_aspects, etc.\n        };\n        logger.debug(`Transit API call for ${dateString}:`, {\n            active_points: payload.active_points || \"default\",\n            pass_keys: Object.keys(pass)\n        });\n        // Enhanced debug logging: Log full payload when debugging empty results\n        logger.debug(`Full transit API payload for ${dateString}:`, JSON.stringify(payload, null, 2));\n        promises.push((async ()=>{\n            let resp = null;\n            let endpoint = \"transit-aspects-data\";\n            let formation = transit_subject.city ? \"city\" : \"coords\";\n            let attempts = 0;\n            const maxAttempts = 3;\n            // Attempt 1: Primary endpoint - /transit-aspects-data\n            try {\n                resp = await apiCallWithRetry(API_ENDPOINTS.TRANSIT_ASPECTS, {\n                    method: \"POST\",\n                    headers,\n                    body: JSON.stringify(payload)\n                }, `Transits for ${subject.name} on ${dateString}`);\n                attempts++;\n                logger.debug(`Transit API response for ${dateString} (${endpoint}):`, {\n                    hasAspects: !!(resp && resp.aspects),\n                    aspectCount: resp && resp.aspects ? resp.aspects.length : 0,\n                    responseKeys: resp ? Object.keys(resp) : \"null response\",\n                    sample: resp && resp.aspects && resp.aspects.length > 0 ? resp.aspects[0] : \"no aspects\"\n                });\n            } catch (e) {\n                logger.warn(`Primary transit endpoint failed for ${dateString}:`, e.message);\n            }\n            // Attempt 2: Fallback to /transit-chart if no aspects found\n            if ((!resp || !resp.aspects || resp.aspects.length === 0) && attempts < maxAttempts) {\n                try {\n                    endpoint = \"transit-chart\";\n                    logger.info(`Fallback: Trying transit-chart endpoint for ${dateString}`);\n                    resp = await apiCallWithRetry(API_ENDPOINTS.TRANSIT_CHART, {\n                        method: \"POST\",\n                        headers,\n                        body: JSON.stringify(payload)\n                    }, `Transit chart fallback for ${subject.name} on ${dateString}`);\n                    attempts++;\n                    // Extract aspects from chart response structure\n                    if (resp && !resp.aspects && resp.data) {\n                        // Sometimes aspects are nested in data\n                        resp.aspects = resp.data.aspects || resp.aspects;\n                    }\n                    logger.debug(`Transit chart fallback response for ${dateString}:`, {\n                        hasAspects: !!(resp && resp.aspects),\n                        aspectCount: resp && resp.aspects ? resp.aspects.length : 0,\n                        responseKeys: resp ? Object.keys(resp) : \"null response\"\n                    });\n                } catch (e) {\n                    logger.warn(`Transit chart fallback failed for ${dateString}:`, e.message);\n                }\n            }\n            // Attempt 3: Try switching transit subject formation if still empty\n            if ((!resp || !resp.aspects || resp.aspects.length === 0) && attempts < maxAttempts) {\n                try {\n                    endpoint = \"formation-switch\";\n                    logger.info(`Formation switch: Trying alternate transit subject for ${dateString}`);\n                    // Switch between city mode and coords mode\n                    const alternateTransitSubject = await async function() {\n                        const base = {\n                            year: dt.getUTCFullYear(),\n                            month: dt.getUTCMonth() + 1,\n                            day: dt.getUTCDate(),\n                            hour: dt.getUTCHours(),\n                            minute: dt.getUTCMinutes(),\n                            zodiac_type: \"Tropic\"\n                        };\n                        // If original was city mode, try coords mode\n                        if (!preferCoords && subject.city && subject.nation) {\n                            const s = await ensureCoords(subject);\n                            return {\n                                ...base,\n                                latitude: s.latitude,\n                                longitude: s.longitude,\n                                timezone: \"UTC\"\n                            };\n                        }\n                        // If original was coords mode, try city mode with geonames\n                        const cityField = subject.state ? `${subject.city}, ${subject.state}` : subject.city || \"London\";\n                        const t = {\n                            ...base,\n                            city: cityField,\n                            nation: subject.nation || \"UK\"\n                        };\n                        if (process.env.GEONAMES_USERNAME) t.geonames_username = process.env.GEONAMES_USERNAME;\n                        return t;\n                    }();\n                    const alternatePayload = {\n                        first_subject: subjectToAPI(subject, pass),\n                        transit_subject: subjectToAPI(alternateTransitSubject, pass),\n                        ...pass\n                    };\n                    resp = await apiCallWithRetry(API_ENDPOINTS.TRANSIT_ASPECTS, {\n                        method: \"POST\",\n                        headers,\n                        body: JSON.stringify(alternatePayload)\n                    }, `Formation switch for ${subject.name} on ${dateString}`);\n                    attempts++;\n                    logger.debug(`Formation switch response for ${dateString}:`, {\n                        hasAspects: !!(resp && resp.aspects),\n                        aspectCount: resp && resp.aspects ? resp.aspects.length : 0,\n                        alternateFormation: alternateTransitSubject.city ? \"city-mode\" : \"coords-mode\"\n                    });\n                } catch (e) {\n                    logger.warn(`Formation switch failed for ${dateString}:`, e.message);\n                }\n            }\n            // Process successful response\n            if (resp && resp.aspects && resp.aspects.length > 0) {\n                transitsByDate[dateString] = resp.aspects;\n                provenanceByDate[dateString] = {\n                    endpoint,\n                    formation,\n                    attempts,\n                    aspect_count: resp.aspects.length\n                };\n                // Extract retro flags if available\n                const retroMap = {};\n                const fs = resp.data?.first_subject || resp.data?.firstSubject;\n                const tr = resp.data?.transit || resp.data?.transit_subject;\n                const collect = (block)=>{\n                    if (!block || typeof block !== \"object\") return;\n                    for (const [k, v] of Object.entries(block)){\n                        if (v && typeof v === \"object\" && \"retrograde\" in v) {\n                            retroMap[v.name || v.body || k] = !!v.retrograde;\n                        }\n                    }\n                };\n                collect(fs);\n                collect(tr);\n                if (Object.keys(retroMap).length) retroFlagsByDate[dateString] = retroMap;\n                logger.info(`✓ Success for ${dateString}: ${resp.aspects.length} aspects via ${endpoint} (attempts: ${attempts})`);\n            } else {\n                logger.warn(`✗ No aspects found for ${dateString} after ${attempts} attempts (endpoints: ${endpoint})`);\n                // Enhanced debug logging: Log full response when no aspects found\n                if (resp) {\n                    logger.debug(`Full raw API response for ${dateString} (no aspects):`, JSON.stringify(resp, null, 2));\n                }\n                provenanceByDate[dateString] = {\n                    endpoint,\n                    formation,\n                    attempts,\n                    aspect_count: 0\n                };\n            }\n        })().catch((e)=>logger.error(`Failed to get transits for ${dateString}`, e)));\n    }\n    await Promise.all(promises);\n    logger.debug(`getTransits completed for ${subject.name}:`, {\n        requestedDates: samples.length,\n        datesWithData: Object.keys(transitsByDate).length,\n        totalAspects: Object.values(transitsByDate).reduce((sum, aspects)=>sum + aspects.length, 0),\n        availableDates: Object.keys(transitsByDate)\n    });\n    return {\n        transitsByDate,\n        retroFlagsByDate,\n        provenanceByDate\n    };\n}\n// Geo resolve via GeoNames\nasync function geoResolve({ city, state, nation }) {\n    const u = process.env.GEONAMES_USERNAME || \"\";\n    const q = encodeURIComponent(state ? `${city}, ${state}` : city);\n    const c = encodeURIComponent(nation || \"\");\n    const searchUrl = `http://api.geonames.org/searchJSON?q=${q}&country=${c}&maxRows=1&username=${encodeURIComponent(u)}`;\n    const res1 = await fetch(searchUrl);\n    const j1 = await res1.json();\n    const g = j1 && Array.isArray(j1.geonames) && j1.geonames[0];\n    if (!g) return null;\n    const lat = parseFloat(g.lat), lon = parseFloat(g.lng);\n    let tz = null;\n    try {\n        const tzUrl = `http://api.geonames.org/timezoneJSON?lat=${lat}&lng=${lon}&username=${encodeURIComponent(u)}`;\n        const res2 = await fetch(tzUrl);\n        const j2 = await res2.json();\n        tz = j2 && (j2.timezoneId || j2.timezone || null);\n    } catch  {}\n    return {\n        lat,\n        lon,\n        tz\n    };\n}\n// Expose resolve-city endpoint helper\nexports.resolveCity = async function(event) {\n    const qs = event.queryStringParameters || {};\n    const city = qs.city || \"\";\n    const state = qs.state || \"\";\n    const nation = qs.nation || \"\";\n    try {\n        const r = await geoResolve({\n            city,\n            state,\n            nation\n        });\n        return {\n            statusCode: 200,\n            headers: {\n                \"content-type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                input: {\n                    city,\n                    state,\n                    nation\n                },\n                resolved: r\n            })\n        };\n    } catch (e) {\n        return {\n            statusCode: 500,\n            headers: {\n                \"content-type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                error: e.message\n            })\n        };\n    }\n};\n// --- Transit Table Formatting: Orb-Band + Phase + Score ---\nfunction formatTransitTable(enrichedAspects, prevDayAspects = null) {\n    if (!Array.isArray(enrichedAspects) || enrichedAspects.length === 0) {\n        return {\n            exact: [],\n            tight: [],\n            moderate: [],\n            wide: [],\n            markdown: \"No aspects for this date.\"\n        };\n    }\n    // Create lookup map for previous day's orbs to determine phase\n    const prevOrbMap = new Map();\n    if (prevDayAspects && Array.isArray(prevDayAspects)) {\n        for (const aspect of prevDayAspects){\n            const key = `${aspect.p1_name}|${aspect._aspect}|${aspect.p2_name}`;\n            prevOrbMap.set(key, aspect._orb);\n        }\n    }\n    // Process aspects with orb bands, phase, and score\n    const processedAspects = enrichedAspects.map((aspect)=>{\n        const orb = aspect._orb || 0;\n        const key = `${aspect.p1_name}|${aspect._aspect}|${aspect.p2_name}`;\n        const prevOrb = prevOrbMap.get(key);\n        // Determine phase: ↑ tightening (orb decreasing), ↓ separating (orb increasing)\n        let phase = \"—\"; // neutral/unknown\n        if (prevOrb != null && typeof prevOrb === \"number\") {\n            if (orb < prevOrb) phase = \"↑\"; // tightening\n            else if (orb > prevOrb) phase = \"↓\"; // separating\n        // if equal, keep neutral\n        }\n        // Calculate score using seismograph internals\n        const aspectForScore = {\n            transit: {\n                body: aspect.p1_name\n            },\n            natal: {\n                body: aspect.p2_name\n            },\n            type: aspect._aspect,\n            orbDeg: orb\n        };\n        const scored = seismoInternals.scoreAspect(aspectForScore, {\n            isAngleProx: aspect.p2_isAngle,\n            critical: false\n        });\n        return {\n            transit: aspect.p1_display || aspect.p1_name,\n            aspect: aspect._aspect,\n            natal: aspect.p2_display || aspect.p2_name,\n            orb: Number(orb.toFixed(1)),\n            phase: phase,\n            score: Number(scored.S.toFixed(2)),\n            _orbValue: orb // for sorting\n        };\n    });\n    // Sort by orb (tightest first)\n    processedAspects.sort((a, b)=>a._orbValue - b._orbValue);\n    // Group by orb bands\n    const exact = processedAspects.filter((a)=>a._orbValue <= 0.5);\n    const tight = processedAspects.filter((a)=>a._orbValue > 0.5 && a._orbValue <= 2.0);\n    const moderate = processedAspects.filter((a)=>a._orbValue > 2.0 && a._orbValue <= 6.0);\n    const wide = processedAspects.filter((a)=>a._orbValue > 6.0);\n    // Generate markdown table format\n    function createMarkdownTable(aspects, title) {\n        if (aspects.length === 0) return \"\";\n        let table = `\\n**${title}**\\n\\n`;\n        table += \"| Transit | Aspect | Natal | Orb (\\xb0) | Phase | Score |\\n\";\n        table += \"|---------|--------|-------|---------|--------|-------|\\n\";\n        for (const a of aspects){\n            table += `| ${a.transit} | ${a.aspect} | ${a.natal} | ${a.orb} | ${a.phase} | ${a.score >= 0 ? \"+\" : \"\"}${a.score} |\\n`;\n        }\n        return table;\n    }\n    let markdown = \"\";\n    if (exact.length > 0) markdown += createMarkdownTable(exact, \"⭐ Exact Aspects (≤0.5\\xb0)\");\n    if (tight.length > 0) markdown += createMarkdownTable(tight, \"\\uD83D\\uDD25 Tight Aspects (0.5\\xb0 - 2\\xb0)\");\n    if (moderate.length > 0) markdown += createMarkdownTable(moderate, \"\\uD83D\\uDCCA Moderate Aspects (2\\xb0 - 6\\xb0)\");\n    if (wide.length > 0) markdown += createMarkdownTable(wide, \"\\uD83C\\uDF2B️ Wide Aspects (>6\\xb0)\");\n    if (markdown === \"\") {\n        markdown = \"No aspects for this date.\";\n    }\n    return {\n        exact,\n        tight,\n        moderate,\n        wide,\n        markdown\n    };\n}\nfunction calculateSeismograph(transitsByDate, retroFlagsByDate = {}) {\n    if (!transitsByDate || Object.keys(transitsByDate).length === 0) {\n        return {\n            daily: {},\n            summary: {}\n        };\n    }\n    const days = Object.keys(transitsByDate).sort();\n    let prev = null;\n    let prevDayFiltered = null;\n    const daily = {};\n    const rollingMagnitudes = []; // Track for 14-day rolling window\n    const valenceHistory = []; // Track for trend analysis\n    for(let i = 0; i < days.length; i++){\n        const d = days[i];\n        const rawDayAspects = transitsByDate[d] || [];\n        const enriched = enrichDailyAspects(rawDayAspects);\n        // Enhance aspects with retrograde flags\n        const retroMap = retroFlagsByDate[d] || {};\n        const enrichedWithRetrograde = enriched.filtered.map((aspect)=>{\n            const p1r = retroMap[aspect.p1_name] ?? retroMap[aspect.p1_display] ?? false;\n            const p2r = retroMap[aspect.p2_name] ?? retroMap[aspect.p2_display] ?? false;\n            return {\n                ...aspect,\n                p1_retrograde: p1r,\n                p2_retrograde: p2r,\n                retrograde_involved: p1r || p2r\n            };\n        });\n        // Generate orb-band transit table with phase and score\n        const transitTable = formatTransitTable(enriched.filtered, prevDayFiltered);\n        const aspectsForAggregate = enriched.filtered.map((x)=>({\n                transit: {\n                    body: x.p1_name,\n                    retrograde: x.p1_retrograde\n                },\n                natal: {\n                    body: x.p2_name,\n                    retrograde: x.p2_retrograde,\n                    isAngleProx: [\n                        \"Ascendant\",\n                        \"Medium_Coeli\",\n                        \"Descendant\",\n                        \"Imum_Coeli\"\n                    ].includes(x.p2_name),\n                    isLuminary: [\n                        \"Sun\",\n                        \"Moon\"\n                    ].includes(x.p2_name),\n                    degCrit: false\n                },\n                type: x._aspect,\n                orbDeg: typeof x._orb === \"number\" ? x._orb : 6.01\n            }));\n        // Prepare rolling context for magnitude normalization\n        const rollingContext = rollingMagnitudes.length >= 1 ? {\n            magnitudes: [\n                ...rollingMagnitudes\n            ]\n        } : null;\n        const agg = aggregate(aspectsForAggregate, prev, {\n            rollingContext\n        });\n        // Determine scaling strategy and confidence\n        let scalingStrategy = \"prior\";\n        const nContext = rollingMagnitudes.length;\n        if (nContext >= 14) scalingStrategy = \"rolling\";\n        else if (nContext >= 2) scalingStrategy = \"blended\";\n        const scaleConfidence = Math.min(1, nContext / 14);\n        // Track rolling magnitudes using the original magnitude before normalization (keep last 14 days)\n        const magnitudeToTrack = agg.originalMagnitude || agg.rawMagnitude || agg.magnitude;\n        rollingMagnitudes.push(magnitudeToTrack);\n        if (rollingMagnitudes.length > 14) rollingMagnitudes.shift();\n        // Track valence history (keep last 7 days for trend)\n        valenceHistory.push(agg.valence);\n        if (valenceHistory.length > 7) valenceHistory.shift();\n        // Identify retrograde recursion aspects\n        const retrogradeAspects = enrichedWithRetrograde.filter((a)=>a.retrograde_involved);\n        // Dispersion-based volatility override (std deviation of hook weights)\n        let dispersionVol = 0;\n        if (enriched.hooks.length >= 2) {\n            const weights = enriched.hooks.map((h)=>h._weight || 0);\n            const meanW = weights.reduce((s, v)=>s + v, 0) / weights.length;\n            const variance = weights.reduce((s, v)=>s + Math.pow(v - meanW, 2), 0) / weights.length;\n            dispersionVol = Math.min(10, Math.sqrt(variance) * 10); // scale\n        }\n        // Build compact drivers reflecting top hooks\n        const driversCompact = (enriched.hooks || []).map((h)=>({\n                a: h.p1_name,\n                b: h.p2_name,\n                type: h._aspect || h.aspect || h.type,\n                orb: h._orb != null ? h._orb : typeof h.orb === \"number\" ? h.orb : typeof h.orbit === \"number\" ? h.orbit : null,\n                applying: typeof h.applying === \"boolean\" ? h.applying : undefined,\n                weight: typeof h._weight === \"number\" ? h._weight : weightAspect(h),\n                // compatibility fields for existing composers/templates\n                planet1: h.p1_name,\n                planet2: h.p2_name,\n                name: h._aspect || h.aspect || h.type,\n                first_planet: h.p1_name,\n                second_planet: h.p2_name,\n                is_transit: true\n            }));\n        const dayEntry = {\n            seismograph: {\n                magnitude: agg.magnitude,\n                valence: agg.valence,\n                volatility: dispersionVol,\n                rawMagnitude: agg.rawMagnitude,\n                originalMagnitude: agg.originalMagnitude,\n                scaling_strategy: scalingStrategy,\n                scaling_confidence: +scaleConfidence.toFixed(2)\n            },\n            aspects: rawDayAspects,\n            filtered_aspects: enrichedWithRetrograde,\n            // Keep legacy 'hooks' for backward compatibility; add normalized 'drivers'\n            hooks: enriched.hooks,\n            drivers: driversCompact,\n            rejections: enriched.rejections,\n            counts: enriched.counts,\n            transit_table: transitTable,\n            retrograde_aspects: retrogradeAspects,\n            valence_trend: valenceHistory.length > 1 ? calculateTrend(valenceHistory) : 0\n        };\n        // Balance/SFD computation (always on in WM-Chart-1.2)\n        try {\n            const balanceVal = computeBalanceValence(enriched.filtered);\n            const { SFD, Splus, Sminus } = computeSFD(enriched.filtered);\n            dayEntry.balance = {\n                magnitude: agg.magnitude,\n                valence: balanceVal,\n                version: \"v1.1\"\n            };\n            dayEntry.sfd = {\n                sfd: SFD,\n                sPlus: Splus,\n                sMinus: Sminus,\n                version: \"v1.2\"\n            };\n        } catch (e) {\n            logger.warn(\"Balance/SFD computation failed for day\", d, e.message);\n        }\n        daily[d] = dayEntry;\n        prev = {\n            scored: agg.scored,\n            Y_effective: agg.valence\n        };\n        prevDayFiltered = enriched.filtered;\n    }\n    const numDays = days.length;\n    const X = Object.values(daily).reduce((s, d)=>s + d.seismograph.magnitude, 0) / numDays;\n    const Y = Object.values(daily).reduce((s, d)=>s + d.seismograph.valence, 0) / numDays;\n    const VI = Object.values(daily).reduce((s, d)=>s + d.seismograph.volatility, 0) / numDays;\n    const summary = {\n        magnitude: +X.toFixed(2),\n        valence: +Y.toFixed(2),\n        volatility: +VI.toFixed(2)\n    };\n    return {\n        daily,\n        summary\n    };\n}\n// Helper function to calculate valence trend\nfunction calculateTrend(values) {\n    if (values.length < 2) return 0;\n    const recent = values.slice(-3); // Last 3 values for trend\n    if (recent.length < 2) return 0;\n    let trend = 0;\n    for(let i = 1; i < recent.length; i++){\n        trend += recent[i] - recent[i - 1];\n    }\n    return +(trend / (recent.length - 1)).toFixed(2);\n}\n// --- Composite helpers ---\nasync function computeComposite(A, B, pass = {}, H) {\n    try {\n        logger.debug(\"Computing composite for subjects:\", {\n            personA: A?.name || \"Unknown A\",\n            personB: B?.name || \"Unknown B\"\n        });\n        const payload = {\n            first_subject: subjectToAPI(A, pass),\n            second_subject: subjectToAPI(B, pass),\n            ...pass\n        };\n        const r = await apiCallWithRetry(API_ENDPOINTS.COMPOSITE_ASPECTS, {\n            method: \"POST\",\n            headers: H,\n            body: JSON.stringify(payload)\n        }, \"Composite aspects\");\n        // Prefer top-level aspects if present, fallback to data.aspects\n        const data = stripGraphicsDeep(r.data || {});\n        const topAspects = Array.isArray(r.aspects) ? r.aspects : data.aspects || [];\n        logger.debug(\"Composite calculation successful, aspects found:\", topAspects.length);\n        return {\n            aspects: topAspects,\n            raw: data\n        };\n    } catch (error) {\n        logger.error(\"Composite calculation failed:\", error);\n        throw new Error(`Composite calculation failed: ${error.message}`);\n    }\n}\n// --- Relational Processing Helpers ---\n/**\n * Generate polarity cards from synastry aspects for relational tension analysis\n * @param {Array} synastryAspects - Cross-chart aspects between Person A and Person B\n * @param {Object} personA - Person A details\n * @param {Object} personB - Person B details\n * @returns {Array} Array of polarity card objects\n */ function generatePolarityCards(synastryAspects, personA, personB) {\n    if (!Array.isArray(synastryAspects) || synastryAspects.length === 0) {\n        return [];\n    }\n    const polarityCards = [];\n    const processedPairs = new Set();\n    // Focus on major tension aspects that create polarity\n    const tensionAspects = synastryAspects.filter((aspect)=>{\n        const type = (aspect.aspect || aspect.type || \"\").toLowerCase();\n        return [\n            \"opposition\",\n            \"square\",\n            \"conjunction\"\n        ].includes(type);\n    });\n    for (const aspect of tensionAspects){\n        const p1 = aspect.p1_name || aspect.a || aspect.first_point || \"\";\n        const p2 = aspect.p2_name || aspect.b || aspect.second_point || \"\";\n        const aspectType = aspect.aspect || aspect.type || \"\";\n        const orb = aspect.orb || aspect.orbit || 0;\n        // Create unique pair identifier to avoid duplicates\n        const pairId = [\n            p1,\n            p2\n        ].sort().join(\"-\");\n        if (processedPairs.has(pairId)) continue;\n        processedPairs.add(pairId);\n        // Generate polarity card for significant aspects (tight orbs)\n        if (parseFloat(orb) <= 6.0) {\n            polarityCards.push({\n                polarity_a: `${personA.name || \"Person A\"}'s ${p1}`,\n                polarity_b: `${personB.name || \"Person B\"}'s ${p2}`,\n                aspect_type: aspectType,\n                orb_degrees: parseFloat(orb),\n                field_description: `${p1} ${aspectType} ${p2}`,\n                map_pattern: `Cross-chart ${aspectType} creating relational tension`,\n                voice_summary: `Polarity between ${p1} and ${p2} energies in the relationship`\n            });\n        }\n    }\n    return polarityCards.slice(0, 3); // Limit to top 3 polarity cards\n}\n/**\n * Detect echo loops and REF cycles from recurring cross-chart patterns\n * @param {Array} synastryAspects - Cross-chart aspects\n * @param {Array} natalAspectsA - Person A's natal aspects\n * @param {Array} natalAspectsB - Person B's natal aspects\n * @returns {Array} Array of echo loop objects\n */ function detectEchoLoops(synastryAspects, natalAspectsA, natalAspectsB) {\n    const echoLoops = [];\n    if (!Array.isArray(synastryAspects)) return echoLoops;\n    // Find recurring planetary patterns across charts\n    const planetPairs = {};\n    for (const aspect of synastryAspects){\n        const p1 = aspect.p1_name || aspect.a || \"\";\n        const p2 = aspect.p2_name || aspect.b || \"\";\n        const type = aspect.aspect || aspect.type || \"\";\n        const key = [\n            p1,\n            p2\n        ].sort().join(\"-\");\n        if (!planetPairs[key]) {\n            planetPairs[key] = [];\n        }\n        planetPairs[key].push({\n            type,\n            orb: aspect.orb || 0\n        });\n    }\n    // Identify echo loops where the same planetary pair appears multiple times\n    for (const [pair, aspects] of Object.entries(planetPairs)){\n        if (aspects.length > 1) {\n            const [planet1, planet2] = pair.split(\"-\");\n            echoLoops.push({\n                pattern_type: \"REF_CYCLE\",\n                planets_involved: [\n                    planet1,\n                    planet2\n                ],\n                occurrences: aspects.length,\n                aspects: aspects,\n                description: `Recurring ${planet1}-${planet2} feedback loop`,\n                intensity: aspects.reduce((sum, a)=>sum + (6 - parseFloat(a.orb || 6)), 0)\n            });\n        }\n    }\n    return echoLoops.slice(0, 5); // Limit to top 5 echo loops\n}\n/**\n * Generate shared SST tags for both participants in relational context\n * @param {Object} personA - Person A details and chart data\n * @param {Object} personB - Person B details and chart data  \n * @param {Array} synastryAspects - Cross-chart aspects\n * @returns {Object} SST tags for both persons\n */ function generateSharedSSTTags(personA, personB, synastryAspects) {\n    // This is a simplified SST implementation - in practice this would involve\n    // more sophisticated analysis of lived resonance patterns\n    const sstTags = {\n        person_a_tags: [],\n        person_b_tags: [],\n        shared_resonance: []\n    };\n    // Generate SST tags for Person A\n    if (personA.aspects && Array.isArray(personA.aspects)) {\n        const significantAspects = personA.aspects.filter((a)=>parseFloat(a.orb || 6) <= 3.0).slice(0, 3);\n        sstTags.person_a_tags = significantAspects.map((aspect)=>({\n                vector: `${aspect.p1_name || aspect.a}-${aspect.p2_name || aspect.b}`,\n                tag: \"WB\",\n                aspect_type: aspect.aspect || aspect.type,\n                orb: aspect.orb\n            }));\n    }\n    // Generate SST tags for Person B  \n    if (personB.aspects && Array.isArray(personB.aspects)) {\n        const significantAspects = personB.aspects.filter((a)=>parseFloat(a.orb || 6) <= 3.0).slice(0, 3);\n        sstTags.person_b_tags = significantAspects.map((aspect)=>({\n                vector: `${aspect.p1_name || aspect.a}-${aspect.p2_name || aspect.b}`,\n                tag: \"WB\",\n                aspect_type: aspect.aspect || aspect.type,\n                orb: aspect.orb\n            }));\n    }\n    // Generate shared resonance from synastry\n    if (Array.isArray(synastryAspects)) {\n        const sharedAspects = synastryAspects.filter((a)=>parseFloat(a.orb || 6) <= 4.0).slice(0, 3);\n        sstTags.shared_resonance = sharedAspects.map((aspect)=>({\n                vector: `${aspect.p1_name || aspect.a}↔${aspect.p2_name || aspect.b}`,\n                tag: \"WB\",\n                aspect_type: aspect.aspect || aspect.type,\n                orb: aspect.orb,\n                description: \"Cross-chart resonance\"\n            }));\n    }\n    return sstTags;\n}\n/**\n * Compute relational Balance Meter for the bond itself (not just individuals)\n * @param {Array} synastryAspects - Cross-chart aspects\n * @param {Array} compositeAspects - Composite chart internal aspects\n * @param {Object} compositTransits - Composite transit data by date\n * @returns {Object} Relational balance meter data\n */ function computeRelationalBalanceMeter(synastryAspects, compositeAspects, compositeTransits) {\n    // Simplified relational balance calculation\n    // In practice this would use the Balance Meter algorithms adapted for relational context\n    let totalSupport = 0;\n    let totalFriction = 0;\n    let aspectCount = 0;\n    // Analyze synastry aspects for relational support/friction\n    if (Array.isArray(synastryAspects)) {\n        for (const aspect of synastryAspects){\n            const type = (aspect.aspect || aspect.type || \"\").toLowerCase();\n            const orb = parseFloat(aspect.orb || 6);\n            aspectCount++;\n            // Supportive aspects\n            if ([\n                \"trine\",\n                \"sextile\",\n                \"conjunction\"\n            ].includes(type)) {\n                totalSupport += Math.max(0, 6 - orb) / 6; // Weight by tightness\n            }\n            // Friction aspects  \n            if ([\n                \"square\",\n                \"opposition\"\n            ].includes(type)) {\n                totalFriction += Math.max(0, 6 - orb) / 6;\n            }\n        }\n    }\n    // Calculate relational SFD (Support-Friction Differential)\n    const relationalSFD = aspectCount > 0 ? Math.round((totalSupport - totalFriction) * 100) / 100 : 0;\n    // Determine relational valence\n    let relationalValence = \"\\uD83C\\uDF17\"; // Default to mixed\n    if (relationalSFD > 1.0) relationalValence = \"\\uD83C\\uDF1E\";\n    else if (relationalSFD < -1.0) relationalValence = \"\\uD83C\\uDF11\";\n    // Calculate magnitude based on total aspect intensity\n    const magnitude = Math.min(5, Math.max(0, (totalSupport + totalFriction) * 2));\n    return {\n        relational_sfd: relationalSFD,\n        relational_magnitude: Math.round(magnitude * 100) / 100,\n        relational_valence: relationalValence,\n        support_score: Math.round(totalSupport * 100) / 100,\n        friction_score: Math.round(totalFriction * 100) / 100,\n        aspect_count: aspectCount,\n        climate_description: `Relational field showing ${relationalValence} dynamic with ${magnitude.toFixed(1)} intensity`\n    };\n}\n/**\n * Generate vector-integrity tags for latent/suppressed/dormant relational vectors\n * @param {Array} synastryAspects - Cross-chart aspects\n * @param {Array} compositeAspects - Composite chart aspects\n * @returns {Array} Vector integrity tags\n */ function generateVectorIntegrityTags(synastryAspects, compositeAspects) {\n    const vectorTags = [];\n    // Look for wide orb aspects that are structurally present but behaviorally quiet\n    const wideAspects = [];\n    if (Array.isArray(synastryAspects)) {\n        wideAspects.push(...synastryAspects.filter((a)=>{\n            const orb = parseFloat(a.orb || 0);\n            return orb > 4.0 && orb <= 8.0; // Wide but still within range\n        }));\n    }\n    if (Array.isArray(compositeAspects)) {\n        wideAspects.push(...compositeAspects.filter((a)=>{\n            const orb = parseFloat(a.orb || 0);\n            return orb > 4.0 && orb <= 8.0;\n        }));\n    }\n    for (const aspect of wideAspects.slice(0, 3)){\n        const p1 = aspect.p1_name || aspect.a || \"\";\n        const p2 = aspect.p2_name || aspect.b || \"\";\n        const type = aspect.aspect || aspect.type || \"\";\n        const orb = parseFloat(aspect.orb || 0);\n        let status = \"LATENT\";\n        let description = \"structural presence but contained/waiting\";\n        // Determine vector status based on planets and aspect type\n        if ([\n            \"Saturn\",\n            \"Pluto\",\n            \"Neptune\"\n        ].includes(p1) || [\n            \"Saturn\",\n            \"Pluto\",\n            \"Neptune\"\n        ].includes(p2)) {\n            status = \"DORMANT\";\n            description = \"waiting for specific activation timing\";\n        } else if (orb > 6.0) {\n            status = \"SUPPRESSED\";\n            description = \"boundaries fortified/compensated by other placements\";\n        }\n        vectorTags.push({\n            status: status,\n            vector_name: `${p1}-${p2} ${type}`,\n            orb_degrees: orb,\n            structural_presence: true,\n            behavioral_activity: \"contained\",\n            description: description\n        });\n    }\n    return vectorTags;\n}\n/**\n * Generate comprehensive relational mirror structure with all missing elements\n * @param {Object} personA - Person A data\n * @param {Object} personB - Person B data  \n * @param {Array} synastryAspects - Cross-chart aspects\n * @param {Object} composite - Composite chart data\n * @param {Object} compositTransits - Composite transit data\n * @returns {Object} Complete relational mirror structure\n */ function generateRelationalMirror(personA, personB, synastryAspects, composite, compositeTransits) {\n    logger.debug(\"Generating comprehensive relational mirror structure\");\n    // Generate all missing relational elements\n    const polarityCards = generatePolarityCards(synastryAspects, personA, personB);\n    const echoLoops = detectEchoLoops(synastryAspects, personA.aspects, personB.aspects);\n    const sstTags = generateSharedSSTTags(personA, personB, synastryAspects);\n    const relationalBalanceMeter = computeRelationalBalanceMeter(synastryAspects, composite.aspects, compositeTransits);\n    const vectorIntegrityTags = generateVectorIntegrityTags(synastryAspects, composite.aspects);\n    // Generate Mirror Voice for the relationship\n    const mirrorVoice = {\n        relationship_climate: `${relationalBalanceMeter.climate_description}`,\n        polarity_summary: polarityCards.length > 0 ? `${polarityCards.length} primary polarity tensions identified` : \"No major polarity tensions detected\",\n        echo_pattern_summary: echoLoops.length > 0 ? `${echoLoops.length} recurring feedback loops active` : \"No significant echo patterns detected\",\n        shared_field_description: `Relational field with ${synastryAspects?.length || 0} cross-chart connections`\n    };\n    // Relocation notes (basic implementation - would need actual relocation logic)\n    const relocationNotes = {\n        relocation_applied: false,\n        house_system: \"Placidus\",\n        angles_relocated: false,\n        baseline_remains_natal: true,\n        disclosure: \"No relocation applied; all angles and houses remain natal\"\n    };\n    return {\n        relational_mirror: {\n            polarity_cards: polarityCards,\n            echo_loops: echoLoops,\n            sst_tags: sstTags,\n            relational_balance_meter: relationalBalanceMeter,\n            mirror_voice: mirrorVoice,\n            vector_integrity_tags: vectorIntegrityTags,\n            relocation_notes: relocationNotes,\n            scaffolding_complete: true,\n            mirror_type: \"true_relational_mirror\"\n        }\n    };\n}\n/**\n * Compute composite chart transits using the transit-aspects-data endpoint\n * @param {Object} compositeRaw - Raw composite chart data (first_subject from composite calculation)\n * @param {string} start - Start date (YYYY-MM-DD)\n * @param {string} end - End date (YYYY-MM-DD) \n * @param {string} step - Step size (daily, weekly, etc)\n * @param {Object} pass - Additional parameters to pass through\n * @param {Object} H - Headers for API request\n * @returns {Object} Object with transitsByDate and optional note\n */ async function computeCompositeTransits(compositeRaw, start, end, step, pass = {}, H) {\n    if (!compositeRaw) return {\n        transitsByDate: {}\n    };\n    const transitsByDate = {};\n    const startDate = new Date(start);\n    const endDate = new Date(end);\n    endDate.setDate(endDate.getDate() + 1); // Make end date inclusive\n    const promises = [];\n    // Process each date in the range\n    for(let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)){\n        const dateString = d.toISOString().split(\"T\")[0];\n        // Create transit subject for current date (transiting planets at noon UTC)\n        const transit_subject = {\n            year: d.getUTCFullYear(),\n            month: d.getUTCMonth() + 1,\n            day: d.getUTCDate(),\n            hour: 12,\n            minute: 0,\n            city: \"Greenwich\",\n            nation: \"GB\",\n            latitude: 51.48,\n            longitude: 0,\n            timezone: \"UTC\",\n            zodiac_type: \"Tropic\" // Fix: Add missing zodiac_type for composite transits\n        };\n        // Create payload with composite chart as first_subject and current date as transit_subject\n        const payload = {\n            first_subject: subjectToAPI(compositeRaw, pass),\n            transit_subject: subjectToAPI(transit_subject, pass),\n            ...pass // Include any additional parameters\n        };\n        // Enhanced debug logging for composite transits\n        logger.debug(`Composite transit API call for ${dateString}:`, {\n            pass_keys: Object.keys(pass),\n            composite_subject: compositeRaw?.name || \"Unknown composite\"\n        });\n        logger.debug(`Full composite transit API payload for ${dateString}:`, JSON.stringify(payload, null, 2));\n        promises.push(apiCallWithRetry(API_ENDPOINTS.TRANSIT_ASPECTS, {\n            method: \"POST\",\n            headers: H,\n            body: JSON.stringify(payload)\n        }, `Composite transits for ${dateString}`).then((resp)=>{\n            logger.debug(`Composite transit API response for ${dateString}:`, {\n                hasAspects: !!(resp && resp.aspects),\n                aspectCount: resp && resp.aspects ? resp.aspects.length : 0,\n                responseKeys: resp ? Object.keys(resp) : \"null response\"\n            });\n            // Store aspects for this date if any exist\n            if (resp.aspects && resp.aspects.length > 0) {\n                transitsByDate[dateString] = resp.aspects;\n                logger.debug(`Stored ${resp.aspects.length} composite aspects for ${dateString}`);\n            } else {\n                logger.debug(`No composite aspects found for ${dateString} - response structure:`, resp);\n                logger.debug(`Full raw composite API response for ${dateString} (no aspects):`, JSON.stringify(resp, null, 2));\n            }\n        }).catch((e)=>{\n            logger.warn(`Failed to get composite transits for ${dateString}:`, e.message);\n        // Continue processing other dates even if one fails\n        }));\n    }\n    try {\n        // Execute all API calls in parallel\n        await Promise.all(promises);\n        // Return results with proper structure expected by frontend\n        return {\n            transitsByDate\n        };\n    } catch (e) {\n        logger.error(\"Composite transits calculation failed:\", e);\n        return {\n            transitsByDate: {},\n            _note: \"Composite transits not available in current plan\"\n        };\n    }\n}\n// --- Error ID generator ---\nfunction generateErrorId() {\n    const now = new Date();\n    const date = now.toISOString().slice(0, 10).replace(/-/g, \"\");\n    const time = now.toTimeString().slice(0, 8).replace(/:/g, \"\");\n    const random = Math.random().toString(36).substr(2, 4).toUpperCase();\n    return `ERR-${date}-${time}-${random}`;\n}\nexports.handler = async function(event) {\n    try {\n        if (event.httpMethod !== \"POST\") {\n            return {\n                statusCode: 405,\n                body: JSON.stringify({\n                    error: \"Only POST requests are allowed.\",\n                    code: \"METHOD_NOT_ALLOWED\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        let body;\n        try {\n            body = JSON.parse(event.body || \"{}\");\n        } catch (e) {\n            return {\n                statusCode: 400,\n                body: JSON.stringify({\n                    error: \"Invalid JSON in request body.\",\n                    code: \"INVALID_JSON\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        // --- DEV MOCK: allow UI verification without RapidAPI key ---\n        const wantMock = (!process.env.RAPIDAPI_KEY || process.env.MB_MOCK === \"true\") && \"development\" !== \"production\";\n        if (wantMock) {\n            const today = new Date();\n            const iso = today.toISOString().slice(0, 10);\n            const rangeStart = String(body.startDate || body.transitStartDate || iso);\n            const mock = {\n                success: true,\n                provenance: {\n                    source: \"mock\",\n                    engine: \"MathBrain\",\n                    version: \"0.0-dev\"\n                },\n                context: {\n                    mode: body?.context?.mode || \"mirror\",\n                    translocation: body?.translocation || {\n                        applies: false,\n                        method: \"Natal\"\n                    }\n                },\n                person_a: {\n                    meta: {\n                        birth_time_known: true,\n                        time_precision: \"exact\",\n                        houses_suppressed: false,\n                        effective_time_used: \"12:00\"\n                    },\n                    details: body.personA || {},\n                    chart: {\n                        transitsByDate: {\n                            [rangeStart]: [\n                                {\n                                    p1_name: \"Sun\",\n                                    p2_name: \"Mars\",\n                                    aspect: \"square\",\n                                    orb: 1.2,\n                                    _class: \"major\"\n                                }\n                            ]\n                        }\n                    },\n                    derived: {\n                        seismograph_summary: {\n                            magnitude: 2.3,\n                            valence: 0.6,\n                            volatility: 1.1\n                        }\n                    }\n                },\n                person_b: body.personB ? {\n                    details: body.personB,\n                    chart: {}\n                } : undefined,\n                woven_map: {\n                    type: body.personB ? \"dyad\" : \"solo\",\n                    schema: \"WM-Chart-1.2\",\n                    hook_stack: {\n                        tier_1_orbs: 2\n                    }\n                }\n            };\n            return {\n                statusCode: 200,\n                body: JSON.stringify(mock)\n            };\n        }\n        // Inputs\n        const personA = normalizeSubjectData(body.personA || body.person_a || body.first_subject || body.subject);\n        const personB = normalizeSubjectData(body.personB || body.person_b || body.second_subject);\n        // Use strict validator for full chart endpoints, lean for aspects-only\n        // Accept multiple ways of specifying mode, including saved JSON shapes\n        const modeHint = body.context?.mode || body.mode || body.contextMode?.relational || body.contextMode?.solo || \"\";\n        const modeToken = canonicalizeMode(modeHint);\n        // Time policy: read early so we can apply fallback time before validation when birth time is unknown\n        const timePolicy = canonicalizeTimePolicy(body.time_policy || body.timePolicy || body.birth_time_policy);\n        const wantNatalAspectsOnly = modeToken === \"NATAL_ASPECTS\" || event.path?.includes(\"natal-aspects-data\");\n        const wantBirthData = modeToken === \"BIRTH_DATA\" || event.path?.includes(\"birth-data\");\n        const wantSynastry = modeToken === \"SYNASTRY\" || modeToken === \"SYNASTRY_TRANSITS\";\n        const wantSynastryAspectsOnly = modeToken === \"SYNASTRY_ASPECTS\" || event.path?.includes(\"synastry-aspects-data\");\n        const wantComposite = modeToken === \"COMPOSITE\" || modeToken === \"COMPOSITE_ASPECTS\" || modeToken === \"COMPOSITE_TRANSITS\" || body.wantComposite === true;\n        const wantSkyTransits = modeToken === \"SKY_TRANSITS\" || modeToken === \"WEATHER\" || body.context?.type === \"weather\";\n        const wantBalanceMeter = modeToken === \"BALANCE_METER\" || body.context?.mode === \"balance_meter\";\n        const includeTransitTag = !!body.includeTransitTag;\n        // --- Relationship Context Validation (Partner / Friend / Family) ---\n        // Canonical enumerations supplied by product spec\n        const REL_PRIMARY = [\n            \"PARTNER\",\n            \"FRIEND\",\n            \"FAMILY\"\n        ]; // FRIEND covers Friend / Colleague\n        const PARTNER_TIERS = [\n            \"P1\",\n            \"P2\",\n            \"P3\",\n            \"P4\",\n            \"P5a\",\n            \"P5b\"\n        ];\n        const FRIEND_ROLES = [\n            \"Acquaintance\",\n            \"Mentor\",\n            \"Other\",\n            \"Custom\"\n        ];\n        const FAMILY_ROLES = [\n            \"Parent\",\n            \"Offspring\",\n            \"Sibling\",\n            \"Cousin\",\n            \"Extended\",\n            \"Guardian\",\n            \"Mentor\",\n            \"Other\",\n            \"Custom\"\n        ];\n        function normalizeRelType(t) {\n            if (!t) return \"\";\n            const up = t.toString().trim().toUpperCase();\n            if (up.startsWith(\"FRIEND\")) return \"FRIEND\";\n            if (up === \"COLLEAGUE\" || up.includes(\"COLLEAGUE\")) return \"FRIEND\";\n            if (up.startsWith(\"FAMILY\")) return \"FAMILY\";\n            if (up.startsWith(\"PARTNER\")) return \"PARTNER\";\n            return up; // fallback; will validate later\n        }\n        function validateRelationshipContext(raw, isRelationshipMode) {\n            if (!isRelationshipMode) return {\n                valid: true,\n                value: null,\n                reason: \"Not in relationship mode\"\n            };\n            // Accept multiple aliases including saved config shape `relationalContext`\n            const ctx = raw || body.relationship || body.relationship_context || body.relationshipContext || body.relationalContext || {};\n            const errors = [];\n            const cleaned = {};\n            cleaned.type = normalizeRelType(ctx.type || ctx.relationship_type || ctx.category);\n            if (!REL_PRIMARY.includes(cleaned.type)) {\n                errors.push(\"relationship.type required (PARTNER|FRIEND|FAMILY)\");\n            }\n            // Intimacy tier requirement for PARTNER\n            if (cleaned.type === \"PARTNER\") {\n                cleaned.intimacy_tier = (ctx.intimacy_tier || ctx.tier || \"\").toString();\n                if (!PARTNER_TIERS.includes(cleaned.intimacy_tier)) {\n                    errors.push(`intimacy_tier required for PARTNER (one of ${PARTNER_TIERS.join(\",\")})`);\n                }\n            }\n            // Role requirement for FAMILY; optional for FRIEND\n            if (cleaned.type === \"FAMILY\") {\n                // Accept relationship_role alias; normalize case (e.g., \"parent\" -> \"Parent\")\n                const roleRaw = (ctx.role || ctx.family_role || ctx.relationship_role || \"\").toString();\n                const roleCanon = roleRaw ? roleRaw.charAt(0).toUpperCase() + roleRaw.slice(1).toLowerCase() : \"\";\n                cleaned.role = roleCanon;\n                if (!FAMILY_ROLES.includes(cleaned.role)) {\n                    errors.push(`role required for FAMILY (one of ${FAMILY_ROLES.join(\",\")})`);\n                }\n            } else if (cleaned.type === \"FRIEND\") {\n                const roleRaw = (ctx.role || ctx.friend_role || ctx.relationship_role || \"\").toString();\n                const roleCanon = roleRaw ? roleRaw.charAt(0).toUpperCase() + roleRaw.slice(1).toLowerCase() : \"\";\n                cleaned.role = roleCanon;\n                if (cleaned.role && !FRIEND_ROLES.includes(cleaned.role)) {\n                    errors.push(`friend role invalid (optional, one of ${FRIEND_ROLES.join(\",\")})`);\n                }\n            }\n            // Ex / Estranged flag only for PARTNER or FAMILY\n            if (ctx.ex_estranged !== undefined || ctx.ex || ctx.estranged || ctx.is_ex_relationship !== undefined) {\n                const flag = Boolean(ctx.ex_estranged || ctx.ex || ctx.estranged || ctx.is_ex_relationship);\n                if (cleaned.type === \"FRIEND\") {\n                    errors.push(\"ex_estranged flag not allowed for FRIEND\");\n                } else {\n                    cleaned.ex_estranged = flag;\n                }\n            }\n            if (ctx.notes) cleaned.notes = (ctx.notes || \"\").toString().slice(0, 500);\n            if (errors.length) return {\n                valid: false,\n                errors,\n                value: cleaned\n            };\n            return {\n                valid: true,\n                value: cleaned\n            };\n        }\n        // Keep originals for provenance/meta before applying fallback hour/minute\n        const personAOriginal = {\n            ...personA\n        };\n        const personBOriginal = personB && Object.keys(personB).length ? {\n            ...personB\n        } : null;\n        // Apply time_policy fallback for unknown birth time to satisfy API validators while preserving provenance\n        const applyFallbackTime = (s)=>{\n            if (!s) return s;\n            const missing = s.hour == null || s.minute == null;\n            if (!missing) return s;\n            if (timePolicy === \"planetary_only\" || timePolicy === \"whole_sign\" || timePolicy === \"sensitivity_scan\") {\n                return {\n                    ...s,\n                    hour: 12,\n                    minute: 0\n                };\n            }\n            return s;\n        };\n        Object.assign(personA, applyFallbackTime(personA));\n        Object.assign(personB, applyFallbackTime(personB));\n        const vA = wantNatalAspectsOnly || wantBirthData ? validateSubjectLean(personA) : validateSubject(personA);\n        if (!vA.isValid) {\n            return {\n                statusCode: 400,\n                body: JSON.stringify({\n                    error: `Primary subject validation failed: ${vA.message}`,\n                    code: \"VALIDATION_ERROR_A\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        // Relationship mode strict validation for Person B (fail loud, no silent fallback)\n        const relationshipMode = wantSynastry || wantSynastryAspectsOnly || wantComposite;\n        // Debug logging for Balance Meter logic - Part 1\n        logger.debug(\"Balance Meter decision variables (Part 1):\", {\n            wantBalanceMeter,\n            modeToken,\n            contextMode: body.context?.mode,\n            relationshipMode,\n            wantSynastry,\n            wantSynastryAspectsOnly,\n            wantComposite\n        });\n        let personBStrictValidation = {\n            isValid: false,\n            errors: {\n                reason: \"Not requested\"\n            }\n        };\n        // Relationship context validation (must precede Person B requirements messaging to give precise feedback)\n        const relContextValidation = validateRelationshipContext(body.relationship_context || body.relationshipContext, relationshipMode);\n        if (relationshipMode && !relContextValidation.valid) {\n            return {\n                statusCode: 400,\n                body: JSON.stringify({\n                    error: \"Relationship context invalid\",\n                    code: \"REL_CONTEXT_INVALID\",\n                    errorId: generateErrorId(),\n                    issues: relContextValidation.errors || []\n                })\n            };\n        }\n        if (relationshipMode) {\n            // Auto-fill default zodiac_type if missing BEFORE validation to reduce false negatives\n            if (!personB.zodiac_type) personB.zodiac_type = \"Tropic\";\n            personBStrictValidation = validateSubjectStrictWithMap(personB);\n            if (!personBStrictValidation.isValid) {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        error: \"Secondary subject validation failed\",\n                        code: \"VALIDATION_ERROR_B\",\n                        mode: modeToken,\n                        errorId: generateErrorId(),\n                        fieldErrors: personBStrictValidation.errors\n                    })\n                };\n            }\n        }\n        // Accept both legacy transit* fields and a consolidated body.window = { start, end, step }\n        const win = body.window || body.transit_window || null;\n        const start = win && (win.start || win.startDate) || body.start || body.startDate || body.transitStartDate || body.transit_start_date || body.transitParams?.startDate || body.transit?.startDate;\n        const end = win && (win.end || win.endDate) || body.end || body.endDate || body.transitEndDate || body.transit_end_date || body.transitParams?.endDate || body.transit?.endDate;\n        const step = normalizeStep(win && (win.step || win.interval) || body.step || body.interval || body.transitStep || body.transit_step || body.transitParams?.step || body.transit?.step);\n        const haveRange = Boolean(start && end);\n        // Debug logging for Balance Meter logic - Part 2\n        logger.debug(\"Balance Meter decision variables (Part 2):\", {\n            haveRange,\n            start,\n            end\n        });\n        let headers;\n        try {\n            headers = buildHeaders();\n        } catch (e) {\n            return {\n                statusCode: 500,\n                body: JSON.stringify({\n                    error: e.message,\n                    code: \"CONFIG_ERROR\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        // Early safety: LOCATION_REQUIRED when Balance Meter (or Mirror+climate) lacks transit location\n        const hasLoc = (s)=>s && typeof s.latitude === \"number\" && typeof s.longitude === \"number\" && !!s.timezone;\n        // Transit subjects: allow explicit transit_subject, else default to personA\n        const transitA_raw = body.transit_subject || personA;\n        const transitB_raw = body.transit_subject_B || body.second_transit_subject || personB;\n        // Relocation mode (data-only intent)\n        let relocationMode = body.relocation_mode || body.translocation?.method || \"None\";\n        if (/^midpoint$/i.test(relocationMode)) {\n            return {\n                statusCode: 400,\n                body: JSON.stringify({\n                    code: \"RELOCATION_UNSUPPORTED\",\n                    error: \"Midpoint relocation is not supported for this protocol. Use A_local or B_local.\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        // Default relocation intent\n        // - Dyad + Balance Meter: default to A_local unless explicitly overridden\n        // - Solo with A_local present: default to A_local\n        const hasDyad = !!(personB && Object.keys(personB).length);\n        const aLocal = body.personA?.A_local || body.subjectA?.A_local || null;\n        if ((relocationMode === \"None\" || relocationMode === \"Natal\") && wantBalanceMeter) {\n            if (hasDyad) relocationMode = \"A_local\";\n            else if (aLocal) relocationMode = \"A_local\";\n        }\n        if (wantBalanceMeter) {\n            if (!haveRange) {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"WINDOW_REQUIRED\",\n                        error: \"Balance Meter requires a time window (start, end, step)\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n            const cityModeA = !!(aLocal?.city && aLocal?.nation) || !!(personA?.city && personA?.nation);\n            const cityModeB = !!(personB && (body.personB?.B_local?.city && body.personB?.B_local?.nation || personB.city && personB.nation));\n            if (!hasLoc(transitA_raw) && !cityModeA) {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"LOCATION_REQUIRED\",\n                        error: \"Balance Meter requires location (coords or city/nation) for A\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n            if (personB && Object.keys(personB).length && !hasLoc(transitB_raw || {}) && !cityModeB) {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"LOCATION_REQUIRED\",\n                        error: \"Balance Meter dyad requires location (coords or city/nation) for Person B\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n        } else if ((modeToken === \"MIRROR\" || body.context?.mode === \"mirror\") && includeTransitTag) {\n            if (!hasLoc(transitA_raw)) {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"LOCATION_REQUIRED\",\n                        error: \"Mirror with Climate Tag requires location\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n        }\n        // Build API-shaped subjects now so timezone checks apply to effective transit subjects\n        const natalA = personA; // already normalized\n        const natalB = personB && Object.keys(personB).length ? personB : null;\n        let transitA = {\n            ...transitA_raw\n        };\n        let transitB = transitB_raw ? {\n            ...transitB_raw\n        } : natalB ? {\n            ...natalB\n        } : null;\n        // Apply relocation modes\n        if (relocationMode === \"Midpoint\" && transitB) {\n            if (typeof transitA.latitude !== \"number\" || typeof transitA.longitude !== \"number\" || typeof transitB.latitude !== \"number\" || typeof transitB.longitude !== \"number\") {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"LOCATION_REQUIRED\",\n                        error: \"Midpoint relocation requires coords for both persons\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n            const mid = function midpointCoords(lat1, lon1, lat2, lon2) {\n                const toRad = (d)=>d * Math.PI / 180;\n                const toDeg = (r)=>r * 180 / Math.PI;\n                const φ1 = toRad(lat1), λ1 = toRad(lon1);\n                const φ2 = toRad(lat2), λ2 = toRad(lon2);\n                const x1 = Math.cos(φ1) * Math.cos(λ1), y1 = Math.cos(φ1) * Math.sin(λ1), z1 = Math.sin(φ1);\n                const x2 = Math.cos(φ2) * Math.cos(λ2), y2 = Math.cos(φ2) * Math.sin(λ2), z2 = Math.sin(φ2);\n                const xm = (x1 + x2) / 2, ym = (y1 + y2) / 2, zm = (z1 + z2) / 2;\n                const φm = Math.atan2(zm, Math.sqrt(xm * xm + ym * ym));\n                const λm = Math.atan2(ym, xm);\n                return {\n                    latitude: toDeg(φm),\n                    longitude: toDeg(λm)\n                };\n            }(transitA.latitude, transitA.longitude, transitB.latitude, transitB.longitude);\n            try {\n                const tz = __webpack_require__(/*! tz-lookup */ \"(rsc)/./node_modules/tz-lookup/tz.js\")(mid.latitude, mid.longitude);\n                transitA = {\n                    ...transitA,\n                    latitude: mid.latitude,\n                    longitude: mid.longitude,\n                    timezone: tz\n                };\n                transitB = transitB ? {\n                    ...transitB,\n                    latitude: mid.latitude,\n                    longitude: mid.longitude,\n                    timezone: tz\n                } : transitB;\n            } catch  {\n                return {\n                    statusCode: 422,\n                    body: JSON.stringify({\n                        code: \"HOUSES_UNSTABLE\",\n                        error: \"Midpoint timezone lookup failed; try custom location\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n        } else if (relocationMode === \"A_local\") {\n            // Render as-if at A's local venue (and mirror onto B if present)\n            const loc = aLocal || body.custom_location || null;\n            if (loc) {\n                if (typeof loc.lat === \"number\" && typeof loc.lon === \"number\") {\n                    try {\n                        const tz = loc.tz || __webpack_require__(/*! tz-lookup */ \"(rsc)/./node_modules/tz-lookup/tz.js\")(loc.lat, loc.lon);\n                        transitA = {\n                            ...transitA,\n                            latitude: loc.lat,\n                            longitude: loc.lon,\n                            timezone: tz\n                        };\n                        if (transitB) transitB = {\n                            ...transitB,\n                            latitude: loc.lat,\n                            longitude: loc.lon,\n                            timezone: tz\n                        };\n                    } catch  {\n                        return {\n                            statusCode: 400,\n                            body: JSON.stringify({\n                                code: \"TZ_LOOKUP_FAIL\",\n                                error: \"Could not resolve A_local timezone\",\n                                errorId: generateErrorId()\n                            })\n                        };\n                    }\n                } else if (loc.city && loc.nation) {\n                    // City-based A_local: rely on transit_subject city/nation; do not inject coords\n                    transitA = {\n                        ...transitA,\n                        city: loc.city,\n                        nation: loc.nation\n                    };\n                    if (transitB) transitB = {\n                        ...transitB,\n                        city: loc.city,\n                        nation: loc.nation\n                    };\n                }\n            }\n        } else if (relocationMode === \"B_local\") {\n            if (natalB && transitB && hasLoc(transitB)) {\n            // leave as provided\n            } else if (natalB) {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"LOCATION_REQUIRED\",\n                        error: \"B_local requires coords for Person B\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n        } else if (relocationMode === \"Custom\" && body.custom_location) {\n            const c = body.custom_location;\n            if (typeof c.latitude !== \"number\" || typeof c.longitude !== \"number\") {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"LOCATION_REQUIRED\",\n                        error: \"Custom relocation requires coords\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n            try {\n                const tz = c.timezone || __webpack_require__(/*! tz-lookup */ \"(rsc)/./node_modules/tz-lookup/tz.js\")(c.latitude, c.longitude);\n                transitA = {\n                    ...transitA,\n                    latitude: c.latitude,\n                    longitude: c.longitude,\n                    timezone: tz\n                };\n                if (transitB) transitB = {\n                    ...transitB,\n                    latitude: c.latitude,\n                    longitude: c.longitude,\n                    timezone: tz\n                };\n            } catch  {\n                return {\n                    statusCode: 400,\n                    body: JSON.stringify({\n                        code: \"TZ_LOOKUP_FAIL\",\n                        error: \"Could not resolve custom timezone\",\n                        errorId: generateErrorId()\n                    })\n                };\n            }\n        }\n        // TZ mismatch detection for A (+B if present)\n        try {\n            if (hasLoc(transitA)) {\n                const tz = __webpack_require__(/*! tz-lookup */ \"(rsc)/./node_modules/tz-lookup/tz.js\")(transitA.latitude, transitA.longitude);\n                if (transitA.timezone && transitA.timezone !== tz) {\n                    return {\n                        statusCode: 400,\n                        body: JSON.stringify({\n                            code: \"TZ_MISMATCH\",\n                            error: \"Provided timezone does not match coordinates\",\n                            suggested_timezone: tz,\n                            errorId: generateErrorId()\n                        })\n                    };\n                }\n                if (!transitA.timezone) transitA.timezone = tz;\n            }\n            if (transitB && hasLoc(transitB)) {\n                const tzB = __webpack_require__(/*! tz-lookup */ \"(rsc)/./node_modules/tz-lookup/tz.js\")(transitB.latitude, transitB.longitude);\n                if (transitB.timezone && transitB.timezone !== tzB) {\n                    return {\n                        statusCode: 400,\n                        body: JSON.stringify({\n                            code: \"TZ_MISMATCH\",\n                            error: \"Provided timezone for Person B does not match coordinates\",\n                            suggested_timezone: tzB,\n                            errorId: generateErrorId()\n                        })\n                    };\n                }\n                if (!transitB.timezone) transitB.timezone = tzB;\n            }\n        } catch  {\n        // fall through; if tz-lookup failed we return a generic\n        }\n        // High-latitude guard\n        const unstable = (lat)=>Math.abs(Number(lat)) >= 66.0;\n        if (hasLoc(transitA) && unstable(transitA.latitude)) {\n            return {\n                statusCode: 422,\n                body: JSON.stringify({\n                    code: \"HOUSES_UNSTABLE\",\n                    error: \"House math may be unstable at this latitude; consider whole-sign or different location\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        if (transitB && hasLoc(transitB) && unstable(transitB.latitude)) {\n            return {\n                statusCode: 422,\n                body: JSON.stringify({\n                    code: \"HOUSES_UNSTABLE\",\n                    error: \"House math may be unstable for Person B at this latitude; consider whole-sign or different location\",\n                    errorId: generateErrorId()\n                })\n            };\n        }\n        // timePolicy is already determined earlier to allow fallback time before validation\n        const result = {\n            schema: \"WM-Chart-1.2\",\n            provenance: {\n                math_brain_version: MATH_BRAIN_VERSION,\n                ephemeris_source: EPHEMERIS_SOURCE,\n                build_ts: new Date().toISOString(),\n                timezone: personA.timezone || \"UTC\",\n                calibration_boundary: CALIBRATION_BOUNDARY,\n                engine_versions: {\n                    seismograph: \"v1.0\",\n                    balance: \"v1.1\",\n                    sfd: \"v1.2\"\n                },\n                time_meta_a: deriveTimeMetaWithPolicy(personAOriginal, timePolicy),\n                // New provenance fields (stamped after pass/body are finalized below)\n                house_system: undefined,\n                orbs_profile: undefined,\n                timezone_db_version: undefined,\n                relocation_mode: relocationMode || \"none\"\n            },\n            context: {\n                mode: modeToken || \"UNKNOWN\"\n            },\n            mirror_ready: true,\n            contract: \"clear-mirror/1.2\",\n            person_a: {\n                details: personAOriginal,\n                meta: deriveTimeMetaWithPolicy(personAOriginal, timePolicy)\n            }\n        };\n        // Eagerly initialize Person B details in any relationship mode so UI never loses the panel\n        if (relationshipMode && personB && Object.keys(personB).length) {\n            result.person_b = {\n                details: personBOriginal || personB,\n                meta: deriveTimeMetaWithPolicy(personBOriginal || personB, timePolicy)\n            };\n            result.provenance.time_meta_b = deriveTimeMetaWithPolicy(personBOriginal || personB, timePolicy);\n        }\n        if (relationshipMode && relContextValidation.valid && relContextValidation.value) {\n            result.relationship = relContextValidation.value;\n        }\n        // Attach translocation (relocation) context from request if provided (data-only)\n        try {\n            const tl = body.translocation || body.context?.translocation || null;\n            if (tl) {\n                result.context.translocation = {\n                    applies: !!tl.applies,\n                    method: tl.method || (tl.applies ? \"custom\" : \"Natal\"),\n                    house_system: tl.house_system || \"Placidus\",\n                    tz: tl.tz || personA.timezone || \"UTC\"\n                };\n            }\n        } catch  {}\n        // Extract additional parameters for API calculations (including transits)\n        const pass = {};\n        [\n            \"active_points\",\n            \"active_aspects\",\n            \"houses_system_identifier\",\n            \"sidereal_mode\",\n            \"perspective_type\"\n        ].forEach((k)=>{\n            if (body[k] !== undefined) pass[k] = body[k];\n        });\n        // Quarantine UI/VOICE flags so they never touch math layer\n        const quarantineKeys = [\n            \"voice\",\n            \"voice_mode\",\n            \"exclude_person_b\",\n            \"excludePersonB\",\n            \"reflect_mode\",\n            \"ui\",\n            \"display\"\n        ];\n        quarantineKeys.forEach((k)=>{\n            if (k in pass) delete pass[k];\n        });\n        // Ensure active_points includes all planets (especially outer planets) if not explicitly set\n        if (!pass.active_points) {\n            pass.active_points = [\n                \"Sun\",\n                \"Moon\",\n                \"Mercury\",\n                \"Venus\",\n                \"Mars\",\n                \"Jupiter\",\n                \"Saturn\",\n                \"Uranus\",\n                \"Neptune\",\n                \"Pluto\",\n                \"Mean_Node\",\n                \"True_Node\",\n                \"Mean_South_Node\",\n                \"True_South_Node\",\n                \"Chiron\",\n                \"Mean_Lilith\",\n                \"Ascendant\",\n                \"Medium_Coeli\",\n                \"Descendant\",\n                \"Imum_Coeli\"\n            ];\n            logger.debug(\"Setting default active_points (includes True nodes & full angle set)\");\n        }\n        // Time policy can suppress house/angle semantics: remove angles when policy forbids houses\n        if (timePolicy === \"planetary_only\" || timePolicy === \"sensitivity_scan\") {\n            pass.active_points = pass.active_points.filter((p)=>![\n                    \"Ascendant\",\n                    \"Medium_Coeli\",\n                    \"Descendant\",\n                    \"Imum_Coeli\"\n                ].includes(p));\n            logger.debug(\"Time policy excludes angular points for transits\");\n        }\n        // Whole-sign preference: user allows houses with noon fallback; prefer whole-sign house system\n        if (timePolicy === \"whole_sign\" && !pass.houses_system_identifier) {\n            pass.houses_system_identifier = \"Whole_Sign\";\n            logger.debug(\"Time policy set houses_system_identifier=Whole_Sign\");\n        }\n        // Stamp provenance fields now that pass/body are known\n        try {\n            result.provenance.house_system = pass.houses_system_identifier || result.provenance.house_system || \"Placidus\";\n            result.provenance.orbs_profile = body.orbs_profile || result.provenance.orbs_profile || \"wm-spec-2025-09\";\n            result.provenance.timezone_db_version = result.provenance.timezone_db_version || \"IANA (system)\";\n            result.provenance.relocation_mode = relocationMode || result.provenance.relocation_mode || \"none\";\n        } catch  {}\n        // Ensure active_aspects includes all major aspects if not explicitly set\n        if (!pass.active_aspects) {\n            pass.active_aspects = [\n                // Raven caps for majors: 8/8/7/7/5\n                {\n                    name: \"conjunction\",\n                    orb: 8\n                },\n                {\n                    name: \"opposition\",\n                    orb: 8\n                },\n                {\n                    name: \"trine\",\n                    orb: 7\n                },\n                {\n                    name: \"square\",\n                    orb: 7\n                },\n                {\n                    name: \"sextile\",\n                    orb: 5\n                },\n                // Minors / harmonic\n                {\n                    name: \"quincunx\",\n                    orb: 3\n                },\n                {\n                    name: \"sesquiquadrate\",\n                    orb: 3\n                },\n                {\n                    name: \"semi-square\",\n                    orb: 2\n                },\n                {\n                    name: \"semi-sextile\",\n                    orb: 2\n                },\n                {\n                    name: \"quintile\",\n                    orb: 2\n                },\n                {\n                    name: \"biquintile\",\n                    orb: 2\n                }\n            ];\n            logger.debug(\"Setting default active_aspects to Raven caps list\");\n        }\n        // --- Aspect name normalization (handles user supplied list & legacy synonyms) ---\n        const ASPECT_SYNONYMS = {\n            \"semisquare\": \"semi-square\",\n            \"semi_square\": \"semi-square\",\n            \"semi square\": \"semi-square\",\n            \"semisextile\": \"semi-sextile\",\n            \"semi_sextile\": \"semi-sextile\",\n            \"semi sextile\": \"semi-sextile\",\n            \"inconjunct\": \"quincunx\",\n            \"sesqui-square\": \"sesquiquadrate\",\n            \"sesquisquare\": \"sesquiquadrate\"\n        };\n        if (Array.isArray(pass.active_aspects)) {\n            pass.active_aspects = pass.active_aspects.map((a)=>{\n                if (!a) return null;\n                if (typeof a === \"string\") return {\n                    name: a,\n                    orb: 3\n                };\n                if (typeof a === \"object\") {\n                    const raw = (a.name || a.type || \"\").toString().toLowerCase();\n                    const canonical = ASPECT_SYNONYMS[raw] || raw;\n                    return {\n                        name: canonical,\n                        orb: a.orb != null ? a.orb : 3\n                    };\n                }\n                return null;\n            }).filter(Boolean)// Deduplicate by name keeping largest orb (we'll cap later)\n            .reduce((acc, cur)=>{\n                const existing = acc.find((x)=>x.name === cur.name);\n                if (!existing) acc.push(cur);\n                else if (cur.orb > existing.orb) existing.orb = cur.orb;\n                return acc;\n            }, []);\n            // Clamp to provider caps before calling upstream\n            pass.active_aspects = pass.active_aspects.map((a)=>{\n                const cap = ASPECT_ORB_CAPS[a.name] || a.orb;\n                const clamped = Math.min(a.orb, cap);\n                if (a.orb > clamped) logger.debug(`Clamping orb for ${a.name} from ${a.orb} -> ${clamped}`);\n                return {\n                    name: a.name,\n                    orb: clamped\n                };\n            });\n        }\n        logger.debug(\"Normalized + clamped active_aspects list:\", pass.active_aspects);\n        // 1) Natal (chart + aspects, natal aspects-only, or birth data)\n        let natalResponse;\n        if (wantBalanceMeter) {\n            // For Balance Meter runs, skip natal API calls; seismograph uses transits only\n            result.person_a = result.person_a || {};\n            result.person_a.details = personA;\n        } else if (wantBirthData) {\n            natalResponse = await callNatal(API_ENDPOINTS.BIRTH_DATA, personA, headers, pass, \"Birth data (A)\");\n            result.person_a.birth_data = stripGraphicsDeep(natalResponse.data || {});\n        } else if (wantNatalAspectsOnly) {\n            natalResponse = await callNatal(API_ENDPOINTS.NATAL_ASPECTS_DATA, personA, headers, pass, \"Natal aspects data (A)\");\n            const chartData = stripGraphicsDeep(natalResponse.data || {});\n            result.person_a.chart = chartData;\n            result.person_a.aspects = Array.isArray(natalResponse.aspects) ? natalResponse.aspects : chartData.aspects || [];\n        } else {\n            natalResponse = await callNatal(API_ENDPOINTS.BIRTH_CHART, personA, headers, pass, \"Birth chart (A)\");\n            const chartData = stripGraphicsDeep(natalResponse.data || {});\n            result.person_a.chart = chartData;\n            result.person_a.aspects = Array.isArray(natalResponse.aspects) ? natalResponse.aspects : chartData.aspects || [];\n        }\n        // Birth-time suppression marker\n        try {\n            const birthTimeMissing = (s)=>s?.hour == null || s?.minute == null;\n            // Policy drives suppression: for unknown birth time, planetary_only and sensitivity_scan suppress houses; whole_sign allows\n            const shouldSuppress = (s)=>birthTimeMissing(s) && (timePolicy === \"planetary_only\" || timePolicy === \"sensitivity_scan\");\n            if (shouldSuppress(personAOriginal)) result.person_a.houses_suppressed = true;\n            if (result.person_b && shouldSuppress(personBOriginal || personB)) result.person_b.houses_suppressed = true;\n            // Keep meta aligned with suppression and policy\n            result.person_a.meta = Object.assign({}, result.person_a.meta, deriveTimeMetaWithPolicy(personAOriginal, timePolicy));\n            if (result.person_b) result.person_b.meta = Object.assign({}, result.person_b.meta || {}, deriveTimeMetaWithPolicy(personBOriginal || personB, timePolicy));\n        } catch  {}\n        // 2) Transits (optional; raw aspects by date, with advanced options)\n        // Skip transit processing for natal_only mode even if date range is provided\n        const skipTransits = modeToken === \"NATAL_ONLY\";\n        // Sky transits mode - planetary transits without personal natal chart\n        if (wantSkyTransits && haveRange) {\n            logger.debug(\"Processing sky transits mode:\", {\n                start,\n                end,\n                step\n            });\n            // Create a dummy subject for sky-only transits (no personal data)\n            const skySubject = {\n                name: \"Sky Patterns\",\n                birth_date: start,\n                birth_time: \"12:00\",\n                birth_location: \"Greenwich, UK\",\n                timezone: \"GMT\"\n            };\n            try {\n                const { transitsByDate, retroFlagsByDate, provenanceByDate } = await getTransits(skySubject, {\n                    startDate: start,\n                    endDate: end,\n                    step\n                }, headers, pass);\n                // Apply seismograph analysis to sky transits\n                const seismographData = calculateSeismograph(transitsByDate, retroFlagsByDate);\n                // Store sky transit data\n                result.sky_transits = {\n                    transitsByDate: seismographData.daily,\n                    provenanceByDate,\n                    derived: {\n                        seismograph_summary: seismographData.summary,\n                        mode: \"sky_patterns_only\"\n                    }\n                };\n                logger.debug(\"Sky transits completed with seismograph analysis\");\n            } catch (e) {\n                logger.warn(\"Sky transits computation failed:\", e.message);\n                result.sky_transits = {\n                    error: \"Failed to compute sky patterns\"\n                };\n            }\n        } else if (haveRange && !skipTransits) {\n            // Use new getTransits and seismograph logic with configuration parameters\n            const { transitsByDate, retroFlagsByDate, provenanceByDate } = await getTransits(personA, {\n                startDate: start,\n                endDate: end,\n                step\n            }, headers, pass);\n            result.person_a.chart = {\n                ...result.person_a.chart,\n                transitsByDate\n            };\n            // Raven-lite integration: flatten all aspects for derived.t2n_aspects\n            const allAspects = Object.values(transitsByDate).flatMap((day)=>day);\n            logger.debug(`Transit aspects found: ${allAspects.length} total including outer planets`);\n            result.person_a.derived = result.person_a.derived || {};\n            result.person_a.derived.t2n_aspects = mapT2NAspects(allAspects);\n            // Add transit_data array for test compatibility\n            result.person_a.transit_data = Object.values(transitsByDate);\n            // Seismograph summary (using all aspects including outer planets for complete structural analysis)\n            const seismographData = calculateSeismograph(transitsByDate, retroFlagsByDate);\n            result.person_a.derived.seismograph_summary = seismographData.summary;\n            // NOTE: transitsByDate now includes per-day: aspects (raw), filtered_aspects, hooks, counts, seismograph metrics\n            // Frontend can progressively disclose hooks first, then filtered_aspects, then full list.\n            result.person_a.chart.transitsByDate = seismographData.daily;\n            result.person_a.chart.provenanceByDate = provenanceByDate;\n        }\n        // 2b) Dual natal modes (explicit): provide both natal charts (and optional transits) WITHOUT synastry math\n        const dualNatalMode = modeToken === \"DUAL_NATAL\" || modeToken === \"DUAL_NATAL_TRANSITS\";\n        if ((dualNatalMode || !relationshipMode && modeToken && modeToken.startsWith(\"NATAL\") && personB && Object.keys(personB).length) && personB) {\n            const vBLeanPassive = validateSubjectLean(personB);\n            if (vBLeanPassive.isValid) {\n                if (!result.person_b || !result.person_b.chart) {\n                    try {\n                        const natalB = await callNatal(API_ENDPOINTS.BIRTH_CHART, personB, headers, pass, \"Birth chart (B dual)\");\n                        const chartDataB = stripGraphicsDeep(natalB.data || {});\n                        result.person_b = {\n                            details: personB,\n                            chart: chartDataB,\n                            aspects: Array.isArray(natalB.aspects) ? natalB.aspects : chartDataB.aspects || []\n                        };\n                    } catch (e) {\n                        logger.warn(\"Dual Person B natal fetch failed\", e.message);\n                        result.person_b = {\n                            details: personB,\n                            error: \"Failed to compute Person B chart\"\n                        };\n                    }\n                }\n                // Optional Person B transits in dual transits mode\n                if (haveRange && !skipTransits && modeToken === \"DUAL_NATAL_TRANSITS\") {\n                    try {\n                        const { transitsByDate: transitsByDateB, retroFlagsByDate: retroFlagsByDateB, provenanceByDate: provenanceByDateB } = await getTransits(personB, {\n                            startDate: start,\n                            endDate: end,\n                            step\n                        }, headers, pass);\n                        const allB = Object.values(transitsByDateB).flatMap((day)=>day);\n                        const seismoB = calculateSeismograph(transitsByDateB, retroFlagsByDateB);\n                        // Enriched Person B transits (dual mode) with hooks & filtered_aspects\n                        result.person_b.chart = {\n                            ...result.person_b.chart || {},\n                            transitsByDate: seismoB.daily,\n                            provenanceByDate: provenanceByDateB\n                        };\n                        result.person_b.derived = result.person_b.derived || {};\n                        result.person_b.derived.seismograph_summary = seismoB.summary;\n                        result.person_b.derived.t2n_aspects = mapT2NAspects(allB); // Person B self transits (transit-to-natal B)\n                        result.person_b.transit_data = Object.values(transitsByDateB);\n                    } catch (e) {\n                        logger.warn(\"Dual Person B transits fetch failed\", e.message);\n                        result.person_b.transits_error = \"Failed to compute Person B transits\";\n                    }\n                }\n            } else {\n                result.person_b = {\n                    details: personB,\n                    validation_error: vBLeanPassive.message\n                };\n            }\n        }\n        // 2c) Implicit dual transit support: if mode is a single-person NATAL* variant that requests transits (e.g., NATAL_TRANSITS)\n        // and Person B was supplied, compute Person B transits as well (without requiring explicit DUAL_NATAL_TRANSITS token).\n        // Skip if relationshipMode (synastry/composite) to avoid duplication, and skip if already handled by explicit dual mode above.\n        if (haveRange && !skipTransits && !relationshipMode && personB && Object.keys(personB).length && modeToken && modeToken.startsWith(\"NATAL\") && modeToken.includes(\"TRANSITS\") && modeToken !== \"DUAL_NATAL_TRANSITS\") {\n            const vBLeanPassive2 = validateSubjectLean(personB);\n            if (vBLeanPassive2.isValid) {\n                // Ensure we have Person B natal baseline (light fetch if missing)\n                if (!result.person_b || !result.person_b.chart) {\n                    try {\n                        const natalB = await callNatal(API_ENDPOINTS.BIRTH_CHART, personB, headers, pass, \"Birth chart (B implicit dual)\");\n                        const chartDataB = stripGraphicsDeep(natalB.data || {});\n                        result.person_b = {\n                            details: personB,\n                            chart: chartDataB,\n                            aspects: Array.isArray(natalB.aspects) ? natalB.aspects : chartDataB.aspects || []\n                        };\n                    } catch (e) {\n                        logger.warn(\"Implicit dual Person B natal fetch failed\", e.message);\n                        result.person_b = {\n                            ...result.person_b || {},\n                            details: personB,\n                            error: \"Failed to compute Person B chart\"\n                        };\n                    }\n                }\n                // Only compute B transits if not already present\n                const hasBTransits = !!(result.person_b && result.person_b.chart && result.person_b.chart.transitsByDate);\n                if (!hasBTransits) {\n                    try {\n                        const { transitsByDate: transitsByDateB, retroFlagsByDate: retroFlagsByDateB, provenanceByDate: provenanceByDateB } = await getTransits(personB, {\n                            startDate: start,\n                            endDate: end,\n                            step\n                        }, headers, pass);\n                        const allB = Object.values(transitsByDateB).flatMap((day)=>day);\n                        const seismoB = calculateSeismograph(transitsByDateB, retroFlagsByDateB);\n                        // Enriched Person B implicit dual transits with hooks & filtered_aspects\n                        result.person_b.chart = {\n                            ...result.person_b.chart || {},\n                            transitsByDate: seismoB.daily,\n                            provenanceByDate: provenanceByDateB\n                        };\n                        result.person_b.derived = result.person_b.derived || {};\n                        result.person_b.derived.seismograph_summary = seismoB.summary;\n                        result.person_b.derived.t2n_aspects = mapT2NAspects(allB);\n                        result.person_b.transit_data = Object.values(transitsByDateB);\n                        result.person_b.implicit_dual_transits = true; // provenance flag\n                    } catch (e) {\n                        logger.warn(\"Implicit dual Person B transits fetch failed\", e.message);\n                        result.person_b.transits_error = \"Failed to compute Person B transits\";\n                    }\n                }\n            } else {\n                result.person_b = {\n                    ...result.person_b || {},\n                    details: personB,\n                    validation_error: vBLeanPassive2.message\n                };\n            }\n        }\n        // 3) Synastry (chart + aspects, or synastry aspects-only)\n        const validBLean = validateSubjectLean(personB);\n        const validBStrict = validateSubject(personB);\n        if (wantSynastryAspectsOnly && validBLean.isValid) {\n            // Synastry aspects-only endpoint\n            const syn = await apiCallWithRetry(API_ENDPOINTS.SYNASTRY_ASPECTS, {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    first_subject: subjectToAPI(personA, {\n                        ...pass,\n                        require_city: true\n                    }),\n                    second_subject: subjectToAPI(personB, {\n                        ...pass,\n                        require_city: true\n                    })\n                })\n            }, \"Synastry aspects data\");\n            const synData = stripGraphicsDeep(syn.data || {});\n            result.person_b = {\n                ...result.person_b || {},\n                details: personB\n            };\n            result.synastry_aspects = Array.isArray(syn.aspects) ? syn.aspects : synData.aspects || [];\n            result.synastry_data = synData;\n            // Generate relational mirror for synastry-aspects-only mode\n            const relationalMirror = generateRelationalMirror(result.person_a || {\n                details: personA,\n                aspects: []\n            }, {\n                details: personB,\n                aspects: []\n            }, result.synastry_aspects, {\n                aspects: [],\n                raw: {}\n            }, {});\n            // Add relational processing to synastry results\n            result.synastry_relational_mirror = relationalMirror.relational_mirror;\n            logger.debug(\"Added relational mirror to synastry-aspects-only mode\");\n            // Optional: augment with Person B natal chart so UI has both charts in aspects-only mode\n            try {\n                const natalB = await callNatal(API_ENDPOINTS.BIRTH_CHART, personB, headers, pass, \"Birth chart (B for synastry-aspects)\");\n                const chartDataB = stripGraphicsDeep(natalB.data || {});\n                result.person_b.chart = chartDataB;\n            } catch (e) {\n                logger.warn(\"Could not augment synastry-aspects with Person B natal chart\", e.message);\n            }\n        } else if (wantSynastry && validBStrict.isValid) {\n            // Full synastry chart endpoint\n            const syn = await apiCallWithRetry(API_ENDPOINTS.SYNASTRY_CHART, {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    first_subject: subjectToAPI(personA, {\n                        ...pass,\n                        require_city: true\n                    }),\n                    second_subject: subjectToAPI(personB, {\n                        ...pass,\n                        require_city: true\n                    })\n                })\n            }, \"Synastry chart\");\n            const synClean = stripGraphicsDeep(syn.data || {});\n            result.person_b = {\n                details: personB,\n                chart: synClean.second_subject || {}\n            };\n            result.synastry_aspects = Array.isArray(syn.aspects) ? syn.aspects : synClean.aspects || [];\n            // Generate relational mirror for full synastry mode\n            const relationalMirror = generateRelationalMirror(result.person_a || {\n                details: personA,\n                aspects: []\n            }, result.person_b, result.synastry_aspects, {\n                aspects: [],\n                raw: {}\n            }, {});\n            // Add relational processing to synastry results\n            result.synastry_relational_mirror = relationalMirror.relational_mirror;\n            logger.debug(\"Added relational mirror to full synastry mode\");\n            // Add Person B transits for synastry modes (especially SYNASTRY_TRANSITS)\n            if (modeToken === \"SYNASTRY_TRANSITS\" && haveRange && !skipTransits) {\n                logger.debug(\"Computing Person B transits for synastry mode:\", {\n                    start,\n                    end,\n                    step\n                });\n                const { transitsByDate: transitsByDateB, retroFlagsByDate: retroFlagsByDateB, provenanceByDate: provenanceByDateB } = await getTransits(personB, {\n                    startDate: start,\n                    endDate: end,\n                    step\n                }, headers, pass);\n                result.person_b.chart = {\n                    ...result.person_b.chart,\n                    transitsByDate: transitsByDateB\n                };\n                // Apply seismograph analysis to Person B transits\n                const seismographDataB = calculateSeismograph(transitsByDateB, retroFlagsByDateB);\n                // Enriched Person B synastry transits\n                result.person_b.chart.transitsByDate = seismographDataB.daily;\n                result.person_b.chart.provenanceByDate = provenanceByDateB;\n                result.person_b.derived = {\n                    seismograph_summary: seismographDataB.summary,\n                    t2n_aspects: mapT2NAspects(Object.values(transitsByDateB).flatMap((day)=>day))\n                };\n                logger.debug(\"Person B transits completed for synastry mode\");\n            }\n        }\n        // === COMPOSITE CHARTS AND TRANSITS ===\n        const vB = personB ? validateSubjectLean(personB) : {\n            isValid: false\n        };\n        if (wantComposite && vB.isValid) {\n            // Step 1: Always compute composite aspects first (data-only endpoint)\n            // This creates the midpoint composite chart data that serves as the base for transits\n            const composite = await computeComposite(personA, personB, pass, headers);\n            // Step 1.5: Add natal scaffolding for both persons (required for full relational mirror)\n            // CRITICAL FIX: Composite reports need both natal charts to generate polarity cards, \n            // Echo Loops, and SST logs. Without this scaffolding, the Poetic Brain only gets\n            // Balance Meter data and metadata, missing the foundational chart geometries.\n            // Ensure Person B natal chart is included if not already fetched\n            if (!result.person_b || !result.person_b.chart) {\n                try {\n                    logger.debug(\"Fetching Person B natal chart for composite scaffolding\");\n                    const natalB = await callNatal(API_ENDPOINTS.BIRTH_CHART, personB, headers, pass, \"Birth chart (B for composite scaffolding)\");\n                    const chartDataB = stripGraphicsDeep(natalB.data || {});\n                    result.person_b = {\n                        ...result.person_b || {},\n                        details: personB,\n                        chart: chartDataB,\n                        aspects: Array.isArray(natalB.aspects) ? natalB.aspects : chartDataB.aspects || []\n                    };\n                    logger.debug(\"Person B natal chart added to composite scaffolding\");\n                } catch (e) {\n                    logger.warn(\"Could not fetch Person B natal chart for composite scaffolding\", e.message);\n                    result.person_b = {\n                        ...result.person_b || {},\n                        details: personB\n                    };\n                }\n            } else {\n                // Person B chart already exists, just ensure details are included\n                result.person_b = {\n                    ...result.person_b || {},\n                    details: personB\n                };\n            }\n            // Add synastry aspects for cross-field hooks and polarity cards\n            try {\n                logger.debug(\"Computing synastry aspects for composite scaffolding\");\n                const syn = await apiCallWithRetry(API_ENDPOINTS.SYNASTRY_ASPECTS, {\n                    method: \"POST\",\n                    headers,\n                    body: JSON.stringify({\n                        first_subject: subjectToAPI(personA, pass),\n                        second_subject: subjectToAPI(personB, pass)\n                    })\n                }, \"Synastry aspects for composite scaffolding\");\n                const synData = stripGraphicsDeep(syn.data || {});\n                const synastryAspects = Array.isArray(syn.aspects) ? syn.aspects : synData.aspects || [];\n                // Generate comprehensive relational mirror with all missing elements\n                const relationalMirror = generateRelationalMirror(result.person_a || {\n                    details: personA,\n                    aspects: []\n                }, result.person_b || {\n                    details: personB,\n                    aspects: []\n                }, synastryAspects, composite, {} // composite transits will be added later if date range provided\n                );\n                result.composite = {\n                    aspects: composite.aspects,\n                    data: composite.raw,\n                    synastry_aspects: synastryAspects,\n                    synastry_data: synData,\n                    ...relationalMirror // Include comprehensive relational processing\n                };\n                logger.debug(`Added ${synastryAspects.length} synastry aspects and complete relational mirror to composite scaffolding`);\n            } catch (e) {\n                logger.warn(\"Could not compute synastry aspects for composite scaffolding\", e.message);\n                // Generate relational mirror even without synastry aspects (limited but still relational)\n                const relationalMirror = generateRelationalMirror(result.person_a || {\n                    details: personA,\n                    aspects: []\n                }, result.person_b || {\n                    details: personB,\n                    aspects: []\n                }, [], composite, {});\n                result.composite = {\n                    aspects: composite.aspects,\n                    data: composite.raw,\n                    ...relationalMirror // Include relational processing even without synastry\n                };\n            }\n            // Step 2: Composite transits: TEMPORARILY DISABLED due to API compatibility issues\n            // The transit API expects natal chart birth data but composite charts only have planetary positions\n            // TODO: Investigate if there's a specific composite transit endpoint or if we need synthetic birth data\n            if (haveRange && !skipTransits && modeToken === \"COMPOSITE_TRANSITS\") {\n                logger.debug(\"Computing composite transits for date range:\", {\n                    start,\n                    end,\n                    step\n                });\n                // Calculate transits to the composite chart using the composite chart as base\n                const t = await computeCompositeTransits(composite.raw, start, end, step, pass, headers);\n                // Store raw transit aspects by date\n                result.composite.transitsByDate = t.transitsByDate;\n                if (t._note) result.composite.note = t._note;\n                // Step 3: Apply seismograph analysis to composite transits\n                // This converts raw aspects into magnitude, valence, and volatility metrics\n                const seismographData = calculateSeismograph(t.transitsByDate, {});\n                // Replace raw aspects with seismograph-processed daily data\n                // Enriched composite transits with hooks & filtered_aspects\n                result.composite.transitsByDate = seismographData.daily;\n                // Add derived metrics for frontend consumption\n                result.composite.derived = {\n                    seismograph_summary: seismographData.summary\n                };\n                // Update relational Balance Meter with transit data if relational mirror exists\n                if (result.composite.relational_mirror) {\n                    const updatedRelationalBalanceMeter = computeRelationalBalanceMeter(result.composite.synastry_aspects || [], result.composite.aspects || [], seismographData.daily);\n                    result.composite.relational_mirror.relational_balance_meter = updatedRelationalBalanceMeter;\n                    logger.debug(\"Updated relational Balance Meter with composite transit data\");\n                }\n                // Annotate if transits were auto-added (mode not explicitly COMPOSITE_TRANSITS)\n                if (modeToken !== \"COMPOSITE_TRANSITS\") {\n                    result.composite.auto_transits_included = true;\n                    result.composite.request_mode = modeToken;\n                }\n                logger.debug(\"Composite transits completed with seismograph analysis\");\n            }\n            // Add note about disabled composite transits only when not explicitly requested\n            if (haveRange && !skipTransits && modeToken !== \"COMPOSITE_TRANSITS\") {\n                result.composite.transitsByDate = {};\n                result.composite.note = \"Composite transits temporarily disabled due to API compatibility issues\";\n                logger.debug(\"Composite transits disabled - returning empty transit data\");\n            }\n        }\n        // === BALANCE METER MODE ===\n        // Only generate Balance Meter for solo reports, not relational ones\n        logger.debug(\"Checking Balance Meter conditions:\", {\n            wantBalanceMeter,\n            haveRange,\n            relationshipMode,\n            shouldRunBalanceMeter: wantBalanceMeter && haveRange && !relationshipMode\n        });\n        if (wantBalanceMeter && haveRange && !relationshipMode) {\n            logger.debug(\"Processing Balance Meter mode for standalone report\");\n            // Ensure Person A transit seismograph exists; compute if missing\n            if (!result.person_a?.chart?.transitsByDate) {\n                try {\n                    const { transitsByDate, retroFlagsByDate, provenanceByDate } = await getTransits(personA, {\n                        startDate: start,\n                        endDate: end,\n                        step\n                    }, headers, pass);\n                    const seismographData = calculateSeismograph(transitsByDate, retroFlagsByDate);\n                    result.person_a = result.person_a || {};\n                    result.person_a.derived = result.person_a.derived || {};\n                    result.person_a.derived.seismograph_summary = seismographData.summary;\n                    result.person_a.chart = {\n                        ...result.person_a.chart || {},\n                        transitsByDate: seismographData.daily,\n                        provenanceByDate\n                    };\n                } catch (e) {\n                    logger.warn(\"Balance Meter fallback transit compute failed:\", e.message);\n                }\n            }\n            if (result.person_a?.chart?.transitsByDate) {\n                // Balance Meter report focuses on triple-channel seismograph outputs\n                const balanceMeterReport = {\n                    period: {\n                        start: start,\n                        end: end,\n                        step: step\n                    },\n                    schema_version: \"1.2\",\n                    channel_summary: result.person_a.derived?.seismograph_summary || null,\n                    daily_entries: result.person_a.chart.transitsByDate,\n                    person: {\n                        name: personA.name || \"Subject\",\n                        birth_date: personA.birth_date,\n                        birth_time: personA.birth_time,\n                        birth_location: personA.birth_location\n                    }\n                };\n                // Replace standard natal-centric response with Balance Meter focus\n                result.balance_meter = balanceMeterReport;\n                result.mode = \"balance_meter\";\n                logger.debug(\"Balance Meter standalone report generated successfully\");\n            } else {\n                logger.warn(\"Balance Meter requested but no transits available to compute report\");\n            }\n        }\n        // Post-compute contract assertions: if relationship mode requested ensure presence of person_b/composite\n        if (relationshipMode) {\n            const missing = [];\n            if ((wantSynastry || wantSynastryAspectsOnly) && !result.person_b) missing.push(\"person_b\");\n            if (wantComposite && !result.composite) missing.push(\"composite\");\n            if (missing.length) {\n                throw Object.assign(new Error(\"PIPELINE_DROPPED_B\"), {\n                    code: \"PIPELINE_DROPPED_B\",\n                    missing\n                });\n            }\n        }\n        // Final narrative key scrub (defense-in-depth for Clear Mirror contract)\n        function scrubNarrativeKeys(obj) {\n            if (!obj || typeof obj !== \"object\") return obj;\n            if (Array.isArray(obj)) return obj.map(scrubNarrativeKeys);\n            const out = {};\n            for (const [k, v] of Object.entries(obj)){\n                if (k === \"field\" || k === \"voice\" || k === \"map\") continue;\n                out[k] = scrubNarrativeKeys(v);\n            }\n            return out;\n        }\n        // Attach relocation coordinates when applied\n        try {\n            if (relocationMode === \"A_local\") {\n                const loc = aLocal || body.custom_location || null;\n                if (loc && typeof loc.lat === \"number\" && typeof loc.lon === \"number\") {\n                    const tz = loc.tz || transitA?.timezone || null;\n                    result.provenance.relocation_coords = {\n                        lat: loc.lat,\n                        lon: loc.lon,\n                        tz\n                    };\n                }\n            } else if (relocationMode === \"Midpoint\") {\n                if (typeof transitA?.latitude === \"number\" && typeof transitA?.longitude === \"number\" && transitA?.timezone) {\n                    result.provenance.relocation_coords = {\n                        lat: transitA.latitude,\n                        lon: transitA.longitude,\n                        tz: transitA.timezone\n                    };\n                }\n            } else if (relocationMode === \"Custom\") {\n                const c = body.custom_location;\n                if (c && typeof c.latitude === \"number\" && typeof c.longitude === \"number\") {\n                    result.provenance.relocation_coords = {\n                        lat: c.latitude,\n                        lon: c.longitude,\n                        tz: transitA?.timezone || c.timezone || null\n                    };\n                }\n            }\n        } catch  {}\n        // Human-readable house system\n        try {\n            const hs = result.provenance.house_system;\n            const names = {\n                P: \"Placidus\",\n                W: \"Whole Sign\",\n                R: \"Regiomontanus\",\n                K: \"Koch\",\n                C: \"Campanus\",\n                E: \"Equal\"\n            };\n            if (typeof hs === \"string\" && hs.length === 1 && names[hs]) {\n                result.provenance.house_system_name = names[hs];\n            }\n        } catch  {}\n        // Attach a data-only Woven Map report (does not add VOICE content)\n        try {\n            const period = start && end ? {\n                start,\n                end,\n                step\n            } : null;\n            result.woven_map = composeWovenMapReport({\n                result,\n                mode: modeToken,\n                period\n            });\n        } catch (e) {\n            logger.warn(\"Woven Map composer failed:\", e.message);\n        }\n        const safeResult = scrubNarrativeKeys(result);\n        return {\n            statusCode: 200,\n            body: JSON.stringify(safeResult)\n        };\n    } catch (error) {\n        logger.error(\"Handler error:\", error);\n        return {\n            statusCode: 500,\n            body: JSON.stringify({\n                error: error?.message || \"Internal server error\",\n                code: error?.code || \"INTERNAL_ERROR\",\n                errorId: generateErrorId(),\n                stack: error?.stack || null,\n                details: error\n            })\n        };\n    }\n};\n// ---------------------------------------------------------------------------\n// City Resolution Endpoint - Helper for debugging city->coords resolution\n// GET /api/resolve-city?city=Bryn+Mawr&state=PA&nation=US\n// Returns resolved coordinates and timezone to verify what the API sees\n// ---------------------------------------------------------------------------\nexports.resolveCity = async function(event) {\n    try {\n        const qs = event.queryStringParameters || {};\n        const city = qs.city;\n        const state = qs.state;\n        const nation = qs.nation || \"US\";\n        if (!city) {\n            return {\n                statusCode: 400,\n                body: JSON.stringify({\n                    error: \"city parameter required\"\n                })\n            };\n        }\n        // Use same formation logic as transit subjects\n        const cityField = state ? `${city}, ${state}` : city;\n        const testSubject = {\n            name: \"Test Resolution\",\n            year: 2025,\n            month: 1,\n            day: 1,\n            hour: 12,\n            minute: 0,\n            city: cityField,\n            nation: nation,\n            zodiac_type: \"Tropic\"\n        };\n        if (process.env.GEONAMES_USERNAME) {\n            testSubject.geonames_username = process.env.GEONAMES_USERNAME;\n        }\n        const headers = buildHeaders();\n        const payload = {\n            name: testSubject.name,\n            year: testSubject.year,\n            month: testSubject.month,\n            day: testSubject.day,\n            hour: testSubject.hour,\n            minute: testSubject.minute,\n            city: testSubject.city,\n            nation: testSubject.nation,\n            zodiac_type: testSubject.zodiac_type,\n            ...testSubject.geonames_username && {\n                geonames_username: testSubject.geonames_username\n            }\n        };\n        // Use birth-data endpoint for quick resolution test\n        const response = await apiCallWithRetry(API_ENDPOINTS.BIRTH_DATA, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(payload)\n        }, `City resolution test for ${cityField}, ${nation}`);\n        const resolved = {\n            success: true,\n            query: {\n                city,\n                state,\n                nation,\n                formatted: cityField\n            },\n            resolved: {\n                latitude: response.lat || response.latitude,\n                longitude: response.lng || response.longitude,\n                timezone: response.tz_str || response.timezone,\n                city_resolved: response.city,\n                nation_resolved: response.nation\n            },\n            geonames_used: !!testSubject.geonames_username,\n            raw_response: response\n        };\n        logger.info(`City resolution: ${cityField}, ${nation} -> ${resolved.resolved.latitude}, ${resolved.resolved.longitude}`);\n        return {\n            statusCode: 200,\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(resolved)\n        };\n    } catch (error) {\n        logger.error(\"City resolution error:\", error);\n        return {\n            statusCode: 500,\n            body: JSON.stringify({\n                success: false,\n                error: error.message || \"City resolution failed\",\n                details: error\n            })\n        };\n    }\n};\n// ---------------------------------------------------------------------------\n// Lightweight health endpoint logic (consumed by astrology-health.js wrapper)\n// Provides: version, environment, cold start info, basic config validation,\n// optional external API latency probe (opt-in via ?ping=now)\n// ---------------------------------------------------------------------------\nlet __RC_COLD_START_TS = global.__RC_COLD_START_TS || Date.now();\nglobal.__RC_COLD_START_TS = __RC_COLD_START_TS;\nlet __RC_HEALTH_INVOCATIONS = global.__RC_HEALTH_INVOCATIONS || 0;\nglobal.__RC_HEALTH_INVOCATIONS = __RC_HEALTH_INVOCATIONS;\nasync function rapidApiPing(headers) {\n    const controller = new AbortController();\n    const to = setTimeout(()=>controller.abort(), 3500);\n    try {\n        const res = await fetch(`${API_ENDPOINTS.NOW}`, {\n            method: \"GET\",\n            headers,\n            signal: controller.signal\n        });\n        const ok = res.ok;\n        const status = res.status;\n        clearTimeout(to);\n        return {\n            ok,\n            status\n        };\n    } catch (e) {\n        clearTimeout(to);\n        return {\n            ok: false,\n            error: e.name === \"AbortError\" ? \"timeout\" : e.message\n        };\n    }\n}\nexports.health = async function(event) {\n    __RC_HEALTH_INVOCATIONS++;\n    const qs = event && event.queryStringParameters || {};\n    const wantPing = \"ping\" in qs || \"now\" in qs; // enable API probe with ?ping or ?ping=1\n    const rapKeyPresent = !!process.env.RAPIDAPI_KEY;\n    let ping = null;\n    if (wantPing && rapKeyPresent) {\n        try {\n            ping = await rapidApiPing(buildHeaders());\n        } catch (e) {\n            ping = {\n                ok: false,\n                error: e.message\n            };\n        }\n    }\n    const body = {\n        success: true,\n        service: \"astrology-mathbrain\",\n        version: MATH_BRAIN_VERSION,\n        ephemeris_source: EPHEMERIS_SOURCE,\n        calibration_boundary: CALIBRATION_BOUNDARY,\n        timestamp: new Date().toISOString(),\n        environment: \"development\" || 0,\n        rapidapi: {\n            configured: rapKeyPresent,\n            ping: ping\n        },\n        cold_start_ms: Date.now() - __RC_COLD_START_TS,\n        invocations: __RC_HEALTH_INVOCATIONS,\n        uptime_s: process.uptime(),\n        memory: (()=>{\n            try {\n                const m = process.memoryUsage();\n                return {\n                    rss: m.rss,\n                    heapUsed: m.heapUsed,\n                    heapTotal: m.heapTotal\n                };\n            } catch  {\n                return null;\n            }\n        })()\n    };\n    return {\n        statusCode: 200,\n        headers: {\n            \"content-type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc2VydmVyL2FzdHJvbG9neS1tYXRoYnJhaW4uanMiLCJtYXBwaW5ncyI6IkFBQUEsc0hBQXNIO0FBQ3RILDRGQUE0Rjs7QUFFNUYsTUFBTSxFQUFFQSxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDOUIsTUFBTSxFQUFFQyxZQUFZQyxlQUFlLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFRyxVQUFVLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3RELE1BQU1LLGVBQWU7QUFFckIsTUFBTUMsZ0JBQWdCO0lBQ3BCQyxhQUFvQixDQUFDLEVBQUVGLGFBQWEsbUJBQW1CLENBQUM7SUFDeERHLG9CQUFvQixDQUFDLEVBQUVILGFBQWEsMEJBQTBCLENBQUM7SUFDL0RJLGdCQUFvQixDQUFDLEVBQUVKLGFBQWEsc0JBQXNCLENBQUM7SUFDM0RLLGVBQW9CLENBQUMsRUFBRUwsYUFBYSxxQkFBcUIsQ0FBQztJQUMxRE0saUJBQW9CLENBQUMsRUFBRU4sYUFBYSw0QkFBNEIsQ0FBQztJQUNqRU8sa0JBQW9CLENBQUMsRUFBRVAsYUFBYSw2QkFBNkIsQ0FBQztJQUNsRVEsWUFBb0IsQ0FBQyxFQUFFUixhQUFhLGtCQUFrQixDQUFDO0lBQ3ZEUyxLQUFvQixDQUFDLEVBQUVULGFBQWEsV0FBVyxDQUFDO0lBQ2hEVSxtQkFBb0IsQ0FBQyxFQUFFVixhQUFhLDhCQUE4QixDQUFDO0FBQ3JFO0FBRUEsNERBQTREO0FBQzVELE1BQU0sRUFBRVcsYUFBYSxFQUFFLEdBQUdoQixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVpQixxQkFBcUIsRUFBRSxHQUFHakIsbUJBQU9BLENBQUM7QUFDMUMsTUFBTWtCLFNBQVM7SUFDYkMsS0FBSyxDQUFDLEdBQUdDLE9BQVNDLFFBQVFGLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLQztJQUMxQ0UsTUFBTSxDQUFDLEdBQUdGLE9BQVNDLFFBQVFDLElBQUks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LFdBQVcsSUFBSXZnQixPQUFPOFAsV0FBVztRQUNqQzBRLGFBQWFuMUIsaUJBQXdCO1FBQ3JDbzFCLFVBQVU7WUFDUkMsWUFBWU47WUFDWkMsTUFBTUE7UUFDUjtRQUNBTSxlQUFlM2dCLEtBQUttUSxHQUFHLEtBQUtxUDtRQUM1Qm9CLGFBQWFsQjtRQUNibUIsVUFBVXgxQixRQUFReTFCLE1BQU07UUFDeEJDLFFBQVEsQ0FBQztZQUFLLElBQUc7Z0JBQUMsTUFBTXp6QixJQUFFakMsUUFBUTIxQixXQUFXO2dCQUFHLE9BQU87b0JBQUVDLEtBQUkzekIsRUFBRTJ6QixHQUFHO29CQUFFQyxVQUFTNXpCLEVBQUU0ekIsUUFBUTtvQkFBRUMsV0FBVTd6QixFQUFFNnpCLFNBQVM7Z0JBQUM7WUFBRyxFQUFDLE9BQUs7Z0JBQUUsT0FBTztZQUFNO1FBQUM7SUFDMUk7SUFDQSxPQUFPO1FBQUV2ZCxZQUFZO1FBQUtqUCxTQUFTO1lBQUUsZ0JBQWU7UUFBbUI7UUFBR00sTUFBTUMsS0FBS0MsU0FBUyxDQUFDRjtJQUFNO0FBQ3ZHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd292ZW4td2ViLWFwcC8uL2xpYi9zZXJ2ZXIvYXN0cm9sb2d5LW1hdGhicmFpbi5qcz9hZjc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgY29kZSBpcyBhIGNvbnNvbGlkYXRlZCBhbmQgY2xlYW5lZCB2ZXJzaW9uIG9mIHRoZSBwcm92aWRlZCBKYXZhc2NyaXB0IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBBc3Ryb2xvZ2VyIEFQSS5cbi8vIEl0IGlzIHJlYWR5IHRvIGJlIHVzZWQgYXMgYSBzZXJ2ZXJsZXNzIGZ1bmN0aW9uIGhhbmRsZXIgKGUuZy4sIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCkuXG5cbmNvbnN0IHsgYWdncmVnYXRlIH0gPSByZXF1aXJlKCcuLi8uLi9zcmMvc2Vpc21vZ3JhcGgnKTtcbmNvbnN0IHsgX2ludGVybmFsczogc2Vpc21vSW50ZXJuYWxzIH0gPSByZXF1aXJlKCcuLi8uLi9zcmMvc2Vpc21vZ3JhcGgnKTtcbmNvbnN0IHsgY29tcHV0ZVNGRCwgY29tcHV0ZUJhbGFuY2VWYWxlbmNlIH0gPSByZXF1aXJlKCcuLi8uLi9zcmMvYmFsYW5jZS1tZXRlcicpO1xuY29uc3QgQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vYXN0cm9sb2dlci5wLnJhcGlkYXBpLmNvbSc7XG5cbmNvbnN0IEFQSV9FTkRQT0lOVFMgPSB7XG4gIEJJUlRIX0NIQVJUOiAgICAgICAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdjQvYmlydGgtY2hhcnRgLCAgICAgICAgICAvLyBuYXRhbCBjaGFydCArIGFzcGVjdHNcbiAgTkFUQUxfQVNQRUNUU19EQVRBOiBgJHtBUElfQkFTRV9VUkx9L2FwaS92NC9uYXRhbC1hc3BlY3RzLWRhdGFgLCAgLy8gbmF0YWwgYXNwZWN0cyBvbmx5XG4gIFNZTkFTVFJZX0NIQVJUOiAgICAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdjQvc3luYXN0cnktY2hhcnRgLCAgICAgICAvLyBB4oaUQiArIGFzcGVjdHNcbiAgVFJBTlNJVF9DSEFSVDogICAgICBgJHtBUElfQkFTRV9VUkx9L2FwaS92NC90cmFuc2l0LWNoYXJ0YCwgICAgICAgIC8vIHN1YmplY3QgKyBhc3BlY3RzXG4gIFRSQU5TSVRfQVNQRUNUUzogICAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdjQvdHJhbnNpdC1hc3BlY3RzLWRhdGFgLCAvLyBkYXRhLW9ubHlcbiAgU1lOQVNUUllfQVNQRUNUUzogICBgJHtBUElfQkFTRV9VUkx9L2FwaS92NC9zeW5hc3RyeS1hc3BlY3RzLWRhdGFgLFxuICBCSVJUSF9EQVRBOiAgICAgICAgIGAke0FQSV9CQVNFX1VSTH0vYXBpL3Y0L2JpcnRoLWRhdGFgLFxuICBOT1c6ICAgICAgICAgICAgICAgIGAke0FQSV9CQVNFX1VSTH0vYXBpL3Y0L25vd2AsXG4gIENPTVBPU0lURV9BU1BFQ1RTOiAgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdjQvY29tcG9zaXRlLWFzcGVjdHMtZGF0YWAsIC8vIGNvbXBvc2l0ZSBhc3BlY3RzIG9ubHlcbn07XG5cbi8vIFNpbXBsaWZpZWQgbG9nZ2luZyB1dGlsaXR5IHRvIGF2b2lkIGV4dGVybmFsIGRlcGVuZGVuY2llc1xuY29uc3QgeyBtYXBUMk5Bc3BlY3RzIH0gPSByZXF1aXJlKCcuLi8uLi9zcmMvcmF2ZW4tbGl0ZS1tYXBwZXInKTtcbmNvbnN0IHsgY29tcG9zZVdvdmVuTWFwUmVwb3J0IH0gPSByZXF1aXJlKCcuLi8uLi9zcmMvcmVwb3J0ZXJzL3dvdmVuLW1hcC1jb21wb3NlcicpO1xuY29uc3QgbG9nZ2VyID0ge1xuICBsb2c6ICguLi5hcmdzKSA9PiBjb25zb2xlLmxvZyhgW0xPR11gLCAuLi5hcmdzKSxcbiAgaW5mbzogKC4uLmFyZ3MpID0+IGNvbnNvbGUuaW5mbyhgW0lORk9dYCwgLi4uYXJncyksXG4gIHdhcm46ICguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4oYFtXQVJOXWAsIC4uLmFyZ3MpLFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoYFtFUlJPUl1gLCAuLi5hcmdzKSxcbiAgZGVidWc6ICguLi5hcmdzKSA9PiBwcm9jZXNzLmVudi5MT0dfTEVWRUwgPT09ICdkZWJ1ZycgJiYgY29uc29sZS5kZWJ1ZyhgW0RFQlVHXWAsIC4uLmFyZ3MpLFxufTtcblxuLy8gLS0tIERBVEEtT05MWSBIRUxQRVJTIChkcm9wLWluKSAtLS1cbmZ1bmN0aW9uIHN0cmlwR3JhcGhpY3NEZWVwKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIG9iajtcbiAgY29uc3Qga2lsbCA9IG5ldyBTZXQoW1xuICAgICd3aGVlbCcsJ3N2ZycsJ2ltYWdlJywnaW1hZ2VzJywnY2hhcnRfaW1hZ2UnLCdncmFwaGljYWwnLCdwbmcnLCdqcGcnLCdqcGVnJywncGRmJyxcbiAgICAnd2hlZWxfdXJsJywnaW1hZ2VfdXJsJywnY2hhcnRVcmwnLCdyZW5kZXJlZF9zdmcnLCdyZW5kZXJlZF9wbmcnXG4gIF0pO1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChzdHJpcEdyYXBoaWNzRGVlcCk7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgaWYgKGtpbGwuaGFzKGspKSBjb250aW51ZTtcbiAgICBpZiAodiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG91dFtrXSA9IHN0cmlwR3JhcGhpY3NEZWVwKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRba10gPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBQcm92ZW5hbmNlIGNvbnN0YW50c1xuY29uc3QgTUFUSF9CUkFJTl9WRVJTSU9OID0gJzAuMi4xJzsgLy8gU2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgdmVyc2lvblxuY29uc3QgRVBIRU1FUklTX1NPVVJDRSA9ICdBc3Ryb2xvZ2VyQVBJLXY0JztcbmNvbnN0IENBTElCUkFUSU9OX0JPVU5EQVJZID0gJzIwMjUtMDktMDUnO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdGVwKHN0ZXApIHtcbiAgY29uc3QgcyA9IFN0cmluZyhzdGVwIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoWydkYWlseScsJ3dlZWtseScsJ21vbnRobHknXS5pbmNsdWRlcyhzKSkgcmV0dXJuIHM7XG4gIGlmIChzID09PSAnMWQnKSByZXR1cm4gJ2RhaWx5JztcbiAgaWYgKHMgPT09ICc3ZCcpIHJldHVybiAnd2Vla2x5JztcbiAgaWYgKHMgPT09ICcxbScgfHwgcyA9PT0gJzFtbycgfHwgcyA9PT0gJ21vbnRobHknKSByZXR1cm4gJ21vbnRobHknO1xuICByZXR1cm4gJ2RhaWx5Jztcbn1cblxuLy8gVGltZXpvbmUgbm9ybWFsaXphdGlvbiBmb3IgY29tbW9uIGFsaWFzZXMgYW5kIFVTLyogZm9ybXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWV6b25lKHR6KSB7XG4gIGlmICghdHogfHwgdHlwZW9mIHR6ICE9PSAnc3RyaW5nJykgcmV0dXJuIHR6O1xuICBjb25zdCB0ID0gdHoudHJpbSgpO1xuICBjb25zdCBtYXAgPSB7XG4gICAgLy8gVVMgYXJlYSBhbGlhc2VzXG4gICAgJ1VTL0Vhc3Rlcm4nOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gICAgJ1VTL0NlbnRyYWwnOiAnQW1lcmljYS9DaGljYWdvJyxcbiAgICAnVVMvTW91bnRhaW4nOiAnQW1lcmljYS9EZW52ZXInLFxuICAgICdVUy9QYWNpZmljJzogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnLFxuICAgICdVUy9Bcml6b25hJzogJ0FtZXJpY2EvUGhvZW5peCcsXG4gICAgJ1VTL0FsYXNrYSc6ICdBbWVyaWNhL0FuY2hvcmFnZScsXG4gICAgJ1VTL0hhd2FpaSc6ICdQYWNpZmljL0hvbm9sdWx1JyxcbiAgICAnVVMvRWFzdC1JbmRpYW5hJzogJ0FtZXJpY2EvSW5kaWFuYS9JbmRpYW5hcG9saXMnLFxuICAgIC8vIEFiYnJldmlhdGlvbnMgKGJlc3QtZWZmb3J0OyBEU1Qgbm90IGluZmVycmVkLCBidXQgdXBzdHJlYW0gb25seSBuZWVkcyBJQU5BIElEKVxuICAgICdFU1QnOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gICAgJ0VEVCc6ICdBbWVyaWNhL05ld19Zb3JrJyxcbiAgICAnQ1NUJzogJ0FtZXJpY2EvQ2hpY2FnbycsXG4gICAgJ0NEVCc6ICdBbWVyaWNhL0NoaWNhZ28nLFxuICAgICdNU1QnOiAnQW1lcmljYS9EZW52ZXInLFxuICAgICdNRFQnOiAnQW1lcmljYS9EZW52ZXInLFxuICAgICdQU1QnOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgJ1BEVCc6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyxcbiAgICAnQUtTVCc6ICdBbWVyaWNhL0FuY2hvcmFnZScsXG4gICAgJ0FLRFQnOiAnQW1lcmljYS9BbmNob3JhZ2UnLFxuICAgICdIU1QnOiAnUGFjaWZpYy9Ib25vbHVsdSdcbiAgfTtcbiAgcmV0dXJuIG1hcFt0XSB8fCB0O1xufVxuXG4vLyBEZXJpdmUgdGltZSBwcm92ZW5hbmNlIGZvciBhIHN1YmplY3QgYmFzZWQgb24gcHJlc2VuY2Ugb2YgaG91ci9taW51dGVcbmZ1bmN0aW9uIGRlcml2ZVRpbWVNZXRhKHN1YmplY3QpIHtcbiAgY29uc3QgaCA9IHN1YmplY3Q/LmhvdXI7XG4gIGNvbnN0IG0gPSBzdWJqZWN0Py5taW51dGU7XG4gIGNvbnN0IGtub3duID0gKGggIT09IHVuZGVmaW5lZCAmJiBoICE9PSBudWxsKSAmJiAobSAhPT0gdW5kZWZpbmVkICYmIG0gIT09IG51bGwpO1xuICBjb25zdCBwYWQyID0gKG4pPT4gU3RyaW5nKG4pLnBhZFN0YXJ0KDIsICcwJyk7XG4gIHJldHVybiB7XG4gICAgYmlydGhfdGltZV9rbm93bjogISFrbm93bixcbiAgICB0aW1lX3ByZWNpc2lvbjoga25vd24gPyAnZXhhY3QnIDogJ3Vua25vd24nLFxuICAgIGVmZmVjdGl2ZV90aW1lX3VzZWQ6IGtub3duID8gYCR7cGFkMihoKX06JHtwYWQyKG0pfWAgOiB1bmRlZmluZWRcbiAgfTtcbn1cblxuLy8gQ2Fub25pY2FsaXplIGFuIGluY29taW5nIHRpbWUgcG9saWN5IHRva2VuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVUaW1lUG9saWN5KHJhdykge1xuICBpZiAoIXJhdykgcmV0dXJuICd1c2VyX3Byb3ZpZGVkJztcbiAgY29uc3QgdCA9IFN0cmluZyhyYXcpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodCA9PT0gJ3BsYW5ldGFyeV9vbmx5JyB8fCB0ID09PSAncGxhbmV0YXJ5LW9ubHknIHx8IHQgPT09ICdwbGFuZXRhcnknKSByZXR1cm4gJ3BsYW5ldGFyeV9vbmx5JztcbiAgaWYgKHQgPT09ICd3aG9sZV9zaWduJyB8fCB0ID09PSAnd2hvbGUtc2lnbicgfHwgdCA9PT0gJ3dob2xlc2lnbicgfHwgdCA9PT0gJ3dob2xlJykgcmV0dXJuICd3aG9sZV9zaWduJztcbiAgaWYgKHQgPT09ICdzZW5zaXRpdml0eV9zY2FuJyB8fCB0ID09PSAnc2Vuc2l0aXZpdHktc2NhbicgfHwgdCA9PT0gJ3NjYW4nKSByZXR1cm4gJ3NlbnNpdGl2aXR5X3NjYW4nO1xuICByZXR1cm4gJ3VzZXJfcHJvdmlkZWQnO1xufVxuXG4vLyBEZXJpdmUgdGltZSBwcm92ZW5hbmNlIGJ1dCBob25vciBleHBsaWNpdCB0aW1lX3BvbGljeSB3aGVuIGJpcnRoIHRpbWUgaXMgdW5rbm93blxuZnVuY3Rpb24gZGVyaXZlVGltZU1ldGFXaXRoUG9saWN5KHN1YmplY3QsIHRpbWVQb2xpY3kpIHtcbiAgY29uc3QgYmFzZSA9IGRlcml2ZVRpbWVNZXRhKHN1YmplY3QpO1xuICBjb25zdCB1bmtub3duID0gIWJhc2UuYmlydGhfdGltZV9rbm93bjtcbiAgaWYgKCF1bmtub3duKSByZXR1cm4gYmFzZTtcbiAgY29uc3QgcG9saWN5ID0gY2Fub25pY2FsaXplVGltZVBvbGljeSh0aW1lUG9saWN5KTtcbiAgaWYgKHBvbGljeSA9PT0gJ3BsYW5ldGFyeV9vbmx5Jykge1xuICAgIHJldHVybiB7IGJpcnRoX3RpbWVfa25vd246IGZhbHNlLCB0aW1lX3ByZWNpc2lvbjogJ3Vua25vd24nLCBlZmZlY3RpdmVfdGltZV91c2VkOiB1bmRlZmluZWQgfTtcbiAgfVxuICBpZiAocG9saWN5ID09PSAnd2hvbGVfc2lnbicpIHtcbiAgICByZXR1cm4geyBiaXJ0aF90aW1lX2tub3duOiBmYWxzZSwgdGltZV9wcmVjaXNpb246ICdub29uX2ZhbGxiYWNrJywgZWZmZWN0aXZlX3RpbWVfdXNlZDogJzEyOjAwJyB9O1xuICB9XG4gIGlmIChwb2xpY3kgPT09ICdzZW5zaXRpdml0eV9zY2FuJykge1xuICAgIHJldHVybiB7IGJpcnRoX3RpbWVfa25vd246IGZhbHNlLCB0aW1lX3ByZWNpc2lvbjogJ3JhbmdlX3NjYW4nLCBlZmZlY3RpdmVfdGltZV91c2VkOiB1bmRlZmluZWQgfTtcbiAgfVxuICByZXR1cm4gYmFzZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJqZWN0TGVhbihzID0ge30pIHtcbiAgY29uc3QgcmVxID0gWyd5ZWFyJywnbW9udGgnLCdkYXknLCdob3VyJywnbWludXRlJywnbGF0aXR1ZGUnLCdsb25naXR1ZGUnXTtcbiAgY29uc3QgbWlzc2luZyA9IHJlcS5maWx0ZXIoayA9PiBzW2tdID09PSB1bmRlZmluZWQgfHwgc1trXSA9PT0gbnVsbCB8fCBzW2tdID09PSAnJyk7XG4gIHJldHVybiB7IGlzVmFsaWQ6IG1pc3NpbmcubGVuZ3RoID09PSAwLCBtZXNzYWdlOiBtaXNzaW5nLmxlbmd0aCA/IGBNaXNzaW5nOiAke21pc3Npbmcuam9pbignLCAnKX1gIDogJ29rJyB9O1xufVxuXG4vLyAtLS0gSGVscGVyIEZ1bmN0aW9ucyAtLS1cblxuLyoqXG4gKiBQYXJzZXMgY29vcmRpbmF0ZSBzdHJpbmdzIGluIHZhcmlvdXMgZm9ybWF0cyAoRE1TLCBkZWNpbWFsKVxuICogQWNjZXB0czogXCI0MMKwMSdOLCA3NcKwMTgnV1wiLCBcIjQwwrAgMScgTiwgNzXCsCAxOCcgV1wiLCBvcHRpb25hbCBzZWNvbmRzIGFuZCB1bmljb2RlIHByaW1lcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZFN0cmluZyAtIENvb3JkaW5hdGUgc3RyaW5nLlxuICogQHJldHVybnMge3tsYXQ6IG51bWJlciwgbG9uOiBudW1iZXJ9fG51bGx9IFBhcnNlZCBjb29yZGluYXRlcyBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29vcmRpbmF0ZXMoY29vcmRTdHJpbmcpIHtcbiAgaWYgKCFjb29yZFN0cmluZyB8fCB0eXBlb2YgY29vcmRTdHJpbmcgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbDtcblxuICAvLyBOb3JtYWxpemUgY29tbW9uIHVuaWNvZGUgdmFyaWFudHNcbiAgbGV0IHMgPSBjb29yZFN0cmluZy50cmltKClcbiAgICAucmVwbGFjZSgvwrovZywgJ8KwJykgICAgLy8gYWx0IGRlZ3JlZSBzeW1ib2xcbiAgICAucmVwbGFjZSgvW+KAmeKAsl0vZywgXCInXCIpIC8vIHByaW1lIHRvIGFwb3N0cm9waGVcbiAgICAucmVwbGFjZSgvW+KAneKAs10vZywgJ1wiJyk7IC8vIGRvdWJsZSBwcmltZSB0byBxdW90ZVxuXG4gIC8vIEZsZXhpYmxlIERNUyBwYXR0ZXJuIHdpdGggb3B0aW9uYWwgbWludXRlcy9zZWNvbmRzIGFuZCBzcGFjZXNcbiAgLy8gR3JvdXBzOiAxPWxhdERlZywyPWxhdE1pbj8sMz1sYXRTZWM/LDQ9bGF0SGVtLDU9bG9uRGVnLDY9bG9uTWluPyw3PWxvblNlYz8sOD1sb25IZW1cbiAgY29uc3QgRE1TID0gL15cXHMqKFxcZHsxLDN9KSg/OlxccyrCsFxccyooXFxkezEsMn0pKD86WydcIl0/XFxzKihbXFxkLl0rKSk/KT9cXHMqKFtOU10pXFxzKixcXHMqKFxcZHsxLDN9KSg/OlxccyrCsFxccyooXFxkezEsMn0pKD86WydcIl0/XFxzKihbXFxkLl0rKSk/KT9cXHMqKFtFV10pXFxzKiQvaTtcbiAgY29uc3QgbSA9IERNUy5leGVjKHMpO1xuICBpZiAobSkge1xuICAgIGNvbnN0IGRtc1RvRGVjID0gKGQsIG0sIHNlYywgaGVtKSA9PiB7XG4gICAgICBjb25zdCBkZWcgPSBwYXJzZUludChkLCAxMCkgfHwgMDtcbiAgICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KG0gfHwgJzAnLCAxMCkgfHwgMDtcbiAgICAgIGNvbnN0IHNlY0YgPSBwYXJzZUZsb2F0KHNlYyB8fCAnMCcpIHx8IDA7XG4gICAgICBsZXQgdmFsID0gZGVnICsgbWluIC8gNjAgKyBzZWNGIC8gMzYwMDtcbiAgICAgIGlmICgvU3xXL2kudGVzdChoZW0pKSB2YWwgKj0gLTE7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG4gICAgY29uc3QgbGF0ID0gZG1zVG9EZWMobVsxXSwgbVsyXSwgbVszXSwgbVs0XSk7XG4gICAgY29uc3QgbG9uID0gZG1zVG9EZWMobVs1XSwgbVs2XSwgbVs3XSwgbVs4XSk7XG4gICAgaWYgKGlzRmluaXRlKGxhdCkgJiYgaXNGaW5pdGUobG9uKSAmJiBNYXRoLmFicyhsYXQpIDw9IDkwICYmIE1hdGguYWJzKGxvbikgPD0gMTgwKSB7XG4gICAgICBsb2dnZXIuaW5mbygnUGFyc2VkIERNUyBjb29yZGluYXRlcycsIHsgaW5wdXQ6IGNvb3JkU3RyaW5nLCBvdXRwdXQ6IHsgbGF0LCBsb24gfSB9KTtcbiAgICAgIHJldHVybiB7IGxhdCwgbG9uIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRGVjaW1hbCBmYWxsYmFjazogXCI0MC4wMTY3LCAtNzUuMzAwMFwiXG4gIGNvbnN0IERFQyA9IC9eXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPylcXHMqJC87XG4gIGNvbnN0IGQgPSBERUMuZXhlYyhzKTtcbiAgaWYgKGQpIHtcbiAgICBjb25zdCBsYXQgPSBwYXJzZUZsb2F0KGRbMV0pO1xuICAgIGNvbnN0IGxvbiA9IHBhcnNlRmxvYXQoZFsyXSk7XG4gICAgaWYgKGlzRmluaXRlKGxhdCkgJiYgaXNGaW5pdGUobG9uKSAmJiBNYXRoLmFicyhsYXQpIDw9IDkwICYmIE1hdGguYWJzKGxvbikgPD0gMTgwKSB7XG4gICAgICByZXR1cm4geyBsYXQsIGxvbiB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBzdGFuZGFyZCBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgUmFwaWRBUEkga2V5IGlzIG5vdCBjb25maWd1cmVkLlxuICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnMoKSB7XG4gIGNvbnN0IGtleSA9IHByb2Nlc3MuZW52LlJBUElEQVBJX0tFWTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JBUElEQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgY29uZmlndXJlZC4nKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwieC1yYXBpZGFwaS1rZXlcIjoga2V5LFxuICAgIFwieC1yYXBpZGFwaS1ob3N0XCI6IFwiYXN0cm9sb2dlci5wLnJhcGlkYXBpLmNvbVwiLFxuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHN1YmplY3Qgb2JqZWN0IGZvciBhbGwgcmVxdWlyZWQgZmllbGRzLlxuICogQHBhcmFtIHtPYmplY3R9IHN1YmplY3QgLSBUaGUgc3ViamVjdCBkYXRhIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMge3tpc1ZhbGlkOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmd9fVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCkge1xuICBjb25zdCBiYXNlUmVxID0gWyd5ZWFyJywnbW9udGgnLCdkYXknLCdob3VyJywnbWludXRlJywnbmFtZScsJ3pvZGlhY190eXBlJ107XG4gIGNvbnN0IGJhc2VNaXNzaW5nID0gYmFzZVJlcS5maWx0ZXIoZiA9PiBzdWJqZWN0W2ZdID09PSB1bmRlZmluZWQgfHwgc3ViamVjdFtmXSA9PT0gbnVsbCB8fCBzdWJqZWN0W2ZdID09PSAnJyk7XG4gIC8vIEFjY2VwdCBlaXRoZXIgY29vcmRzLW1vZGUgT1IgY2l0eS1tb2RlXG4gIGNvbnN0IGhhc0Nvb3JkcyA9ICh0eXBlb2Ygc3ViamVjdC5sYXRpdHVkZSA9PT0gJ251bWJlcicpICYmICh0eXBlb2Ygc3ViamVjdC5sb25naXR1ZGUgPT09ICdudW1iZXInKSAmJiAhIXN1YmplY3QudGltZXpvbmU7XG4gIGNvbnN0IGhhc0NpdHkgPSAhIShzdWJqZWN0LmNpdHkgJiYgc3ViamVjdC5uYXRpb24pO1xuICBjb25zdCBva01vZGUgPSBoYXNDb29yZHMgfHwgaGFzQ2l0eTtcbiAgY29uc3QgbW9kZU1zZyA9IG9rTW9kZSA/ICcnIDogJ2Nvb3JkcyhsYXQsbG9uLHRpbWV6b25lKSBPUiBjaXR5LG5hdGlvbiByZXF1aXJlZCc7XG4gIGNvbnN0IG1pc3NpbmdNc2cgPSBiYXNlTWlzc2luZy5sZW5ndGggPyBgTWlzc2luZzogJHtiYXNlTWlzc2luZy5qb2luKCcsICcpfWAgOiAnJztcbiAgcmV0dXJuIHsgaXNWYWxpZDogYmFzZU1pc3NpbmcubGVuZ3RoID09PSAwICYmIG9rTW9kZSwgbWVzc2FnZTogW21pc3NpbmdNc2csIG1vZGVNc2ddLmZpbHRlcihCb29sZWFuKS5qb2luKCc7ICcpIHx8ICdvaycgfTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHN1YmplY3QgZGF0YSBmcm9tIHZhcmlvdXMgaW5wdXQgZm9ybWF0cyB0byB0aGUgQVBJJ3MgYFN1YmplY3RNb2RlbGAuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFJhdyBzdWJqZWN0IGRhdGEuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOb3JtYWxpemVkIHN1YmplY3QgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1YmplY3REYXRhKGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgcmV0dXJuIHt9O1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgbmFtZTogZGF0YS5uYW1lIHx8ICdTdWJqZWN0JyxcbiAgeWVhcjogZGF0YS55ZWFyLCBtb250aDogZGF0YS5tb250aCwgZGF5OiBkYXRhLmRheSxcbiAgaG91cjogZGF0YS5ob3VyLCBtaW51dGU6IGRhdGEubWludXRlLFxuICBjaXR5OiBkYXRhLmNpdHksIG5hdGlvbjogZGF0YS5uYXRpb24sXG4gIGxhdGl0dWRlOiBkYXRhLmxhdGl0dWRlID8/IGRhdGEubGF0LFxuICBsb25naXR1ZGU6IGRhdGEubG9uZ2l0dWRlID8/IGRhdGEubG9uID8/IGRhdGEubG5nLFxuICB0aW1lem9uZTogbm9ybWFsaXplVGltZXpvbmUoZGF0YS50aW1lem9uZSB8fCBkYXRhLnR6X3N0ciksXG4gICAgem9kaWFjX3R5cGU6IGRhdGEuem9kaWFjX3R5cGUgfHwgZGF0YS56b2RpYWMgfHwgJ1Ryb3BpYycsXG4gIH07XG5cbiAgLy8gQ29udmVydCBsZWdhY3kgZmllbGRzXG4gIGlmIChkYXRhLmRhdGUpIHtcbiAgICBjb25zdCBbbSwgZCwgeV0gPSBkYXRhLmRhdGUuc3BsaXQoJy0nKS5tYXAoTnVtYmVyKTtcbiAgICBub3JtYWxpemVkLnllYXIgPSBub3JtYWxpemVkLnllYXIgfHwgeTtcbiAgICBub3JtYWxpemVkLm1vbnRoID0gbm9ybWFsaXplZC5tb250aCB8fCBtO1xuICAgIG5vcm1hbGl6ZWQuZGF5ID0gbm9ybWFsaXplZC5kYXkgfHwgZDtcbiAgfVxuICBpZiAoZGF0YS50aW1lKSB7XG4gICAgY29uc3QgW2gsIG1pbl0gPSBkYXRhLnRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBub3JtYWxpemVkLmhvdXIgPSBub3JtYWxpemVkLmhvdXIgfHwgaDtcbiAgICBub3JtYWxpemVkLm1pbnV0ZSA9IG5vcm1hbGl6ZWQubWludXRlIHx8IG1pbjtcbiAgfVxuICAvLyBTdXBwb3J0IGJpcnRoX2RhdGUgLyBiaXJ0aF90aW1lIGFsaWFzZXNcbiAgaWYgKGRhdGEuYmlydGhfZGF0ZSAmJiAoIW5vcm1hbGl6ZWQueWVhciB8fCAhbm9ybWFsaXplZC5tb250aCB8fCAhbm9ybWFsaXplZC5kYXkpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFt5LCBtLCBkXSA9IFN0cmluZyhkYXRhLmJpcnRoX2RhdGUpLnNwbGl0KCctJykubWFwKE51bWJlcik7XG4gICAgICBpZiAoeSAmJiBtICYmIGQpIHsgbm9ybWFsaXplZC55ZWFyID0geTsgbm9ybWFsaXplZC5tb250aCA9IG07IG5vcm1hbGl6ZWQuZGF5ID0gZDsgfVxuICAgIH0gY2F0Y2goXykge31cbiAgfVxuICBpZiAoZGF0YS5iaXJ0aF90aW1lICYmICghbm9ybWFsaXplZC5ob3VyIHx8ICFub3JtYWxpemVkLm1pbnV0ZSkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW2gsIG1pbl0gPSBTdHJpbmcoZGF0YS5iaXJ0aF90aW1lKS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICAgICAgaWYgKGggIT09IHVuZGVmaW5lZCAmJiBtaW4gIT09IHVuZGVmaW5lZCkgeyBub3JtYWxpemVkLmhvdXIgPSBoOyBub3JtYWxpemVkLm1pbnV0ZSA9IG1pbjsgfVxuICAgIH0gY2F0Y2goXykge31cbiAgfVxuICAvLyBDaXR5IC8gQ291bnRyeSBhbGlhc2VzXG4gIGlmICghbm9ybWFsaXplZC5jaXR5KSB7XG4gICAgbm9ybWFsaXplZC5jaXR5ID0gZGF0YS5iaXJ0aF9jaXR5IHx8IGRhdGEuY2l0eV9uYW1lIHx8IGRhdGEudG93biB8fCBub3JtYWxpemVkLmNpdHk7XG4gIH1cbiAgaWYgKCFub3JtYWxpemVkLm5hdGlvbikge1xuICAgIG5vcm1hbGl6ZWQubmF0aW9uID0gZGF0YS5iaXJ0aF9jb3VudHJ5IHx8IGRhdGEuY291bnRyeSB8fCBkYXRhLmNvdW50cnlfY29kZSB8fCBub3JtYWxpemVkLm5hdGlvbjtcbiAgfVxuICAvLyBUaW1lem9uZSBhbGlhc2VzXG4gIGlmICghbm9ybWFsaXplZC50aW1lem9uZSkge1xuICAgIG5vcm1hbGl6ZWQudGltZXpvbmUgPSBub3JtYWxpemVUaW1lem9uZShkYXRhLm9mZnNldCB8fCBkYXRhLnR6IHx8IGRhdGEudHppZCB8fCBkYXRhLnRpbWVfem9uZSB8fCBub3JtYWxpemVkLnRpbWV6b25lKTtcbiAgfVxuICBpZiAoZGF0YS5jb29yZGluYXRlcykge1xuICAgIGNvbnN0IFtsYXQsIGxuZ10gPSBkYXRhLmNvb3JkaW5hdGVzLnNwbGl0KCcsJykubWFwKHMgPT4gcGFyc2VGbG9hdChzLnRyaW0oKSkpO1xuICAgIG5vcm1hbGl6ZWQubGF0aXR1ZGUgPSBub3JtYWxpemVkLmxhdGl0dWRlIHx8IGxhdDtcbiAgICBub3JtYWxpemVkLmxvbmdpdHVkZSA9IG5vcm1hbGl6ZWQubG9uZ2l0dWRlIHx8IGxuZztcbiAgfVxuXG4gIC8vIEhhbmRsZSBjb29yZGluYXRlIHBhcnNpbmcgdXNpbmcgdGhlIGVuaGFuY2VkIHBhcnNlQ29vcmRpbmF0ZXMgZnVuY3Rpb25cbiAgaWYgKCFub3JtYWxpemVkLmxhdGl0dWRlIHx8ICFub3JtYWxpemVkLmxvbmdpdHVkZSkge1xuICAgIC8vIENoZWNrIHZhcmlvdXMgZmllbGQgbmFtZXMgZm9yIGNvb3JkaW5hdGUgZGF0YVxuICAgIGNvbnN0IGNvb3JkRmllbGRzID0gWydhc3RybycsICdjb29yZHMnLCAnY29vcmRpbmF0ZScsICdjb29yZCcsICdsb2NhdGlvbiddO1xuICAgIGxldCBjb29yZFN0cmluZyA9IG51bGw7XG4gICAgXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBjb29yZEZpZWxkcykge1xuICAgICAgaWYgKGRhdGFbZmllbGRdICYmIHR5cGVvZiBkYXRhW2ZpZWxkXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29vcmRTdHJpbmcgPSBkYXRhW2ZpZWxkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIGZvdW5kIGEgY29vcmRpbmF0ZSBzdHJpbmcsIHBhcnNlIGl0XG4gICAgaWYgKGNvb3JkU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvb3JkaW5hdGVzKGNvb3JkU3RyaW5nKTtcbiAgICAgICAgaWYgKHBhcnNlZCAmJiBwYXJzZWQubGF0ICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLmxvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybWFsaXplZC5sYXRpdHVkZSA9IG5vcm1hbGl6ZWQubGF0aXR1ZGUgPz8gcGFyc2VkLmxhdDtcbiAgICAgICAgICBub3JtYWxpemVkLmxvbmdpdHVkZSA9IG5vcm1hbGl6ZWQubG9uZ2l0dWRlID8/IHBhcnNlZC5sb247XG4gICAgICAgICAgbG9nZ2VyLmluZm8oJ0Nvb3JkaW5hdGUgcGFyc2luZyBzdWNjZXNzZnVsJywgeyBcbiAgICAgICAgICAgIGlucHV0OiBjb29yZFN0cmluZywgXG4gICAgICAgICAgICBvdXRwdXQ6IHsgbGF0OiBwYXJzZWQubGF0LCBsb246IHBhcnNlZC5sb24gfSBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIud2FybignQ29vcmRpbmF0ZSBwYXJzaW5nIGZhaWxlZCcsIHsgaW5wdXQ6IGNvb3JkU3RyaW5nIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Nvb3JkaW5hdGUgcGFyc2luZyBlcnJvcicsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UsIGlucHV0OiBjb29yZFN0cmluZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBsYXQvbG9uIGFyZSBzdGlsbCBzdHJpbmdzLCB0cnkgdG8gcGFyc2UgdGhlbSBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGVvZiBub3JtYWxpemVkLmxhdGl0dWRlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9ybWFsaXplZC5sb25naXR1ZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvb3JkU3RyaW5nID0gYCR7bm9ybWFsaXplZC5sYXRpdHVkZX0sJHtub3JtYWxpemVkLmxvbmdpdHVkZX1gO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb29yZGluYXRlcyhjb29yZFN0cmluZyk7XG4gICAgICBpZiAocGFyc2VkICYmIHBhcnNlZC5sYXQgIT09IHVuZGVmaW5lZCAmJiBwYXJzZWQubG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9ybWFsaXplZC5sYXRpdHVkZSA9IHBhcnNlZC5sYXQ7XG4gICAgICAgIG5vcm1hbGl6ZWQubG9uZ2l0dWRlID0gcGFyc2VkLmxvbjtcbiAgICAgICAgbG9nZ2VyLmluZm8oJ0luZGl2aWR1YWwgY29vcmRpbmF0ZSBwYXJzaW5nIHN1Y2Nlc3NmdWwnLCB7IFxuICAgICAgICAgIGlucHV0OiBjb29yZFN0cmluZywgXG4gICAgICAgICAgb3V0cHV0OiB7IGxhdDogcGFyc2VkLmxhdCwgbG9uOiBwYXJzZWQubG9uIH0gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0luZGl2aWR1YWwgY29vcmRpbmF0ZSBwYXJzaW5nIGVycm9yJywgeyBcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsIFxuICAgICAgICBsYXQ6IG5vcm1hbGl6ZWQubGF0aXR1ZGUsIFxuICAgICAgICBsb246IG5vcm1hbGl6ZWQubG9uZ2l0dWRlIFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8qKlxuICogQ29udmVydCBpbnRlcm5hbCBub3JtYWxpemVkIHN1YmplY3Qgc2hhcGUgdG8gQXN0cm9sb2dlciBBUEkgU3ViamVjdCBNb2RlbC5cbiAqIEludGVybmFsIHVzZXMgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdGltZXpvbmU7IEFQSSBleHBlY3RzIGxhdCwgbG5nLCB0el9zdHIuXG4gKiBLZWVwcyBjb3JlIGJpcnRoIGZpZWxkcyBhbmQgb3B0aW9uYWwgaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyLlxuICogQHBhcmFtIHtPYmplY3R9IHMgLSBJbnRlcm5hbCBzdWJqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFzcyAtIE9wdGlvbmFsIHBhc3MtdGhyb3VnaCBjb25maWcgKG1heSBpbmNsdWRlIGhvdXNlc19zeXN0ZW1faWRlbnRpZmllcilcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFQSSBTdWJqZWN0TW9kZWxcbiAqL1xuZnVuY3Rpb24gc3ViamVjdFRvQVBJKHMgPSB7fSwgcGFzcyA9IHt9KSB7XG4gIGlmICghcykgcmV0dXJuIHt9O1xuICBjb25zdCBoYXNDb29yZHMgPSAodHlwZW9mIHMubGF0aXR1ZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzLmxhdCA9PT0gJ251bWJlcicpXG4gICAgJiYgKHR5cGVvZiBzLmxvbmdpdHVkZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHMubG9uID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygcy5sbmcgPT09ICdudW1iZXInKVxuICAgICYmIChzLnRpbWV6b25lIHx8IHMudHpfc3RyKTtcbiAgY29uc3QgaGFzQ2l0eSA9ICEhKHMuY2l0eSAmJiBzLm5hdGlvbik7XG4gIGNvbnN0IHR6Tm9ybSA9IG5vcm1hbGl6ZVRpbWV6b25lKHMudGltZXpvbmUgfHwgcy50el9zdHIpO1xuICBjb25zdCBhcGlTdWJqZWN0ID0ge1xuICAgIG5hbWU6IHMubmFtZSxcbiAgICB5ZWFyOiBzLnllYXIsIG1vbnRoOiBzLm1vbnRoLCBkYXk6IHMuZGF5LFxuICAgIGhvdXI6IHMuaG91ciwgbWludXRlOiBzLm1pbnV0ZSxcbiAgICB6b2RpYWNfdHlwZTogcy56b2RpYWNfdHlwZSB8fCAnVHJvcGljJ1xuICB9O1xuICAvLyBTZW5kIGNvb3JkaW5hdGVzIGlmIGF2YWlsYWJsZSAoQVBJIGV4cGVjdHMgbGF0L2xuZy90el9zdHIgZmllbGQgbmFtZXMpXG4gIGNvbnN0IGluY2x1ZGVDb29yZHMgPSBoYXNDb29yZHMgJiYgIXBhc3MuZm9yY2VfY2l0eV9tb2RlICYmICFwYXNzLnN1cHByZXNzX2Nvb3JkcztcbiAgaWYgKGluY2x1ZGVDb29yZHMpIHtcbiAgICBhcGlTdWJqZWN0LmxhdCA9IHMubGF0aXR1ZGUgPz8gcy5sYXQ7XG4gICAgYXBpU3ViamVjdC5sbmcgPSBzLmxvbmdpdHVkZSA/PyBzLmxvbiA/PyBzLmxuZztcbiAgICBhcGlTdWJqZWN0LnR6X3N0ciA9IHR6Tm9ybTtcbiAgfVxuICBcbiAgLy8gU2VuZCBjaXR5L25hdGlvbiB3aGVuIHJlcXVlc3RlZCBvciB3aGVuIGNvb3JkcyBhcmUgYWJzZW50XG4gIC8vIE5vdGVzOiBTb21lIG5hdGFsIGVuZHBvaW50cyB2YWxpZGF0ZSBwcmVzZW5jZSBvZiBjaXR5IGZpZWxkIGV2ZW4gaWYgbGF0L2xuZy90eiBwcm92aWRlZC5cbiAgLy8gcGFzcy5yZXF1aXJlX2NpdHkgZm9yY2VzIGluY2x1c2lvbiBhbG9uZ3NpZGUgY29vcmRzOyB3ZSBhdm9pZCBhZGRpbmcgZ2VvbmFtZXNfdXNlcm5hbWVcbiAgLy8gd2hlbiBjb29yZHMgYXJlIHByZXNlbnQgdG8gcmVkdWNlIHJlc29sdmVyIGFtYmlndWl0eS5cbiAgY29uc3Qgd2FudENpdHkgPSBoYXNDaXR5ICYmIChwYXNzLnJlcXVpcmVfY2l0eSB8fCAhaW5jbHVkZUNvb3Jkcyk7XG4gIGlmICh3YW50Q2l0eSkge1xuICAgIGFwaVN1YmplY3QuY2l0eSA9IHMuc3RhdGUgPyBgJHtzLmNpdHl9LCAke3Muc3RhdGV9YCA6IHMuY2l0eTtcbiAgICBhcGlTdWJqZWN0Lm5hdGlvbiA9IHMubmF0aW9uO1xuICAgIC8vIE9ubHkgaW5jbHVkZSBnZW9uYW1lc191c2VybmFtZSB3aGVuIG9wZXJhdGluZyBpbiBwdXJlIGNpdHkgbW9kZSAobm8gY29vcmRzKSB1bmxlc3MgZXhwbGljaXRseSBmb3JjZWRcbiAgICBpZiAoKCFpbmNsdWRlQ29vcmRzIHx8IHBhc3MuZm9yY2VfY2l0eV9tb2RlKSAmJiBwcm9jZXNzLmVudi5HRU9OQU1FU19VU0VSTkFNRSAmJiAhcGFzcz8uc3VwcHJlc3NfZ2VvbmFtZXMpIHtcbiAgICAgIChhcGlTdWJqZWN0KS5nZW9uYW1lc191c2VybmFtZSA9IHByb2Nlc3MuZW52LkdFT05BTUVTX1VTRVJOQU1FO1xuICAgIH1cbiAgfVxuICBjb25zdCBoc3lzID0gcy5ob3VzZXNfc3lzdGVtX2lkZW50aWZpZXIgfHwgcGFzcy5ob3VzZXNfc3lzdGVtX2lkZW50aWZpZXI7XG4gIGlmIChoc3lzKSBhcGlTdWJqZWN0LmhvdXNlc19zeXN0ZW1faWRlbnRpZmllciA9IGhzeXM7XG4gIHJldHVybiBhcGlTdWJqZWN0O1xufVxuXG4vLyBIZWxwZXI6IGNhbGwgbmF0YWwgZW5kcG9pbnRzIHdpdGggZm9ybWF0aW9uIGZhbGxiYWNrXG5hc3luYyBmdW5jdGlvbiBjYWxsTmF0YWwoZW5kcG9pbnQsIHN1YmplY3QsIGhlYWRlcnMsIHBhc3MgPSB7fSwgZGVzY3JpcHRpb24gPSAnTmF0YWwgY2FsbCcpe1xuICBjb25zdCBjYW5Vc2VHZW8gPSAhIXByb2Nlc3MuZW52LkdFT05BTUVTX1VTRVJOQU1FICYmICEhKHN1YmplY3QuY2l0eSAmJiBzdWJqZWN0Lm5hdGlvbik7XG4gIGlmIChjYW5Vc2VHZW8pIHtcbiAgICAvLyBBdHRlbXB0IDE6IGNpdHkgKyBHZW9OYW1lcyAocHJlZmVycmVkIHBlciBpbnRlZ3JhdGlvbiBub3RlcylcbiAgICBjb25zdCBwYXlsb2FkQ2l0eVdpdGhHZW8gPSB7IHN1YmplY3Q6IHN1YmplY3RUb0FQSShzdWJqZWN0LCB7IC4uLnBhc3MsIHJlcXVpcmVfY2l0eTogdHJ1ZSwgZm9yY2VfY2l0eV9tb2RlOiB0cnVlLCBzdXBwcmVzc19jb29yZHM6IHRydWUsIHN1cHByZXNzX2dlb25hbWVzOiBmYWxzZSB9KSB9O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeShlbmRwb2ludCwgeyBtZXRob2Q6ICdQT1NUJywgaGVhZGVycywgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZENpdHlXaXRoR2VvKSB9LCBgJHtkZXNjcmlwdGlvbn0gKGNpdHkrZ2VvbmFtZXMpYCk7XG4gICAgfSBjYXRjaCAoZTApIHtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBjb29yZHMtb25seVxuICAgIH1cbiAgfVxuICAvLyBBdHRlbXB0IDI6IGNvb3Jkcy1vbmx5IChubyBjaXR5LCBubyBnZW9uYW1lcylcbiAgY29uc3QgcGF5bG9hZENvb3JkcyA9IHsgc3ViamVjdDogc3ViamVjdFRvQVBJKHN1YmplY3QsIHsgLi4ucGFzcywgcmVxdWlyZV9jaXR5OiBmYWxzZSwgZm9yY2VfY2l0eV9tb2RlOiBmYWxzZSwgc3VwcHJlc3NfZ2VvbmFtZXM6IHRydWUgfSkgfTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeShlbmRwb2ludCwgeyBtZXRob2Q6ICdQT1NUJywgaGVhZGVycywgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZENvb3JkcykgfSwgZGVzY3JpcHRpb24pO1xuICB9IGNhdGNoIChlMSkge1xuICAgIGNvbnN0IGNhblRyeUNpdHkgPSAhIShzdWJqZWN0LmNpdHkgJiYgc3ViamVjdC5uYXRpb24pO1xuICAgIGNvbnN0IGlzNHh4ID0gZTEgJiYgZTEuY29kZSA9PT0gJ0NMSUVOVF9FUlJPUicgJiYgZTEuc3RhdHVzID49IDQwMCAmJiBlMS5zdGF0dXMgPCA1MDA7XG4gICAgaWYgKCFpczR4eCB8fCAhY2FuVHJ5Q2l0eSkgdGhyb3cgZTE7XG4gICAgLy8gQXR0ZW1wdCAzOiBjaXR5LW9ubHkgd2l0aG91dCBHZW9OYW1lcyAoZm9yIHByb3ZpZGVycyB0aGF0IGFjY2VwdCBmcmVlLXRleHQgY2l0eSlcbiAgICBjb25zdCBwYXlsb2FkQ2l0eU5vR2VvID0geyBzdWJqZWN0OiBzdWJqZWN0VG9BUEkoc3ViamVjdCwgeyAuLi5wYXNzLCByZXF1aXJlX2NpdHk6IHRydWUsIGZvcmNlX2NpdHlfbW9kZTogdHJ1ZSwgc3VwcHJlc3NfY29vcmRzOiB0cnVlLCBzdXBwcmVzc19nZW9uYW1lczogdHJ1ZSB9KSB9O1xuICAgIHJldHVybiBhd2FpdCBhcGlDYWxsV2l0aFJldHJ5KGVuZHBvaW50LCB7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzLCBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkQ2l0eU5vR2VvKSB9LCBgJHtkZXNjcmlwdGlvbn0gKGNpdHktb25seSlgKTtcbiAgfVxufVxuXG4vLyAtLS0tIEFzcGVjdCBGaWx0ZXJpbmcgJiBIb29rIEV4dHJhY3Rpb24gKHJlZmluZWQpIC0tLS1cbi8vIEFzcGVjdCBjbGFzc2VzXG5jb25zdCBBU1BFQ1RfQ0xBU1MgPSB7XG4gIG1ham9yOiBuZXcgU2V0KFsnY29uanVuY3Rpb24nLCdvcHBvc2l0aW9uJywnc3F1YXJlJywndHJpbmUnLCdzZXh0aWxlJ10pLFxuICBtaW5vcjogbmV3IFNldChbJ3F1aW5jdW54Jywnc2VzcXVpcXVhZHJhdGUnLCdzZW1pLXNxdWFyZScsJ3NlbWktc2V4dGlsZSddKSxcbiAgaGFybW9uaWM6IG5ldyBTZXQoWydxdWludGlsZScsJ2JpcXVpbnRpbGUnXSlcbn07XG5cbi8vIE9yYiBjYXBzIGJ5IGFzcGVjdCAoZ2VvbWV0cnkgY29uc3RyYWludCkg4oCUIGFsaWduZWQgdG8gc3BlY1xuY29uc3QgQVNQRUNUX09SQl9DQVBTID0ge1xuICBjb25qdW5jdGlvbjogOCxcbiAgb3Bwb3NpdGlvbjogOCxcbiAgc3F1YXJlOiA3LFxuICB0cmluZTogNyxcbiAgc2V4dGlsZTogNSxcbiAgcXVpbmN1bng6IDMsXG4gIHNlc3F1aXF1YWRyYXRlOiAzLFxuICAnc2VtaS1zcXVhcmUnOiAyLFxuICAnc2VtaS1zZXh0aWxlJzogMixcbiAgcXVpbnRpbGU6IDIsXG4gIGJpcXVpbnRpbGU6IDJcbn07XG5cbi8vIE9yYiBjYXBzIGJ5IGJvZHkgY2xhc3MgKHNsb3dlciBib2RpZXMgdG9sZXJhdGUgbGFyZ2VyIG9yYnMgZm9yIHRoZSBzYW1lIHN0cnVjdHVyYWwgc2FsaWVuY2UpXG5jb25zdCBCT0RZX0NMQVNTX0NBUFMgPSB7XG4gIGx1bWluYXJ5OiAxMixcbiAgcGVyc29uYWw6IDgsXG4gIHNvY2lhbDogNywgICAgIC8vIEp1cGl0ZXIgLyBTYXR1cm5cbiAgb3V0ZXI6IDYsXG4gIGFuZ2xlOiA4LFxuICBwb2ludDogNSwgICAgICAvLyBDaGlyb24sIE5vZGVzLCBMaWxpdGhcbiAgb3RoZXI6IDZcbn07XG5cbmNvbnN0IFJFVFVSTl9CT0RJRVMgPSBuZXcgU2V0KFsnU2F0dXJuJywnSnVwaXRlcicsJ0NoaXJvbicsJ01lYW5fTm9kZScsJ01lYW5fU291dGhfTm9kZScsJ1RydWVfTm9kZScsJ1RydWVfU291dGhfTm9kZSddKTtcbmNvbnN0IFBPSU5UX0JPRElFUyA9IG5ldyBTZXQoW1xuICAnQXNjZW5kYW50JywnTWVkaXVtX0NvZWxpJywnRGVzY2VuZGFudCcsJ0ltdW1fQ29lbGknLFxuICAnTWVhbl9Ob2RlJywnVHJ1ZV9Ob2RlJywnTWVhbl9Tb3V0aF9Ob2RlJywnVHJ1ZV9Tb3V0aF9Ob2RlJyxcbiAgJ0NoaXJvbicsJ01lYW5fTGlsaXRoJ1xuXSk7IC8vIEVuc3VyZSBUcnVlIG5vZGVzICYgYWxsIGFuZ2xlcyBpbmNsdWRlZFxuXG5mdW5jdGlvbiBjbGFzc2lmeUFzcGVjdE5hbWUobmFtZSl7XG4gIGlmIChBU1BFQ1RfQ0xBU1MubWFqb3IuaGFzKG5hbWUpKSByZXR1cm4gJ21ham9yJztcbiAgaWYgKEFTUEVDVF9DTEFTUy5taW5vci5oYXMobmFtZSkpIHJldHVybiAnbWlub3InO1xuICBpZiAoQVNQRUNUX0NMQVNTLmhhcm1vbmljLmhhcyhuYW1lKSkgcmV0dXJuICdoYXJtb25pYyc7XG4gIHJldHVybiAnb3RoZXInO1xufVxuXG4vLyBIYXJkLWNhcCBhZGp1c3RtZW50c1xuY29uc3QgUEVSU09OQUxfU0VUID0gbmV3IFNldChbJ1N1bicsJ01vb24nLCdNZXJjdXJ5JywnVmVudXMnLCdNYXJzJ10pO1xuY29uc3QgT1VURVJfU0VUID0gbmV3IFNldChbJ0p1cGl0ZXInLCdTYXR1cm4nLCdVcmFudXMnLCdOZXB0dW5lJywnUGx1dG8nXSk7XG5mdW5jdGlvbiBhZGp1c3RPcmJDYXBGb3JTcGVjaWFscyhiYXNlQ2FwLCBwMSwgcDIpe1xuICBsZXQgY2FwID0gYmFzZUNhcDtcbiAgaWYgKHAxID09PSAnTW9vbicgfHwgcDIgPT09ICdNb29uJykgY2FwICs9IDE7IC8vIE1vb24gKzHCsFxuICBjb25zdCBvdXRlclBlcnNvbmFsID0gKE9VVEVSX1NFVC5oYXMocDEpICYmIFBFUlNPTkFMX1NFVC5oYXMocDIpKSB8fCAoT1VURVJfU0VULmhhcyhwMikgJiYgUEVSU09OQUxfU0VULmhhcyhwMSkpO1xuICBpZiAob3V0ZXJQZXJzb25hbCkgY2FwIC09IDE7IC8vIE91dGVyIOKGkiBwZXJzb25hbCDiiJIxwrBcbiAgaWYgKGNhcCA8IDEpIGNhcCA9IDE7XG4gIHJldHVybiBjYXA7XG59XG5cbmZ1bmN0aW9uIGJvZHlDbGFzcyhuYW1lKXtcbiAgc3dpdGNoKG5hbWUpe1xuICAgIGNhc2UgJ1N1bic6XG4gICAgY2FzZSAnTW9vbic6IHJldHVybiAnbHVtaW5hcnknO1xuICAgIGNhc2UgJ01lcmN1cnknOlxuICAgIGNhc2UgJ1ZlbnVzJzpcbiAgICBjYXNlICdNYXJzJzogcmV0dXJuICdwZXJzb25hbCc7XG4gICAgY2FzZSAnSnVwaXRlcic6XG4gICAgY2FzZSAnU2F0dXJuJzogcmV0dXJuICdzb2NpYWwnO1xuICAgIGNhc2UgJ1VyYW51cyc6XG4gICAgY2FzZSAnTmVwdHVuZSc6XG4gICAgY2FzZSAnUGx1dG8nOiByZXR1cm4gJ291dGVyJztcbiAgICBjYXNlICdBc2NlbmRhbnQnOlxuICAgIGNhc2UgJ01lZGl1bV9Db2VsaSc6XG4gICAgY2FzZSAnRGVzY2VuZGFudCc6XG4gICAgY2FzZSAnSW11bV9Db2VsaSc6IHJldHVybiAnYW5nbGUnO1xuICAgIGNhc2UgJ0NoaXJvbic6XG4gICAgY2FzZSAnTWVhbl9Ob2RlJzpcbiAgY2FzZSAnVHJ1ZV9Ob2RlJzpcbiAgICBjYXNlICdNZWFuX1NvdXRoX05vZGUnOlxuICBjYXNlICdUcnVlX1NvdXRoX05vZGUnOlxuICAgIGNhc2UgJ01lYW5fTGlsaXRoJzogcmV0dXJuICdwb2ludCc7XG4gICAgZGVmYXVsdDogcmV0dXJuICdvdGhlcic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGxheUJvZHlOYW1lKHJhdyl7XG4gIGNvbnN0IG1hcCA9IHtcbiAgICAnTWVkaXVtX0NvZWxpJzogJ01DJyxcbiAgJ0ltdW1fQ29lbGknOiAnSUMnLFxuICAgICdNZWFuX05vZGUnOiAnTm9ydGggTm9kZScsXG4gICAgJ01lYW5fU291dGhfTm9kZSc6ICdTb3V0aCBOb2RlJyxcbiAgJ1RydWVfTm9kZSc6ICdOb3J0aCBOb2RlIChUcnVlKScsXG4gICdUcnVlX1NvdXRoX05vZGUnOiAnU291dGggTm9kZSAoVHJ1ZSknLFxuICAgICdNZWFuX0xpbGl0aCc6ICdMaWxpdGgnXG4gIH07XG4gIHJldHVybiBtYXBbcmF3XSB8fCByYXc7XG59XG5cbmZ1bmN0aW9uIHdlaWdodEFzcGVjdChhKXtcbiAgY29uc3QgYmFzZSA9IGEuX2NsYXNzID09PSAnbWFqb3InID8gMS4wIDogYS5fY2xhc3MgPT09ICdtaW5vcicgPyAwLjU1IDogYS5fY2xhc3MgPT09ICdoYXJtb25pYycgPyAwLjQ1IDogMC40O1xuICBjb25zdCBhc3BlY3RDYXAgPSBBU1BFQ1RfT1JCX0NBUFNbYS5fYXNwZWN0XSB8fCA2O1xuICBjb25zdCBjbGFzc0NhcFRyYW5zaXQgPSBCT0RZX0NMQVNTX0NBUFNbYm9keUNsYXNzKGEucDFfbmFtZSldIHx8IDY7XG4gIGNvbnN0IGNsYXNzQ2FwTmF0YWwgPSBCT0RZX0NMQVNTX0NBUFNbYm9keUNsYXNzKGEucDJfbmFtZSldIHx8IDY7XG4gIGxldCBlZmZlY3RpdmVDYXAgPSBNYXRoLm1pbihhc3BlY3RDYXAsIE1hdGgubWF4KGNsYXNzQ2FwVHJhbnNpdCwgY2xhc3NDYXBOYXRhbCkpO1xuICBlZmZlY3RpdmVDYXAgPSBhZGp1c3RPcmJDYXBGb3JTcGVjaWFscyhlZmZlY3RpdmVDYXAsIGEucDFfbmFtZSwgYS5wMl9uYW1lKTtcbiAgY29uc3QgdGlnaHRuZXNzID0gYS5fb3JiICE9IG51bGwgPyBNYXRoLm1heCgwLCAxIC0gKGEuX29yYiAvIGVmZmVjdGl2ZUNhcCkpIDogMDtcbiAgY29uc3QgbHVtT3JBbmdsZSA9IChhLnAxX2lzTHVtaW5hcnkgfHwgYS5wMl9pc0x1bWluYXJ5IHx8IGEucDFfaXNBbmdsZSB8fCBhLnAyX2lzQW5nbGUpID8gMS4xNSA6IDEuMDtcbiAgcmV0dXJuICsoYmFzZSAqIHRpZ2h0bmVzcyAqIGx1bU9yQW5nbGUpLnRvRml4ZWQoNCk7XG59XG5cbmZ1bmN0aW9uIGVucmljaERhaWx5QXNwZWN0cyhyYXdMaXN0KXtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0xpc3QpKSByZXR1cm4geyByYXc6IFtdLCBmaWx0ZXJlZDogW10sIGhvb2tzOiBbXSwgcmVqZWN0aW9uczogW10sIGNvdW50czogeyByYXc6MCwgZmlsdGVyZWQ6MCwgaG9va3M6MCB9IH07XG4gIGNvbnN0IGVucmljaGVkID0gW107XG4gIGNvbnN0IHJlamVjdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBhIG9mIHJhd0xpc3Qpe1xuICAgIGNvbnN0IGFzcGVjdE5hbWUgPSAoYS5hc3BlY3QgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgb3JiID0gdHlwZW9mIGEub3JiaXQgPT09ICdudW1iZXInID8gYS5vcmJpdCA6ICh0eXBlb2YgYS5vcmIgPT09ICdudW1iZXInID8gYS5vcmIgOiBudWxsKTtcbiAgICBjb25zdCBwMSA9IGEucDFfbmFtZTsgY29uc3QgcDIgPSBhLnAyX25hbWU7XG4gICAgY29uc3Qgc2FtZUJvZHkgPSBwMSA9PT0gcDI7XG4gICAgY29uc3QgY2xzID0gY2xhc3NpZnlBc3BlY3ROYW1lKGFzcGVjdE5hbWUpO1xuICAgIGNvbnN0IHAxQ2xhc3MgPSBib2R5Q2xhc3MocDEpO1xuICAgIGNvbnN0IHAyQ2xhc3MgPSBib2R5Q2xhc3MocDIpO1xuICAgIGNvbnN0IGFzcGVjdENhcCA9IEFTUEVDVF9PUkJfQ0FQU1thc3BlY3ROYW1lXSB8fCA2O1xuICAgIGNvbnN0IGNsYXNzQ2FwID0gTWF0aC5tYXgoQk9EWV9DTEFTU19DQVBTW3AxQ2xhc3NdIHx8IDYsIEJPRFlfQ0xBU1NfQ0FQU1twMkNsYXNzXSB8fCA2KTtcbiAgICBsZXQgZWZmZWN0aXZlQ2FwID0gTWF0aC5taW4oYXNwZWN0Q2FwLCBjbGFzc0NhcCk7XG4gICAgZWZmZWN0aXZlQ2FwID0gYWRqdXN0T3JiQ2FwRm9yU3BlY2lhbHMoZWZmZWN0aXZlQ2FwLCBwMSwgcDIpO1xuICAgIGxldCBkcm9wUmVhc29uID0gJyc7XG5cbiAgICBpZiAoc2FtZUJvZHkpIHtcbiAgICAgIGlmICghWydjb25qdW5jdGlvbicsJ29wcG9zaXRpb24nXS5pbmNsdWRlcyhhc3BlY3ROYW1lKSkgZHJvcFJlYXNvbiA9ICdPVVRfT0ZfQ0FQJzsgLy8gdHJlYXQgbm9uLXJldHVybiBzZWxmIGFzcGVjdCBhcyBvdXQtb2Ytc2NvcGVcbiAgICAgIGVsc2UgaWYgKCEoUkVUVVJOX0JPRElFUy5oYXMocDEpIHx8IFsnU3VuJywnTW9vbiddLmluY2x1ZGVzKHAxKSkpIGRyb3BSZWFzb24gPSAnT1VUX09GX0NBUCc7XG4gICAgfVxuICAgIGlmICghZHJvcFJlYXNvbiAmJiBvcmIgIT0gbnVsbCAmJiBvcmIgPiBlZmZlY3RpdmVDYXApIGRyb3BSZWFzb24gPSAnT1VUX09GX0NBUCc7XG5cbiAgICBjb25zdCByZWMgPSB7XG4gICAgICAuLi5hLFxuICAgICAgX2FzcGVjdDogYXNwZWN0TmFtZSxcbiAgICAgIF9vcmI6IG9yYixcbiAgICAgIF9jbGFzczogY2xzLFxuICAgICAgX3NhbWVCb2R5OiBzYW1lQm9keSxcbiAgICAgIHAxX2Rpc3BsYXk6IGRpc3BsYXlCb2R5TmFtZShwMSksXG4gICAgICBwMl9kaXNwbGF5OiBkaXNwbGF5Qm9keU5hbWUocDIpLFxuICAgICAgcDFfaXNMdW1pbmFyeTogWydTdW4nLCdNb29uJ10uaW5jbHVkZXMocDEpLFxuICAgICAgcDJfaXNMdW1pbmFyeTogWydTdW4nLCdNb29uJ10uaW5jbHVkZXMocDIpLFxuICAgICAgcDFfaXNBbmdsZTogWydBc2NlbmRhbnQnLCdNZWRpdW1fQ29lbGknLCdEZXNjZW5kYW50JywnSW11bV9Db2VsaSddLmluY2x1ZGVzKHAxKSxcbiAgICAgIHAyX2lzQW5nbGU6IFsnQXNjZW5kYW50JywnTWVkaXVtX0NvZWxpJywnRGVzY2VuZGFudCcsJ0ltdW1fQ29lbGknXS5pbmNsdWRlcyhwMiksXG4gICAgICBwMV9jbGFzczogcDFDbGFzcyxcbiAgICAgIHAyX2NsYXNzOiBwMkNsYXNzLFxuICAgICAgZWZmZWN0aXZlX2NhcDogZWZmZWN0aXZlQ2FwXG4gICAgfTtcbiAgICBpZiAoZHJvcFJlYXNvbil7XG4gICAgICByZWplY3Rpb25zLnB1c2goeyBhc3BlY3Q6IGAke3AxfSAke2FzcGVjdE5hbWV9ICR7cDJ9YCwgcmVhc29uOiBkcm9wUmVhc29uLCBvcmIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYy5fd2VpZ2h0ID0gd2VpZ2h0QXNwZWN0KHJlYyk7XG4gICAgICBlbnJpY2hlZC5wdXNoKHJlYyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUG9zdC13ZWlnaHQgZmlsdGVyaW5nIGZvciB3ZWFrIHdlaWdodFxuICBjb25zdCBzdHJvbmcgPSBbXTsgXG4gIGZvciAoY29uc3QgciBvZiBlbnJpY2hlZCl7XG4gICAgaWYgKChyLl93ZWlnaHQgfHwgMCkgPCAwLjE1KXtcbiAgICAgIHJlamVjdGlvbnMucHVzaCh7IGFzcGVjdDogYCR7ci5wMV9uYW1lfSAke3IuX2FzcGVjdH0gJHtyLnAyX25hbWV9YCwgcmVhc29uOiAnV0VBS19XRUlHSFQnLCBvcmI6IHIuX29yYiB9KTtcbiAgICB9IGVsc2Ugc3Ryb25nLnB1c2gocik7XG4gIH1cblxuICAvLyBEaXZlcnNpdHkgJiBkdXBsaWNhdGUgcGFpciBmaWx0ZXJpbmdcbiAgY29uc3QgcGFpclNlZW4gPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHByaW1hcnlDb3VudHMgPSBuZXcgTWFwKCk7IC8vIGx1bWluYXJ5ICsgYW5nbGUgZG9taW5hbmNlIGd1YXJkXG4gIGNvbnN0IGZpbHRlcmVkID0gW107XG4gIGZvciAoY29uc3QgciBvZiBzdHJvbmcpe1xuICAgIGNvbnN0IHBhaXJLZXkgPSBbci5wMV9uYW1lLCByLnAyX25hbWVdLnNvcnQoKS5qb2luKCd8JykgKyAnfCcgKyByLl9hc3BlY3Q7XG4gICAgaWYgKHBhaXJTZWVuLmhhcyhwYWlyS2V5KSkgeyByZWplY3Rpb25zLnB1c2goeyBhc3BlY3Q6IGAke3IucDFfbmFtZX0gJHtyLl9hc3BlY3R9ICR7ci5wMl9uYW1lfWAsIHJlYXNvbjogJ0RVUExJQ0FURV9QQUlSJywgb3JiOiByLl9vcmIgfSk7IGNvbnRpbnVlOyB9XG4gICAgcGFpclNlZW4uYWRkKHBhaXJLZXkpO1xuICAgIGNvbnN0IHByaW1hcmllcyA9IFtdO1xuICAgIGlmIChyLnAxX2lzTHVtaW5hcnkgfHwgci5wMV9pc0FuZ2xlKSBwcmltYXJpZXMucHVzaChyLnAxX25hbWUpO1xuICAgIGlmIChyLnAyX2lzTHVtaW5hcnkgfHwgci5wMl9pc0FuZ2xlKSBwcmltYXJpZXMucHVzaChyLnAyX25hbWUpO1xuICAgIGxldCBwcmltYXJ5RHVwID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwIG9mIHByaW1hcmllcyl7XG4gICAgICBjb25zdCBjID0gKHByaW1hcnlDb3VudHMuZ2V0KHApIHx8IDApICsgMTtcbiAgICAgIHByaW1hcnlDb3VudHMuc2V0KHAsIGMpO1xuICAgICAgaWYgKGMgPiAzKXsgcHJpbWFyeUR1cCA9IHRydWU7IH1cbiAgICB9XG4gICAgaWYgKHByaW1hcnlEdXApe1xuICAgICAgcmVqZWN0aW9ucy5wdXNoKHsgYXNwZWN0OiBgJHtyLnAxX25hbWV9ICR7ci5fYXNwZWN0fSAke3IucDJfbmFtZX1gLCByZWFzb246ICdQUklNQVJZX0RVUCcsIG9yYjogci5fb3JiIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZpbHRlcmVkLnB1c2gocik7XG4gIH1cblxuICAvLyBIb29rIHNlbGVjdGlvbiBwcmlvcml0aXNhdGlvblxuICBjb25zdCBob29rQ2FuZGlkYXRlcyA9IGZpbHRlcmVkLmZpbHRlcihhID0+IHtcbiAgICBjb25zdCBvcmIgPSBhLl9vcmIgIT0gbnVsbCA/IGEuX29yYiA6IDYuMDE7XG4gICAgY29uc3QgaXNFeGFjdCA9IG9yYiA8PSAwLjU7XG4gICAgY29uc3QgaXNUaWdodCA9IG9yYiA8PSAxLjU7XG4gICAgY29uc3QgaXNMdW0gPSBhLnAxX2lzTHVtaW5hcnkgfHwgYS5wMl9pc0x1bWluYXJ5O1xuICAgIGNvbnN0IGlzQW5nbGUgPSBhLnAxX2lzQW5nbGUgfHwgYS5wMl9pc0FuZ2xlO1xuICAgIGNvbnN0IGlzTm9kZUNoaXJvbiA9IFsnTWVhbl9Ob2RlJywnTWVhbl9Tb3V0aF9Ob2RlJywnQ2hpcm9uJ10uaW5jbHVkZXMoYS5wMV9uYW1lKSB8fCBbJ01lYW5fTm9kZScsJ01lYW5fU291dGhfTm9kZScsJ0NoaXJvbiddLmluY2x1ZGVzKGEucDJfbmFtZSk7XG4gICAgaWYgKGlzRXhhY3QpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0x1bSAmJiBvcmIgPD0gMykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQW5nbGUgJiYgb3JiIDw9IDIuNSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzTm9kZUNoaXJvbiAmJiBvcmIgPD0gMikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEuX2NsYXNzID09PSAnbWFqb3InICYmIGlzVGlnaHQpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAgY29uc3QgaG9va3MgPSAoaG9va0NhbmRpZGF0ZXMubGVuZ3RoID8gaG9va0NhbmRpZGF0ZXMgOiBmaWx0ZXJlZC5zbGljZSgwLCA4KSlcbiAgICAuc2xpY2UoKVxuICAgIC5zb3J0KChhLGIpPT57XG4gICAgICBjb25zdCBvYSA9IGEuX29yYiA/PyA2LjAxOyBjb25zdCBvYiA9IGIuX29yYiA/PyA2LjAxO1xuICAgICAgY29uc3QgZWEgPSBvYSA8PSAwLjU7IGNvbnN0IGViID0gb2IgPD0gMC41O1xuICAgICAgaWYgKGVhICE9PSBlYikgcmV0dXJuIGVhID8gLTEgOiAxO1xuICAgICAgY29uc3QgbGEgPSBhLnAxX2lzTHVtaW5hcnkgfHwgYS5wMl9pc0x1bWluYXJ5OyBjb25zdCBsYiA9IGIucDFfaXNMdW1pbmFyeSB8fCBiLnAyX2lzTHVtaW5hcnk7XG4gICAgICBpZiAobGEgIT09IGxiKSByZXR1cm4gbGEgPyAtMSA6IDE7XG4gICAgICBpZiAob2EgIT09IG9iKSByZXR1cm4gb2EgLSBvYjtcbiAgICAgIHJldHVybiAoYi5fd2VpZ2h0fHwwKSAtIChhLl93ZWlnaHR8fDApO1xuICAgIH0pXG4gICAgLnNsaWNlKDAsMTIpO1xuXG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdMaXN0LFxuICAgIGZpbHRlcmVkLFxuICAgIGhvb2tzLFxuICAgIHJlamVjdGlvbnMsXG4gICAgY291bnRzOiB7IHJhdzogcmF3TGlzdC5sZW5ndGgsIGZpbHRlcmVkOiBmaWx0ZXJlZC5sZW5ndGgsIGhvb2tzOiBob29rcy5sZW5ndGgsIHJlamVjdGVkOiByZWplY3Rpb25zLmxlbmd0aCB9XG4gIH07XG59XG5cblxuLy8gQ2Fub25pY2FsaXplIGluY29taW5nIG1vZGUgdG9rZW5zOiB0cmltLCB1cHBlcmNhc2UsIHJlcGxhY2Ugc3BhY2VzL2Rhc2hlcyB3aXRoIHNpbmdsZSB1bmRlcnNjb3JlLCBjb2xsYXBzZSByZXBlYXRzXG5mdW5jdGlvbiBjYW5vbmljYWxpemVNb2RlKHJhdykge1xuICBpZiAoIXJhdykgcmV0dXJuICcnO1xuICByZXR1cm4gcmF3LnRvU3RyaW5nKClcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UoL1stXFxzXSsvZywgJ18nKVxuICAgIC5yZXBsYWNlKC9fXysvZywgJ18nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBCdWlsZCBmaWVsZC1ieS1maWVsZCB2YWxpZGF0aW9uIG1hcCBmb3Igc3RyaWN0IHN1YmplY3QgcmVxdWlyZW1lbnRzXG5jb25zdCBTVFJJQ1RfUkVRVUlSRURfRklFTERTID0gWyd5ZWFyJywnbW9udGgnLCdkYXknLCdob3VyJywnbWludXRlJywnbmFtZScsJ3pvZGlhY190eXBlJ107XG5mdW5jdGlvbiB2YWxpZGF0ZVN1YmplY3RTdHJpY3RXaXRoTWFwKHN1YmplY3QpIHtcbiAgY29uc3QgZXJyb3JzID0ge307XG4gIFNUUklDVF9SRVFVSVJFRF9GSUVMRFMuZm9yRWFjaChmID0+IHtcbiAgICBpZiAoc3ViamVjdFtmXSA9PT0gdW5kZWZpbmVkIHx8IHN1YmplY3RbZl0gPT09IG51bGwgfHwgc3ViamVjdFtmXSA9PT0gJycpIHtcbiAgICAgIGVycm9yc1tmXSA9ICdNaXNzaW5nIG9yIGVtcHR5JztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBpc1ZhbGlkOiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCA9PT0gMCwgZXJyb3JzIH07XG59XG5cbi8qKlxuICogUm9idXN0bHkgY2FsbHMgYW4gQVBJIGVuZHBvaW50IHdpdGggcmV0cnkgbG9naWMgYW5kIGVycm9yIGhhbmRsaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBBUEkgZW5kcG9pbnQgVVJMLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBGZXRjaCBvcHRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIGxvZ2dpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmV0cmllcyAtIE1heCByZXRyeSBhdHRlbXB0cy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBwYXJzZWQgSlNPTiByZXNwb25zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBpQ2FsbFdpdGhSZXRyeSh1cmwsIG9wdGlvbnMsIG9wZXJhdGlvbiwgbWF4UmV0cmllcyA9IDIpIHtcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgQVBJIGNhbGwgYXR0ZW1wdCAke2F0dGVtcHR9LyR7bWF4UmV0cmllc30gZm9yICR7b3BlcmF0aW9ufWApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCAmJiByZXNwb25zZS5zdGF0dXMgIT09IDQyOSkge1xuICAgICAgICAgIC8vIENhcHR1cmUgc3RhdHVzICsgYm9keSBvbmNlXG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgIGxldCByYXdUZXh0ID0gJyc7XG4gICAgICAgICAgdHJ5IHsgcmF3VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTsgfSBjYXRjaCB7IHJhd1RleHQgPSAnVW5hYmxlIHRvIHJlYWQgcmVzcG9uc2UgYm9keSc7IH1cbiAgICAgICAgICBsZXQgcGFyc2VkTWVzc2FnZSA9IHJhd1RleHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBKU09OLnBhcnNlKHJhd1RleHQpO1xuICAgICAgICAgICAgaWYgKGoubWVzc2FnZSkgcGFyc2VkTWVzc2FnZSA9IGoubWVzc2FnZTtcbiAgICAgICAgICB9IGNhdGNoKF8pIHsvKiBrZWVwIHJhd1RleHQgKi99XG4gICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgYXV0aC9zdWJzY3JpcHRpb24gaXNzdWVzXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSA0MDEgfHwgc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGludCA9IHBhcnNlZE1lc3NhZ2UgJiYgL25vdCBzdWJzY3JpYmVkfHVuYXV0aG9yaXplZHxpbnZhbGlkIGFwaSBrZXl8YXBpIGtleSBpcyBpbnZhbGlkL2kudGVzdChwYXJzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICAgID8gJ1ZlcmlmeSBSQVBJREFQSV9LRVksIHN1YnNjcmlwdGlvbiBwbGFuLCBhbmQgdGhhdCB0aGUga2V5IG1hdGNoZXMgdGhpcyBBUEkuJ1xuICAgICAgICAgICAgICAgIDogJ0F1dGhlbnRpY2F0aW9uIC8gc3Vic2NyaXB0aW9uIGlzc3VlIGxpa2VseS4nO1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JhcGlkQVBJIGF1dGgvc3Vic2NyaXB0aW9uIGVycm9yJywgeyBzdGF0dXMsIG9wZXJhdGlvbiwgcGFyc2VkTWVzc2FnZSwgaGludCB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBSYXBpZEFQSSBhY2Nlc3MgZGVuaWVkICgke3N0YXR1c30pOiAke3BhcnNlZE1lc3NhZ2V9LiAke2hpbnR9YCk7XG4gICAgICAgICAgICAgIGVyci5jb2RlID0gJ1JBUElEQVBJX1NVQlNDUklQVElPTic7XG4gICAgICAgICAgICAgIGVyci5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgIGVyci5yYXcgPSByYXdUZXh0LnNsaWNlKDAsMTIwMCk7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0NsaWVudCBlcnJvciAobm9uLXJldHJ5YWJsZSknLCB7IHN0YXR1cywgb3BlcmF0aW9uLCB1cmwsIGJvZHk6IHJhd1RleHQuc2xpY2UoMCwxMjAwKSB9KTtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYENsaWVudCBlcnJvciAke3N0YXR1c30gZm9yICR7b3BlcmF0aW9ufWApO1xuICAgICAgICAgIGVyci5jb2RlID0gJ0NMSUVOVF9FUlJPUic7XG4gICAgICAgICAgZXJyLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICBlcnIucmF3ID0gcmF3VGV4dC5zbGljZSgwLDEyMDApO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIud2FybihgQVBJIGNhbGwgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfS4gUmV0cnlpbmcuLi5gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGF0dGVtcHQgPT09IG1heFJldHJpZXMgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnTm9uLXJldHJ5YWJsZScpKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIGFmdGVyICR7YXR0ZW1wdH0gYXR0ZW1wdHM6ICR7ZXJyb3IubWVzc2FnZX1gLCB7IHVybCwgb3BlcmF0aW9uLCBjb2RlOiBlcnJvci5jb2RlLCBzdGF0dXM6IGVycm9yLnN0YXR1cyB9KTtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdSQVBJREFQSV9TVUJTQ1JJUFRJT04nKSB0aHJvdyBlcnJvcjsgLy8gc3VyZmFjZSBkaXJlY3RseVxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0NMSUVOVF9FUlJPUicpIHRocm93IGVycm9yO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFNlcnZpY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuYCk7XG4gICAgICAgIGVyci5jb2RlID0gJ1VQU1RSRUFNX1RFTVBPUkFSWSc7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5wb3coMiwgYXR0ZW1wdCkgKiAxMDAgKyBNYXRoLnJhbmRvbSgpICogMTAwOyAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIGRlbGF5KSk7XG4gICAgfVxuICB9XG59XG5cbi8vIC0tLSBUcmFuc2l0IGhlbHBlcnMgLS0tXG4vLyBDb29yZGluYXRlIHBhcnNpbmcgKHN1cHBvcnRzIERNUyBcIjMwwrAxMCdOXCIgYW5kIGRlY2ltYWwpXG5mdW5jdGlvbiBwYXJzZUNvb3JkaW5hdGUodmFsKXtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsO1xuICBjb25zdCBkZWMgPSB2YWwudHJpbSgpO1xuICBpZiAoL14tP1xcZCsoPzpcXC5cXGQrKT8kLy50ZXN0KGRlYykpIHJldHVybiBwYXJzZUZsb2F0KGRlYyk7XG4gIC8vIERNUyBwYXR0ZXJuIGUuZy4sIDMwwrAxMCcxNVwiTiBvciAzMMKwMTAnTlxuICBjb25zdCBkbXMgPSAvXlxccyooXFxkezEsM30pW14wLTldKyhcXGR7MSwyfSk/KD86W14wLTldKyhcXGR7MSwyfSg/OlxcLlxcZCspPykpP1xccyooW05uU3NFZVd3XSlcXHMqJC8uZXhlYyhkZWMpO1xuICBpZiAoZG1zKXtcbiAgICBjb25zdCBkPStkbXNbMV07IGNvbnN0IG09ZG1zWzJdPytkbXNbMl06MDsgY29uc3Qgcz1kbXNbM10/K2Rtc1szXTowOyBjb25zdCBoZW1pPWRtc1s0XTtcbiAgICBjb25zdCBzaWduPS9bU3NXd10vLnRlc3QoaGVtaSk/LTE6MTsgcmV0dXJuIHNpZ24qKGQgKyBtLzYwICsgcy8zNjAwKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNpdHMoc3ViamVjdCwgdHJhbnNpdFBhcmFtcywgaGVhZGVycywgcGFzcyA9IHt9KSB7XG4gIGlmICghdHJhbnNpdFBhcmFtcyB8fCAhdHJhbnNpdFBhcmFtcy5zdGFydERhdGUgfHwgIXRyYW5zaXRQYXJhbXMuZW5kRGF0ZSkgcmV0dXJuIHt9O1xuXG4gIGNvbnN0IHsgYnVpbGRXaW5kb3dTYW1wbGVzIH0gPSByZXF1aXJlKCcuLi8uLi9saWIvdGltZS1zYW1wbGluZycpO1xuICBjb25zdCB0cmFuc2l0c0J5RGF0ZSA9IHt9O1xuICBjb25zdCByZXRyb0ZsYWdzQnlEYXRlID0ge307IC8vIGJvZHkgLT4gcmV0cm8gYm9vbGVhbiBwZXIgZGF0ZVxuICBjb25zdCBwcm92ZW5hbmNlQnlEYXRlID0ge307IC8vIHBlci1kYXkgZW5kcG9pbnQgKyBmb3JtYXRpb24gcHJvdmVuYW5jZVxuXG4gIC8vIERldGVybWluZSBzYW1wbGluZyB0aW1lem9uZTogcHJlZmVyIHN1YmplY3QudGltZXpvbmUsIGVsc2UgVVRDXG4gIGNvbnN0IGlhbmFUeiA9IHN1YmplY3Q/LnRpbWV6b25lIHx8ICdVVEMnO1xuICBjb25zdCBzdGVwID0gbm9ybWFsaXplU3RlcCh0cmFuc2l0UGFyYW1zLnN0ZXAgfHwgJ2RhaWx5Jyk7XG4gIGNvbnN0IHNhbXBsZXMgPSBidWlsZFdpbmRvd1NhbXBsZXMoeyBzdGFydDogdHJhbnNpdFBhcmFtcy5zdGFydERhdGUsIGVuZDogdHJhbnNpdFBhcmFtcy5lbmREYXRlLCBzdGVwIH0sIGlhbmFUeik7XG5cbiAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgLy8gSGVscGVyOiBlbnN1cmUgY29vcmRzL3R6IGZyb20gY2l0eSB1c2luZyBHZW9OYW1lcyB3aGVuIG5lZWRlZFxuICBhc3luYyBmdW5jdGlvbiBlbnN1cmVDb29yZHMocyl7XG4gICAgaWYgKCFzKSByZXR1cm4gcztcbiAgICBjb25zdCBoYXNDb29yZHMgPSB0eXBlb2Ygcy5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHMubG9uZ2l0dWRlID09PSAnbnVtYmVyJyAmJiAhIXMudGltZXpvbmU7XG4gICAgaWYgKGhhc0Nvb3JkcykgcmV0dXJuIHM7XG4gICAgaWYgKHMuY2l0eSAmJiBzLm5hdGlvbil7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gYXdhaXQgZ2VvUmVzb2x2ZSh7IGNpdHk6IHMuY2l0eSwgc3RhdGU6IHMuc3RhdGUsIG5hdGlvbjogcy5uYXRpb24gfSk7XG4gICAgICAgIGlmIChyICYmIHR5cGVvZiByLmxhdCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHIubG9uID09PSAnbnVtYmVyJyl7XG4gICAgICAgICAgcmV0dXJuIHsgLi4ucywgbGF0aXR1ZGU6IHIubGF0LCBsb25naXR1ZGU6IHIubG9uLCB0aW1lem9uZTogbm9ybWFsaXplVGltZXpvbmUoci50eiB8fCBzLnRpbWV6b25lIHx8ICdVVEMnKSB9O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpeyBsb2dnZXIud2FybignZW5zdXJlQ29vcmRzIGdlb1Jlc29sdmUgZmFpbGVkJywgZS5tZXNzYWdlKTsgfVxuICAgIH1cbiAgICByZXR1cm4geyAuLi5zLCBsYXRpdHVkZTogcy5sYXRpdHVkZSA/PyA1MS40OCwgbG9uZ2l0dWRlOiBzLmxvbmdpdHVkZSA/PyAwLCB0aW1lem9uZTogbm9ybWFsaXplVGltZXpvbmUocy50aW1lem9uZSB8fCAnVVRDJykgfTtcbiAgfVxuXG4gIC8vIERldGVybWluZSBhIGNvbnNpc3RlbnQgZm9ybWF0aW9uIGFwcHJvYWNoIHVwLWZyb250IGZvciB0aGUgZW50aXJlIHdpbmRvd1xuICAvLyBSdWxlOiBpZiBjb29yZHMrdHogcHJlc2VudCwgdXNlIGNvb3Jkcy1vbmx5IGZvciBhbGwgZGF5czsgZWxzZSB1c2UgY2l0eS1tb2RlICh3aXRoIG9wdGlvbmFsIGdlb25hbWVzX3VzZXJuYW1lKVxuICBjb25zdCBwcmVmZXJDb29yZHMgPSAodHlwZW9mIHN1YmplY3QubGF0aXR1ZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzdWJqZWN0LmxhdCA9PT0gJ251bWJlcicpXG4gICAgJiYgKHR5cGVvZiBzdWJqZWN0LmxvbmdpdHVkZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHN1YmplY3QubG9uID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc3ViamVjdC5sbmcgPT09ICdudW1iZXInKVxuICAgICYmICEhKHN1YmplY3QudGltZXpvbmUgfHwgc3ViamVjdC50el9zdHIpO1xuXG4gIGZvciAoY29uc3Qgc2FtcGxlSXNvIG9mIHNhbXBsZXMpIHtcbiAgICBjb25zdCBkdCA9IG5ldyBEYXRlKHNhbXBsZUlzbyk7XG4gICAgY29uc3QgZGF0ZVN0cmluZyA9IHNhbXBsZUlzby5zbGljZSgwLCAxMCk7IC8vIFlZWVktTU0tRERcbiAgICAvLyBUcmFuc2l0IGluc3RhbnQ6IHByZWZlciBjaXR5IG1vZGU7IGZhbGxiYWNrIHRvIGNvb3JkcyByZXNvbHZlZFxuICAgICAgY29uc3QgdHJhbnNpdF9zdWJqZWN0ID0gYXdhaXQgKGFzeW5jIGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICAgICAgeWVhcjogZHQuZ2V0VVRDRnVsbFllYXIoKSwgbW9udGg6IGR0LmdldFVUQ01vbnRoKCkgKyAxLCBkYXk6IGR0LmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICBob3VyOiBkdC5nZXRVVENIb3VycygpLCBtaW51dGU6IGR0LmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgICB6b2RpYWNfdHlwZTogJ1Ryb3BpYydcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZWZlckNvb3Jkcykge1xuICAgICAgICAgIGNvbnN0IHMgPSBhd2FpdCBlbnN1cmVDb29yZHMoc3ViamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbGF0aXR1ZGU6IHMubGF0aXR1ZGUsIGxvbmdpdHVkZTogcy5sb25naXR1ZGUsIHRpbWV6b25lOiAnVVRDJyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpdHlGaWVsZCA9IHN1YmplY3Quc3RhdGUgPyBgJHtzdWJqZWN0LmNpdHl9LCAke3N1YmplY3Quc3RhdGV9YCA6IHN1YmplY3QuY2l0eTtcbiAgICAgICAgY29uc3QgdCA9IHsgLi4uYmFzZSwgY2l0eTogY2l0eUZpZWxkLCBuYXRpb246IHN1YmplY3QubmF0aW9uIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5HRU9OQU1FU19VU0VSTkFNRSkgKHQpLmdlb25hbWVzX3VzZXJuYW1lID0gcHJvY2Vzcy5lbnYuR0VPTkFNRVNfVVNFUk5BTUU7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSkoKTtcblxuICAgIC8vIEluY2x1ZGUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciB3aGljaCBwbGFuZXRzIHRvIGluY2x1ZGVcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgZmlyc3Rfc3ViamVjdDogc3ViamVjdFRvQVBJKHN1YmplY3QsIHBhc3MpLFxuICAgICAgdHJhbnNpdF9zdWJqZWN0OiBzdWJqZWN0VG9BUEkodHJhbnNpdF9zdWJqZWN0LCBwYXNzKSxcbiAgICAgIC4uLnBhc3MgLy8gSW5jbHVkZSBhY3RpdmVfcG9pbnRzLCBhY3RpdmVfYXNwZWN0cywgZXRjLlxuICAgIH07XG5cbiAgICBsb2dnZXIuZGVidWcoYFRyYW5zaXQgQVBJIGNhbGwgZm9yICR7ZGF0ZVN0cmluZ306YCwge1xuICAgICAgYWN0aXZlX3BvaW50czogcGF5bG9hZC5hY3RpdmVfcG9pbnRzIHx8ICdkZWZhdWx0JyxcbiAgICAgIHBhc3Nfa2V5czogT2JqZWN0LmtleXMocGFzcylcbiAgICB9KTtcblxuICAgIC8vIEVuaGFuY2VkIGRlYnVnIGxvZ2dpbmc6IExvZyBmdWxsIHBheWxvYWQgd2hlbiBkZWJ1Z2dpbmcgZW1wdHkgcmVzdWx0c1xuICAgIGxvZ2dlci5kZWJ1ZyhgRnVsbCB0cmFuc2l0IEFQSSBwYXlsb2FkIGZvciAke2RhdGVTdHJpbmd9OmAsIEpTT04uc3RyaW5naWZ5KHBheWxvYWQsIG51bGwsIDIpKTtcblxuICAgIHByb21pc2VzLnB1c2goXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICBsZXQgcmVzcCA9IG51bGw7XG4gIGxldCBlbmRwb2ludCA9ICd0cmFuc2l0LWFzcGVjdHMtZGF0YSc7XG4gIGxldCBmb3JtYXRpb24gPSB0cmFuc2l0X3N1YmplY3QuY2l0eSA/ICdjaXR5JyA6ICdjb29yZHMnO1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDM7XG5cbiAgICAgICAgLy8gQXR0ZW1wdCAxOiBQcmltYXJ5IGVuZHBvaW50IC0gL3RyYW5zaXQtYXNwZWN0cy1kYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcCA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoXG4gICAgICAgICAgICBBUElfRU5EUE9JTlRTLlRSQU5TSVRfQVNQRUNUUyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGBUcmFuc2l0cyBmb3IgJHtzdWJqZWN0Lm5hbWV9IG9uICR7ZGF0ZVN0cmluZ31gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICAgIFxuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVHJhbnNpdCBBUEkgcmVzcG9uc2UgZm9yICR7ZGF0ZVN0cmluZ30gKCR7ZW5kcG9pbnR9KTpgLCB7XG4gICAgICAgICAgICBoYXNBc3BlY3RzOiAhIShyZXNwICYmIHJlc3AuYXNwZWN0cyksXG4gICAgICAgICAgICBhc3BlY3RDb3VudDogKHJlc3AgJiYgcmVzcC5hc3BlY3RzKSA/IHJlc3AuYXNwZWN0cy5sZW5ndGggOiAwLFxuICAgICAgICAgICAgcmVzcG9uc2VLZXlzOiByZXNwID8gT2JqZWN0LmtleXMocmVzcCkgOiAnbnVsbCByZXNwb25zZScsXG4gICAgICAgICAgICBzYW1wbGU6IHJlc3AgJiYgcmVzcC5hc3BlY3RzICYmIHJlc3AuYXNwZWN0cy5sZW5ndGggPiAwID8gcmVzcC5hc3BlY3RzWzBdIDogJ25vIGFzcGVjdHMnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgUHJpbWFyeSB0cmFuc2l0IGVuZHBvaW50IGZhaWxlZCBmb3IgJHtkYXRlU3RyaW5nfTpgLCBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0ZW1wdCAyOiBGYWxsYmFjayB0byAvdHJhbnNpdC1jaGFydCBpZiBubyBhc3BlY3RzIGZvdW5kXG4gICAgICAgIGlmICgoIXJlc3AgfHwgIXJlc3AuYXNwZWN0cyB8fCByZXNwLmFzcGVjdHMubGVuZ3RoID09PSAwKSAmJiBhdHRlbXB0cyA8IG1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVuZHBvaW50ID0gJ3RyYW5zaXQtY2hhcnQnO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZhbGxiYWNrOiBUcnlpbmcgdHJhbnNpdC1jaGFydCBlbmRwb2ludCBmb3IgJHtkYXRlU3RyaW5nfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXNwID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeShcbiAgICAgICAgICAgICAgQVBJX0VORFBPSU5UUy5UUkFOU0lUX0NIQVJULFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYFRyYW5zaXQgY2hhcnQgZmFsbGJhY2sgZm9yICR7c3ViamVjdC5uYW1lfSBvbiAke2RhdGVTdHJpbmd9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF0dGVtcHRzKys7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYXNwZWN0cyBmcm9tIGNoYXJ0IHJlc3BvbnNlIHN0cnVjdHVyZVxuICAgICAgICAgICAgaWYgKHJlc3AgJiYgIXJlc3AuYXNwZWN0cyAmJiByZXNwLmRhdGEpIHtcbiAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIGFzcGVjdHMgYXJlIG5lc3RlZCBpbiBkYXRhXG4gICAgICAgICAgICAgIHJlc3AuYXNwZWN0cyA9IHJlc3AuZGF0YS5hc3BlY3RzIHx8IHJlc3AuYXNwZWN0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUcmFuc2l0IGNoYXJ0IGZhbGxiYWNrIHJlc3BvbnNlIGZvciAke2RhdGVTdHJpbmd9OmAsIHtcbiAgICAgICAgICAgICAgaGFzQXNwZWN0czogISEocmVzcCAmJiByZXNwLmFzcGVjdHMpLFxuICAgICAgICAgICAgICBhc3BlY3RDb3VudDogKHJlc3AgJiYgcmVzcC5hc3BlY3RzKSA/IHJlc3AuYXNwZWN0cy5sZW5ndGggOiAwLFxuICAgICAgICAgICAgICByZXNwb25zZUtleXM6IHJlc3AgPyBPYmplY3Qua2V5cyhyZXNwKSA6ICdudWxsIHJlc3BvbnNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRyYW5zaXQgY2hhcnQgZmFsbGJhY2sgZmFpbGVkIGZvciAke2RhdGVTdHJpbmd9OmAsIGUubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0ZW1wdCAzOiBUcnkgc3dpdGNoaW5nIHRyYW5zaXQgc3ViamVjdCBmb3JtYXRpb24gaWYgc3RpbGwgZW1wdHlcbiAgICAgICAgaWYgKCghcmVzcCB8fCAhcmVzcC5hc3BlY3RzIHx8IHJlc3AuYXNwZWN0cy5sZW5ndGggPT09IDApICYmIGF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSAnZm9ybWF0aW9uLXN3aXRjaCc7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgRm9ybWF0aW9uIHN3aXRjaDogVHJ5aW5nIGFsdGVybmF0ZSB0cmFuc2l0IHN1YmplY3QgZm9yICR7ZGF0ZVN0cmluZ31gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3dpdGNoIGJldHdlZW4gY2l0eSBtb2RlIGFuZCBjb29yZHMgbW9kZVxuICAgICAgICAgICAgY29uc3QgYWx0ZXJuYXRlVHJhbnNpdFN1YmplY3QgPSBhd2FpdCAoYXN5bmMgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiBkdC5nZXRVVENGdWxsWWVhcigpLCBtb250aDogZHQuZ2V0VVRDTW9udGgoKSArIDEsIGRheTogZHQuZ2V0VVRDRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGhvdXI6IGR0LmdldFVUQ0hvdXJzKCksIG1pbnV0ZTogZHQuZ2V0VVRDTWludXRlcygpLFxuICAgICAgICAgICAgICAgIHpvZGlhY190eXBlOiAnVHJvcGljJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSWYgb3JpZ2luYWwgd2FzIGNpdHkgbW9kZSwgdHJ5IGNvb3JkcyBtb2RlXG4gICAgICAgICAgICAgIGlmICghcHJlZmVyQ29vcmRzICYmIHN1YmplY3QuY2l0eSAmJiBzdWJqZWN0Lm5hdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhd2FpdCBlbnN1cmVDb29yZHMoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbGF0aXR1ZGU6IHMubGF0aXR1ZGUsIGxvbmdpdHVkZTogcy5sb25naXR1ZGUsIHRpbWV6b25lOiAnVVRDJyB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIG9yaWdpbmFsIHdhcyBjb29yZHMgbW9kZSwgdHJ5IGNpdHkgbW9kZSB3aXRoIGdlb25hbWVzXG4gICAgICAgICAgICAgIGNvbnN0IGNpdHlGaWVsZCA9IHN1YmplY3Quc3RhdGUgPyBgJHtzdWJqZWN0LmNpdHl9LCAke3N1YmplY3Quc3RhdGV9YCA6IChzdWJqZWN0LmNpdHkgfHwgJ0xvbmRvbicpO1xuICAgICAgICAgICAgICBjb25zdCB0ID0geyAuLi5iYXNlLCBjaXR5OiBjaXR5RmllbGQsIG5hdGlvbjogc3ViamVjdC5uYXRpb24gfHwgJ1VLJyB9O1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuR0VPTkFNRVNfVVNFUk5BTUUpIHQuZ2VvbmFtZXNfdXNlcm5hbWUgPSBwcm9jZXNzLmVudi5HRU9OQU1FU19VU0VSTkFNRTtcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICBjb25zdCBhbHRlcm5hdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICBmaXJzdF9zdWJqZWN0OiBzdWJqZWN0VG9BUEkoc3ViamVjdCwgcGFzcyksXG4gICAgICAgICAgICAgIHRyYW5zaXRfc3ViamVjdDogc3ViamVjdFRvQVBJKGFsdGVybmF0ZVRyYW5zaXRTdWJqZWN0LCBwYXNzKSxcbiAgICAgICAgICAgICAgLi4ucGFzc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzcCA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoXG4gICAgICAgICAgICAgIEFQSV9FTkRQT0lOVFMuVFJBTlNJVF9BU1BFQ1RTLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShhbHRlcm5hdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYEZvcm1hdGlvbiBzd2l0Y2ggZm9yICR7c3ViamVjdC5uYW1lfSBvbiAke2RhdGVTdHJpbmd9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF0dGVtcHRzKys7XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgRm9ybWF0aW9uIHN3aXRjaCByZXNwb25zZSBmb3IgJHtkYXRlU3RyaW5nfTpgLCB7XG4gICAgICAgICAgICAgIGhhc0FzcGVjdHM6ICEhKHJlc3AgJiYgcmVzcC5hc3BlY3RzKSxcbiAgICAgICAgICAgICAgYXNwZWN0Q291bnQ6IChyZXNwICYmIHJlc3AuYXNwZWN0cykgPyByZXNwLmFzcGVjdHMubGVuZ3RoIDogMCxcbiAgICAgICAgICAgICAgYWx0ZXJuYXRlRm9ybWF0aW9uOiBhbHRlcm5hdGVUcmFuc2l0U3ViamVjdC5jaXR5ID8gJ2NpdHktbW9kZScgOiAnY29vcmRzLW1vZGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgRm9ybWF0aW9uIHN3aXRjaCBmYWlsZWQgZm9yICR7ZGF0ZVN0cmluZ306YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAgICAgICAgaWYgKHJlc3AgJiYgcmVzcC5hc3BlY3RzICYmIHJlc3AuYXNwZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdHJhbnNpdHNCeURhdGVbZGF0ZVN0cmluZ10gPSByZXNwLmFzcGVjdHM7XG4gICAgICAgICAgcHJvdmVuYW5jZUJ5RGF0ZVtkYXRlU3RyaW5nXSA9IHtcbiAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgZm9ybWF0aW9uLFxuICAgICAgICAgICAgYXR0ZW1wdHMsXG4gICAgICAgICAgICBhc3BlY3RfY291bnQ6IHJlc3AuYXNwZWN0cy5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEV4dHJhY3QgcmV0cm8gZmxhZ3MgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgY29uc3QgcmV0cm9NYXAgPSB7fTtcbiAgICAgICAgICBjb25zdCBmcyA9IHJlc3AuZGF0YT8uZmlyc3Rfc3ViamVjdCB8fCByZXNwLmRhdGE/LmZpcnN0U3ViamVjdDtcbiAgICAgICAgICBjb25zdCB0ciA9IHJlc3AuZGF0YT8udHJhbnNpdCB8fCByZXNwLmRhdGE/LnRyYW5zaXRfc3ViamVjdDtcbiAgICAgICAgICBjb25zdCBjb2xsZWN0ID0gKGJsb2NrKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWJsb2NrIHx8IHR5cGVvZiBibG9jayAhPT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssdl0gb2YgT2JqZWN0LmVudHJpZXMoYmxvY2spKSB7XG4gICAgICAgICAgICAgIGlmICh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAncmV0cm9ncmFkZScgaW4gdikge1xuICAgICAgICAgICAgICAgIHJldHJvTWFwWyh2Lm5hbWV8fHYuYm9keXx8ayldID0gISF2LnJldHJvZ3JhZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbGxlY3QoZnMpOyBjb2xsZWN0KHRyKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocmV0cm9NYXApLmxlbmd0aCkgcmV0cm9GbGFnc0J5RGF0ZVtkYXRlU3RyaW5nXSA9IHJldHJvTWFwO1xuICAgICAgICAgIFxuICAgICAgICAgIGxvZ2dlci5pbmZvKGDinJMgU3VjY2VzcyBmb3IgJHtkYXRlU3RyaW5nfTogJHtyZXNwLmFzcGVjdHMubGVuZ3RofSBhc3BlY3RzIHZpYSAke2VuZHBvaW50fSAoYXR0ZW1wdHM6ICR7YXR0ZW1wdHN9KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGDinJcgTm8gYXNwZWN0cyBmb3VuZCBmb3IgJHtkYXRlU3RyaW5nfSBhZnRlciAke2F0dGVtcHRzfSBhdHRlbXB0cyAoZW5kcG9pbnRzOiAke2VuZHBvaW50fSlgKTtcbiAgICAgICAgICAvLyBFbmhhbmNlZCBkZWJ1ZyBsb2dnaW5nOiBMb2cgZnVsbCByZXNwb25zZSB3aGVuIG5vIGFzcGVjdHMgZm91bmRcbiAgICAgICAgICBpZiAocmVzcCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBGdWxsIHJhdyBBUEkgcmVzcG9uc2UgZm9yICR7ZGF0ZVN0cmluZ30gKG5vIGFzcGVjdHMpOmAsIEpTT04uc3RyaW5naWZ5KHJlc3AsIG51bGwsIDIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvdmVuYW5jZUJ5RGF0ZVtkYXRlU3RyaW5nXSA9IHsgZW5kcG9pbnQsIGZvcm1hdGlvbiwgYXR0ZW1wdHMsIGFzcGVjdF9jb3VudDogMCB9O1xuICAgICAgICB9XG4gICAgICB9KSgpLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IHRyYW5zaXRzIGZvciAke2RhdGVTdHJpbmd9YCwgZSkpXG4gICAgKTtcbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIFxuICBsb2dnZXIuZGVidWcoYGdldFRyYW5zaXRzIGNvbXBsZXRlZCBmb3IgJHtzdWJqZWN0Lm5hbWV9OmAsIHtcbiAgICByZXF1ZXN0ZWREYXRlczogc2FtcGxlcy5sZW5ndGgsXG4gICAgZGF0ZXNXaXRoRGF0YTogT2JqZWN0LmtleXModHJhbnNpdHNCeURhdGUpLmxlbmd0aCxcbiAgICB0b3RhbEFzcGVjdHM6IE9iamVjdC52YWx1ZXModHJhbnNpdHNCeURhdGUpLnJlZHVjZSgoc3VtLCBhc3BlY3RzKSA9PiBzdW0gKyBhc3BlY3RzLmxlbmd0aCwgMCksXG4gICAgYXZhaWxhYmxlRGF0ZXM6IE9iamVjdC5rZXlzKHRyYW5zaXRzQnlEYXRlKVxuICB9KTtcbiAgXG4gIHJldHVybiB7IHRyYW5zaXRzQnlEYXRlLCByZXRyb0ZsYWdzQnlEYXRlLCBwcm92ZW5hbmNlQnlEYXRlIH07XG59XG5cbi8vIEdlbyByZXNvbHZlIHZpYSBHZW9OYW1lc1xuYXN5bmMgZnVuY3Rpb24gZ2VvUmVzb2x2ZSh7IGNpdHksIHN0YXRlLCBuYXRpb24gfSl7XG4gIGNvbnN0IHUgPSBwcm9jZXNzLmVudi5HRU9OQU1FU19VU0VSTkFNRSB8fCAnJztcbiAgY29uc3QgcSA9IGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZSA/IGAke2NpdHl9LCAke3N0YXRlfWAgOiBjaXR5KTtcbiAgY29uc3QgYyA9IGVuY29kZVVSSUNvbXBvbmVudChuYXRpb24gfHwgJycpO1xuICBjb25zdCBzZWFyY2hVcmwgPSBgaHR0cDovL2FwaS5nZW9uYW1lcy5vcmcvc2VhcmNoSlNPTj9xPSR7cX0mY291bnRyeT0ke2N9Jm1heFJvd3M9MSZ1c2VybmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudCh1KX1gO1xuICBjb25zdCByZXMxID0gYXdhaXQgZmV0Y2goc2VhcmNoVXJsKTtcbiAgY29uc3QgajEgPSBhd2FpdCByZXMxLmpzb24oKTtcbiAgY29uc3QgZyA9IGoxICYmIEFycmF5LmlzQXJyYXkoajEuZ2VvbmFtZXMpICYmIGoxLmdlb25hbWVzWzBdO1xuICBpZiAoIWcpIHJldHVybiBudWxsO1xuICBjb25zdCBsYXQgPSBwYXJzZUZsb2F0KGcubGF0KSwgbG9uID0gcGFyc2VGbG9hdChnLmxuZyk7XG4gIGxldCB0eiA9IG51bGw7XG4gIHRyeSB7XG4gICAgY29uc3QgdHpVcmwgPSBgaHR0cDovL2FwaS5nZW9uYW1lcy5vcmcvdGltZXpvbmVKU09OP2xhdD0ke2xhdH0mbG5nPSR7bG9ufSZ1c2VybmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudCh1KX1gO1xuICAgIGNvbnN0IHJlczIgPSBhd2FpdCBmZXRjaCh0elVybCk7XG4gICAgY29uc3QgajIgPSBhd2FpdCByZXMyLmpzb24oKTtcbiAgICB0eiA9IGoyICYmIChqMi50aW1lem9uZUlkIHx8IGoyLnRpbWV6b25lIHx8IG51bGwpO1xuICB9IGNhdGNoIHt9XG4gIHJldHVybiB7IGxhdCwgbG9uLCB0eiB9O1xufVxuXG4vLyBFeHBvc2UgcmVzb2x2ZS1jaXR5IGVuZHBvaW50IGhlbHBlclxuZXhwb3J0cy5yZXNvbHZlQ2l0eSA9IGFzeW5jIGZ1bmN0aW9uKGV2ZW50KXtcbiAgY29uc3QgcXMgPSBldmVudC5xdWVyeVN0cmluZ1BhcmFtZXRlcnMgfHwge307XG4gIGNvbnN0IGNpdHkgPSBxcy5jaXR5IHx8ICcnO1xuICBjb25zdCBzdGF0ZSA9IHFzLnN0YXRlIHx8ICcnO1xuICBjb25zdCBuYXRpb24gPSBxcy5uYXRpb24gfHwgJyc7XG4gIHRyeSB7XG4gICAgY29uc3QgciA9IGF3YWl0IGdlb1Jlc29sdmUoeyBjaXR5LCBzdGF0ZSwgbmF0aW9uIH0pO1xuICAgIHJldHVybiB7IHN0YXR1c0NvZGU6IDIwMCwgaGVhZGVyczogeyAnY29udGVudC10eXBlJzonYXBwbGljYXRpb24vanNvbicgfSwgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbnB1dDp7Y2l0eSxzdGF0ZSxuYXRpb259LCByZXNvbHZlZDpyIH0pIH07XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNTAwLCBoZWFkZXJzOiB7ICdjb250ZW50LXR5cGUnOidhcHBsaWNhdGlvbi9qc29uJyB9LCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVycm9yOiBlLm1lc3NhZ2UgfSkgfTtcbiAgfVxufVxuXG4vLyAtLS0gVHJhbnNpdCBUYWJsZSBGb3JtYXR0aW5nOiBPcmItQmFuZCArIFBoYXNlICsgU2NvcmUgLS0tXG5mdW5jdGlvbiBmb3JtYXRUcmFuc2l0VGFibGUoZW5yaWNoZWRBc3BlY3RzLCBwcmV2RGF5QXNwZWN0cyA9IG51bGwpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVucmljaGVkQXNwZWN0cykgfHwgZW5yaWNoZWRBc3BlY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBleGFjdDogW10sXG4gICAgICB0aWdodDogW10sXG4gICAgICBtb2RlcmF0ZTogW10sXG4gICAgICB3aWRlOiBbXSxcbiAgICAgIG1hcmtkb3duOiBcIk5vIGFzcGVjdHMgZm9yIHRoaXMgZGF0ZS5cIlxuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGUgbG9va3VwIG1hcCBmb3IgcHJldmlvdXMgZGF5J3Mgb3JicyB0byBkZXRlcm1pbmUgcGhhc2VcbiAgY29uc3QgcHJldk9yYk1hcCA9IG5ldyBNYXAoKTtcbiAgaWYgKHByZXZEYXlBc3BlY3RzICYmIEFycmF5LmlzQXJyYXkocHJldkRheUFzcGVjdHMpKSB7XG4gICAgZm9yIChjb25zdCBhc3BlY3Qgb2YgcHJldkRheUFzcGVjdHMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2FzcGVjdC5wMV9uYW1lfXwke2FzcGVjdC5fYXNwZWN0fXwke2FzcGVjdC5wMl9uYW1lfWA7XG4gICAgICBwcmV2T3JiTWFwLnNldChrZXksIGFzcGVjdC5fb3JiKTtcbiAgICB9XG4gIH1cblxuICAvLyBQcm9jZXNzIGFzcGVjdHMgd2l0aCBvcmIgYmFuZHMsIHBoYXNlLCBhbmQgc2NvcmVcbiAgY29uc3QgcHJvY2Vzc2VkQXNwZWN0cyA9IGVucmljaGVkQXNwZWN0cy5tYXAoYXNwZWN0ID0+IHtcbiAgICBjb25zdCBvcmIgPSBhc3BlY3QuX29yYiB8fCAwO1xuICAgIGNvbnN0IGtleSA9IGAke2FzcGVjdC5wMV9uYW1lfXwke2FzcGVjdC5fYXNwZWN0fXwke2FzcGVjdC5wMl9uYW1lfWA7XG4gICAgY29uc3QgcHJldk9yYiA9IHByZXZPcmJNYXAuZ2V0KGtleSk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHBoYXNlOiDihpEgdGlnaHRlbmluZyAob3JiIGRlY3JlYXNpbmcpLCDihpMgc2VwYXJhdGluZyAob3JiIGluY3JlYXNpbmcpXG4gICAgbGV0IHBoYXNlID0gJ+KAlCc7IC8vIG5ldXRyYWwvdW5rbm93blxuICAgIGlmIChwcmV2T3JiICE9IG51bGwgJiYgdHlwZW9mIHByZXZPcmIgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAob3JiIDwgcHJldk9yYikgcGhhc2UgPSAn4oaRJzsgLy8gdGlnaHRlbmluZ1xuICAgICAgZWxzZSBpZiAob3JiID4gcHJldk9yYikgcGhhc2UgPSAn4oaTJzsgLy8gc2VwYXJhdGluZ1xuICAgICAgLy8gaWYgZXF1YWwsIGtlZXAgbmV1dHJhbFxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBzY29yZSB1c2luZyBzZWlzbW9ncmFwaCBpbnRlcm5hbHNcbiAgICBjb25zdCBhc3BlY3RGb3JTY29yZSA9IHtcbiAgICAgIHRyYW5zaXQ6IHsgYm9keTogYXNwZWN0LnAxX25hbWUgfSxcbiAgICAgIG5hdGFsOiB7IGJvZHk6IGFzcGVjdC5wMl9uYW1lIH0sXG4gICAgICB0eXBlOiBhc3BlY3QuX2FzcGVjdCxcbiAgICAgIG9yYkRlZzogb3JiXG4gICAgfTtcbiAgICBjb25zdCBzY29yZWQgPSBzZWlzbW9JbnRlcm5hbHMuc2NvcmVBc3BlY3QoYXNwZWN0Rm9yU2NvcmUsIHtcbiAgICAgIGlzQW5nbGVQcm94OiBhc3BlY3QucDJfaXNBbmdsZSxcbiAgICAgIGNyaXRpY2FsOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXQ6IGFzcGVjdC5wMV9kaXNwbGF5IHx8IGFzcGVjdC5wMV9uYW1lLFxuICAgICAgYXNwZWN0OiBhc3BlY3QuX2FzcGVjdCxcbiAgICAgIG5hdGFsOiBhc3BlY3QucDJfZGlzcGxheSB8fCBhc3BlY3QucDJfbmFtZSxcbiAgICAgIG9yYjogTnVtYmVyKG9yYi50b0ZpeGVkKDEpKSxcbiAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgIHNjb3JlOiBOdW1iZXIoc2NvcmVkLlMudG9GaXhlZCgyKSksXG4gICAgICBfb3JiVmFsdWU6IG9yYiAvLyBmb3Igc29ydGluZ1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFNvcnQgYnkgb3JiICh0aWdodGVzdCBmaXJzdClcbiAgcHJvY2Vzc2VkQXNwZWN0cy5zb3J0KChhLCBiKSA9PiBhLl9vcmJWYWx1ZSAtIGIuX29yYlZhbHVlKTtcblxuICAvLyBHcm91cCBieSBvcmIgYmFuZHNcbiAgY29uc3QgZXhhY3QgPSBwcm9jZXNzZWRBc3BlY3RzLmZpbHRlcihhID0+IGEuX29yYlZhbHVlIDw9IDAuNSk7XG4gIGNvbnN0IHRpZ2h0ID0gcHJvY2Vzc2VkQXNwZWN0cy5maWx0ZXIoYSA9PiBhLl9vcmJWYWx1ZSA+IDAuNSAmJiBhLl9vcmJWYWx1ZSA8PSAyLjApO1xuICBjb25zdCBtb2RlcmF0ZSA9IHByb2Nlc3NlZEFzcGVjdHMuZmlsdGVyKGEgPT4gYS5fb3JiVmFsdWUgPiAyLjAgJiYgYS5fb3JiVmFsdWUgPD0gNi4wKTtcbiAgY29uc3Qgd2lkZSA9IHByb2Nlc3NlZEFzcGVjdHMuZmlsdGVyKGEgPT4gYS5fb3JiVmFsdWUgPiA2LjApO1xuXG4gIC8vIEdlbmVyYXRlIG1hcmtkb3duIHRhYmxlIGZvcm1hdFxuICBmdW5jdGlvbiBjcmVhdGVNYXJrZG93blRhYmxlKGFzcGVjdHMsIHRpdGxlKSB7XG4gICAgaWYgKGFzcGVjdHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgXG4gICAgbGV0IHRhYmxlID0gYFxcbioqJHt0aXRsZX0qKlxcblxcbmA7XG4gICAgdGFibGUgKz0gJ3wgVHJhbnNpdCB8IEFzcGVjdCB8IE5hdGFsIHwgT3JiICjCsCkgfCBQaGFzZSB8IFNjb3JlIHxcXG4nO1xuICAgIHRhYmxlICs9ICd8LS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS18XFxuJztcbiAgICBcbiAgICBmb3IgKGNvbnN0IGEgb2YgYXNwZWN0cykge1xuICAgICAgdGFibGUgKz0gYHwgJHthLnRyYW5zaXR9IHwgJHthLmFzcGVjdH0gfCAke2EubmF0YWx9IHwgJHthLm9yYn0gfCAke2EucGhhc2V9IHwgJHthLnNjb3JlID49IDAgPyAnKycgOiAnJ30ke2Euc2NvcmV9IHxcXG5gO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICBsZXQgbWFya2Rvd24gPSAnJztcbiAgaWYgKGV4YWN0Lmxlbmd0aCA+IDApIG1hcmtkb3duICs9IGNyZWF0ZU1hcmtkb3duVGFibGUoZXhhY3QsICfirZAgRXhhY3QgQXNwZWN0cyAo4omkMC41wrApJyk7XG4gIGlmICh0aWdodC5sZW5ndGggPiAwKSBtYXJrZG93biArPSBjcmVhdGVNYXJrZG93blRhYmxlKHRpZ2h0LCAn8J+UpSBUaWdodCBBc3BlY3RzICgwLjXCsCAtIDLCsCknKTtcbiAgaWYgKG1vZGVyYXRlLmxlbmd0aCA+IDApIG1hcmtkb3duICs9IGNyZWF0ZU1hcmtkb3duVGFibGUobW9kZXJhdGUsICfwn5OKIE1vZGVyYXRlIEFzcGVjdHMgKDLCsCAtIDbCsCknKTtcbiAgaWYgKHdpZGUubGVuZ3RoID4gMCkgbWFya2Rvd24gKz0gY3JlYXRlTWFya2Rvd25UYWJsZSh3aWRlLCAn8J+Mq++4jyBXaWRlIEFzcGVjdHMgKD42wrApJyk7XG5cbiAgaWYgKG1hcmtkb3duID09PSAnJykge1xuICAgIG1hcmtkb3duID0gXCJObyBhc3BlY3RzIGZvciB0aGlzIGRhdGUuXCI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4YWN0LFxuICAgIHRpZ2h0LFxuICAgIG1vZGVyYXRlLFxuICAgIHdpZGUsXG4gICAgbWFya2Rvd25cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2Vpc21vZ3JhcGgodHJhbnNpdHNCeURhdGUsIHJldHJvRmxhZ3NCeURhdGUgPSB7fSkge1xuICBpZiAoIXRyYW5zaXRzQnlEYXRlIHx8IE9iamVjdC5rZXlzKHRyYW5zaXRzQnlEYXRlKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyBkYWlseToge30sIHN1bW1hcnk6IHt9IH07XG4gIH1cblxuICBjb25zdCBkYXlzID0gT2JqZWN0LmtleXModHJhbnNpdHNCeURhdGUpLnNvcnQoKTtcbiAgbGV0IHByZXYgPSBudWxsO1xuICBsZXQgcHJldkRheUZpbHRlcmVkID0gbnVsbDtcbiAgY29uc3QgZGFpbHkgPSB7fTtcbiAgY29uc3Qgcm9sbGluZ01hZ25pdHVkZXMgPSBbXTsgLy8gVHJhY2sgZm9yIDE0LWRheSByb2xsaW5nIHdpbmRvd1xuICBjb25zdCB2YWxlbmNlSGlzdG9yeSA9IFtdOyAvLyBUcmFjayBmb3IgdHJlbmQgYW5hbHlzaXNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRheXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkID0gZGF5c1tpXTtcbiAgICBjb25zdCByYXdEYXlBc3BlY3RzID0gdHJhbnNpdHNCeURhdGVbZF0gfHwgW107XG4gIGNvbnN0IGVucmljaGVkID0gZW5yaWNoRGFpbHlBc3BlY3RzKHJhd0RheUFzcGVjdHMpO1xuICAgIFxuICAgIC8vIEVuaGFuY2UgYXNwZWN0cyB3aXRoIHJldHJvZ3JhZGUgZmxhZ3NcbiAgICBjb25zdCByZXRyb01hcCA9IHJldHJvRmxhZ3NCeURhdGVbZF0gfHwge307XG4gICAgY29uc3QgZW5yaWNoZWRXaXRoUmV0cm9ncmFkZSA9IGVucmljaGVkLmZpbHRlcmVkLm1hcChhc3BlY3QgPT4ge1xuICAgICAgY29uc3QgcDFyID0gcmV0cm9NYXBbYXNwZWN0LnAxX25hbWVdID8/IHJldHJvTWFwW2FzcGVjdC5wMV9kaXNwbGF5XSA/PyBmYWxzZTtcbiAgICAgIGNvbnN0IHAyciA9IHJldHJvTWFwW2FzcGVjdC5wMl9uYW1lXSA/PyByZXRyb01hcFthc3BlY3QucDJfZGlzcGxheV0gPz8gZmFsc2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hc3BlY3QsXG4gICAgICAgIHAxX3JldHJvZ3JhZGU6IHAxcixcbiAgICAgICAgcDJfcmV0cm9ncmFkZTogcDJyLFxuICAgICAgICByZXRyb2dyYWRlX2ludm9sdmVkOiBwMXIgfHwgcDJyXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIG9yYi1iYW5kIHRyYW5zaXQgdGFibGUgd2l0aCBwaGFzZSBhbmQgc2NvcmVcbiAgICBjb25zdCB0cmFuc2l0VGFibGUgPSBmb3JtYXRUcmFuc2l0VGFibGUoZW5yaWNoZWQuZmlsdGVyZWQsIHByZXZEYXlGaWx0ZXJlZCk7XG4gICAgXG4gICAgY29uc3QgYXNwZWN0c0ZvckFnZ3JlZ2F0ZSA9IGVucmljaGVkLmZpbHRlcmVkLm1hcCh4ID0+ICh7XG4gICAgICB0cmFuc2l0OiB7IGJvZHk6IHgucDFfbmFtZSwgcmV0cm9ncmFkZTogeC5wMV9yZXRyb2dyYWRlIH0sXG4gICAgICBuYXRhbDoge1xuICAgICAgICBib2R5OiB4LnAyX25hbWUsXG4gICAgICAgIHJldHJvZ3JhZGU6IHgucDJfcmV0cm9ncmFkZSxcbiAgICAgICAgaXNBbmdsZVByb3g6IFtcIkFzY2VuZGFudFwiLFwiTWVkaXVtX0NvZWxpXCIsXCJEZXNjZW5kYW50XCIsXCJJbXVtX0NvZWxpXCJdLmluY2x1ZGVzKHgucDJfbmFtZSksXG4gICAgICAgIGlzTHVtaW5hcnk6IFtcIlN1blwiLFwiTW9vblwiXS5pbmNsdWRlcyh4LnAyX25hbWUpLFxuICAgICAgICBkZWdDcml0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHR5cGU6IHguX2FzcGVjdCxcbiAgICAgIG9yYkRlZzogdHlwZW9mIHguX29yYiA9PT0gJ251bWJlcicgPyB4Ll9vcmIgOiA2LjAxXG4gICAgfSkpO1xuXG4gICAgLy8gUHJlcGFyZSByb2xsaW5nIGNvbnRleHQgZm9yIG1hZ25pdHVkZSBub3JtYWxpemF0aW9uXG4gICAgY29uc3Qgcm9sbGluZ0NvbnRleHQgPSByb2xsaW5nTWFnbml0dWRlcy5sZW5ndGggPj0gMSA/IHsgbWFnbml0dWRlczogWy4uLnJvbGxpbmdNYWduaXR1ZGVzXSB9IDogbnVsbDtcbiAgICBcbiAgY29uc3QgYWdnID0gYWdncmVnYXRlKGFzcGVjdHNGb3JBZ2dyZWdhdGUsIHByZXYsIHsgcm9sbGluZ0NvbnRleHQgfSk7XG5cbiAgLy8gRGV0ZXJtaW5lIHNjYWxpbmcgc3RyYXRlZ3kgYW5kIGNvbmZpZGVuY2VcbiAgbGV0IHNjYWxpbmdTdHJhdGVneSA9ICdwcmlvcic7XG4gIGNvbnN0IG5Db250ZXh0ID0gcm9sbGluZ01hZ25pdHVkZXMubGVuZ3RoO1xuICBpZiAobkNvbnRleHQgPj0gMTQpIHNjYWxpbmdTdHJhdGVneSA9ICdyb2xsaW5nJztcbiAgZWxzZSBpZiAobkNvbnRleHQgPj0gMikgc2NhbGluZ1N0cmF0ZWd5ID0gJ2JsZW5kZWQnO1xuICBjb25zdCBzY2FsZUNvbmZpZGVuY2UgPSBNYXRoLm1pbigxLCBuQ29udGV4dCAvIDE0KTtcbiAgICBcbiAgICAvLyBUcmFjayByb2xsaW5nIG1hZ25pdHVkZXMgdXNpbmcgdGhlIG9yaWdpbmFsIG1hZ25pdHVkZSBiZWZvcmUgbm9ybWFsaXphdGlvbiAoa2VlcCBsYXN0IDE0IGRheXMpXG4gICAgY29uc3QgbWFnbml0dWRlVG9UcmFjayA9IGFnZy5vcmlnaW5hbE1hZ25pdHVkZSB8fCBhZ2cucmF3TWFnbml0dWRlIHx8IGFnZy5tYWduaXR1ZGU7XG4gICAgcm9sbGluZ01hZ25pdHVkZXMucHVzaChtYWduaXR1ZGVUb1RyYWNrKTtcbiAgICBpZiAocm9sbGluZ01hZ25pdHVkZXMubGVuZ3RoID4gMTQpIHJvbGxpbmdNYWduaXR1ZGVzLnNoaWZ0KCk7XG4gICAgXG4gICAgLy8gVHJhY2sgdmFsZW5jZSBoaXN0b3J5IChrZWVwIGxhc3QgNyBkYXlzIGZvciB0cmVuZClcbiAgICB2YWxlbmNlSGlzdG9yeS5wdXNoKGFnZy52YWxlbmNlKTtcbiAgICBpZiAodmFsZW5jZUhpc3RvcnkubGVuZ3RoID4gNykgdmFsZW5jZUhpc3Rvcnkuc2hpZnQoKTtcbiAgICBcbiAgICAvLyBJZGVudGlmeSByZXRyb2dyYWRlIHJlY3Vyc2lvbiBhc3BlY3RzXG4gICAgY29uc3QgcmV0cm9ncmFkZUFzcGVjdHMgPSBlbnJpY2hlZFdpdGhSZXRyb2dyYWRlLmZpbHRlcihhID0+IGEucmV0cm9ncmFkZV9pbnZvbHZlZCk7XG4gICAgXG4gICAgLy8gRGlzcGVyc2lvbi1iYXNlZCB2b2xhdGlsaXR5IG92ZXJyaWRlIChzdGQgZGV2aWF0aW9uIG9mIGhvb2sgd2VpZ2h0cylcbiAgICBsZXQgZGlzcGVyc2lvblZvbCA9IDA7XG4gICAgaWYgKGVucmljaGVkLmhvb2tzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCB3ZWlnaHRzID0gZW5yaWNoZWQuaG9va3MubWFwKGggPT4gaC5fd2VpZ2h0IHx8IDApO1xuICAgICAgY29uc3QgbWVhblcgPSB3ZWlnaHRzLnJlZHVjZSgocyx2KT0+cyt2LDApL3dlaWdodHMubGVuZ3RoO1xuICAgICAgY29uc3QgdmFyaWFuY2UgPSB3ZWlnaHRzLnJlZHVjZSgocyx2KT0+cytNYXRoLnBvdyh2LW1lYW5XLDIpLDApL3dlaWdodHMubGVuZ3RoO1xuICAgICAgZGlzcGVyc2lvblZvbCA9IE1hdGgubWluKDEwLCBNYXRoLnNxcnQodmFyaWFuY2UpICogMTApOyAvLyBzY2FsZVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIGNvbXBhY3QgZHJpdmVycyByZWZsZWN0aW5nIHRvcCBob29rc1xuICAgIGNvbnN0IGRyaXZlcnNDb21wYWN0ID0gKGVucmljaGVkLmhvb2tzIHx8IFtdKS5tYXAoaCA9PiAoe1xuICAgICAgYTogaC5wMV9uYW1lLFxuICAgICAgYjogaC5wMl9uYW1lLFxuICAgICAgdHlwZTogaC5fYXNwZWN0IHx8IGguYXNwZWN0IHx8IGgudHlwZSxcbiAgICAgIG9yYjogaC5fb3JiICE9IG51bGwgPyBoLl9vcmIgOiAodHlwZW9mIGgub3JiID09PSAnbnVtYmVyJyA/IGgub3JiIDogKHR5cGVvZiBoLm9yYml0ID09PSAnbnVtYmVyJyA/IGgub3JiaXQgOiBudWxsKSksXG4gICAgICBhcHBseWluZzogdHlwZW9mIGguYXBwbHlpbmcgPT09ICdib29sZWFuJyA/IGguYXBwbHlpbmcgOiB1bmRlZmluZWQsXG4gICAgICB3ZWlnaHQ6IHR5cGVvZiBoLl93ZWlnaHQgPT09ICdudW1iZXInID8gaC5fd2VpZ2h0IDogd2VpZ2h0QXNwZWN0KGgpLFxuICAgICAgLy8gY29tcGF0aWJpbGl0eSBmaWVsZHMgZm9yIGV4aXN0aW5nIGNvbXBvc2Vycy90ZW1wbGF0ZXNcbiAgICAgIHBsYW5ldDE6IGgucDFfbmFtZSxcbiAgICAgIHBsYW5ldDI6IGgucDJfbmFtZSxcbiAgICAgIG5hbWU6IGguX2FzcGVjdCB8fCBoLmFzcGVjdCB8fCBoLnR5cGUsXG4gICAgICBmaXJzdF9wbGFuZXQ6IGgucDFfbmFtZSxcbiAgICAgIHNlY29uZF9wbGFuZXQ6IGgucDJfbmFtZSxcbiAgICAgIGlzX3RyYW5zaXQ6IHRydWVcbiAgICB9KSk7XG5cbiAgICBjb25zdCBkYXlFbnRyeSA9IHtcbiAgICAgIHNlaXNtb2dyYXBoOiB7IFxuICAgICAgICBtYWduaXR1ZGU6IGFnZy5tYWduaXR1ZGUsIFxuICAgICAgICB2YWxlbmNlOiBhZ2cudmFsZW5jZSwgXG4gICAgICAgIHZvbGF0aWxpdHk6IGRpc3BlcnNpb25Wb2wsIC8vIHVzZSBkaXNwZXJzaW9uIG1lYXN1cmVcbiAgICAgICAgcmF3TWFnbml0dWRlOiBhZ2cucmF3TWFnbml0dWRlLFxuICAgICAgICBvcmlnaW5hbE1hZ25pdHVkZTogYWdnLm9yaWdpbmFsTWFnbml0dWRlLFxuICAgICAgICBzY2FsaW5nX3N0cmF0ZWd5OiBzY2FsaW5nU3RyYXRlZ3ksXG4gICAgICAgIHNjYWxpbmdfY29uZmlkZW5jZTogK3NjYWxlQ29uZmlkZW5jZS50b0ZpeGVkKDIpXG4gICAgICB9LFxuICAgICAgYXNwZWN0czogcmF3RGF5QXNwZWN0cyxcbiAgICAgIGZpbHRlcmVkX2FzcGVjdHM6IGVucmljaGVkV2l0aFJldHJvZ3JhZGUsXG4gICAgICAvLyBLZWVwIGxlZ2FjeSAnaG9va3MnIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OyBhZGQgbm9ybWFsaXplZCAnZHJpdmVycydcbiAgICAgIGhvb2tzOiBlbnJpY2hlZC5ob29rcyxcbiAgICAgIGRyaXZlcnM6IGRyaXZlcnNDb21wYWN0LFxuICAgICAgcmVqZWN0aW9uczogZW5yaWNoZWQucmVqZWN0aW9ucyxcbiAgICAgIGNvdW50czogZW5yaWNoZWQuY291bnRzLFxuICAgICAgdHJhbnNpdF90YWJsZTogdHJhbnNpdFRhYmxlLFxuICAgICAgcmV0cm9ncmFkZV9hc3BlY3RzOiByZXRyb2dyYWRlQXNwZWN0cyxcbiAgICAgIHZhbGVuY2VfdHJlbmQ6IHZhbGVuY2VIaXN0b3J5Lmxlbmd0aCA+IDEgPyBjYWxjdWxhdGVUcmVuZCh2YWxlbmNlSGlzdG9yeSkgOiAwXG4gICAgfTtcblxuICAgIC8vIEJhbGFuY2UvU0ZEIGNvbXB1dGF0aW9uIChhbHdheXMgb24gaW4gV00tQ2hhcnQtMS4yKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYWxhbmNlVmFsID0gY29tcHV0ZUJhbGFuY2VWYWxlbmNlKGVucmljaGVkLmZpbHRlcmVkKTtcbiAgICAgIGNvbnN0IHsgU0ZELCBTcGx1cywgU21pbnVzIH0gPSBjb21wdXRlU0ZEKGVucmljaGVkLmZpbHRlcmVkKTtcbiAgICAgIGRheUVudHJ5LmJhbGFuY2UgPSB7IG1hZ25pdHVkZTogYWdnLm1hZ25pdHVkZSwgdmFsZW5jZTogYmFsYW5jZVZhbCwgdmVyc2lvbjogJ3YxLjEnIH07XG4gICAgICBkYXlFbnRyeS5zZmQgPSB7IHNmZDogU0ZELCBzUGx1czogU3BsdXMsIHNNaW51czogU21pbnVzLCB2ZXJzaW9uOiAndjEuMicgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIud2FybignQmFsYW5jZS9TRkQgY29tcHV0YXRpb24gZmFpbGVkIGZvciBkYXknLCBkLCBlLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGRhaWx5W2RdID0gZGF5RW50cnk7XG4gICAgcHJldiA9IHsgc2NvcmVkOiBhZ2cuc2NvcmVkLCBZX2VmZmVjdGl2ZTogYWdnLnZhbGVuY2UgfTtcbiAgICBwcmV2RGF5RmlsdGVyZWQgPSBlbnJpY2hlZC5maWx0ZXJlZDtcbiAgfVxuXG4gIGNvbnN0IG51bURheXMgPSBkYXlzLmxlbmd0aDtcbiAgY29uc3QgWCA9IE9iamVjdC52YWx1ZXMoZGFpbHkpLnJlZHVjZSgocywgZCkgPT4gcyArIGQuc2Vpc21vZ3JhcGgubWFnbml0dWRlLCAwKSAvIG51bURheXM7XG4gIGNvbnN0IFkgPSBPYmplY3QudmFsdWVzKGRhaWx5KS5yZWR1Y2UoKHMsIGQpID0+IHMgKyBkLnNlaXNtb2dyYXBoLnZhbGVuY2UsIDApIC8gbnVtRGF5cztcbiAgY29uc3QgVkkgPSBPYmplY3QudmFsdWVzKGRhaWx5KS5yZWR1Y2UoKHMsIGQpID0+IHMgKyBkLnNlaXNtb2dyYXBoLnZvbGF0aWxpdHksIDApIC8gbnVtRGF5cztcbiAgY29uc3Qgc3VtbWFyeSA9IHsgbWFnbml0dWRlOiArWC50b0ZpeGVkKDIpLCB2YWxlbmNlOiArWS50b0ZpeGVkKDIpLCB2b2xhdGlsaXR5OiArVkkudG9GaXhlZCgyKSB9O1xuXG4gIHJldHVybiB7IGRhaWx5LCBzdW1tYXJ5IH07XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdmFsZW5jZSB0cmVuZFxuZnVuY3Rpb24gY2FsY3VsYXRlVHJlbmQodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIGNvbnN0IHJlY2VudCA9IHZhbHVlcy5zbGljZSgtMyk7IC8vIExhc3QgMyB2YWx1ZXMgZm9yIHRyZW5kXG4gIGlmIChyZWNlbnQubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIFxuICBsZXQgdHJlbmQgPSAwO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHJlY2VudC5sZW5ndGg7IGkrKykge1xuICAgIHRyZW5kICs9IHJlY2VudFtpXSAtIHJlY2VudFtpLTFdO1xuICB9XG4gIHJldHVybiArKHRyZW5kIC8gKHJlY2VudC5sZW5ndGggLSAxKSkudG9GaXhlZCgyKTtcbn1cblxuLy8gLS0tIENvbXBvc2l0ZSBoZWxwZXJzIC0tLVxuYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0ZShBLCBCLCBwYXNzID0ge30sIEgpIHtcbiAgdHJ5IHtcbiAgICBsb2dnZXIuZGVidWcoJ0NvbXB1dGluZyBjb21wb3NpdGUgZm9yIHN1YmplY3RzOicsIHsgXG4gICAgICBwZXJzb25BOiBBPy5uYW1lIHx8ICdVbmtub3duIEEnLCBcbiAgICAgIHBlcnNvbkI6IEI/Lm5hbWUgfHwgJ1Vua25vd24gQicgXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGZpcnN0X3N1YmplY3Q6IHN1YmplY3RUb0FQSShBLCBwYXNzKSxcbiAgICAgIHNlY29uZF9zdWJqZWN0OiBzdWJqZWN0VG9BUEkoQiwgcGFzcyksXG4gICAgICAuLi5wYXNzLFxuICAgIH07XG4gICAgXG4gIGNvbnN0IHIgPSBhd2FpdCBhcGlDYWxsV2l0aFJldHJ5KFxuICAgICAgQVBJX0VORFBPSU5UUy5DT01QT1NJVEVfQVNQRUNUUyxcbiAgICAgIHsgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnM6IEgsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpIH0sXG4gICAgICAnQ29tcG9zaXRlIGFzcGVjdHMnXG4gICAgKTtcbiAgLy8gUHJlZmVyIHRvcC1sZXZlbCBhc3BlY3RzIGlmIHByZXNlbnQsIGZhbGxiYWNrIHRvIGRhdGEuYXNwZWN0c1xuICBjb25zdCBkYXRhID0gc3RyaXBHcmFwaGljc0RlZXAoci5kYXRhIHx8IHt9KTtcbiAgY29uc3QgdG9wQXNwZWN0cyA9IEFycmF5LmlzQXJyYXkoci5hc3BlY3RzKSA/IHIuYXNwZWN0cyA6IChkYXRhLmFzcGVjdHMgfHwgW10pO1xuICBsb2dnZXIuZGVidWcoJ0NvbXBvc2l0ZSBjYWxjdWxhdGlvbiBzdWNjZXNzZnVsLCBhc3BlY3RzIGZvdW5kOicsIHRvcEFzcGVjdHMubGVuZ3RoKTtcbiAgcmV0dXJuIHsgYXNwZWN0czogdG9wQXNwZWN0cywgcmF3OiBkYXRhIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdDb21wb3NpdGUgY2FsY3VsYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvc2l0ZSBjYWxjdWxhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vLyAtLS0gUmVsYXRpb25hbCBQcm9jZXNzaW5nIEhlbHBlcnMgLS0tXG4vKipcbiAqIEdlbmVyYXRlIHBvbGFyaXR5IGNhcmRzIGZyb20gc3luYXN0cnkgYXNwZWN0cyBmb3IgcmVsYXRpb25hbCB0ZW5zaW9uIGFuYWx5c2lzXG4gKiBAcGFyYW0ge0FycmF5fSBzeW5hc3RyeUFzcGVjdHMgLSBDcm9zcy1jaGFydCBhc3BlY3RzIGJldHdlZW4gUGVyc29uIEEgYW5kIFBlcnNvbiBCXG4gKiBAcGFyYW0ge09iamVjdH0gcGVyc29uQSAtIFBlcnNvbiBBIGRldGFpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwZXJzb25CIC0gUGVyc29uIEIgZGV0YWlsc1xuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBwb2xhcml0eSBjYXJkIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQb2xhcml0eUNhcmRzKHN5bmFzdHJ5QXNwZWN0cywgcGVyc29uQSwgcGVyc29uQikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc3luYXN0cnlBc3BlY3RzKSB8fCBzeW5hc3RyeUFzcGVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcG9sYXJpdHlDYXJkcyA9IFtdO1xuICBjb25zdCBwcm9jZXNzZWRQYWlycyA9IG5ldyBTZXQoKTtcblxuICAvLyBGb2N1cyBvbiBtYWpvciB0ZW5zaW9uIGFzcGVjdHMgdGhhdCBjcmVhdGUgcG9sYXJpdHlcbiAgY29uc3QgdGVuc2lvbkFzcGVjdHMgPSBzeW5hc3RyeUFzcGVjdHMuZmlsdGVyKGFzcGVjdCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IChhc3BlY3QuYXNwZWN0IHx8IGFzcGVjdC50eXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBbJ29wcG9zaXRpb24nLCAnc3F1YXJlJywgJ2Nvbmp1bmN0aW9uJ10uaW5jbHVkZXModHlwZSk7XG4gIH0pO1xuXG4gIGZvciAoY29uc3QgYXNwZWN0IG9mIHRlbnNpb25Bc3BlY3RzKSB7XG4gICAgY29uc3QgcDEgPSBhc3BlY3QucDFfbmFtZSB8fCBhc3BlY3QuYSB8fCBhc3BlY3QuZmlyc3RfcG9pbnQgfHwgJyc7XG4gICAgY29uc3QgcDIgPSBhc3BlY3QucDJfbmFtZSB8fCBhc3BlY3QuYiB8fCBhc3BlY3Quc2Vjb25kX3BvaW50IHx8ICcnO1xuICAgIGNvbnN0IGFzcGVjdFR5cGUgPSBhc3BlY3QuYXNwZWN0IHx8IGFzcGVjdC50eXBlIHx8ICcnO1xuICAgIGNvbnN0IG9yYiA9IGFzcGVjdC5vcmIgfHwgYXNwZWN0Lm9yYml0IHx8IDA7XG5cbiAgICAvLyBDcmVhdGUgdW5pcXVlIHBhaXIgaWRlbnRpZmllciB0byBhdm9pZCBkdXBsaWNhdGVzXG4gICAgY29uc3QgcGFpcklkID0gW3AxLCBwMl0uc29ydCgpLmpvaW4oJy0nKTtcbiAgICBpZiAocHJvY2Vzc2VkUGFpcnMuaGFzKHBhaXJJZCkpIGNvbnRpbnVlO1xuICAgIHByb2Nlc3NlZFBhaXJzLmFkZChwYWlySWQpO1xuXG4gICAgLy8gR2VuZXJhdGUgcG9sYXJpdHkgY2FyZCBmb3Igc2lnbmlmaWNhbnQgYXNwZWN0cyAodGlnaHQgb3JicylcbiAgICBpZiAocGFyc2VGbG9hdChvcmIpIDw9IDYuMCkge1xuICAgICAgcG9sYXJpdHlDYXJkcy5wdXNoKHtcbiAgICAgICAgcG9sYXJpdHlfYTogYCR7cGVyc29uQS5uYW1lIHx8ICdQZXJzb24gQSd9J3MgJHtwMX1gLFxuICAgICAgICBwb2xhcml0eV9iOiBgJHtwZXJzb25CLm5hbWUgfHwgJ1BlcnNvbiBCJ30ncyAke3AyfWAsXG4gICAgICAgIGFzcGVjdF90eXBlOiBhc3BlY3RUeXBlLFxuICAgICAgICBvcmJfZGVncmVlczogcGFyc2VGbG9hdChvcmIpLFxuICAgICAgICBmaWVsZF9kZXNjcmlwdGlvbjogYCR7cDF9ICR7YXNwZWN0VHlwZX0gJHtwMn1gLFxuICAgICAgICBtYXBfcGF0dGVybjogYENyb3NzLWNoYXJ0ICR7YXNwZWN0VHlwZX0gY3JlYXRpbmcgcmVsYXRpb25hbCB0ZW5zaW9uYCxcbiAgICAgICAgdm9pY2Vfc3VtbWFyeTogYFBvbGFyaXR5IGJldHdlZW4gJHtwMX0gYW5kICR7cDJ9IGVuZXJnaWVzIGluIHRoZSByZWxhdGlvbnNoaXBgXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9sYXJpdHlDYXJkcy5zbGljZSgwLCAzKTsgLy8gTGltaXQgdG8gdG9wIDMgcG9sYXJpdHkgY2FyZHNcbn1cblxuLyoqXG4gKiBEZXRlY3QgZWNobyBsb29wcyBhbmQgUkVGIGN5Y2xlcyBmcm9tIHJlY3VycmluZyBjcm9zcy1jaGFydCBwYXR0ZXJuc1xuICogQHBhcmFtIHtBcnJheX0gc3luYXN0cnlBc3BlY3RzIC0gQ3Jvc3MtY2hhcnQgYXNwZWN0c1xuICogQHBhcmFtIHtBcnJheX0gbmF0YWxBc3BlY3RzQSAtIFBlcnNvbiBBJ3MgbmF0YWwgYXNwZWN0c1xuICogQHBhcmFtIHtBcnJheX0gbmF0YWxBc3BlY3RzQiAtIFBlcnNvbiBCJ3MgbmF0YWwgYXNwZWN0c1xuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlY2hvIGxvb3Agb2JqZWN0c1xuICovXG5mdW5jdGlvbiBkZXRlY3RFY2hvTG9vcHMoc3luYXN0cnlBc3BlY3RzLCBuYXRhbEFzcGVjdHNBLCBuYXRhbEFzcGVjdHNCKSB7XG4gIGNvbnN0IGVjaG9Mb29wcyA9IFtdO1xuICBcbiAgaWYgKCFBcnJheS5pc0FycmF5KHN5bmFzdHJ5QXNwZWN0cykpIHJldHVybiBlY2hvTG9vcHM7XG5cbiAgLy8gRmluZCByZWN1cnJpbmcgcGxhbmV0YXJ5IHBhdHRlcm5zIGFjcm9zcyBjaGFydHNcbiAgY29uc3QgcGxhbmV0UGFpcnMgPSB7fTtcbiAgXG4gIGZvciAoY29uc3QgYXNwZWN0IG9mIHN5bmFzdHJ5QXNwZWN0cykge1xuICAgIGNvbnN0IHAxID0gYXNwZWN0LnAxX25hbWUgfHwgYXNwZWN0LmEgfHwgJyc7XG4gICAgY29uc3QgcDIgPSBhc3BlY3QucDJfbmFtZSB8fCBhc3BlY3QuYiB8fCAnJztcbiAgICBjb25zdCB0eXBlID0gYXNwZWN0LmFzcGVjdCB8fCBhc3BlY3QudHlwZSB8fCAnJztcbiAgICBcbiAgICBjb25zdCBrZXkgPSBbcDEsIHAyXS5zb3J0KCkuam9pbignLScpO1xuICAgIGlmICghcGxhbmV0UGFpcnNba2V5XSkge1xuICAgICAgcGxhbmV0UGFpcnNba2V5XSA9IFtdO1xuICAgIH1cbiAgICBwbGFuZXRQYWlyc1trZXldLnB1c2goeyB0eXBlLCBvcmI6IGFzcGVjdC5vcmIgfHwgMCB9KTtcbiAgfVxuXG4gIC8vIElkZW50aWZ5IGVjaG8gbG9vcHMgd2hlcmUgdGhlIHNhbWUgcGxhbmV0YXJ5IHBhaXIgYXBwZWFycyBtdWx0aXBsZSB0aW1lc1xuICBmb3IgKGNvbnN0IFtwYWlyLCBhc3BlY3RzXSBvZiBPYmplY3QuZW50cmllcyhwbGFuZXRQYWlycykpIHtcbiAgICBpZiAoYXNwZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBbcGxhbmV0MSwgcGxhbmV0Ml0gPSBwYWlyLnNwbGl0KCctJyk7XG4gICAgICBlY2hvTG9vcHMucHVzaCh7XG4gICAgICAgIHBhdHRlcm5fdHlwZTogJ1JFRl9DWUNMRScsXG4gICAgICAgIHBsYW5ldHNfaW52b2x2ZWQ6IFtwbGFuZXQxLCBwbGFuZXQyXSxcbiAgICAgICAgb2NjdXJyZW5jZXM6IGFzcGVjdHMubGVuZ3RoLFxuICAgICAgICBhc3BlY3RzOiBhc3BlY3RzLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFJlY3VycmluZyAke3BsYW5ldDF9LSR7cGxhbmV0Mn0gZmVlZGJhY2sgbG9vcGAsXG4gICAgICAgIGludGVuc2l0eTogYXNwZWN0cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgKDYgLSBwYXJzZUZsb2F0KGEub3JiIHx8IDYpKSwgMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlY2hvTG9vcHMuc2xpY2UoMCwgNSk7IC8vIExpbWl0IHRvIHRvcCA1IGVjaG8gbG9vcHNcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBzaGFyZWQgU1NUIHRhZ3MgZm9yIGJvdGggcGFydGljaXBhbnRzIGluIHJlbGF0aW9uYWwgY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHBlcnNvbkEgLSBQZXJzb24gQSBkZXRhaWxzIGFuZCBjaGFydCBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gcGVyc29uQiAtIFBlcnNvbiBCIGRldGFpbHMgYW5kIGNoYXJ0IGRhdGEgIFxuICogQHBhcmFtIHtBcnJheX0gc3luYXN0cnlBc3BlY3RzIC0gQ3Jvc3MtY2hhcnQgYXNwZWN0c1xuICogQHJldHVybnMge09iamVjdH0gU1NUIHRhZ3MgZm9yIGJvdGggcGVyc29uc1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNoYXJlZFNTVFRhZ3MocGVyc29uQSwgcGVyc29uQiwgc3luYXN0cnlBc3BlY3RzKSB7XG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIFNTVCBpbXBsZW1lbnRhdGlvbiAtIGluIHByYWN0aWNlIHRoaXMgd291bGQgaW52b2x2ZVxuICAvLyBtb3JlIHNvcGhpc3RpY2F0ZWQgYW5hbHlzaXMgb2YgbGl2ZWQgcmVzb25hbmNlIHBhdHRlcm5zXG4gIFxuICBjb25zdCBzc3RUYWdzID0ge1xuICAgIHBlcnNvbl9hX3RhZ3M6IFtdLFxuICAgIHBlcnNvbl9iX3RhZ3M6IFtdLFxuICAgIHNoYXJlZF9yZXNvbmFuY2U6IFtdXG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgU1NUIHRhZ3MgZm9yIFBlcnNvbiBBXG4gIGlmIChwZXJzb25BLmFzcGVjdHMgJiYgQXJyYXkuaXNBcnJheShwZXJzb25BLmFzcGVjdHMpKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRBc3BlY3RzID0gcGVyc29uQS5hc3BlY3RzLmZpbHRlcihhID0+IFxuICAgICAgcGFyc2VGbG9hdChhLm9yYiB8fCA2KSA8PSAzLjBcbiAgICApLnNsaWNlKDAsIDMpO1xuICAgIFxuICAgIHNzdFRhZ3MucGVyc29uX2FfdGFncyA9IHNpZ25pZmljYW50QXNwZWN0cy5tYXAoYXNwZWN0ID0+ICh7XG4gICAgICB2ZWN0b3I6IGAke2FzcGVjdC5wMV9uYW1lIHx8IGFzcGVjdC5hfS0ke2FzcGVjdC5wMl9uYW1lIHx8IGFzcGVjdC5ifWAsXG4gICAgICB0YWc6ICdXQicsIC8vIERlZmF1bHQgdG8gV2l0aGluIEJvdW5kYXJ5IC0gd291bGQgbmVlZCB1c2VyIGZlZWRiYWNrIGluIHByYWN0aWNlXG4gICAgICBhc3BlY3RfdHlwZTogYXNwZWN0LmFzcGVjdCB8fCBhc3BlY3QudHlwZSxcbiAgICAgIG9yYjogYXNwZWN0Lm9yYlxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIFNTVCB0YWdzIGZvciBQZXJzb24gQiAgXG4gIGlmIChwZXJzb25CLmFzcGVjdHMgJiYgQXJyYXkuaXNBcnJheShwZXJzb25CLmFzcGVjdHMpKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRBc3BlY3RzID0gcGVyc29uQi5hc3BlY3RzLmZpbHRlcihhID0+IFxuICAgICAgcGFyc2VGbG9hdChhLm9yYiB8fCA2KSA8PSAzLjBcbiAgICApLnNsaWNlKDAsIDMpO1xuICAgIFxuICAgIHNzdFRhZ3MucGVyc29uX2JfdGFncyA9IHNpZ25pZmljYW50QXNwZWN0cy5tYXAoYXNwZWN0ID0+ICh7XG4gICAgICB2ZWN0b3I6IGAke2FzcGVjdC5wMV9uYW1lIHx8IGFzcGVjdC5hfS0ke2FzcGVjdC5wMl9uYW1lIHx8IGFzcGVjdC5ifWAsXG4gICAgICB0YWc6ICdXQicsIC8vIERlZmF1bHQgdG8gV2l0aGluIEJvdW5kYXJ5XG4gICAgICBhc3BlY3RfdHlwZTogYXNwZWN0LmFzcGVjdCB8fCBhc3BlY3QudHlwZSxcbiAgICAgIG9yYjogYXNwZWN0Lm9yYlxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHNoYXJlZCByZXNvbmFuY2UgZnJvbSBzeW5hc3RyeVxuICBpZiAoQXJyYXkuaXNBcnJheShzeW5hc3RyeUFzcGVjdHMpKSB7XG4gICAgY29uc3Qgc2hhcmVkQXNwZWN0cyA9IHN5bmFzdHJ5QXNwZWN0cy5maWx0ZXIoYSA9PiBcbiAgICAgIHBhcnNlRmxvYXQoYS5vcmIgfHwgNikgPD0gNC4wXG4gICAgKS5zbGljZSgwLCAzKTtcbiAgICBcbiAgICBzc3RUYWdzLnNoYXJlZF9yZXNvbmFuY2UgPSBzaGFyZWRBc3BlY3RzLm1hcChhc3BlY3QgPT4gKHtcbiAgICAgIHZlY3RvcjogYCR7YXNwZWN0LnAxX25hbWUgfHwgYXNwZWN0LmF94oaUJHthc3BlY3QucDJfbmFtZSB8fCBhc3BlY3QuYn1gLFxuICAgICAgdGFnOiAnV0InLCAvLyBEZWZhdWx0IHRvIFdpdGhpbiBCb3VuZGFyeVxuICAgICAgYXNwZWN0X3R5cGU6IGFzcGVjdC5hc3BlY3QgfHwgYXNwZWN0LnR5cGUsXG4gICAgICBvcmI6IGFzcGVjdC5vcmIsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Nyb3NzLWNoYXJ0IHJlc29uYW5jZSdcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gc3N0VGFncztcbn1cblxuLyoqXG4gKiBDb21wdXRlIHJlbGF0aW9uYWwgQmFsYW5jZSBNZXRlciBmb3IgdGhlIGJvbmQgaXRzZWxmIChub3QganVzdCBpbmRpdmlkdWFscylcbiAqIEBwYXJhbSB7QXJyYXl9IHN5bmFzdHJ5QXNwZWN0cyAtIENyb3NzLWNoYXJ0IGFzcGVjdHNcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvc2l0ZUFzcGVjdHMgLSBDb21wb3NpdGUgY2hhcnQgaW50ZXJuYWwgYXNwZWN0c1xuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvc2l0VHJhbnNpdHMgLSBDb21wb3NpdGUgdHJhbnNpdCBkYXRhIGJ5IGRhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlbGF0aW9uYWwgYmFsYW5jZSBtZXRlciBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVSZWxhdGlvbmFsQmFsYW5jZU1ldGVyKHN5bmFzdHJ5QXNwZWN0cywgY29tcG9zaXRlQXNwZWN0cywgY29tcG9zaXRlVHJhbnNpdHMpIHtcbiAgLy8gU2ltcGxpZmllZCByZWxhdGlvbmFsIGJhbGFuY2UgY2FsY3VsYXRpb25cbiAgLy8gSW4gcHJhY3RpY2UgdGhpcyB3b3VsZCB1c2UgdGhlIEJhbGFuY2UgTWV0ZXIgYWxnb3JpdGhtcyBhZGFwdGVkIGZvciByZWxhdGlvbmFsIGNvbnRleHRcbiAgXG4gIGxldCB0b3RhbFN1cHBvcnQgPSAwO1xuICBsZXQgdG90YWxGcmljdGlvbiA9IDA7XG4gIGxldCBhc3BlY3RDb3VudCA9IDA7XG5cbiAgLy8gQW5hbHl6ZSBzeW5hc3RyeSBhc3BlY3RzIGZvciByZWxhdGlvbmFsIHN1cHBvcnQvZnJpY3Rpb25cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3luYXN0cnlBc3BlY3RzKSkge1xuICAgIGZvciAoY29uc3QgYXNwZWN0IG9mIHN5bmFzdHJ5QXNwZWN0cykge1xuICAgICAgY29uc3QgdHlwZSA9IChhc3BlY3QuYXNwZWN0IHx8IGFzcGVjdC50eXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3Qgb3JiID0gcGFyc2VGbG9hdChhc3BlY3Qub3JiIHx8IDYpO1xuICAgICAgXG4gICAgICBhc3BlY3RDb3VudCsrO1xuICAgICAgXG4gICAgICAvLyBTdXBwb3J0aXZlIGFzcGVjdHNcbiAgICAgIGlmIChbJ3RyaW5lJywgJ3NleHRpbGUnLCAnY29uanVuY3Rpb24nXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICB0b3RhbFN1cHBvcnQgKz0gTWF0aC5tYXgoMCwgNiAtIG9yYikgLyA2OyAvLyBXZWlnaHQgYnkgdGlnaHRuZXNzXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZyaWN0aW9uIGFzcGVjdHMgIFxuICAgICAgaWYgKFsnc3F1YXJlJywgJ29wcG9zaXRpb24nXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICB0b3RhbEZyaWN0aW9uICs9IE1hdGgubWF4KDAsIDYgLSBvcmIpIC8gNjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgcmVsYXRpb25hbCBTRkQgKFN1cHBvcnQtRnJpY3Rpb24gRGlmZmVyZW50aWFsKVxuICBjb25zdCByZWxhdGlvbmFsU0ZEID0gYXNwZWN0Q291bnQgPiAwID8gXG4gICAgTWF0aC5yb3VuZCgodG90YWxTdXBwb3J0IC0gdG90YWxGcmljdGlvbikgKiAxMDApIC8gMTAwIDogMDtcblxuICAvLyBEZXRlcm1pbmUgcmVsYXRpb25hbCB2YWxlbmNlXG4gIGxldCByZWxhdGlvbmFsVmFsZW5jZSA9ICfwn4yXJzsgLy8gRGVmYXVsdCB0byBtaXhlZFxuICBpZiAocmVsYXRpb25hbFNGRCA+IDEuMCkgcmVsYXRpb25hbFZhbGVuY2UgPSAn8J+Mnic7XG4gIGVsc2UgaWYgKHJlbGF0aW9uYWxTRkQgPCAtMS4wKSByZWxhdGlvbmFsVmFsZW5jZSA9ICfwn4yRJztcblxuICAvLyBDYWxjdWxhdGUgbWFnbml0dWRlIGJhc2VkIG9uIHRvdGFsIGFzcGVjdCBpbnRlbnNpdHlcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5taW4oNSwgTWF0aC5tYXgoMCwgKHRvdGFsU3VwcG9ydCArIHRvdGFsRnJpY3Rpb24pICogMikpO1xuXG4gIHJldHVybiB7XG4gICAgcmVsYXRpb25hbF9zZmQ6IHJlbGF0aW9uYWxTRkQsXG4gICAgcmVsYXRpb25hbF9tYWduaXR1ZGU6IE1hdGgucm91bmQobWFnbml0dWRlICogMTAwKSAvIDEwMCxcbiAgICByZWxhdGlvbmFsX3ZhbGVuY2U6IHJlbGF0aW9uYWxWYWxlbmNlLFxuICAgIHN1cHBvcnRfc2NvcmU6IE1hdGgucm91bmQodG90YWxTdXBwb3J0ICogMTAwKSAvIDEwMCxcbiAgICBmcmljdGlvbl9zY29yZTogTWF0aC5yb3VuZCh0b3RhbEZyaWN0aW9uICogMTAwKSAvIDEwMCxcbiAgICBhc3BlY3RfY291bnQ6IGFzcGVjdENvdW50LFxuICAgIGNsaW1hdGVfZGVzY3JpcHRpb246IGBSZWxhdGlvbmFsIGZpZWxkIHNob3dpbmcgJHtyZWxhdGlvbmFsVmFsZW5jZX0gZHluYW1pYyB3aXRoICR7bWFnbml0dWRlLnRvRml4ZWQoMSl9IGludGVuc2l0eWBcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB2ZWN0b3ItaW50ZWdyaXR5IHRhZ3MgZm9yIGxhdGVudC9zdXBwcmVzc2VkL2Rvcm1hbnQgcmVsYXRpb25hbCB2ZWN0b3JzXG4gKiBAcGFyYW0ge0FycmF5fSBzeW5hc3RyeUFzcGVjdHMgLSBDcm9zcy1jaGFydCBhc3BlY3RzXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb3NpdGVBc3BlY3RzIC0gQ29tcG9zaXRlIGNoYXJ0IGFzcGVjdHNcbiAqIEByZXR1cm5zIHtBcnJheX0gVmVjdG9yIGludGVncml0eSB0YWdzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVmVjdG9ySW50ZWdyaXR5VGFncyhzeW5hc3RyeUFzcGVjdHMsIGNvbXBvc2l0ZUFzcGVjdHMpIHtcbiAgY29uc3QgdmVjdG9yVGFncyA9IFtdO1xuICBcbiAgLy8gTG9vayBmb3Igd2lkZSBvcmIgYXNwZWN0cyB0aGF0IGFyZSBzdHJ1Y3R1cmFsbHkgcHJlc2VudCBidXQgYmVoYXZpb3JhbGx5IHF1aWV0XG4gIGNvbnN0IHdpZGVBc3BlY3RzID0gW107XG4gIFxuICBpZiAoQXJyYXkuaXNBcnJheShzeW5hc3RyeUFzcGVjdHMpKSB7XG4gICAgd2lkZUFzcGVjdHMucHVzaCguLi5zeW5hc3RyeUFzcGVjdHMuZmlsdGVyKGEgPT4ge1xuICAgICAgY29uc3Qgb3JiID0gcGFyc2VGbG9hdChhLm9yYiB8fCAwKTtcbiAgICAgIHJldHVybiBvcmIgPiA0LjAgJiYgb3JiIDw9IDguMDsgLy8gV2lkZSBidXQgc3RpbGwgd2l0aGluIHJhbmdlXG4gICAgfSkpO1xuICB9XG4gIFxuICBpZiAoQXJyYXkuaXNBcnJheShjb21wb3NpdGVBc3BlY3RzKSkge1xuICAgIHdpZGVBc3BlY3RzLnB1c2goLi4uY29tcG9zaXRlQXNwZWN0cy5maWx0ZXIoYSA9PiB7XG4gICAgICBjb25zdCBvcmIgPSBwYXJzZUZsb2F0KGEub3JiIHx8IDApO1xuICAgICAgcmV0dXJuIG9yYiA+IDQuMCAmJiBvcmIgPD0gOC4wO1xuICAgIH0pKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgYXNwZWN0IG9mIHdpZGVBc3BlY3RzLnNsaWNlKDAsIDMpKSB7XG4gICAgY29uc3QgcDEgPSBhc3BlY3QucDFfbmFtZSB8fCBhc3BlY3QuYSB8fCAnJztcbiAgICBjb25zdCBwMiA9IGFzcGVjdC5wMl9uYW1lIHx8IGFzcGVjdC5iIHx8ICcnO1xuICAgIGNvbnN0IHR5cGUgPSBhc3BlY3QuYXNwZWN0IHx8IGFzcGVjdC50eXBlIHx8ICcnO1xuICAgIGNvbnN0IG9yYiA9IHBhcnNlRmxvYXQoYXNwZWN0Lm9yYiB8fCAwKTtcbiAgICBcbiAgICBsZXQgc3RhdHVzID0gJ0xBVEVOVCc7XG4gICAgbGV0IGRlc2NyaXB0aW9uID0gJ3N0cnVjdHVyYWwgcHJlc2VuY2UgYnV0IGNvbnRhaW5lZC93YWl0aW5nJztcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgdmVjdG9yIHN0YXR1cyBiYXNlZCBvbiBwbGFuZXRzIGFuZCBhc3BlY3QgdHlwZVxuICAgIGlmIChbJ1NhdHVybicsICdQbHV0bycsICdOZXB0dW5lJ10uaW5jbHVkZXMocDEpIHx8IFsnU2F0dXJuJywgJ1BsdXRvJywgJ05lcHR1bmUnXS5pbmNsdWRlcyhwMikpIHtcbiAgICAgIHN0YXR1cyA9ICdET1JNQU5UJztcbiAgICAgIGRlc2NyaXB0aW9uID0gJ3dhaXRpbmcgZm9yIHNwZWNpZmljIGFjdGl2YXRpb24gdGltaW5nJztcbiAgICB9IGVsc2UgaWYgKG9yYiA+IDYuMCkge1xuICAgICAgc3RhdHVzID0gJ1NVUFBSRVNTRUQnOyAgXG4gICAgICBkZXNjcmlwdGlvbiA9ICdib3VuZGFyaWVzIGZvcnRpZmllZC9jb21wZW5zYXRlZCBieSBvdGhlciBwbGFjZW1lbnRzJztcbiAgICB9XG5cbiAgICB2ZWN0b3JUYWdzLnB1c2goe1xuICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICB2ZWN0b3JfbmFtZTogYCR7cDF9LSR7cDJ9ICR7dHlwZX1gLFxuICAgICAgb3JiX2RlZ3JlZXM6IG9yYixcbiAgICAgIHN0cnVjdHVyYWxfcHJlc2VuY2U6IHRydWUsXG4gICAgICBiZWhhdmlvcmFsX2FjdGl2aXR5OiAnY29udGFpbmVkJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZlY3RvclRhZ3M7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgY29tcHJlaGVuc2l2ZSByZWxhdGlvbmFsIG1pcnJvciBzdHJ1Y3R1cmUgd2l0aCBhbGwgbWlzc2luZyBlbGVtZW50c1xuICogQHBhcmFtIHtPYmplY3R9IHBlcnNvbkEgLSBQZXJzb24gQSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gcGVyc29uQiAtIFBlcnNvbiBCIGRhdGEgIFxuICogQHBhcmFtIHtBcnJheX0gc3luYXN0cnlBc3BlY3RzIC0gQ3Jvc3MtY2hhcnQgYXNwZWN0c1xuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvc2l0ZSAtIENvbXBvc2l0ZSBjaGFydCBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcG9zaXRUcmFuc2l0cyAtIENvbXBvc2l0ZSB0cmFuc2l0IGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvbXBsZXRlIHJlbGF0aW9uYWwgbWlycm9yIHN0cnVjdHVyZVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJlbGF0aW9uYWxNaXJyb3IocGVyc29uQSwgcGVyc29uQiwgc3luYXN0cnlBc3BlY3RzLCBjb21wb3NpdGUsIGNvbXBvc2l0ZVRyYW5zaXRzKSB7XG4gIGxvZ2dlci5kZWJ1ZygnR2VuZXJhdGluZyBjb21wcmVoZW5zaXZlIHJlbGF0aW9uYWwgbWlycm9yIHN0cnVjdHVyZScpO1xuICBcbiAgLy8gR2VuZXJhdGUgYWxsIG1pc3NpbmcgcmVsYXRpb25hbCBlbGVtZW50c1xuICBjb25zdCBwb2xhcml0eUNhcmRzID0gZ2VuZXJhdGVQb2xhcml0eUNhcmRzKHN5bmFzdHJ5QXNwZWN0cywgcGVyc29uQSwgcGVyc29uQik7XG4gIGNvbnN0IGVjaG9Mb29wcyA9IGRldGVjdEVjaG9Mb29wcyhzeW5hc3RyeUFzcGVjdHMsIHBlcnNvbkEuYXNwZWN0cywgcGVyc29uQi5hc3BlY3RzKTtcbiAgY29uc3Qgc3N0VGFncyA9IGdlbmVyYXRlU2hhcmVkU1NUVGFncyhwZXJzb25BLCBwZXJzb25CLCBzeW5hc3RyeUFzcGVjdHMpO1xuICBjb25zdCByZWxhdGlvbmFsQmFsYW5jZU1ldGVyID0gY29tcHV0ZVJlbGF0aW9uYWxCYWxhbmNlTWV0ZXIoXG4gICAgc3luYXN0cnlBc3BlY3RzLCBcbiAgICBjb21wb3NpdGUuYXNwZWN0cywgXG4gICAgY29tcG9zaXRlVHJhbnNpdHNcbiAgKTtcbiAgY29uc3QgdmVjdG9ySW50ZWdyaXR5VGFncyA9IGdlbmVyYXRlVmVjdG9ySW50ZWdyaXR5VGFncyhzeW5hc3RyeUFzcGVjdHMsIGNvbXBvc2l0ZS5hc3BlY3RzKTtcblxuICAvLyBHZW5lcmF0ZSBNaXJyb3IgVm9pY2UgZm9yIHRoZSByZWxhdGlvbnNoaXBcbiAgY29uc3QgbWlycm9yVm9pY2UgPSB7XG4gICAgcmVsYXRpb25zaGlwX2NsaW1hdGU6IGAke3JlbGF0aW9uYWxCYWxhbmNlTWV0ZXIuY2xpbWF0ZV9kZXNjcmlwdGlvbn1gLFxuICAgIHBvbGFyaXR5X3N1bW1hcnk6IHBvbGFyaXR5Q2FyZHMubGVuZ3RoID4gMCA/IFxuICAgICAgYCR7cG9sYXJpdHlDYXJkcy5sZW5ndGh9IHByaW1hcnkgcG9sYXJpdHkgdGVuc2lvbnMgaWRlbnRpZmllZGAgOiBcbiAgICAgICdObyBtYWpvciBwb2xhcml0eSB0ZW5zaW9ucyBkZXRlY3RlZCcsXG4gICAgZWNob19wYXR0ZXJuX3N1bW1hcnk6IGVjaG9Mb29wcy5sZW5ndGggPiAwID8gXG4gICAgICBgJHtlY2hvTG9vcHMubGVuZ3RofSByZWN1cnJpbmcgZmVlZGJhY2sgbG9vcHMgYWN0aXZlYCA6IFxuICAgICAgJ05vIHNpZ25pZmljYW50IGVjaG8gcGF0dGVybnMgZGV0ZWN0ZWQnLFxuICAgIHNoYXJlZF9maWVsZF9kZXNjcmlwdGlvbjogYFJlbGF0aW9uYWwgZmllbGQgd2l0aCAke3N5bmFzdHJ5QXNwZWN0cz8ubGVuZ3RoIHx8IDB9IGNyb3NzLWNoYXJ0IGNvbm5lY3Rpb25zYFxuICB9O1xuXG4gIC8vIFJlbG9jYXRpb24gbm90ZXMgKGJhc2ljIGltcGxlbWVudGF0aW9uIC0gd291bGQgbmVlZCBhY3R1YWwgcmVsb2NhdGlvbiBsb2dpYylcbiAgY29uc3QgcmVsb2NhdGlvbk5vdGVzID0ge1xuICAgIHJlbG9jYXRpb25fYXBwbGllZDogZmFsc2UsXG4gICAgaG91c2Vfc3lzdGVtOiAnUGxhY2lkdXMnLCAvLyBEZWZhdWx0XG4gICAgYW5nbGVzX3JlbG9jYXRlZDogZmFsc2UsXG4gICAgYmFzZWxpbmVfcmVtYWluc19uYXRhbDogdHJ1ZSxcbiAgICBkaXNjbG9zdXJlOiAnTm8gcmVsb2NhdGlvbiBhcHBsaWVkOyBhbGwgYW5nbGVzIGFuZCBob3VzZXMgcmVtYWluIG5hdGFsJ1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgcmVsYXRpb25hbF9taXJyb3I6IHtcbiAgICAgIHBvbGFyaXR5X2NhcmRzOiBwb2xhcml0eUNhcmRzLFxuICAgICAgZWNob19sb29wczogZWNob0xvb3BzLFxuICAgICAgc3N0X3RhZ3M6IHNzdFRhZ3MsXG4gICAgICByZWxhdGlvbmFsX2JhbGFuY2VfbWV0ZXI6IHJlbGF0aW9uYWxCYWxhbmNlTWV0ZXIsXG4gICAgICBtaXJyb3Jfdm9pY2U6IG1pcnJvclZvaWNlLFxuICAgICAgdmVjdG9yX2ludGVncml0eV90YWdzOiB2ZWN0b3JJbnRlZ3JpdHlUYWdzLFxuICAgICAgcmVsb2NhdGlvbl9ub3RlczogcmVsb2NhdGlvbk5vdGVzLFxuICAgICAgc2NhZmZvbGRpbmdfY29tcGxldGU6IHRydWUsXG4gICAgICBtaXJyb3JfdHlwZTogJ3RydWVfcmVsYXRpb25hbF9taXJyb3InXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgY29tcG9zaXRlIGNoYXJ0IHRyYW5zaXRzIHVzaW5nIHRoZSB0cmFuc2l0LWFzcGVjdHMtZGF0YSBlbmRwb2ludFxuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvc2l0ZVJhdyAtIFJhdyBjb21wb3NpdGUgY2hhcnQgZGF0YSAoZmlyc3Rfc3ViamVjdCBmcm9tIGNvbXBvc2l0ZSBjYWxjdWxhdGlvbilcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydCAtIFN0YXJ0IGRhdGUgKFlZWVktTU0tREQpXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kIC0gRW5kIGRhdGUgKFlZWVktTU0tREQpIFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ZXAgLSBTdGVwIHNpemUgKGRhaWx5LCB3ZWVrbHksIGV0YylcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXNzIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdGhyb3VnaFxuICogQHBhcmFtIHtPYmplY3R9IEggLSBIZWFkZXJzIGZvciBBUEkgcmVxdWVzdFxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggdHJhbnNpdHNCeURhdGUgYW5kIG9wdGlvbmFsIG5vdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0ZVRyYW5zaXRzKGNvbXBvc2l0ZVJhdywgc3RhcnQsIGVuZCwgc3RlcCwgcGFzcyA9IHt9LCBIKSB7XG4gIGlmICghY29tcG9zaXRlUmF3KSByZXR1cm4geyB0cmFuc2l0c0J5RGF0ZToge30gfTtcbiAgXG4gIGNvbnN0IHRyYW5zaXRzQnlEYXRlID0ge307XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0KTtcbiAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKGVuZCk7XG4gIGVuZERhdGUuc2V0RGF0ZShlbmREYXRlLmdldERhdGUoKSArIDEpOyAvLyBNYWtlIGVuZCBkYXRlIGluY2x1c2l2ZVxuXG4gIGNvbnN0IHByb21pc2VzID0gW107XG4gIFxuICAvLyBQcm9jZXNzIGVhY2ggZGF0ZSBpbiB0aGUgcmFuZ2VcbiAgZm9yIChsZXQgZCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7IGQgPCBlbmREYXRlOyBkLnNldERhdGUoZC5nZXREYXRlKCkgKyAxKSkge1xuICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBkLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICBcbiAgICAvLyBDcmVhdGUgdHJhbnNpdCBzdWJqZWN0IGZvciBjdXJyZW50IGRhdGUgKHRyYW5zaXRpbmcgcGxhbmV0cyBhdCBub29uIFVUQylcbiAgICBjb25zdCB0cmFuc2l0X3N1YmplY3QgPSB7XG4gICAgICB5ZWFyOiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgICBob3VyOiAxMixcbiAgICAgIG1pbnV0ZTogMCxcbiAgICAgIGNpdHk6IFwiR3JlZW53aWNoXCIsXG4gICAgICBuYXRpb246IFwiR0JcIixcbiAgICAgIGxhdGl0dWRlOiA1MS40OCxcbiAgICAgIGxvbmdpdHVkZTogMCxcbiAgICAgIHRpbWV6b25lOiBcIlVUQ1wiLFxuICAgICAgem9kaWFjX3R5cGU6IFwiVHJvcGljXCIgLy8gRml4OiBBZGQgbWlzc2luZyB6b2RpYWNfdHlwZSBmb3IgY29tcG9zaXRlIHRyYW5zaXRzXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBwYXlsb2FkIHdpdGggY29tcG9zaXRlIGNoYXJ0IGFzIGZpcnN0X3N1YmplY3QgYW5kIGN1cnJlbnQgZGF0ZSBhcyB0cmFuc2l0X3N1YmplY3RcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgZmlyc3Rfc3ViamVjdDogc3ViamVjdFRvQVBJKGNvbXBvc2l0ZVJhdywgcGFzcyksIC8vIFVzZSBjb21wb3NpdGUgY2hhcnQgYXMgdGhlIGJhc2UgY2hhcnRcbiAgICAgIHRyYW5zaXRfc3ViamVjdDogc3ViamVjdFRvQVBJKHRyYW5zaXRfc3ViamVjdCwgcGFzcyksIC8vIEN1cnJlbnQgdHJhbnNpdGluZyBwbGFuZXRzXG4gICAgICAuLi5wYXNzICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIH07XG5cbiAgICAvLyBFbmhhbmNlZCBkZWJ1ZyBsb2dnaW5nIGZvciBjb21wb3NpdGUgdHJhbnNpdHNcbiAgICBsb2dnZXIuZGVidWcoYENvbXBvc2l0ZSB0cmFuc2l0IEFQSSBjYWxsIGZvciAke2RhdGVTdHJpbmd9OmAsIHtcbiAgICAgIHBhc3Nfa2V5czogT2JqZWN0LmtleXMocGFzcyksXG4gICAgICBjb21wb3NpdGVfc3ViamVjdDogY29tcG9zaXRlUmF3Py5uYW1lIHx8ICdVbmtub3duIGNvbXBvc2l0ZSdcbiAgICB9KTtcbiAgICBsb2dnZXIuZGVidWcoYEZ1bGwgY29tcG9zaXRlIHRyYW5zaXQgQVBJIHBheWxvYWQgZm9yICR7ZGF0ZVN0cmluZ306YCwgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgbnVsbCwgMikpO1xuXG4gICAgcHJvbWlzZXMucHVzaChcbiAgICAgIGFwaUNhbGxXaXRoUmV0cnkoXG4gICAgICAgIEFQSV9FTkRQT0lOVFMuVFJBTlNJVF9BU1BFQ1RTLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogSCxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgfSxcbiAgICAgICAgYENvbXBvc2l0ZSB0cmFuc2l0cyBmb3IgJHtkYXRlU3RyaW5nfWBcbiAgICAgICkudGhlbihyZXNwID0+IHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb21wb3NpdGUgdHJhbnNpdCBBUEkgcmVzcG9uc2UgZm9yICR7ZGF0ZVN0cmluZ306YCwge1xuICAgICAgICAgIGhhc0FzcGVjdHM6ICEhKHJlc3AgJiYgcmVzcC5hc3BlY3RzKSxcbiAgICAgICAgICBhc3BlY3RDb3VudDogKHJlc3AgJiYgcmVzcC5hc3BlY3RzKSA/IHJlc3AuYXNwZWN0cy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3BvbnNlS2V5czogcmVzcCA/IE9iamVjdC5rZXlzKHJlc3ApIDogJ251bGwgcmVzcG9uc2UnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0b3JlIGFzcGVjdHMgZm9yIHRoaXMgZGF0ZSBpZiBhbnkgZXhpc3RcbiAgICAgICAgaWYgKHJlc3AuYXNwZWN0cyAmJiByZXNwLmFzcGVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRyYW5zaXRzQnlEYXRlW2RhdGVTdHJpbmddID0gcmVzcC5hc3BlY3RzO1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgU3RvcmVkICR7cmVzcC5hc3BlY3RzLmxlbmd0aH0gY29tcG9zaXRlIGFzcGVjdHMgZm9yICR7ZGF0ZVN0cmluZ31gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIGNvbXBvc2l0ZSBhc3BlY3RzIGZvdW5kIGZvciAke2RhdGVTdHJpbmd9IC0gcmVzcG9uc2Ugc3RydWN0dXJlOmAsIHJlc3ApO1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgRnVsbCByYXcgY29tcG9zaXRlIEFQSSByZXNwb25zZSBmb3IgJHtkYXRlU3RyaW5nfSAobm8gYXNwZWN0cyk6YCwgSlNPTi5zdHJpbmdpZnkocmVzcCwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byBnZXQgY29tcG9zaXRlIHRyYW5zaXRzIGZvciAke2RhdGVTdHJpbmd9OmAsIGUubWVzc2FnZSk7XG4gICAgICAgIC8vIENvbnRpbnVlIHByb2Nlc3Npbmcgb3RoZXIgZGF0ZXMgZXZlbiBpZiBvbmUgZmFpbHNcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gRXhlY3V0ZSBhbGwgQVBJIGNhbGxzIGluIHBhcmFsbGVsXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIFxuICAgIC8vIFJldHVybiByZXN1bHRzIHdpdGggcHJvcGVyIHN0cnVjdHVyZSBleHBlY3RlZCBieSBmcm9udGVuZFxuICAgIHJldHVybiB7IHRyYW5zaXRzQnlEYXRlIH07XG4gICAgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0NvbXBvc2l0ZSB0cmFuc2l0cyBjYWxjdWxhdGlvbiBmYWlsZWQ6JywgZSk7XG4gICAgcmV0dXJuIHsgXG4gICAgICB0cmFuc2l0c0J5RGF0ZToge30sIFxuICAgICAgX25vdGU6ICdDb21wb3NpdGUgdHJhbnNpdHMgbm90IGF2YWlsYWJsZSBpbiBjdXJyZW50IHBsYW4nIFxuICAgIH07XG4gIH1cbn1cblxuXG4vLyAtLS0gRXJyb3IgSUQgZ2VuZXJhdG9yIC0tLVxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcklkKCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBkYXRlID0gbm93LnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApLnJlcGxhY2UoLy0vZywgJycpO1xuICBjb25zdCB0aW1lID0gbm93LnRvVGltZVN0cmluZygpLnNsaWNlKDAsIDgpLnJlcGxhY2UoLzovZywgJycpO1xuICBjb25zdCByYW5kb20gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNCkudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIGBFUlItJHtkYXRlfS0ke3RpbWV9LSR7cmFuZG9tfWA7XG59XG5cblxuZXhwb3J0cy5oYW5kbGVyID0gYXN5bmMgZnVuY3Rpb24oZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoZXZlbnQuaHR0cE1ldGhvZCAhPT0gJ1BPU1QnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlOiA0MDUsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlcnJvcjogJ09ubHkgUE9TVCByZXF1ZXN0cyBhcmUgYWxsb3dlZC4nLFxuICAgICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX0FMTE9XRUQnLFxuICAgICAgICAgIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gSlNPTi5wYXJzZShldmVudC5ib2R5IHx8ICd7fScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBKU09OIGluIHJlcXVlc3QgYm9keS4nLFxuICAgICAgICAgIGNvZGU6ICdJTlZBTElEX0pTT04nLFxuICAgICAgICAgIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIC0tLSBERVYgTU9DSzogYWxsb3cgVUkgdmVyaWZpY2F0aW9uIHdpdGhvdXQgUmFwaWRBUEkga2V5IC0tLVxuICAgIGNvbnN0IHdhbnRNb2NrID0gKCFwcm9jZXNzLmVudi5SQVBJREFQSV9LRVkgfHwgcHJvY2Vzcy5lbnYuTUJfTU9DSyA9PT0gJ3RydWUnKSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuICAgIGlmICh3YW50TW9jaykge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgaXNvID0gdG9kYXkudG9JU09TdHJpbmcoKS5zbGljZSgwLDEwKTtcbiAgICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBTdHJpbmcoYm9keS5zdGFydERhdGUgfHwgYm9keS50cmFuc2l0U3RhcnREYXRlIHx8IGlzbyk7XG4gICAgICBjb25zdCBtb2NrID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBwcm92ZW5hbmNlOiB7IHNvdXJjZTogJ21vY2snLCBlbmdpbmU6ICdNYXRoQnJhaW4nLCB2ZXJzaW9uOiAnMC4wLWRldicgfSxcbiAgICAgICAgY29udGV4dDogeyBtb2RlOiBib2R5Py5jb250ZXh0Py5tb2RlIHx8ICdtaXJyb3InLCB0cmFuc2xvY2F0aW9uOiBib2R5Py50cmFuc2xvY2F0aW9uIHx8IHsgYXBwbGllczogZmFsc2UsIG1ldGhvZDogJ05hdGFsJyB9IH0sXG4gICAgICAgIHBlcnNvbl9hOiB7XG4gICAgICAgICAgbWV0YTogeyBiaXJ0aF90aW1lX2tub3duOiB0cnVlLCB0aW1lX3ByZWNpc2lvbjogJ2V4YWN0JywgaG91c2VzX3N1cHByZXNzZWQ6IGZhbHNlLCBlZmZlY3RpdmVfdGltZV91c2VkOiAnMTI6MDAnIH0sXG4gICAgICAgICAgZGV0YWlsczogYm9keS5wZXJzb25BIHx8IHt9LFxuICAgICAgICAgIGNoYXJ0OiB7IHRyYW5zaXRzQnlEYXRlOiB7IFtyYW5nZVN0YXJ0XTogW3sgcDFfbmFtZTogJ1N1bicsIHAyX25hbWU6ICdNYXJzJywgYXNwZWN0OiAnc3F1YXJlJywgb3JiOiAxLjIsIF9jbGFzczogJ21ham9yJyB9XSB9IH0sXG4gICAgICAgICAgZGVyaXZlZDogeyBzZWlzbW9ncmFwaF9zdW1tYXJ5OiB7IG1hZ25pdHVkZTogMi4zLCB2YWxlbmNlOiAwLjYsIHZvbGF0aWxpdHk6IDEuMSB9IH1cbiAgICAgICAgfSxcbiAgICAgICAgcGVyc29uX2I6IGJvZHkucGVyc29uQiA/IHsgZGV0YWlsczogYm9keS5wZXJzb25CLCBjaGFydDogeyB9IH0gOiB1bmRlZmluZWQsXG4gICAgICAgIHdvdmVuX21hcDogeyB0eXBlOiBib2R5LnBlcnNvbkIgPyAnZHlhZCcgOiAnc29sbycsIHNjaGVtYTogJ1dNLUNoYXJ0LTEuMicsIGhvb2tfc3RhY2s6IHsgdGllcl8xX29yYnM6IDIgfSB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogMjAwLCBib2R5OiBKU09OLnN0cmluZ2lmeShtb2NrKSB9O1xuICAgIH1cblxuICAvLyBJbnB1dHNcbiAgY29uc3QgcGVyc29uQSA9IG5vcm1hbGl6ZVN1YmplY3REYXRhKGJvZHkucGVyc29uQSB8fCBib2R5LnBlcnNvbl9hIHx8IGJvZHkuZmlyc3Rfc3ViamVjdCB8fCBib2R5LnN1YmplY3QpO1xuICAgIGNvbnN0IHBlcnNvbkIgPSBub3JtYWxpemVTdWJqZWN0RGF0YShib2R5LnBlcnNvbkIgfHwgYm9keS5wZXJzb25fYiB8fCBib2R5LnNlY29uZF9zdWJqZWN0KTtcbiAgICAvLyBVc2Ugc3RyaWN0IHZhbGlkYXRvciBmb3IgZnVsbCBjaGFydCBlbmRwb2ludHMsIGxlYW4gZm9yIGFzcGVjdHMtb25seVxuICAvLyBBY2NlcHQgbXVsdGlwbGUgd2F5cyBvZiBzcGVjaWZ5aW5nIG1vZGUsIGluY2x1ZGluZyBzYXZlZCBKU09OIHNoYXBlc1xuICBjb25zdCBtb2RlSGludCA9IGJvZHkuY29udGV4dD8ubW9kZSB8fCBib2R5Lm1vZGUgfHwgYm9keS5jb250ZXh0TW9kZT8ucmVsYXRpb25hbCB8fCBib2R5LmNvbnRleHRNb2RlPy5zb2xvIHx8ICcnO1xuICBjb25zdCBtb2RlVG9rZW4gPSBjYW5vbmljYWxpemVNb2RlKG1vZGVIaW50KTtcbiAgLy8gVGltZSBwb2xpY3k6IHJlYWQgZWFybHkgc28gd2UgY2FuIGFwcGx5IGZhbGxiYWNrIHRpbWUgYmVmb3JlIHZhbGlkYXRpb24gd2hlbiBiaXJ0aCB0aW1lIGlzIHVua25vd25cbiAgY29uc3QgdGltZVBvbGljeSA9IGNhbm9uaWNhbGl6ZVRpbWVQb2xpY3koYm9keS50aW1lX3BvbGljeSB8fCBib2R5LnRpbWVQb2xpY3kgfHwgYm9keS5iaXJ0aF90aW1lX3BvbGljeSk7XG4gICAgY29uc3Qgd2FudE5hdGFsQXNwZWN0c09ubHkgPSBtb2RlVG9rZW4gPT09ICdOQVRBTF9BU1BFQ1RTJyB8fCBldmVudC5wYXRoPy5pbmNsdWRlcygnbmF0YWwtYXNwZWN0cy1kYXRhJyk7XG4gICAgY29uc3Qgd2FudEJpcnRoRGF0YSA9IG1vZGVUb2tlbiA9PT0gJ0JJUlRIX0RBVEEnIHx8IGV2ZW50LnBhdGg/LmluY2x1ZGVzKCdiaXJ0aC1kYXRhJyk7XG4gICAgY29uc3Qgd2FudFN5bmFzdHJ5ID0gbW9kZVRva2VuID09PSAnU1lOQVNUUlknIHx8IG1vZGVUb2tlbiA9PT0gJ1NZTkFTVFJZX1RSQU5TSVRTJztcbiAgICBjb25zdCB3YW50U3luYXN0cnlBc3BlY3RzT25seSA9IG1vZGVUb2tlbiA9PT0gJ1NZTkFTVFJZX0FTUEVDVFMnIHx8IGV2ZW50LnBhdGg/LmluY2x1ZGVzKCdzeW5hc3RyeS1hc3BlY3RzLWRhdGEnKTtcbiAgICBjb25zdCB3YW50Q29tcG9zaXRlID0gbW9kZVRva2VuID09PSAnQ09NUE9TSVRFJyB8fCBtb2RlVG9rZW4gPT09ICdDT01QT1NJVEVfQVNQRUNUUycgfHwgbW9kZVRva2VuID09PSAnQ09NUE9TSVRFX1RSQU5TSVRTJyB8fCBib2R5LndhbnRDb21wb3NpdGUgPT09IHRydWU7XG4gICAgY29uc3Qgd2FudFNreVRyYW5zaXRzID0gbW9kZVRva2VuID09PSAnU0tZX1RSQU5TSVRTJyB8fCBtb2RlVG9rZW4gPT09ICdXRUFUSEVSJyB8fCBib2R5LmNvbnRleHQ/LnR5cGUgPT09ICd3ZWF0aGVyJztcbiAgY29uc3Qgd2FudEJhbGFuY2VNZXRlciA9IG1vZGVUb2tlbiA9PT0gJ0JBTEFOQ0VfTUVURVInIHx8IGJvZHkuY29udGV4dD8ubW9kZSA9PT0gJ2JhbGFuY2VfbWV0ZXInO1xuICBjb25zdCBpbmNsdWRlVHJhbnNpdFRhZyA9ICEhYm9keS5pbmNsdWRlVHJhbnNpdFRhZztcblxuICAgIC8vIC0tLSBSZWxhdGlvbnNoaXAgQ29udGV4dCBWYWxpZGF0aW9uIChQYXJ0bmVyIC8gRnJpZW5kIC8gRmFtaWx5KSAtLS1cbiAgICAvLyBDYW5vbmljYWwgZW51bWVyYXRpb25zIHN1cHBsaWVkIGJ5IHByb2R1Y3Qgc3BlY1xuICAgIGNvbnN0IFJFTF9QUklNQVJZID0gWydQQVJUTkVSJywnRlJJRU5EJywnRkFNSUxZJ107IC8vIEZSSUVORCBjb3ZlcnMgRnJpZW5kIC8gQ29sbGVhZ3VlXG4gICAgY29uc3QgUEFSVE5FUl9USUVSUyA9IFsnUDEnLCdQMicsJ1AzJywnUDQnLCdQNWEnLCdQNWInXTtcbiAgICBjb25zdCBGUklFTkRfUk9MRVMgPSBbJ0FjcXVhaW50YW5jZScsJ01lbnRvcicsJ090aGVyJywnQ3VzdG9tJ107XG4gICAgY29uc3QgRkFNSUxZX1JPTEVTID0gWydQYXJlbnQnLCdPZmZzcHJpbmcnLCdTaWJsaW5nJywnQ291c2luJywnRXh0ZW5kZWQnLCdHdWFyZGlhbicsJ01lbnRvcicsJ090aGVyJywnQ3VzdG9tJ107XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVSZWxUeXBlKHQpe1xuICAgICAgaWYoIXQpIHJldHVybiAnJztcbiAgICAgIGNvbnN0IHVwID0gdC50b1N0cmluZygpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVwLnN0YXJ0c1dpdGgoJ0ZSSUVORCcpKSByZXR1cm4gJ0ZSSUVORCc7XG4gICAgICBpZiAodXAgPT09ICdDT0xMRUFHVUUnIHx8IHVwLmluY2x1ZGVzKCdDT0xMRUFHVUUnKSkgcmV0dXJuICdGUklFTkQnO1xuICAgICAgaWYgKHVwLnN0YXJ0c1dpdGgoJ0ZBTUlMWScpKSByZXR1cm4gJ0ZBTUlMWSc7XG4gICAgICBpZiAodXAuc3RhcnRzV2l0aCgnUEFSVE5FUicpKSByZXR1cm4gJ1BBUlRORVInO1xuICAgICAgcmV0dXJuIHVwOyAvLyBmYWxsYmFjazsgd2lsbCB2YWxpZGF0ZSBsYXRlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUmVsYXRpb25zaGlwQ29udGV4dChyYXcsIGlzUmVsYXRpb25zaGlwTW9kZSl7XG4gICAgICBpZighaXNSZWxhdGlvbnNoaXBNb2RlKSByZXR1cm4geyB2YWxpZDogdHJ1ZSwgdmFsdWU6IG51bGwsIHJlYXNvbjogJ05vdCBpbiByZWxhdGlvbnNoaXAgbW9kZScgfTtcbiAgICAgIC8vIEFjY2VwdCBtdWx0aXBsZSBhbGlhc2VzIGluY2x1ZGluZyBzYXZlZCBjb25maWcgc2hhcGUgYHJlbGF0aW9uYWxDb250ZXh0YFxuICAgICAgY29uc3QgY3R4ID0gcmF3IHx8IGJvZHkucmVsYXRpb25zaGlwIHx8IGJvZHkucmVsYXRpb25zaGlwX2NvbnRleHQgfHwgYm9keS5yZWxhdGlvbnNoaXBDb250ZXh0IHx8IGJvZHkucmVsYXRpb25hbENvbnRleHQgfHwge307XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IGNsZWFuZWQgPSB7fTtcblxuICAgICAgY2xlYW5lZC50eXBlID0gbm9ybWFsaXplUmVsVHlwZShjdHgudHlwZSB8fCBjdHgucmVsYXRpb25zaGlwX3R5cGUgfHwgY3R4LmNhdGVnb3J5KTtcbiAgICAgIGlmKCFSRUxfUFJJTUFSWS5pbmNsdWRlcyhjbGVhbmVkLnR5cGUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKCdyZWxhdGlvbnNoaXAudHlwZSByZXF1aXJlZCAoUEFSVE5FUnxGUklFTkR8RkFNSUxZKScpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRpbWFjeSB0aWVyIHJlcXVpcmVtZW50IGZvciBQQVJUTkVSXG4gICAgICBpZiAoY2xlYW5lZC50eXBlID09PSAnUEFSVE5FUicpIHtcbiAgICAgICAgY2xlYW5lZC5pbnRpbWFjeV90aWVyID0gKGN0eC5pbnRpbWFjeV90aWVyIHx8IGN0eC50aWVyIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICBpZighUEFSVE5FUl9USUVSUy5pbmNsdWRlcyhjbGVhbmVkLmludGltYWN5X3RpZXIpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYGludGltYWN5X3RpZXIgcmVxdWlyZWQgZm9yIFBBUlRORVIgKG9uZSBvZiAke1BBUlRORVJfVElFUlMuam9pbignLCcpfSlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSb2xlIHJlcXVpcmVtZW50IGZvciBGQU1JTFk7IG9wdGlvbmFsIGZvciBGUklFTkRcbiAgICAgIGlmIChjbGVhbmVkLnR5cGUgPT09ICdGQU1JTFknKSB7XG4gICAgICAgIC8vIEFjY2VwdCByZWxhdGlvbnNoaXBfcm9sZSBhbGlhczsgbm9ybWFsaXplIGNhc2UgKGUuZy4sIFwicGFyZW50XCIgLT4gXCJQYXJlbnRcIilcbiAgICAgICAgY29uc3Qgcm9sZVJhdyA9IChjdHgucm9sZSB8fCBjdHguZmFtaWx5X3JvbGUgfHwgY3R4LnJlbGF0aW9uc2hpcF9yb2xlIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCByb2xlQ2Fub24gPSByb2xlUmF3ID8gcm9sZVJhdy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJvbGVSYXcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICBjbGVhbmVkLnJvbGUgPSByb2xlQ2Fub247XG4gICAgICAgIGlmKCFGQU1JTFlfUk9MRVMuaW5jbHVkZXMoY2xlYW5lZC5yb2xlKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGByb2xlIHJlcXVpcmVkIGZvciBGQU1JTFkgKG9uZSBvZiAke0ZBTUlMWV9ST0xFUy5qb2luKCcsJyl9KWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNsZWFuZWQudHlwZSA9PT0gJ0ZSSUVORCcpIHtcbiAgICAgICAgY29uc3Qgcm9sZVJhdyA9IChjdHgucm9sZSB8fCBjdHguZnJpZW5kX3JvbGUgfHwgY3R4LnJlbGF0aW9uc2hpcF9yb2xlIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCByb2xlQ2Fub24gPSByb2xlUmF3ID8gcm9sZVJhdy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJvbGVSYXcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICBjbGVhbmVkLnJvbGUgPSByb2xlQ2Fub247XG4gICAgICAgIGlmIChjbGVhbmVkLnJvbGUgJiYgIUZSSUVORF9ST0xFUy5pbmNsdWRlcyhjbGVhbmVkLnJvbGUpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYGZyaWVuZCByb2xlIGludmFsaWQgKG9wdGlvbmFsLCBvbmUgb2YgJHtGUklFTkRfUk9MRVMuam9pbignLCcpfSlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFeCAvIEVzdHJhbmdlZCBmbGFnIG9ubHkgZm9yIFBBUlRORVIgb3IgRkFNSUxZXG4gICAgICBpZiAoY3R4LmV4X2VzdHJhbmdlZCAhPT0gdW5kZWZpbmVkIHx8IGN0eC5leCB8fCBjdHguZXN0cmFuZ2VkIHx8IGN0eC5pc19leF9yZWxhdGlvbnNoaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBmbGFnID0gQm9vbGVhbihjdHguZXhfZXN0cmFuZ2VkIHx8IGN0eC5leCB8fCBjdHguZXN0cmFuZ2VkIHx8IGN0eC5pc19leF9yZWxhdGlvbnNoaXApO1xuICAgICAgICBpZiAoY2xlYW5lZC50eXBlID09PSAnRlJJRU5EJykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKCdleF9lc3RyYW5nZWQgZmxhZyBub3QgYWxsb3dlZCBmb3IgRlJJRU5EJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW5lZC5leF9lc3RyYW5nZWQgPSBmbGFnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHgubm90ZXMpIGNsZWFuZWQubm90ZXMgPSAoY3R4Lm5vdGVzIHx8ICcnKS50b1N0cmluZygpLnNsaWNlKDAsIDUwMCk7XG5cbiAgICAgIGlmKGVycm9ycy5sZW5ndGgpIHJldHVybiB7IHZhbGlkOmZhbHNlLCBlcnJvcnMsIHZhbHVlOiBjbGVhbmVkIH07XG4gICAgICByZXR1cm4geyB2YWxpZDp0cnVlLCB2YWx1ZTogY2xlYW5lZCB9O1xuICAgIH1cblxuXG4gIC8vIEtlZXAgb3JpZ2luYWxzIGZvciBwcm92ZW5hbmNlL21ldGEgYmVmb3JlIGFwcGx5aW5nIGZhbGxiYWNrIGhvdXIvbWludXRlXG4gIGNvbnN0IHBlcnNvbkFPcmlnaW5hbCA9IHsgLi4ucGVyc29uQSB9O1xuICBjb25zdCBwZXJzb25CT3JpZ2luYWwgPSBwZXJzb25CICYmIE9iamVjdC5rZXlzKHBlcnNvbkIpLmxlbmd0aCA/IHsgLi4ucGVyc29uQiB9IDogbnVsbDtcblxuICAvLyBBcHBseSB0aW1lX3BvbGljeSBmYWxsYmFjayBmb3IgdW5rbm93biBiaXJ0aCB0aW1lIHRvIHNhdGlzZnkgQVBJIHZhbGlkYXRvcnMgd2hpbGUgcHJlc2VydmluZyBwcm92ZW5hbmNlXG4gICAgY29uc3QgYXBwbHlGYWxsYmFja1RpbWUgPSAocykgPT4ge1xuICAgICAgaWYgKCFzKSByZXR1cm4gcztcbiAgICAgIGNvbnN0IG1pc3NpbmcgPSBzLmhvdXIgPT0gbnVsbCB8fCBzLm1pbnV0ZSA9PSBudWxsO1xuICAgICAgaWYgKCFtaXNzaW5nKSByZXR1cm4gcztcbiAgICAgIGlmICh0aW1lUG9saWN5ID09PSAncGxhbmV0YXJ5X29ubHknIHx8IHRpbWVQb2xpY3kgPT09ICd3aG9sZV9zaWduJyB8fCB0aW1lUG9saWN5ID09PSAnc2Vuc2l0aXZpdHlfc2NhbicpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucywgaG91cjogMTIsIG1pbnV0ZTogMCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHBlcnNvbkEsIGFwcGx5RmFsbGJhY2tUaW1lKHBlcnNvbkEpKTtcbiAgICBPYmplY3QuYXNzaWduKHBlcnNvbkIsIGFwcGx5RmFsbGJhY2tUaW1lKHBlcnNvbkIpKTtcblxuICAgIGNvbnN0IHZBID0gKHdhbnROYXRhbEFzcGVjdHNPbmx5IHx8IHdhbnRCaXJ0aERhdGEpID8gdmFsaWRhdGVTdWJqZWN0TGVhbihwZXJzb25BKSA6IHZhbGlkYXRlU3ViamVjdChwZXJzb25BKTtcbiAgICBpZiAoIXZBLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVycm9yOiBgUHJpbWFyeSBzdWJqZWN0IHZhbGlkYXRpb24gZmFpbGVkOiAke3ZBLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUl9BJyxcbiAgICAgICAgICBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBSZWxhdGlvbnNoaXAgbW9kZSBzdHJpY3QgdmFsaWRhdGlvbiBmb3IgUGVyc29uIEIgKGZhaWwgbG91ZCwgbm8gc2lsZW50IGZhbGxiYWNrKVxuICAgIGNvbnN0IHJlbGF0aW9uc2hpcE1vZGUgPSB3YW50U3luYXN0cnkgfHwgd2FudFN5bmFzdHJ5QXNwZWN0c09ubHkgfHwgd2FudENvbXBvc2l0ZTtcbiAgICBcbiAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBCYWxhbmNlIE1ldGVyIGxvZ2ljIC0gUGFydCAxXG4gICAgbG9nZ2VyLmRlYnVnKCdCYWxhbmNlIE1ldGVyIGRlY2lzaW9uIHZhcmlhYmxlcyAoUGFydCAxKTonLCB7XG4gICAgICB3YW50QmFsYW5jZU1ldGVyLFxuICAgICAgbW9kZVRva2VuLFxuICAgICAgY29udGV4dE1vZGU6IGJvZHkuY29udGV4dD8ubW9kZSxcbiAgICAgIHJlbGF0aW9uc2hpcE1vZGUsXG4gICAgICB3YW50U3luYXN0cnksXG4gICAgICB3YW50U3luYXN0cnlBc3BlY3RzT25seSxcbiAgICAgIHdhbnRDb21wb3NpdGVcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgcGVyc29uQlN0cmljdFZhbGlkYXRpb24gPSB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcnM6IHsgcmVhc29uOiAnTm90IHJlcXVlc3RlZCcgfSB9O1xuICAgIC8vIFJlbGF0aW9uc2hpcCBjb250ZXh0IHZhbGlkYXRpb24gKG11c3QgcHJlY2VkZSBQZXJzb24gQiByZXF1aXJlbWVudHMgbWVzc2FnaW5nIHRvIGdpdmUgcHJlY2lzZSBmZWVkYmFjaylcbiAgICBjb25zdCByZWxDb250ZXh0VmFsaWRhdGlvbiA9IHZhbGlkYXRlUmVsYXRpb25zaGlwQ29udGV4dChib2R5LnJlbGF0aW9uc2hpcF9jb250ZXh0IHx8IGJvZHkucmVsYXRpb25zaGlwQ29udGV4dCwgcmVsYXRpb25zaGlwTW9kZSk7XG4gICAgaWYgKHJlbGF0aW9uc2hpcE1vZGUgJiYgIXJlbENvbnRleHRWYWxpZGF0aW9uLnZhbGlkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlcnJvcjogJ1JlbGF0aW9uc2hpcCBjb250ZXh0IGludmFsaWQnLFxuICAgICAgICAgIGNvZGU6ICdSRUxfQ09OVEVYVF9JTlZBTElEJyxcbiAgICAgICAgICBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSxcbiAgICAgICAgICBpc3N1ZXM6IHJlbENvbnRleHRWYWxpZGF0aW9uLmVycm9ycyB8fCBbXVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlbGF0aW9uc2hpcE1vZGUpIHtcbiAgICAgIC8vIEF1dG8tZmlsbCBkZWZhdWx0IHpvZGlhY190eXBlIGlmIG1pc3NpbmcgQkVGT1JFIHZhbGlkYXRpb24gdG8gcmVkdWNlIGZhbHNlIG5lZ2F0aXZlc1xuICAgICAgaWYgKCFwZXJzb25CLnpvZGlhY190eXBlKSBwZXJzb25CLnpvZGlhY190eXBlID0gJ1Ryb3BpYyc7XG4gICAgICBwZXJzb25CU3RyaWN0VmFsaWRhdGlvbiA9IHZhbGlkYXRlU3ViamVjdFN0cmljdFdpdGhNYXAocGVyc29uQik7XG4gICAgICBpZiAoIXBlcnNvbkJTdHJpY3RWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZXJyb3I6ICdTZWNvbmRhcnkgc3ViamVjdCB2YWxpZGF0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUl9CJyxcbiAgICAgICAgICAgIG1vZGU6IG1vZGVUb2tlbixcbiAgICAgICAgICAgIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpLFxuICAgICAgICAgICAgZmllbGRFcnJvcnM6IHBlcnNvbkJTdHJpY3RWYWxpZGF0aW9uLmVycm9yc1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gIC8vIEFjY2VwdCBib3RoIGxlZ2FjeSB0cmFuc2l0KiBmaWVsZHMgYW5kIGEgY29uc29saWRhdGVkIGJvZHkud2luZG93ID0geyBzdGFydCwgZW5kLCBzdGVwIH1cbiAgICBjb25zdCB3aW4gPSBib2R5LndpbmRvdyB8fCBib2R5LnRyYW5zaXRfd2luZG93IHx8IG51bGw7XG4gICAgY29uc3Qgc3RhcnQgPSAod2luICYmICh3aW4uc3RhcnQgfHwgd2luLnN0YXJ0RGF0ZSkpIHx8IGJvZHkuc3RhcnQgfHwgYm9keS5zdGFydERhdGUgfHwgYm9keS50cmFuc2l0U3RhcnREYXRlIHx8IGJvZHkudHJhbnNpdF9zdGFydF9kYXRlIHx8IGJvZHkudHJhbnNpdFBhcmFtcz8uc3RhcnREYXRlIHx8IGJvZHkudHJhbnNpdD8uc3RhcnREYXRlO1xuICAgIGNvbnN0IGVuZCAgID0gKHdpbiAmJiAod2luLmVuZCB8fCB3aW4uZW5kRGF0ZSkpICAgICB8fCBib2R5LmVuZCAgIHx8IGJvZHkuZW5kRGF0ZSAgIHx8IGJvZHkudHJhbnNpdEVuZERhdGUgICB8fCBib2R5LnRyYW5zaXRfZW5kX2RhdGUgICB8fCBib2R5LnRyYW5zaXRQYXJhbXM/LmVuZERhdGUgfHwgYm9keS50cmFuc2l0Py5lbmREYXRlO1xuICAgIGNvbnN0IHN0ZXAgID0gbm9ybWFsaXplU3RlcCgod2luICYmICh3aW4uc3RlcCB8fCB3aW4uaW50ZXJ2YWwpKSB8fCBib2R5LnN0ZXAgfHwgYm9keS5pbnRlcnZhbCB8fCBib2R5LnRyYW5zaXRTdGVwIHx8IGJvZHkudHJhbnNpdF9zdGVwIHx8IGJvZHkudHJhbnNpdFBhcmFtcz8uc3RlcCB8fCBib2R5LnRyYW5zaXQ/LnN0ZXApO1xuICAgIGNvbnN0IGhhdmVSYW5nZSA9IEJvb2xlYW4oc3RhcnQgJiYgZW5kKTtcbiAgICBcbiAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBCYWxhbmNlIE1ldGVyIGxvZ2ljIC0gUGFydCAyXG4gICAgbG9nZ2VyLmRlYnVnKCdCYWxhbmNlIE1ldGVyIGRlY2lzaW9uIHZhcmlhYmxlcyAoUGFydCAyKTonLCB7XG4gICAgICBoYXZlUmFuZ2UsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0pO1xuXG4gIGxldCBoZWFkZXJzO1xuICAgIHRyeSB7XG4gICAgICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZXJyb3I6IGUubWVzc2FnZSxcbiAgICAgICAgICBjb2RlOiAnQ09ORklHX0VSUk9SJyxcbiAgICAgICAgICBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFYXJseSBzYWZldHk6IExPQ0FUSU9OX1JFUVVJUkVEIHdoZW4gQmFsYW5jZSBNZXRlciAob3IgTWlycm9yK2NsaW1hdGUpIGxhY2tzIHRyYW5zaXQgbG9jYXRpb25cbiAgICBjb25zdCBoYXNMb2MgPSAocyk9PiBzICYmIHR5cGVvZiBzLmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygcy5sb25naXR1ZGUgPT09ICdudW1iZXInICYmICEhcy50aW1lem9uZTtcbiAgICAvLyBUcmFuc2l0IHN1YmplY3RzOiBhbGxvdyBleHBsaWNpdCB0cmFuc2l0X3N1YmplY3QsIGVsc2UgZGVmYXVsdCB0byBwZXJzb25BXG4gICAgY29uc3QgdHJhbnNpdEFfcmF3ID0gYm9keS50cmFuc2l0X3N1YmplY3QgfHwgcGVyc29uQTtcbiAgICBjb25zdCB0cmFuc2l0Ql9yYXcgPSBib2R5LnRyYW5zaXRfc3ViamVjdF9CIHx8IGJvZHkuc2Vjb25kX3RyYW5zaXRfc3ViamVjdCB8fCBwZXJzb25CO1xuXG4gICAgLy8gUmVsb2NhdGlvbiBtb2RlIChkYXRhLW9ubHkgaW50ZW50KVxuICBsZXQgcmVsb2NhdGlvbk1vZGUgPSAoYm9keS5yZWxvY2F0aW9uX21vZGUgfHwgYm9keS50cmFuc2xvY2F0aW9uPy5tZXRob2QgfHwgJ05vbmUnKTtcbiAgICBpZiAoL15taWRwb2ludCQvaS50ZXN0KHJlbG9jYXRpb25Nb2RlKSkge1xuICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNDAwLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvZGU6J1JFTE9DQVRJT05fVU5TVVBQT1JURUQnLCBlcnJvcjonTWlkcG9pbnQgcmVsb2NhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHByb3RvY29sLiBVc2UgQV9sb2NhbCBvciBCX2xvY2FsLicsIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpIH0pIH07XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCByZWxvY2F0aW9uIGludGVudFxuICAgIC8vIC0gRHlhZCArIEJhbGFuY2UgTWV0ZXI6IGRlZmF1bHQgdG8gQV9sb2NhbCB1bmxlc3MgZXhwbGljaXRseSBvdmVycmlkZGVuXG4gICAgLy8gLSBTb2xvIHdpdGggQV9sb2NhbCBwcmVzZW50OiBkZWZhdWx0IHRvIEFfbG9jYWxcbiAgICBjb25zdCBoYXNEeWFkID0gISEocGVyc29uQiAmJiBPYmplY3Qua2V5cyhwZXJzb25CKS5sZW5ndGgpO1xuICAgIGNvbnN0IGFMb2NhbCA9IGJvZHkucGVyc29uQT8uQV9sb2NhbCB8fCBib2R5LnN1YmplY3RBPy5BX2xvY2FsIHx8IG51bGw7XG4gICAgaWYgKChyZWxvY2F0aW9uTW9kZSA9PT0gJ05vbmUnIHx8IHJlbG9jYXRpb25Nb2RlID09PSAnTmF0YWwnKSAmJiB3YW50QmFsYW5jZU1ldGVyKSB7XG4gICAgICBpZiAoaGFzRHlhZCkgcmVsb2NhdGlvbk1vZGUgPSAnQV9sb2NhbCc7XG4gICAgICBlbHNlIGlmIChhTG9jYWwpIHJlbG9jYXRpb25Nb2RlID0gJ0FfbG9jYWwnO1xuICAgIH1cblxuICAgIGlmICh3YW50QmFsYW5jZU1ldGVyKSB7XG4gICAgICBpZiAoIWhhdmVSYW5nZSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonV0lORE9XX1JFUVVJUkVEJywgZXJyb3I6J0JhbGFuY2UgTWV0ZXIgcmVxdWlyZXMgYSB0aW1lIHdpbmRvdyAoc3RhcnQsIGVuZCwgc3RlcCknLCBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSB9KSB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY2l0eU1vZGVBID0gISEoYUxvY2FsPy5jaXR5ICYmIGFMb2NhbD8ubmF0aW9uKSB8fCAhIShwZXJzb25BPy5jaXR5ICYmIHBlcnNvbkE/Lm5hdGlvbik7XG4gICAgICBjb25zdCBjaXR5TW9kZUIgPSAhIShwZXJzb25CICYmICgoYm9keS5wZXJzb25CPy5CX2xvY2FsPy5jaXR5ICYmIGJvZHkucGVyc29uQj8uQl9sb2NhbD8ubmF0aW9uKSB8fCAocGVyc29uQi5jaXR5ICYmIHBlcnNvbkIubmF0aW9uKSkpO1xuICAgICAgaWYgKCFoYXNMb2ModHJhbnNpdEFfcmF3KSAmJiAhY2l0eU1vZGVBKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1c0NvZGU6IDQwMCwgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb2RlOidMT0NBVElPTl9SRVFVSVJFRCcsIGVycm9yOidCYWxhbmNlIE1ldGVyIHJlcXVpcmVzIGxvY2F0aW9uIChjb29yZHMgb3IgY2l0eS9uYXRpb24pIGZvciBBJywgZXJyb3JJZDogZ2VuZXJhdGVFcnJvcklkKCkgfSkgfTtcbiAgICAgIH1cbiAgICAgIGlmIChwZXJzb25CICYmIE9iamVjdC5rZXlzKHBlcnNvbkIpLmxlbmd0aCAmJiAhaGFzTG9jKHRyYW5zaXRCX3JhdyB8fCB7fSkgJiYgIWNpdHlNb2RlQikge1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonTE9DQVRJT05fUkVRVUlSRUQnLCBlcnJvcjonQmFsYW5jZSBNZXRlciBkeWFkIHJlcXVpcmVzIGxvY2F0aW9uIChjb29yZHMgb3IgY2l0eS9uYXRpb24pIGZvciBQZXJzb24gQicsIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpIH0pIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgobW9kZVRva2VuID09PSAnTUlSUk9SJyB8fCBib2R5LmNvbnRleHQ/Lm1vZGUgPT09ICdtaXJyb3InKSAmJiBpbmNsdWRlVHJhbnNpdFRhZykge1xuICAgICAgaWYgKCFoYXNMb2ModHJhbnNpdEFfcmF3KSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonTE9DQVRJT05fUkVRVUlSRUQnLCBlcnJvcjonTWlycm9yIHdpdGggQ2xpbWF0ZSBUYWcgcmVxdWlyZXMgbG9jYXRpb24nLCBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSB9KSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIEFQSS1zaGFwZWQgc3ViamVjdHMgbm93IHNvIHRpbWV6b25lIGNoZWNrcyBhcHBseSB0byBlZmZlY3RpdmUgdHJhbnNpdCBzdWJqZWN0c1xuICAgIGNvbnN0IG5hdGFsQSA9IHBlcnNvbkE7IC8vIGFscmVhZHkgbm9ybWFsaXplZFxuICAgIGNvbnN0IG5hdGFsQiA9IHBlcnNvbkIgJiYgT2JqZWN0LmtleXMocGVyc29uQikubGVuZ3RoID8gcGVyc29uQiA6IG51bGw7XG4gICAgbGV0IHRyYW5zaXRBID0geyAuLi50cmFuc2l0QV9yYXcgfTtcbiAgICBsZXQgdHJhbnNpdEIgPSB0cmFuc2l0Ql9yYXcgPyB7IC4uLnRyYW5zaXRCX3JhdyB9IDogKG5hdGFsQiA/IHsgLi4ubmF0YWxCIH0gOiBudWxsKTtcblxuICAgIC8vIEFwcGx5IHJlbG9jYXRpb24gbW9kZXNcbiAgICBpZiAocmVsb2NhdGlvbk1vZGUgPT09ICdNaWRwb2ludCcgJiYgdHJhbnNpdEIpIHtcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNpdEEubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0cmFuc2l0QS5sb25naXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0cmFuc2l0Qi5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRyYW5zaXRCLmxvbmdpdHVkZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNDAwLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvZGU6J0xPQ0FUSU9OX1JFUVVJUkVEJywgZXJyb3I6J01pZHBvaW50IHJlbG9jYXRpb24gcmVxdWlyZXMgY29vcmRzIGZvciBib3RoIHBlcnNvbnMnLCBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSB9KSB9O1xuICAgICAgfVxuICAgICAgY29uc3QgbWlkID0gKGZ1bmN0aW9uIG1pZHBvaW50Q29vcmRzKGxhdDEsIGxvbjEsIGxhdDIsIGxvbjIpe1xuICAgICAgICBjb25zdCB0b1JhZCA9IGQgPT4gZCAqIE1hdGguUEkgLyAxODA7IGNvbnN0IHRvRGVnID0gciA9PiByICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgY29uc3Qgz4YxID0gdG9SYWQobGF0MSksIM67MSA9IHRvUmFkKGxvbjEpOyBjb25zdCDPhjIgPSB0b1JhZChsYXQyKSwgzrsyID0gdG9SYWQobG9uMik7XG4gICAgICAgIGNvbnN0IHgxID0gTWF0aC5jb3Moz4YxKSAqIE1hdGguY29zKM67MSksIHkxID0gTWF0aC5jb3Moz4YxKSAqIE1hdGguc2luKM67MSksIHoxID0gTWF0aC5zaW4oz4YxKTtcbiAgICAgICAgY29uc3QgeDIgPSBNYXRoLmNvcyjPhjIpICogTWF0aC5jb3MozrsyKSwgeTIgPSBNYXRoLmNvcyjPhjIpICogTWF0aC5zaW4ozrsyKSwgejIgPSBNYXRoLnNpbijPhjIpO1xuICAgICAgICBjb25zdCB4bSA9ICh4MSt4MikvMiwgeW09KHkxK3kyKS8yLCB6bT0oejErejIpLzI7IGNvbnN0IM+GbSA9IE1hdGguYXRhbjIoem0sIE1hdGguc3FydCh4bSp4bSt5bSp5bSkpOyBjb25zdCDOu20gPSBNYXRoLmF0YW4yKHltLCB4bSk7XG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiB0b0RlZyjPhm0pLCBsb25naXR1ZGU6IHRvRGVnKM67bSkgfTtcbiAgICAgIH0pKHRyYW5zaXRBLmxhdGl0dWRlLCB0cmFuc2l0QS5sb25naXR1ZGUsIHRyYW5zaXRCLmxhdGl0dWRlLCB0cmFuc2l0Qi5sb25naXR1ZGUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHogPSByZXF1aXJlKCd0ei1sb29rdXAnKShtaWQubGF0aXR1ZGUsIG1pZC5sb25naXR1ZGUpO1xuICAgICAgICB0cmFuc2l0QSA9IHsgLi4udHJhbnNpdEEsIGxhdGl0dWRlOiBtaWQubGF0aXR1ZGUsIGxvbmdpdHVkZTogbWlkLmxvbmdpdHVkZSwgdGltZXpvbmU6IHR6IH07XG4gICAgICAgIHRyYW5zaXRCID0gdHJhbnNpdEIgPyB7IC4uLnRyYW5zaXRCLCBsYXRpdHVkZTogbWlkLmxhdGl0dWRlLCBsb25naXR1ZGU6IG1pZC5sb25naXR1ZGUsIHRpbWV6b25lOiB0eiB9IDogdHJhbnNpdEI7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNDIyLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvZGU6J0hPVVNFU19VTlNUQUJMRScsIGVycm9yOidNaWRwb2ludCB0aW1lem9uZSBsb29rdXAgZmFpbGVkOyB0cnkgY3VzdG9tIGxvY2F0aW9uJywgZXJyb3JJZDogZ2VuZXJhdGVFcnJvcklkKCkgfSkgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbG9jYXRpb25Nb2RlID09PSAnQV9sb2NhbCcpIHtcbiAgICAgIC8vIFJlbmRlciBhcy1pZiBhdCBBJ3MgbG9jYWwgdmVudWUgKGFuZCBtaXJyb3Igb250byBCIGlmIHByZXNlbnQpXG4gICAgICBjb25zdCBsb2MgPSBhTG9jYWwgfHwgYm9keS5jdXN0b21fbG9jYXRpb24gfHwgbnVsbDtcbiAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2MubGF0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbG9jLmxvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHogPSBsb2MudHogfHwgcmVxdWlyZSgndHotbG9va3VwJykobG9jLmxhdCwgbG9jLmxvbik7XG4gICAgICAgICAgICB0cmFuc2l0QSA9IHsgLi4udHJhbnNpdEEsIGxhdGl0dWRlOiBsb2MubGF0LCBsb25naXR1ZGU6IGxvYy5sb24sIHRpbWV6b25lOiB0eiB9O1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRCKSB0cmFuc2l0QiA9IHsgLi4udHJhbnNpdEIsIGxhdGl0dWRlOiBsb2MubGF0LCBsb25naXR1ZGU6IGxvYy5sb24sIHRpbWV6b25lOiB0eiB9O1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNDAwLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvZGU6J1RaX0xPT0tVUF9GQUlMJywgZXJyb3I6J0NvdWxkIG5vdCByZXNvbHZlIEFfbG9jYWwgdGltZXpvbmUnLCBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSB9KSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsb2MuY2l0eSAmJiBsb2MubmF0aW9uKSB7XG4gICAgICAgICAgLy8gQ2l0eS1iYXNlZCBBX2xvY2FsOiByZWx5IG9uIHRyYW5zaXRfc3ViamVjdCBjaXR5L25hdGlvbjsgZG8gbm90IGluamVjdCBjb29yZHNcbiAgICAgICAgICB0cmFuc2l0QSA9IHsgLi4udHJhbnNpdEEsIGNpdHk6IGxvYy5jaXR5LCBuYXRpb246IGxvYy5uYXRpb24gfTtcbiAgICAgICAgICBpZiAodHJhbnNpdEIpIHRyYW5zaXRCID0geyAuLi50cmFuc2l0QiwgY2l0eTogbG9jLmNpdHksIG5hdGlvbjogbG9jLm5hdGlvbiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWxvY2F0aW9uTW9kZSA9PT0gJ0JfbG9jYWwnKSB7XG4gICAgICBpZiAobmF0YWxCICYmIHRyYW5zaXRCICYmIGhhc0xvYyh0cmFuc2l0QikpIHtcbiAgICAgICAgLy8gbGVhdmUgYXMgcHJvdmlkZWRcbiAgICAgIH0gZWxzZSBpZiAobmF0YWxCKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1c0NvZGU6IDQwMCwgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjb2RlOidMT0NBVElPTl9SRVFVSVJFRCcsIGVycm9yOidCX2xvY2FsIHJlcXVpcmVzIGNvb3JkcyBmb3IgUGVyc29uIEInLCBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSB9KSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVsb2NhdGlvbk1vZGUgPT09ICdDdXN0b20nICYmIGJvZHkuY3VzdG9tX2xvY2F0aW9uKSB7XG4gICAgICBjb25zdCBjID0gYm9keS5jdXN0b21fbG9jYXRpb247XG4gICAgICBpZiAodHlwZW9mIGMubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjLmxvbmdpdHVkZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNDAwLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvZGU6J0xPQ0FUSU9OX1JFUVVJUkVEJywgZXJyb3I6J0N1c3RvbSByZWxvY2F0aW9uIHJlcXVpcmVzIGNvb3JkcycsIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpIH0pIH07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0eiA9IGMudGltZXpvbmUgfHwgcmVxdWlyZSgndHotbG9va3VwJykoYy5sYXRpdHVkZSwgYy5sb25naXR1ZGUpO1xuICAgICAgICB0cmFuc2l0QSA9IHsgLi4udHJhbnNpdEEsIGxhdGl0dWRlOiBjLmxhdGl0dWRlLCBsb25naXR1ZGU6IGMubG9uZ2l0dWRlLCB0aW1lem9uZTogdHogfTtcbiAgICAgICAgaWYgKHRyYW5zaXRCKSB0cmFuc2l0QiA9IHsgLi4udHJhbnNpdEIsIGxhdGl0dWRlOiBjLmxhdGl0dWRlLCBsb25naXR1ZGU6IGMubG9uZ2l0dWRlLCB0aW1lem9uZTogdHogfTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonVFpfTE9PS1VQX0ZBSUwnLCBlcnJvcjonQ291bGQgbm90IHJlc29sdmUgY3VzdG9tIHRpbWV6b25lJywgZXJyb3JJZDogZ2VuZXJhdGVFcnJvcklkKCkgfSkgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUWiBtaXNtYXRjaCBkZXRlY3Rpb24gZm9yIEEgKCtCIGlmIHByZXNlbnQpXG4gICAgdHJ5IHtcbiAgICAgIGlmIChoYXNMb2ModHJhbnNpdEEpKSB7XG4gICAgICAgIGNvbnN0IHR6ID0gcmVxdWlyZSgndHotbG9va3VwJykodHJhbnNpdEEubGF0aXR1ZGUsIHRyYW5zaXRBLmxvbmdpdHVkZSk7XG4gICAgICAgIGlmICh0cmFuc2l0QS50aW1lem9uZSAmJiB0cmFuc2l0QS50aW1lem9uZSAhPT0gdHopIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonVFpfTUlTTUFUQ0gnLCBlcnJvcjonUHJvdmlkZWQgdGltZXpvbmUgZG9lcyBub3QgbWF0Y2ggY29vcmRpbmF0ZXMnLCBzdWdnZXN0ZWRfdGltZXpvbmU6IHR6LCBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSB9KSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHJhbnNpdEEudGltZXpvbmUpIHRyYW5zaXRBLnRpbWV6b25lID0gdHo7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdEIgJiYgaGFzTG9jKHRyYW5zaXRCKSkge1xuICAgICAgICBjb25zdCB0ekIgPSByZXF1aXJlKCd0ei1sb29rdXAnKSh0cmFuc2l0Qi5sYXRpdHVkZSwgdHJhbnNpdEIubG9uZ2l0dWRlKTtcbiAgICAgICAgaWYgKHRyYW5zaXRCLnRpbWV6b25lICYmIHRyYW5zaXRCLnRpbWV6b25lICE9PSB0ekIpIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonVFpfTUlTTUFUQ0gnLCBlcnJvcjonUHJvdmlkZWQgdGltZXpvbmUgZm9yIFBlcnNvbiBCIGRvZXMgbm90IG1hdGNoIGNvb3JkaW5hdGVzJywgc3VnZ2VzdGVkX3RpbWV6b25lOiB0ekIsIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpIH0pIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFuc2l0Qi50aW1lem9uZSkgdHJhbnNpdEIudGltZXpvbmUgPSB0ekI7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBmYWxsIHRocm91Z2g7IGlmIHR6LWxvb2t1cCBmYWlsZWQgd2UgcmV0dXJuIGEgZ2VuZXJpY1xuICAgIH1cblxuICAgIC8vIEhpZ2gtbGF0aXR1ZGUgZ3VhcmRcbiAgICBjb25zdCB1bnN0YWJsZSA9IChsYXQpPT4gTWF0aC5hYnMoTnVtYmVyKGxhdCkpID49IDY2LjA7XG4gICAgaWYgKGhhc0xvYyh0cmFuc2l0QSkgJiYgdW5zdGFibGUodHJhbnNpdEEubGF0aXR1ZGUpKSB7XG4gICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MjIsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonSE9VU0VTX1VOU1RBQkxFJywgZXJyb3I6J0hvdXNlIG1hdGggbWF5IGJlIHVuc3RhYmxlIGF0IHRoaXMgbGF0aXR1ZGU7IGNvbnNpZGVyIHdob2xlLXNpZ24gb3IgZGlmZmVyZW50IGxvY2F0aW9uJywgZXJyb3JJZDogZ2VuZXJhdGVFcnJvcklkKCkgfSkgfTtcbiAgICB9XG4gICAgaWYgKHRyYW5zaXRCICYmIGhhc0xvYyh0cmFuc2l0QikgJiYgdW5zdGFibGUodHJhbnNpdEIubGF0aXR1ZGUpKSB7XG4gICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MjIsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY29kZTonSE9VU0VTX1VOU1RBQkxFJywgZXJyb3I6J0hvdXNlIG1hdGggbWF5IGJlIHVuc3RhYmxlIGZvciBQZXJzb24gQiBhdCB0aGlzIGxhdGl0dWRlOyBjb25zaWRlciB3aG9sZS1zaWduIG9yIGRpZmZlcmVudCBsb2NhdGlvbicsIGVycm9ySWQ6IGdlbmVyYXRlRXJyb3JJZCgpIH0pIH07XG4gICAgfVxuXG4gIC8vIHRpbWVQb2xpY3kgaXMgYWxyZWFkeSBkZXRlcm1pbmVkIGVhcmxpZXIgdG8gYWxsb3cgZmFsbGJhY2sgdGltZSBiZWZvcmUgdmFsaWRhdGlvblxuXG4gIGNvbnN0IHJlc3VsdCA9IHsgXG4gICAgICBzY2hlbWE6ICdXTS1DaGFydC0xLjInLCBcbiAgICAgIHByb3ZlbmFuY2U6IHtcbiAgICAgICAgbWF0aF9icmFpbl92ZXJzaW9uOiBNQVRIX0JSQUlOX1ZFUlNJT04sXG4gICAgICAgIGVwaGVtZXJpc19zb3VyY2U6IEVQSEVNRVJJU19TT1VSQ0UsXG4gICAgICAgIGJ1aWxkX3RzOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHRpbWV6b25lOiBwZXJzb25BLnRpbWV6b25lIHx8ICdVVEMnLFxuICAgICAgICBjYWxpYnJhdGlvbl9ib3VuZGFyeTogQ0FMSUJSQVRJT05fQk9VTkRBUlksXG4gICAgICAgIGVuZ2luZV92ZXJzaW9uczogeyBzZWlzbW9ncmFwaDogJ3YxLjAnLCBiYWxhbmNlOiAndjEuMScsIHNmZDogJ3YxLjInIH0sXG4gICAgICAgIHRpbWVfbWV0YV9hOiBkZXJpdmVUaW1lTWV0YVdpdGhQb2xpY3kocGVyc29uQU9yaWdpbmFsLCB0aW1lUG9saWN5KSxcbiAgICAgICAgLy8gTmV3IHByb3ZlbmFuY2UgZmllbGRzIChzdGFtcGVkIGFmdGVyIHBhc3MvYm9keSBhcmUgZmluYWxpemVkIGJlbG93KVxuICAgICAgICBob3VzZV9zeXN0ZW06IHVuZGVmaW5lZCxcbiAgICAgICAgb3Jic19wcm9maWxlOiB1bmRlZmluZWQsXG4gICAgICAgIHRpbWV6b25lX2RiX3ZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgcmVsb2NhdGlvbl9tb2RlOiByZWxvY2F0aW9uTW9kZSB8fCAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBjb250ZXh0OiB7IG1vZGU6IG1vZGVUb2tlbiB8fCAnVU5LTk9XTicgfSxcbiAgICAgIG1pcnJvcl9yZWFkeTogdHJ1ZSxcbiAgICAgIGNvbnRyYWN0OiAnY2xlYXItbWlycm9yLzEuMicsXG4gICAgICBwZXJzb25fYTogeyBkZXRhaWxzOiBwZXJzb25BT3JpZ2luYWwsIG1ldGE6IGRlcml2ZVRpbWVNZXRhV2l0aFBvbGljeShwZXJzb25BT3JpZ2luYWwsIHRpbWVQb2xpY3kpIH1cbiAgICB9O1xuICAgIC8vIEVhZ2VybHkgaW5pdGlhbGl6ZSBQZXJzb24gQiBkZXRhaWxzIGluIGFueSByZWxhdGlvbnNoaXAgbW9kZSBzbyBVSSBuZXZlciBsb3NlcyB0aGUgcGFuZWxcbiAgICBpZiAocmVsYXRpb25zaGlwTW9kZSAmJiBwZXJzb25CICYmIE9iamVjdC5rZXlzKHBlcnNvbkIpLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnBlcnNvbl9iID0geyBkZXRhaWxzOiBwZXJzb25CT3JpZ2luYWwgfHwgcGVyc29uQiwgbWV0YTogZGVyaXZlVGltZU1ldGFXaXRoUG9saWN5KHBlcnNvbkJPcmlnaW5hbCB8fCBwZXJzb25CLCB0aW1lUG9saWN5KSB9O1xuICAgICAgcmVzdWx0LnByb3ZlbmFuY2UudGltZV9tZXRhX2IgPSBkZXJpdmVUaW1lTWV0YVdpdGhQb2xpY3kocGVyc29uQk9yaWdpbmFsIHx8IHBlcnNvbkIsIHRpbWVQb2xpY3kpO1xuICAgIH1cbiAgICBpZiAocmVsYXRpb25zaGlwTW9kZSAmJiByZWxDb250ZXh0VmFsaWRhdGlvbi52YWxpZCAmJiByZWxDb250ZXh0VmFsaWRhdGlvbi52YWx1ZSkge1xuICAgICAgcmVzdWx0LnJlbGF0aW9uc2hpcCA9IHJlbENvbnRleHRWYWxpZGF0aW9uLnZhbHVlO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCB0cmFuc2xvY2F0aW9uIChyZWxvY2F0aW9uKSBjb250ZXh0IGZyb20gcmVxdWVzdCBpZiBwcm92aWRlZCAoZGF0YS1vbmx5KVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0bCA9IGJvZHkudHJhbnNsb2NhdGlvbiB8fCBib2R5LmNvbnRleHQ/LnRyYW5zbG9jYXRpb24gfHwgbnVsbDtcbiAgICAgIGlmICh0bCkge1xuICAgICAgICByZXN1bHQuY29udGV4dC50cmFuc2xvY2F0aW9uID0ge1xuICAgICAgICAgIGFwcGxpZXM6ICEhdGwuYXBwbGllcyxcbiAgICAgICAgICBtZXRob2Q6IHRsLm1ldGhvZCB8fCAodGwuYXBwbGllcyA/ICdjdXN0b20nIDogJ05hdGFsJyksXG4gICAgICAgICAgaG91c2Vfc3lzdGVtOiB0bC5ob3VzZV9zeXN0ZW0gfHwgJ1BsYWNpZHVzJyxcbiAgICAgICAgICB0ejogdGwudHogfHwgKHBlcnNvbkEudGltZXpvbmUgfHwgJ1VUQycpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCB7IC8qIGlnbm9yZSAqLyB9XG5cbiAgICAvLyBFeHRyYWN0IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgQVBJIGNhbGN1bGF0aW9ucyAoaW5jbHVkaW5nIHRyYW5zaXRzKVxuICBjb25zdCBwYXNzID0ge307XG4gICAgWydhY3RpdmVfcG9pbnRzJywnYWN0aXZlX2FzcGVjdHMnLCdob3VzZXNfc3lzdGVtX2lkZW50aWZpZXInLCdzaWRlcmVhbF9tb2RlJywncGVyc3BlY3RpdmVfdHlwZSddXG4gICAgICAuZm9yRWFjaChrID0+IHsgaWYgKGJvZHlba10gIT09IHVuZGVmaW5lZCkgcGFzc1trXSA9IGJvZHlba107IH0pO1xuICAgIC8vIFF1YXJhbnRpbmUgVUkvVk9JQ0UgZmxhZ3Mgc28gdGhleSBuZXZlciB0b3VjaCBtYXRoIGxheWVyXG4gICAgY29uc3QgcXVhcmFudGluZUtleXMgPSBbJ3ZvaWNlJywndm9pY2VfbW9kZScsJ2V4Y2x1ZGVfcGVyc29uX2InLCdleGNsdWRlUGVyc29uQicsJ3JlZmxlY3RfbW9kZScsJ3VpJywnZGlzcGxheSddO1xuICAgIHF1YXJhbnRpbmVLZXlzLmZvckVhY2goayA9PiB7IGlmIChrIGluIHBhc3MpIGRlbGV0ZSBwYXNzW2tdOyB9KTtcblxuICAgIC8vIEVuc3VyZSBhY3RpdmVfcG9pbnRzIGluY2x1ZGVzIGFsbCBwbGFuZXRzIChlc3BlY2lhbGx5IG91dGVyIHBsYW5ldHMpIGlmIG5vdCBleHBsaWNpdGx5IHNldFxuICAgIGlmICghcGFzcy5hY3RpdmVfcG9pbnRzKSB7XG4gICAgICBwYXNzLmFjdGl2ZV9wb2ludHMgPSBbXG4gICAgICAgICdTdW4nLCdNb29uJywnTWVyY3VyeScsJ1ZlbnVzJywnTWFycycsJ0p1cGl0ZXInLCdTYXR1cm4nLFxuICAgICAgICAnVXJhbnVzJywnTmVwdHVuZScsJ1BsdXRvJyxcbiAgICAgICAgJ01lYW5fTm9kZScsJ1RydWVfTm9kZScsJ01lYW5fU291dGhfTm9kZScsJ1RydWVfU291dGhfTm9kZScsXG4gICAgICAgICdDaGlyb24nLCdNZWFuX0xpbGl0aCcsXG4gICAgICAgICdBc2NlbmRhbnQnLCdNZWRpdW1fQ29lbGknLCdEZXNjZW5kYW50JywnSW11bV9Db2VsaSdcbiAgICAgIF07XG4gICAgICBsb2dnZXIuZGVidWcoJ1NldHRpbmcgZGVmYXVsdCBhY3RpdmVfcG9pbnRzIChpbmNsdWRlcyBUcnVlIG5vZGVzICYgZnVsbCBhbmdsZSBzZXQpJyk7XG4gICAgfVxuICAgIC8vIFRpbWUgcG9saWN5IGNhbiBzdXBwcmVzcyBob3VzZS9hbmdsZSBzZW1hbnRpY3M6IHJlbW92ZSBhbmdsZXMgd2hlbiBwb2xpY3kgZm9yYmlkcyBob3VzZXNcbiAgICBpZiAodGltZVBvbGljeSA9PT0gJ3BsYW5ldGFyeV9vbmx5JyB8fCB0aW1lUG9saWN5ID09PSAnc2Vuc2l0aXZpdHlfc2NhbicpIHtcbiAgICAgIHBhc3MuYWN0aXZlX3BvaW50cyA9IHBhc3MuYWN0aXZlX3BvaW50cy5maWx0ZXIocCA9PiAhWydBc2NlbmRhbnQnLCdNZWRpdW1fQ29lbGknLCdEZXNjZW5kYW50JywnSW11bV9Db2VsaSddLmluY2x1ZGVzKHApKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnVGltZSBwb2xpY3kgZXhjbHVkZXMgYW5ndWxhciBwb2ludHMgZm9yIHRyYW5zaXRzJyk7XG4gICAgfVxuICAgIC8vIFdob2xlLXNpZ24gcHJlZmVyZW5jZTogdXNlciBhbGxvd3MgaG91c2VzIHdpdGggbm9vbiBmYWxsYmFjazsgcHJlZmVyIHdob2xlLXNpZ24gaG91c2Ugc3lzdGVtXG4gICAgaWYgKHRpbWVQb2xpY3kgPT09ICd3aG9sZV9zaWduJyAmJiAhcGFzcy5ob3VzZXNfc3lzdGVtX2lkZW50aWZpZXIpIHtcbiAgICAgIHBhc3MuaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyID0gJ1dob2xlX1NpZ24nO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdUaW1lIHBvbGljeSBzZXQgaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyPVdob2xlX1NpZ24nKTtcbiAgICB9XG5cbiAgICAvLyBTdGFtcCBwcm92ZW5hbmNlIGZpZWxkcyBub3cgdGhhdCBwYXNzL2JvZHkgYXJlIGtub3duXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdC5wcm92ZW5hbmNlLmhvdXNlX3N5c3RlbSA9IHBhc3MuaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyIHx8IHJlc3VsdC5wcm92ZW5hbmNlLmhvdXNlX3N5c3RlbSB8fCAnUGxhY2lkdXMnO1xuICAgICAgcmVzdWx0LnByb3ZlbmFuY2Uub3Jic19wcm9maWxlID0gYm9keS5vcmJzX3Byb2ZpbGUgfHwgcmVzdWx0LnByb3ZlbmFuY2Uub3Jic19wcm9maWxlIHx8ICd3bS1zcGVjLTIwMjUtMDknO1xuICAgICAgcmVzdWx0LnByb3ZlbmFuY2UudGltZXpvbmVfZGJfdmVyc2lvbiA9IHJlc3VsdC5wcm92ZW5hbmNlLnRpbWV6b25lX2RiX3ZlcnNpb24gfHwgJ0lBTkEgKHN5c3RlbSknO1xuICAgICAgcmVzdWx0LnByb3ZlbmFuY2UucmVsb2NhdGlvbl9tb2RlID0gcmVsb2NhdGlvbk1vZGUgfHwgcmVzdWx0LnByb3ZlbmFuY2UucmVsb2NhdGlvbl9tb2RlIHx8ICdub25lJztcbiAgICB9IGNhdGNoIHsgLyogaWdub3JlICovIH1cblxuICAgIC8vIEVuc3VyZSBhY3RpdmVfYXNwZWN0cyBpbmNsdWRlcyBhbGwgbWFqb3IgYXNwZWN0cyBpZiBub3QgZXhwbGljaXRseSBzZXRcbiAgICBpZiAoIXBhc3MuYWN0aXZlX2FzcGVjdHMpIHtcbiAgICAgIHBhc3MuYWN0aXZlX2FzcGVjdHMgPSBbXG4gICAgICAgIC8vIFJhdmVuIGNhcHMgZm9yIG1ham9yczogOC84LzcvNy81XG4gICAgICAgIHsgbmFtZTogXCJjb25qdW5jdGlvblwiLCBvcmI6IDggfSxcbiAgICAgICAgeyBuYW1lOiBcIm9wcG9zaXRpb25cIiwgIG9yYjogOCB9LFxuICAgICAgICB7IG5hbWU6IFwidHJpbmVcIiwgICAgICAgb3JiOiA3IH0sXG4gICAgICAgIHsgbmFtZTogXCJzcXVhcmVcIiwgICAgICBvcmI6IDcgfSxcbiAgICAgICAgeyBuYW1lOiBcInNleHRpbGVcIiwgICAgIG9yYjogNSB9LFxuICAgICAgICAvLyBNaW5vcnMgLyBoYXJtb25pY1xuICAgICAgICB7IG5hbWU6IFwicXVpbmN1bnhcIiwgICAgICAgIG9yYjogMyB9LFxuICAgICAgICB7IG5hbWU6IFwic2VzcXVpcXVhZHJhdGVcIiwgIG9yYjogMyB9LFxuICAgICAgICB7IG5hbWU6IFwic2VtaS1zcXVhcmVcIiwgICAgIG9yYjogMiB9LFxuICAgICAgICB7IG5hbWU6IFwic2VtaS1zZXh0aWxlXCIsICAgIG9yYjogMiB9LFxuICAgICAgICB7IG5hbWU6IFwicXVpbnRpbGVcIiwgICAgICAgIG9yYjogMiB9LFxuICAgICAgICB7IG5hbWU6IFwiYmlxdWludGlsZVwiLCAgICAgIG9yYjogMiB9XG4gICAgICBdO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdTZXR0aW5nIGRlZmF1bHQgYWN0aXZlX2FzcGVjdHMgdG8gUmF2ZW4gY2FwcyBsaXN0Jyk7XG4gICAgfVxuXG4gICAgLy8gLS0tIEFzcGVjdCBuYW1lIG5vcm1hbGl6YXRpb24gKGhhbmRsZXMgdXNlciBzdXBwbGllZCBsaXN0ICYgbGVnYWN5IHN5bm9ueW1zKSAtLS1cbiAgICBjb25zdCBBU1BFQ1RfU1lOT05ZTVMgPSB7XG4gICAgICAnc2VtaXNxdWFyZSc6ICdzZW1pLXNxdWFyZScsXG4gICAgICAnc2VtaV9zcXVhcmUnOiAnc2VtaS1zcXVhcmUnLFxuICAgICAgJ3NlbWkgc3F1YXJlJzogJ3NlbWktc3F1YXJlJyxcbiAgICAgICdzZW1pc2V4dGlsZSc6ICdzZW1pLXNleHRpbGUnLFxuICAgICAgJ3NlbWlfc2V4dGlsZSc6ICdzZW1pLXNleHRpbGUnLFxuICAgICAgJ3NlbWkgc2V4dGlsZSc6ICdzZW1pLXNleHRpbGUnLFxuICAgICAgJ2luY29uanVuY3QnOiAncXVpbmN1bngnLFxuICAgICAgJ3Nlc3F1aS1zcXVhcmUnOiAnc2VzcXVpcXVhZHJhdGUnLFxuICAgICAgJ3Nlc3F1aXNxdWFyZSc6ICdzZXNxdWlxdWFkcmF0ZSdcbiAgICB9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFzcy5hY3RpdmVfYXNwZWN0cykpIHtcbiAgICAgIHBhc3MuYWN0aXZlX2FzcGVjdHMgPSBwYXNzLmFjdGl2ZV9hc3BlY3RzXG4gICAgICAgIC5tYXAoYSA9PiB7XG4gICAgICAgICAgaWYgKCFhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSByZXR1cm4geyBuYW1lOiBhLCBvcmI6IDMgfTtcbiAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSAoYS5uYW1lIHx8IGEudHlwZSB8fCAnJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsID0gQVNQRUNUX1NZTk9OWU1TW3Jhd10gfHwgcmF3O1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogY2Fub25pY2FsLCBvcmI6IGEub3JiICE9IG51bGwgPyBhLm9yYiA6IDMgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLy8gRGVkdXBsaWNhdGUgYnkgbmFtZSBrZWVwaW5nIGxhcmdlc3Qgb3JiICh3ZSdsbCBjYXAgbGF0ZXIpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhY2MuZmluZCh4ID0+IHgubmFtZSA9PT0gY3VyLm5hbWUpO1xuICAgICAgICAgIGlmICghZXhpc3RpbmcpIGFjYy5wdXNoKGN1cik7IGVsc2UgaWYgKGN1ci5vcmIgPiBleGlzdGluZy5vcmIpIGV4aXN0aW5nLm9yYiA9IGN1ci5vcmI7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAvLyBDbGFtcCB0byBwcm92aWRlciBjYXBzIGJlZm9yZSBjYWxsaW5nIHVwc3RyZWFtXG4gICAgICBwYXNzLmFjdGl2ZV9hc3BlY3RzID0gcGFzcy5hY3RpdmVfYXNwZWN0cy5tYXAoYSA9PiB7XG4gICAgICAgIGNvbnN0IGNhcCA9IEFTUEVDVF9PUkJfQ0FQU1thLm5hbWVdIHx8IGEub3JiO1xuICAgICAgICBjb25zdCBjbGFtcGVkID0gTWF0aC5taW4oYS5vcmIsIGNhcCk7XG4gICAgICAgIGlmIChhLm9yYiA+IGNsYW1wZWQpIGxvZ2dlci5kZWJ1ZyhgQ2xhbXBpbmcgb3JiIGZvciAke2EubmFtZX0gZnJvbSAke2Eub3JifSAtPiAke2NsYW1wZWR9YCk7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IGEubmFtZSwgb3JiOiBjbGFtcGVkIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgbG9nZ2VyLmRlYnVnKCdOb3JtYWxpemVkICsgY2xhbXBlZCBhY3RpdmVfYXNwZWN0cyBsaXN0OicsIHBhc3MuYWN0aXZlX2FzcGVjdHMpO1xuXG4gICAgLy8gMSkgTmF0YWwgKGNoYXJ0ICsgYXNwZWN0cywgbmF0YWwgYXNwZWN0cy1vbmx5LCBvciBiaXJ0aCBkYXRhKVxuICAgIGxldCBuYXRhbFJlc3BvbnNlO1xuICAgIGlmICh3YW50QmFsYW5jZU1ldGVyKSB7XG4gICAgICAvLyBGb3IgQmFsYW5jZSBNZXRlciBydW5zLCBza2lwIG5hdGFsIEFQSSBjYWxsczsgc2Vpc21vZ3JhcGggdXNlcyB0cmFuc2l0cyBvbmx5XG4gICAgICByZXN1bHQucGVyc29uX2EgPSByZXN1bHQucGVyc29uX2EgfHwge307XG4gICAgICByZXN1bHQucGVyc29uX2EuZGV0YWlscyA9IHBlcnNvbkE7XG4gICAgfSBlbHNlIGlmICh3YW50QmlydGhEYXRhKSB7XG4gICAgICBuYXRhbFJlc3BvbnNlID0gYXdhaXQgY2FsbE5hdGFsKFxuICAgICAgICBBUElfRU5EUE9JTlRTLkJJUlRIX0RBVEEsXG4gICAgICAgIHBlcnNvbkEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHBhc3MsXG4gICAgICAgICdCaXJ0aCBkYXRhIChBKSdcbiAgICAgICk7XG4gICAgICByZXN1bHQucGVyc29uX2EuYmlydGhfZGF0YSA9IHN0cmlwR3JhcGhpY3NEZWVwKG5hdGFsUmVzcG9uc2UuZGF0YSB8fCB7fSk7XG4gICAgfSBlbHNlIGlmICh3YW50TmF0YWxBc3BlY3RzT25seSkge1xuICAgICAgbmF0YWxSZXNwb25zZSA9IGF3YWl0IGNhbGxOYXRhbChcbiAgICAgICAgQVBJX0VORFBPSU5UUy5OQVRBTF9BU1BFQ1RTX0RBVEEsXG4gICAgICAgIHBlcnNvbkEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHBhc3MsXG4gICAgICAgICdOYXRhbCBhc3BlY3RzIGRhdGEgKEEpJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGNoYXJ0RGF0YSA9IHN0cmlwR3JhcGhpY3NEZWVwKG5hdGFsUmVzcG9uc2UuZGF0YSB8fCB7fSk7XG4gICAgICByZXN1bHQucGVyc29uX2EuY2hhcnQgPSBjaGFydERhdGE7XG4gICAgICByZXN1bHQucGVyc29uX2EuYXNwZWN0cyA9IEFycmF5LmlzQXJyYXkobmF0YWxSZXNwb25zZS5hc3BlY3RzKSA/IG5hdGFsUmVzcG9uc2UuYXNwZWN0cyA6IChjaGFydERhdGEuYXNwZWN0cyB8fCBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdGFsUmVzcG9uc2UgPSBhd2FpdCBjYWxsTmF0YWwoXG4gICAgICAgIEFQSV9FTkRQT0lOVFMuQklSVEhfQ0hBUlQsXG4gICAgICAgIHBlcnNvbkEsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHBhc3MsXG4gICAgICAgICdCaXJ0aCBjaGFydCAoQSknXG4gICAgICApO1xuICAgICAgY29uc3QgY2hhcnREYXRhID0gc3RyaXBHcmFwaGljc0RlZXAobmF0YWxSZXNwb25zZS5kYXRhIHx8IHt9KTtcbiAgICAgIHJlc3VsdC5wZXJzb25fYS5jaGFydCA9IGNoYXJ0RGF0YTtcbiAgICAgIHJlc3VsdC5wZXJzb25fYS5hc3BlY3RzID0gQXJyYXkuaXNBcnJheShuYXRhbFJlc3BvbnNlLmFzcGVjdHMpID8gbmF0YWxSZXNwb25zZS5hc3BlY3RzIDogKGNoYXJ0RGF0YS5hc3BlY3RzIHx8IFtdKTtcbiAgICB9XG5cbiAgICAvLyBCaXJ0aC10aW1lIHN1cHByZXNzaW9uIG1hcmtlclxuICAgIHRyeSB7XG4gIGNvbnN0IGJpcnRoVGltZU1pc3NpbmcgPSAocykgPT4gcz8uaG91ciA9PSBudWxsIHx8IHM/Lm1pbnV0ZSA9PSBudWxsO1xuICAvLyBQb2xpY3kgZHJpdmVzIHN1cHByZXNzaW9uOiBmb3IgdW5rbm93biBiaXJ0aCB0aW1lLCBwbGFuZXRhcnlfb25seSBhbmQgc2Vuc2l0aXZpdHlfc2NhbiBzdXBwcmVzcyBob3VzZXM7IHdob2xlX3NpZ24gYWxsb3dzXG4gIGNvbnN0IHNob3VsZFN1cHByZXNzID0gKHMpID0+IGJpcnRoVGltZU1pc3NpbmcocykgJiYgKHRpbWVQb2xpY3kgPT09ICdwbGFuZXRhcnlfb25seScgfHwgdGltZVBvbGljeSA9PT0gJ3NlbnNpdGl2aXR5X3NjYW4nKTtcbiAgaWYgKHNob3VsZFN1cHByZXNzKHBlcnNvbkFPcmlnaW5hbCkpIHJlc3VsdC5wZXJzb25fYS5ob3VzZXNfc3VwcHJlc3NlZCA9IHRydWU7XG4gIGlmIChyZXN1bHQucGVyc29uX2IgJiYgc2hvdWxkU3VwcHJlc3MocGVyc29uQk9yaWdpbmFsIHx8IHBlcnNvbkIpKSByZXN1bHQucGVyc29uX2IuaG91c2VzX3N1cHByZXNzZWQgPSB0cnVlO1xuICAgICAgLy8gS2VlcCBtZXRhIGFsaWduZWQgd2l0aCBzdXBwcmVzc2lvbiBhbmQgcG9saWN5XG4gIHJlc3VsdC5wZXJzb25fYS5tZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0LnBlcnNvbl9hLm1ldGEsIGRlcml2ZVRpbWVNZXRhV2l0aFBvbGljeShwZXJzb25BT3JpZ2luYWwsIHRpbWVQb2xpY3kpKTtcbiAgaWYgKHJlc3VsdC5wZXJzb25fYikgcmVzdWx0LnBlcnNvbl9iLm1ldGEgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQucGVyc29uX2IubWV0YSB8fCB7fSwgZGVyaXZlVGltZU1ldGFXaXRoUG9saWN5KHBlcnNvbkJPcmlnaW5hbCB8fCBwZXJzb25CLCB0aW1lUG9saWN5KSk7XG4gICAgfSBjYXRjaCB7LyogaWdub3JlICovfVxuXG4gICAgLy8gMikgVHJhbnNpdHMgKG9wdGlvbmFsOyByYXcgYXNwZWN0cyBieSBkYXRlLCB3aXRoIGFkdmFuY2VkIG9wdGlvbnMpXG4gICAgLy8gU2tpcCB0cmFuc2l0IHByb2Nlc3NpbmcgZm9yIG5hdGFsX29ubHkgbW9kZSBldmVuIGlmIGRhdGUgcmFuZ2UgaXMgcHJvdmlkZWRcbiAgICBjb25zdCBza2lwVHJhbnNpdHMgPSBtb2RlVG9rZW4gPT09ICdOQVRBTF9PTkxZJztcbiAgICBcbiAgICAvLyBTa3kgdHJhbnNpdHMgbW9kZSAtIHBsYW5ldGFyeSB0cmFuc2l0cyB3aXRob3V0IHBlcnNvbmFsIG5hdGFsIGNoYXJ0XG4gICAgaWYgKHdhbnRTa3lUcmFuc2l0cyAmJiBoYXZlUmFuZ2UpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUHJvY2Vzc2luZyBza3kgdHJhbnNpdHMgbW9kZTonLCB7IHN0YXJ0LCBlbmQsIHN0ZXAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IHN1YmplY3QgZm9yIHNreS1vbmx5IHRyYW5zaXRzIChubyBwZXJzb25hbCBkYXRhKVxuICAgICAgY29uc3Qgc2t5U3ViamVjdCA9IHtcbiAgICAgICAgbmFtZTogJ1NreSBQYXR0ZXJucycsXG4gICAgICAgIGJpcnRoX2RhdGU6IHN0YXJ0LCAvLyBVc2Ugc3RhcnQgZGF0ZSBhcyByZWZlcmVuY2VcbiAgICAgICAgYmlydGhfdGltZTogJzEyOjAwJyxcbiAgICAgICAgYmlydGhfbG9jYXRpb246ICdHcmVlbndpY2gsIFVLJywgLy8gTmV1dHJhbCBsb2NhdGlvbiBmb3Igc2t5IHBhdHRlcm5zXG4gICAgICAgIHRpbWV6b25lOiAnR01UJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2l0c0J5RGF0ZSwgcmV0cm9GbGFnc0J5RGF0ZSwgcHJvdmVuYW5jZUJ5RGF0ZSB9ID0gYXdhaXQgZ2V0VHJhbnNpdHMoc2t5U3ViamVjdCwgeyBzdGFydERhdGU6IHN0YXJ0LCBlbmREYXRlOiBlbmQsIHN0ZXAgfSwgaGVhZGVycywgcGFzcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBBcHBseSBzZWlzbW9ncmFwaCBhbmFseXNpcyB0byBza3kgdHJhbnNpdHNcbiAgICAgICAgY29uc3Qgc2Vpc21vZ3JhcGhEYXRhID0gY2FsY3VsYXRlU2Vpc21vZ3JhcGgodHJhbnNpdHNCeURhdGUsIHJldHJvRmxhZ3NCeURhdGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgc2t5IHRyYW5zaXQgZGF0YVxuICAgICAgICByZXN1bHQuc2t5X3RyYW5zaXRzID0ge1xuICAgICAgICAgIHRyYW5zaXRzQnlEYXRlOiBzZWlzbW9ncmFwaERhdGEuZGFpbHksXG4gICAgICAgICAgcHJvdmVuYW5jZUJ5RGF0ZSxcbiAgICAgICAgICBkZXJpdmVkOiB7XG4gICAgICAgICAgICBzZWlzbW9ncmFwaF9zdW1tYXJ5OiBzZWlzbW9ncmFwaERhdGEuc3VtbWFyeSxcbiAgICAgICAgICAgIG1vZGU6ICdza3lfcGF0dGVybnNfb25seSdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoJ1NreSB0cmFuc2l0cyBjb21wbGV0ZWQgd2l0aCBzZWlzbW9ncmFwaCBhbmFseXNpcycpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIud2FybignU2t5IHRyYW5zaXRzIGNvbXB1dGF0aW9uIGZhaWxlZDonLCBlLm1lc3NhZ2UpO1xuICAgICAgICByZXN1bHQuc2t5X3RyYW5zaXRzID0geyBlcnJvcjogJ0ZhaWxlZCB0byBjb21wdXRlIHNreSBwYXR0ZXJucycgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhdmVSYW5nZSAmJiAhc2tpcFRyYW5zaXRzKSB7XG4gICAgICAvLyBVc2UgbmV3IGdldFRyYW5zaXRzIGFuZCBzZWlzbW9ncmFwaCBsb2dpYyB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICBjb25zdCB7IHRyYW5zaXRzQnlEYXRlLCByZXRyb0ZsYWdzQnlEYXRlLCBwcm92ZW5hbmNlQnlEYXRlIH0gPSBhd2FpdCBnZXRUcmFuc2l0cyhwZXJzb25BLCB7IHN0YXJ0RGF0ZTogc3RhcnQsIGVuZERhdGU6IGVuZCwgc3RlcCB9LCBoZWFkZXJzLCBwYXNzKTtcbiAgcmVzdWx0LnBlcnNvbl9hLmNoYXJ0ID0geyAuLi5yZXN1bHQucGVyc29uX2EuY2hhcnQsIHRyYW5zaXRzQnlEYXRlIH07XG4gICAgICAvLyBSYXZlbi1saXRlIGludGVncmF0aW9uOiBmbGF0dGVuIGFsbCBhc3BlY3RzIGZvciBkZXJpdmVkLnQybl9hc3BlY3RzXG4gICAgICBjb25zdCBhbGxBc3BlY3RzID0gT2JqZWN0LnZhbHVlcyh0cmFuc2l0c0J5RGF0ZSkuZmxhdE1hcChkYXkgPT4gZGF5KTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmRlYnVnKGBUcmFuc2l0IGFzcGVjdHMgZm91bmQ6ICR7YWxsQXNwZWN0cy5sZW5ndGh9IHRvdGFsIGluY2x1ZGluZyBvdXRlciBwbGFuZXRzYCk7XG4gICAgICBcbiAgICAgIHJlc3VsdC5wZXJzb25fYS5kZXJpdmVkID0gcmVzdWx0LnBlcnNvbl9hLmRlcml2ZWQgfHwge307XG4gICAgICByZXN1bHQucGVyc29uX2EuZGVyaXZlZC50Mm5fYXNwZWN0cyA9IG1hcFQyTkFzcGVjdHMoYWxsQXNwZWN0cyk7XG4gICAgICAvLyBBZGQgdHJhbnNpdF9kYXRhIGFycmF5IGZvciB0ZXN0IGNvbXBhdGliaWxpdHlcbiAgICAgIHJlc3VsdC5wZXJzb25fYS50cmFuc2l0X2RhdGEgPSBPYmplY3QudmFsdWVzKHRyYW5zaXRzQnlEYXRlKTtcbiAgICAgIFxuICAgICAgLy8gU2Vpc21vZ3JhcGggc3VtbWFyeSAodXNpbmcgYWxsIGFzcGVjdHMgaW5jbHVkaW5nIG91dGVyIHBsYW5ldHMgZm9yIGNvbXBsZXRlIHN0cnVjdHVyYWwgYW5hbHlzaXMpXG4gIGNvbnN0IHNlaXNtb2dyYXBoRGF0YSA9IGNhbGN1bGF0ZVNlaXNtb2dyYXBoKHRyYW5zaXRzQnlEYXRlLCByZXRyb0ZsYWdzQnlEYXRlKTtcbiAgICAgIHJlc3VsdC5wZXJzb25fYS5kZXJpdmVkLnNlaXNtb2dyYXBoX3N1bW1hcnkgPSBzZWlzbW9ncmFwaERhdGEuc3VtbWFyeTtcbiAgLy8gTk9URTogdHJhbnNpdHNCeURhdGUgbm93IGluY2x1ZGVzIHBlci1kYXk6IGFzcGVjdHMgKHJhdyksIGZpbHRlcmVkX2FzcGVjdHMsIGhvb2tzLCBjb3VudHMsIHNlaXNtb2dyYXBoIG1ldHJpY3NcbiAgLy8gRnJvbnRlbmQgY2FuIHByb2dyZXNzaXZlbHkgZGlzY2xvc2UgaG9va3MgZmlyc3QsIHRoZW4gZmlsdGVyZWRfYXNwZWN0cywgdGhlbiBmdWxsIGxpc3QuXG4gICAgICByZXN1bHQucGVyc29uX2EuY2hhcnQudHJhbnNpdHNCeURhdGUgPSBzZWlzbW9ncmFwaERhdGEuZGFpbHk7XG4gICAgICByZXN1bHQucGVyc29uX2EuY2hhcnQucHJvdmVuYW5jZUJ5RGF0ZSA9IHByb3ZlbmFuY2VCeURhdGU7XG4gICAgfVxuXG4gICAgLy8gMmIpIER1YWwgbmF0YWwgbW9kZXMgKGV4cGxpY2l0KTogcHJvdmlkZSBib3RoIG5hdGFsIGNoYXJ0cyAoYW5kIG9wdGlvbmFsIHRyYW5zaXRzKSBXSVRIT1VUIHN5bmFzdHJ5IG1hdGhcbiAgICBjb25zdCBkdWFsTmF0YWxNb2RlID0gbW9kZVRva2VuID09PSAnRFVBTF9OQVRBTCcgfHwgbW9kZVRva2VuID09PSAnRFVBTF9OQVRBTF9UUkFOU0lUUyc7XG4gICAgaWYgKChkdWFsTmF0YWxNb2RlIHx8ICghcmVsYXRpb25zaGlwTW9kZSAmJiBtb2RlVG9rZW4gJiYgbW9kZVRva2VuLnN0YXJ0c1dpdGgoJ05BVEFMJykgJiYgcGVyc29uQiAmJiBPYmplY3Qua2V5cyhwZXJzb25CKS5sZW5ndGgpKSAmJiBwZXJzb25CKSB7XG4gICAgICBjb25zdCB2QkxlYW5QYXNzaXZlID0gdmFsaWRhdGVTdWJqZWN0TGVhbihwZXJzb25CKTtcbiAgICAgIGlmICh2QkxlYW5QYXNzaXZlLmlzVmFsaWQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQucGVyc29uX2IgfHwgIXJlc3VsdC5wZXJzb25fYi5jaGFydCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuYXRhbEIgPSBhd2FpdCBjYWxsTmF0YWwoXG4gICAgICAgICAgICAgIEFQSV9FTkRQT0lOVFMuQklSVEhfQ0hBUlQsXG4gICAgICAgICAgICAgIHBlcnNvbkIsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgIHBhc3MsXG4gICAgICAgICAgICAgICdCaXJ0aCBjaGFydCAoQiBkdWFsKSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBjaGFydERhdGFCID0gc3RyaXBHcmFwaGljc0RlZXAobmF0YWxCLmRhdGEgfHwge30pO1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iID0geyBkZXRhaWxzOiBwZXJzb25CLCBjaGFydDogY2hhcnREYXRhQiwgYXNwZWN0czogQXJyYXkuaXNBcnJheShuYXRhbEIuYXNwZWN0cykgPyBuYXRhbEIuYXNwZWN0cyA6IChjaGFydERhdGFCLmFzcGVjdHMgfHwgW10pIH07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0R1YWwgUGVyc29uIEIgbmF0YWwgZmV0Y2ggZmFpbGVkJywgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJzb25fYiA9IHsgZGV0YWlsczogcGVyc29uQiwgZXJyb3I6ICdGYWlsZWQgdG8gY29tcHV0ZSBQZXJzb24gQiBjaGFydCcgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW9uYWwgUGVyc29uIEIgdHJhbnNpdHMgaW4gZHVhbCB0cmFuc2l0cyBtb2RlXG4gICAgICAgIGlmIChoYXZlUmFuZ2UgJiYgIXNraXBUcmFuc2l0cyAmJiBtb2RlVG9rZW4gPT09ICdEVUFMX05BVEFMX1RSQU5TSVRTJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zaXRzQnlEYXRlOiB0cmFuc2l0c0J5RGF0ZUIsIHJldHJvRmxhZ3NCeURhdGU6IHJldHJvRmxhZ3NCeURhdGVCLCBwcm92ZW5hbmNlQnlEYXRlOiBwcm92ZW5hbmNlQnlEYXRlQiB9ID0gYXdhaXQgZ2V0VHJhbnNpdHMocGVyc29uQiwgeyBzdGFydERhdGU6IHN0YXJ0LCBlbmREYXRlOiBlbmQsIHN0ZXAgfSwgaGVhZGVycywgcGFzcyk7XG4gICAgICAgICAgICBjb25zdCBhbGxCID0gT2JqZWN0LnZhbHVlcyh0cmFuc2l0c0J5RGF0ZUIpLmZsYXRNYXAoZGF5ID0+IGRheSk7XG4gICAgICAgICAgICBjb25zdCBzZWlzbW9CID0gY2FsY3VsYXRlU2Vpc21vZ3JhcGgodHJhbnNpdHNCeURhdGVCLCByZXRyb0ZsYWdzQnlEYXRlQik7XG4gICAgICAgICAgICAvLyBFbnJpY2hlZCBQZXJzb24gQiB0cmFuc2l0cyAoZHVhbCBtb2RlKSB3aXRoIGhvb2tzICYgZmlsdGVyZWRfYXNwZWN0c1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLmNoYXJ0ID0geyAuLi4ocmVzdWx0LnBlcnNvbl9iLmNoYXJ0IHx8IHt9KSwgdHJhbnNpdHNCeURhdGU6IHNlaXNtb0IuZGFpbHksIHByb3ZlbmFuY2VCeURhdGU6IHByb3ZlbmFuY2VCeURhdGVCIH07XG4gICAgICAgICAgICByZXN1bHQucGVyc29uX2IuZGVyaXZlZCA9IHJlc3VsdC5wZXJzb25fYi5kZXJpdmVkIHx8IHt9O1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLmRlcml2ZWQuc2Vpc21vZ3JhcGhfc3VtbWFyeSA9IHNlaXNtb0Iuc3VtbWFyeTtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJzb25fYi5kZXJpdmVkLnQybl9hc3BlY3RzID0gbWFwVDJOQXNwZWN0cyhhbGxCKTsgLy8gUGVyc29uIEIgc2VsZiB0cmFuc2l0cyAodHJhbnNpdC10by1uYXRhbCBCKVxuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLnRyYW5zaXRfZGF0YSA9IE9iamVjdC52YWx1ZXModHJhbnNpdHNCeURhdGVCKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignRHVhbCBQZXJzb24gQiB0cmFuc2l0cyBmZXRjaCBmYWlsZWQnLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLnRyYW5zaXRzX2Vycm9yID0gJ0ZhaWxlZCB0byBjb21wdXRlIFBlcnNvbiBCIHRyYW5zaXRzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wZXJzb25fYiA9IHsgZGV0YWlsczogcGVyc29uQiwgdmFsaWRhdGlvbl9lcnJvcjogdkJMZWFuUGFzc2l2ZS5tZXNzYWdlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMmMpIEltcGxpY2l0IGR1YWwgdHJhbnNpdCBzdXBwb3J0OiBpZiBtb2RlIGlzIGEgc2luZ2xlLXBlcnNvbiBOQVRBTCogdmFyaWFudCB0aGF0IHJlcXVlc3RzIHRyYW5zaXRzIChlLmcuLCBOQVRBTF9UUkFOU0lUUylcbiAgICAvLyBhbmQgUGVyc29uIEIgd2FzIHN1cHBsaWVkLCBjb21wdXRlIFBlcnNvbiBCIHRyYW5zaXRzIGFzIHdlbGwgKHdpdGhvdXQgcmVxdWlyaW5nIGV4cGxpY2l0IERVQUxfTkFUQUxfVFJBTlNJVFMgdG9rZW4pLlxuICAgIC8vIFNraXAgaWYgcmVsYXRpb25zaGlwTW9kZSAoc3luYXN0cnkvY29tcG9zaXRlKSB0byBhdm9pZCBkdXBsaWNhdGlvbiwgYW5kIHNraXAgaWYgYWxyZWFkeSBoYW5kbGVkIGJ5IGV4cGxpY2l0IGR1YWwgbW9kZSBhYm92ZS5cbiAgICBpZiAoXG4gICAgICBoYXZlUmFuZ2UgJiZcbiAgICAgICFza2lwVHJhbnNpdHMgJiZcbiAgICAgICFyZWxhdGlvbnNoaXBNb2RlICYmXG4gICAgICBwZXJzb25CICYmIE9iamVjdC5rZXlzKHBlcnNvbkIpLmxlbmd0aCAmJlxuICAgICAgbW9kZVRva2VuICYmIG1vZGVUb2tlbi5zdGFydHNXaXRoKCdOQVRBTCcpICYmIG1vZGVUb2tlbi5pbmNsdWRlcygnVFJBTlNJVFMnKSAmJlxuICAgICAgbW9kZVRva2VuICE9PSAnRFVBTF9OQVRBTF9UUkFOU0lUUydcbiAgICApIHtcbiAgICAgIGNvbnN0IHZCTGVhblBhc3NpdmUyID0gdmFsaWRhdGVTdWJqZWN0TGVhbihwZXJzb25CKTtcbiAgICAgIGlmICh2QkxlYW5QYXNzaXZlMi5pc1ZhbGlkKSB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIFBlcnNvbiBCIG5hdGFsIGJhc2VsaW5lIChsaWdodCBmZXRjaCBpZiBtaXNzaW5nKVxuICAgICAgICBpZiAoIXJlc3VsdC5wZXJzb25fYiB8fCAhcmVzdWx0LnBlcnNvbl9iLmNoYXJ0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5hdGFsQiA9IGF3YWl0IGNhbGxOYXRhbChcbiAgICAgICAgICAgICAgQVBJX0VORFBPSU5UUy5CSVJUSF9DSEFSVCxcbiAgICAgICAgICAgICAgcGVyc29uQixcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgcGFzcyxcbiAgICAgICAgICAgICAgJ0JpcnRoIGNoYXJ0IChCIGltcGxpY2l0IGR1YWwpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0RGF0YUIgPSBzdHJpcEdyYXBoaWNzRGVlcChuYXRhbEIuZGF0YSB8fCB7fSk7XG4gICAgICAgICAgICByZXN1bHQucGVyc29uX2IgPSB7IGRldGFpbHM6IHBlcnNvbkIsIGNoYXJ0OiBjaGFydERhdGFCLCBhc3BlY3RzOiBBcnJheS5pc0FycmF5KG5hdGFsQi5hc3BlY3RzKSA/IG5hdGFsQi5hc3BlY3RzIDogKGNoYXJ0RGF0YUIuYXNwZWN0cyB8fCBbXSkgfTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignSW1wbGljaXQgZHVhbCBQZXJzb24gQiBuYXRhbCBmZXRjaCBmYWlsZWQnLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iID0geyAuLi4ocmVzdWx0LnBlcnNvbl9iIHx8IHt9KSwgZGV0YWlsczogcGVyc29uQiwgZXJyb3I6ICdGYWlsZWQgdG8gY29tcHV0ZSBQZXJzb24gQiBjaGFydCcgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBjb21wdXRlIEIgdHJhbnNpdHMgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICBjb25zdCBoYXNCVHJhbnNpdHMgPSAhIShyZXN1bHQucGVyc29uX2IgJiYgcmVzdWx0LnBlcnNvbl9iLmNoYXJ0ICYmIHJlc3VsdC5wZXJzb25fYi5jaGFydC50cmFuc2l0c0J5RGF0ZSk7XG4gICAgICAgIGlmICghaGFzQlRyYW5zaXRzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNpdHNCeURhdGU6IHRyYW5zaXRzQnlEYXRlQiwgcmV0cm9GbGFnc0J5RGF0ZTogcmV0cm9GbGFnc0J5RGF0ZUIsIHByb3ZlbmFuY2VCeURhdGU6IHByb3ZlbmFuY2VCeURhdGVCIH0gPSBhd2FpdCBnZXRUcmFuc2l0cyhwZXJzb25CLCB7IHN0YXJ0RGF0ZTogc3RhcnQsIGVuZERhdGU6IGVuZCwgc3RlcCB9LCBoZWFkZXJzLCBwYXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEIgPSBPYmplY3QudmFsdWVzKHRyYW5zaXRzQnlEYXRlQikuZmxhdE1hcChkYXkgPT4gZGF5KTtcbiAgICAgICAgICAgIGNvbnN0IHNlaXNtb0IgPSBjYWxjdWxhdGVTZWlzbW9ncmFwaCh0cmFuc2l0c0J5RGF0ZUIsIHJldHJvRmxhZ3NCeURhdGVCKTtcbiAgICAgICAgICAgIC8vIEVucmljaGVkIFBlcnNvbiBCIGltcGxpY2l0IGR1YWwgdHJhbnNpdHMgd2l0aCBob29rcyAmIGZpbHRlcmVkX2FzcGVjdHNcbiAgICAgICAgICAgIHJlc3VsdC5wZXJzb25fYi5jaGFydCA9IHsgLi4uKHJlc3VsdC5wZXJzb25fYi5jaGFydCB8fCB7fSksIHRyYW5zaXRzQnlEYXRlOiBzZWlzbW9CLmRhaWx5LCBwcm92ZW5hbmNlQnlEYXRlOiBwcm92ZW5hbmNlQnlEYXRlQiB9O1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLmRlcml2ZWQgPSByZXN1bHQucGVyc29uX2IuZGVyaXZlZCB8fCB7fTtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJzb25fYi5kZXJpdmVkLnNlaXNtb2dyYXBoX3N1bW1hcnkgPSBzZWlzbW9CLnN1bW1hcnk7XG4gICAgICAgICAgICByZXN1bHQucGVyc29uX2IuZGVyaXZlZC50Mm5fYXNwZWN0cyA9IG1hcFQyTkFzcGVjdHMoYWxsQik7XG4gICAgICAgICAgICByZXN1bHQucGVyc29uX2IudHJhbnNpdF9kYXRhID0gT2JqZWN0LnZhbHVlcyh0cmFuc2l0c0J5RGF0ZUIpO1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLmltcGxpY2l0X2R1YWxfdHJhbnNpdHMgPSB0cnVlOyAvLyBwcm92ZW5hbmNlIGZsYWdcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignSW1wbGljaXQgZHVhbCBQZXJzb24gQiB0cmFuc2l0cyBmZXRjaCBmYWlsZWQnLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVzdWx0LnBlcnNvbl9iLnRyYW5zaXRzX2Vycm9yID0gJ0ZhaWxlZCB0byBjb21wdXRlIFBlcnNvbiBCIHRyYW5zaXRzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wZXJzb25fYiA9IHsgLi4uKHJlc3VsdC5wZXJzb25fYiB8fCB7fSksIGRldGFpbHM6IHBlcnNvbkIsIHZhbGlkYXRpb25fZXJyb3I6IHZCTGVhblBhc3NpdmUyLm1lc3NhZ2UgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzKSBTeW5hc3RyeSAoY2hhcnQgKyBhc3BlY3RzLCBvciBzeW5hc3RyeSBhc3BlY3RzLW9ubHkpXG4gIGNvbnN0IHZhbGlkQkxlYW4gPSB2YWxpZGF0ZVN1YmplY3RMZWFuKHBlcnNvbkIpO1xuICBjb25zdCB2YWxpZEJTdHJpY3QgPSB2YWxpZGF0ZVN1YmplY3QocGVyc29uQik7XG4gIGlmICh3YW50U3luYXN0cnlBc3BlY3RzT25seSAmJiB2YWxpZEJMZWFuLmlzVmFsaWQpIHtcbiAgICAgIC8vIFN5bmFzdHJ5IGFzcGVjdHMtb25seSBlbmRwb2ludFxuICAgICAgY29uc3Qgc3luID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeShcbiAgICAgICAgQVBJX0VORFBPSU5UUy5TWU5BU1RSWV9BU1BFQ1RTLFxuICAgICAgICB7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGZpcnN0X3N1YmplY3Q6IHN1YmplY3RUb0FQSShwZXJzb25BLCB7IC4uLnBhc3MsIHJlcXVpcmVfY2l0eTogdHJ1ZSB9KSwgc2Vjb25kX3N1YmplY3Q6IHN1YmplY3RUb0FQSShwZXJzb25CLCB7IC4uLnBhc3MsIHJlcXVpcmVfY2l0eTogdHJ1ZSB9KSB9KSB9LFxuICAgICAgICAnU3luYXN0cnkgYXNwZWN0cyBkYXRhJ1xuICAgICAgKTtcbiAgY29uc3Qgc3luRGF0YSA9IHN0cmlwR3JhcGhpY3NEZWVwKHN5bi5kYXRhIHx8IHt9KTtcbiAgcmVzdWx0LnBlcnNvbl9iID0geyAuLi4ocmVzdWx0LnBlcnNvbl9iIHx8IHt9KSwgZGV0YWlsczogcGVyc29uQiB9O1xuICByZXN1bHQuc3luYXN0cnlfYXNwZWN0cyA9IEFycmF5LmlzQXJyYXkoc3luLmFzcGVjdHMpID8gc3luLmFzcGVjdHMgOiAoc3luRGF0YS5hc3BlY3RzIHx8IFtdKTtcbiAgcmVzdWx0LnN5bmFzdHJ5X2RhdGEgPSBzeW5EYXRhO1xuICBcbiAgICAgIC8vIEdlbmVyYXRlIHJlbGF0aW9uYWwgbWlycm9yIGZvciBzeW5hc3RyeS1hc3BlY3RzLW9ubHkgbW9kZVxuICAgICAgY29uc3QgcmVsYXRpb25hbE1pcnJvciA9IGdlbmVyYXRlUmVsYXRpb25hbE1pcnJvcihcbiAgICAgICAgcmVzdWx0LnBlcnNvbl9hIHx8IHsgZGV0YWlsczogcGVyc29uQSwgYXNwZWN0czogW10gfSxcbiAgICAgICAgeyBkZXRhaWxzOiBwZXJzb25CLCBhc3BlY3RzOiBbXSB9LFxuICAgICAgICByZXN1bHQuc3luYXN0cnlfYXNwZWN0cyxcbiAgICAgICAgeyBhc3BlY3RzOiBbXSwgcmF3OiB7fSB9LCAvLyBObyBjb21wb3NpdGUgaW4gYXNwZWN0cy1vbmx5IG1vZGVcbiAgICAgICAge31cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCByZWxhdGlvbmFsIHByb2Nlc3NpbmcgdG8gc3luYXN0cnkgcmVzdWx0c1xuICAgICAgcmVzdWx0LnN5bmFzdHJ5X3JlbGF0aW9uYWxfbWlycm9yID0gcmVsYXRpb25hbE1pcnJvci5yZWxhdGlvbmFsX21pcnJvcjtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQWRkZWQgcmVsYXRpb25hbCBtaXJyb3IgdG8gc3luYXN0cnktYXNwZWN0cy1vbmx5IG1vZGUnKTtcbiAgICAgIC8vIE9wdGlvbmFsOiBhdWdtZW50IHdpdGggUGVyc29uIEIgbmF0YWwgY2hhcnQgc28gVUkgaGFzIGJvdGggY2hhcnRzIGluIGFzcGVjdHMtb25seSBtb2RlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuYXRhbEIgPSBhd2FpdCBjYWxsTmF0YWwoXG4gICAgICAgICAgQVBJX0VORFBPSU5UUy5CSVJUSF9DSEFSVCxcbiAgICAgICAgICBwZXJzb25CLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgcGFzcyxcbiAgICAgICAgICAnQmlydGggY2hhcnQgKEIgZm9yIHN5bmFzdHJ5LWFzcGVjdHMpJ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBjaGFydERhdGFCID0gc3RyaXBHcmFwaGljc0RlZXAobmF0YWxCLmRhdGEgfHwge30pO1xuICAgICAgICByZXN1bHQucGVyc29uX2IuY2hhcnQgPSBjaGFydERhdGFCO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGF1Z21lbnQgc3luYXN0cnktYXNwZWN0cyB3aXRoIFBlcnNvbiBCIG5hdGFsIGNoYXJ0JywgZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdhbnRTeW5hc3RyeSAmJiB2YWxpZEJTdHJpY3QuaXNWYWxpZCkge1xuICAgICAgLy8gRnVsbCBzeW5hc3RyeSBjaGFydCBlbmRwb2ludFxuICAgICAgY29uc3Qgc3luID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeShcbiAgICAgICAgQVBJX0VORFBPSU5UUy5TWU5BU1RSWV9DSEFSVCxcbiAgICAgICAgeyBtZXRob2Q6ICdQT1NUJywgaGVhZGVycywgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBmaXJzdF9zdWJqZWN0OiBzdWJqZWN0VG9BUEkocGVyc29uQSwgeyAuLi5wYXNzLCByZXF1aXJlX2NpdHk6IHRydWUgfSksIHNlY29uZF9zdWJqZWN0OiBzdWJqZWN0VG9BUEkocGVyc29uQiwgeyAuLi5wYXNzLCByZXF1aXJlX2NpdHk6IHRydWUgfSkgfSkgfSxcbiAgICAgICAgJ1N5bmFzdHJ5IGNoYXJ0J1xuICAgICAgKTtcbiAgY29uc3Qgc3luQ2xlYW4gPSBzdHJpcEdyYXBoaWNzRGVlcChzeW4uZGF0YSB8fCB7fSk7XG4gIHJlc3VsdC5wZXJzb25fYiA9IHsgZGV0YWlsczogcGVyc29uQiwgY2hhcnQ6IHN5bkNsZWFuLnNlY29uZF9zdWJqZWN0IHx8IHt9IH07XG4gIHJlc3VsdC5zeW5hc3RyeV9hc3BlY3RzID0gQXJyYXkuaXNBcnJheShzeW4uYXNwZWN0cykgPyBzeW4uYXNwZWN0cyA6IChzeW5DbGVhbi5hc3BlY3RzIHx8IFtdKTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgcmVsYXRpb25hbCBtaXJyb3IgZm9yIGZ1bGwgc3luYXN0cnkgbW9kZVxuICAgICAgY29uc3QgcmVsYXRpb25hbE1pcnJvciA9IGdlbmVyYXRlUmVsYXRpb25hbE1pcnJvcihcbiAgICAgICAgcmVzdWx0LnBlcnNvbl9hIHx8IHsgZGV0YWlsczogcGVyc29uQSwgYXNwZWN0czogW10gfSxcbiAgICAgICAgcmVzdWx0LnBlcnNvbl9iLFxuICAgICAgICByZXN1bHQuc3luYXN0cnlfYXNwZWN0cyxcbiAgICAgICAgeyBhc3BlY3RzOiBbXSwgcmF3OiB7fSB9LCAvLyBObyBjb21wb3NpdGUgaW4gc3luYXN0cnkgbW9kZVxuICAgICAgICB7fVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHJlbGF0aW9uYWwgcHJvY2Vzc2luZyB0byBzeW5hc3RyeSByZXN1bHRzXG4gICAgICByZXN1bHQuc3luYXN0cnlfcmVsYXRpb25hbF9taXJyb3IgPSByZWxhdGlvbmFsTWlycm9yLnJlbGF0aW9uYWxfbWlycm9yO1xuICAgICAgbG9nZ2VyLmRlYnVnKCdBZGRlZCByZWxhdGlvbmFsIG1pcnJvciB0byBmdWxsIHN5bmFzdHJ5IG1vZGUnKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIFBlcnNvbiBCIHRyYW5zaXRzIGZvciBzeW5hc3RyeSBtb2RlcyAoZXNwZWNpYWxseSBTWU5BU1RSWV9UUkFOU0lUUylcbiAgICAgIGlmIChtb2RlVG9rZW4gPT09ICdTWU5BU1RSWV9UUkFOU0lUUycgJiYgaGF2ZVJhbmdlICYmICFza2lwVHJhbnNpdHMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdDb21wdXRpbmcgUGVyc29uIEIgdHJhbnNpdHMgZm9yIHN5bmFzdHJ5IG1vZGU6JywgeyBzdGFydCwgZW5kLCBzdGVwIH0pO1xuICAgICAgY29uc3QgeyB0cmFuc2l0c0J5RGF0ZTogdHJhbnNpdHNCeURhdGVCLCByZXRyb0ZsYWdzQnlEYXRlOiByZXRyb0ZsYWdzQnlEYXRlQiwgcHJvdmVuYW5jZUJ5RGF0ZTogcHJvdmVuYW5jZUJ5RGF0ZUIgfSA9IGF3YWl0IGdldFRyYW5zaXRzKHBlcnNvbkIsIHsgc3RhcnREYXRlOiBzdGFydCwgZW5kRGF0ZTogZW5kLCBzdGVwIH0sIGhlYWRlcnMsIHBhc3MpO1xuICAgICAgICByZXN1bHQucGVyc29uX2IuY2hhcnQgPSB7IC4uLnJlc3VsdC5wZXJzb25fYi5jaGFydCwgdHJhbnNpdHNCeURhdGU6IHRyYW5zaXRzQnlEYXRlQiB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgc2Vpc21vZ3JhcGggYW5hbHlzaXMgdG8gUGVyc29uIEIgdHJhbnNpdHNcbiAgY29uc3Qgc2Vpc21vZ3JhcGhEYXRhQiA9IGNhbGN1bGF0ZVNlaXNtb2dyYXBoKHRyYW5zaXRzQnlEYXRlQiwgcmV0cm9GbGFnc0J5RGF0ZUIpO1xuICAvLyBFbnJpY2hlZCBQZXJzb24gQiBzeW5hc3RyeSB0cmFuc2l0c1xuICAgICAgICByZXN1bHQucGVyc29uX2IuY2hhcnQudHJhbnNpdHNCeURhdGUgPSBzZWlzbW9ncmFwaERhdGFCLmRhaWx5O1xuICAgICAgICByZXN1bHQucGVyc29uX2IuY2hhcnQucHJvdmVuYW5jZUJ5RGF0ZSA9IHByb3ZlbmFuY2VCeURhdGVCO1xuICAgICAgICByZXN1bHQucGVyc29uX2IuZGVyaXZlZCA9IHsgXG4gICAgICAgICAgc2Vpc21vZ3JhcGhfc3VtbWFyeTogc2Vpc21vZ3JhcGhEYXRhQi5zdW1tYXJ5LFxuICAgICAgICAgIHQybl9hc3BlY3RzOiBtYXBUMk5Bc3BlY3RzKE9iamVjdC52YWx1ZXModHJhbnNpdHNCeURhdGVCKS5mbGF0TWFwKGRheSA9PiBkYXkpKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdQZXJzb24gQiB0cmFuc2l0cyBjb21wbGV0ZWQgZm9yIHN5bmFzdHJ5IG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA9PT0gQ09NUE9TSVRFIENIQVJUUyBBTkQgVFJBTlNJVFMgPT09XG4gIGNvbnN0IHZCID0gcGVyc29uQiA/IHZhbGlkYXRlU3ViamVjdExlYW4ocGVyc29uQikgOiB7IGlzVmFsaWQ6ZmFsc2UgfTtcbiAgaWYgKHdhbnRDb21wb3NpdGUgJiYgdkIuaXNWYWxpZCkge1xuICAgICAgLy8gU3RlcCAxOiBBbHdheXMgY29tcHV0ZSBjb21wb3NpdGUgYXNwZWN0cyBmaXJzdCAoZGF0YS1vbmx5IGVuZHBvaW50KVxuICAgICAgLy8gVGhpcyBjcmVhdGVzIHRoZSBtaWRwb2ludCBjb21wb3NpdGUgY2hhcnQgZGF0YSB0aGF0IHNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgdHJhbnNpdHNcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZSA9IGF3YWl0IGNvbXB1dGVDb21wb3NpdGUocGVyc29uQSwgcGVyc29uQiwgcGFzcywgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMS41OiBBZGQgbmF0YWwgc2NhZmZvbGRpbmcgZm9yIGJvdGggcGVyc29ucyAocmVxdWlyZWQgZm9yIGZ1bGwgcmVsYXRpb25hbCBtaXJyb3IpXG4gICAgICAvLyBDUklUSUNBTCBGSVg6IENvbXBvc2l0ZSByZXBvcnRzIG5lZWQgYm90aCBuYXRhbCBjaGFydHMgdG8gZ2VuZXJhdGUgcG9sYXJpdHkgY2FyZHMsIFxuICAgICAgLy8gRWNobyBMb29wcywgYW5kIFNTVCBsb2dzLiBXaXRob3V0IHRoaXMgc2NhZmZvbGRpbmcsIHRoZSBQb2V0aWMgQnJhaW4gb25seSBnZXRzXG4gICAgICAvLyBCYWxhbmNlIE1ldGVyIGRhdGEgYW5kIG1ldGFkYXRhLCBtaXNzaW5nIHRoZSBmb3VuZGF0aW9uYWwgY2hhcnQgZ2VvbWV0cmllcy5cbiAgICAgIC8vIEVuc3VyZSBQZXJzb24gQiBuYXRhbCBjaGFydCBpcyBpbmNsdWRlZCBpZiBub3QgYWxyZWFkeSBmZXRjaGVkXG4gICAgICBpZiAoIXJlc3VsdC5wZXJzb25fYiB8fCAhcmVzdWx0LnBlcnNvbl9iLmNoYXJ0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKCdGZXRjaGluZyBQZXJzb24gQiBuYXRhbCBjaGFydCBmb3IgY29tcG9zaXRlIHNjYWZmb2xkaW5nJyk7XG4gICAgICAgICAgY29uc3QgbmF0YWxCID0gYXdhaXQgY2FsbE5hdGFsKFxuICAgICAgICAgICAgQVBJX0VORFBPSU5UUy5CSVJUSF9DSEFSVCxcbiAgICAgICAgICAgIHBlcnNvbkIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcGFzcyxcbiAgICAgICAgICAgICdCaXJ0aCBjaGFydCAoQiBmb3IgY29tcG9zaXRlIHNjYWZmb2xkaW5nKSdcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGNoYXJ0RGF0YUIgPSBzdHJpcEdyYXBoaWNzRGVlcChuYXRhbEIuZGF0YSB8fCB7fSk7XG4gICAgICAgICAgcmVzdWx0LnBlcnNvbl9iID0geyBcbiAgICAgICAgICAgIC4uLihyZXN1bHQucGVyc29uX2IgfHwge30pLCBcbiAgICAgICAgICAgIGRldGFpbHM6IHBlcnNvbkIsIFxuICAgICAgICAgICAgY2hhcnQ6IGNoYXJ0RGF0YUIsXG4gICAgICAgICAgICBhc3BlY3RzOiBBcnJheS5pc0FycmF5KG5hdGFsQi5hc3BlY3RzKSA/IG5hdGFsQi5hc3BlY3RzIDogKGNoYXJ0RGF0YUIuYXNwZWN0cyB8fCBbXSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnUGVyc29uIEIgbmF0YWwgY2hhcnQgYWRkZWQgdG8gY29tcG9zaXRlIHNjYWZmb2xkaW5nJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGZldGNoIFBlcnNvbiBCIG5hdGFsIGNoYXJ0IGZvciBjb21wb3NpdGUgc2NhZmZvbGRpbmcnLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgIHJlc3VsdC5wZXJzb25fYiA9IHsgLi4uKHJlc3VsdC5wZXJzb25fYiB8fCB7fSksIGRldGFpbHM6IHBlcnNvbkIgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGVyc29uIEIgY2hhcnQgYWxyZWFkeSBleGlzdHMsIGp1c3QgZW5zdXJlIGRldGFpbHMgYXJlIGluY2x1ZGVkXG4gICAgICAgIHJlc3VsdC5wZXJzb25fYiA9IHsgLi4uKHJlc3VsdC5wZXJzb25fYiB8fCB7fSksIGRldGFpbHM6IHBlcnNvbkIgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIHN5bmFzdHJ5IGFzcGVjdHMgZm9yIGNyb3NzLWZpZWxkIGhvb2tzIGFuZCBwb2xhcml0eSBjYXJkc1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdDb21wdXRpbmcgc3luYXN0cnkgYXNwZWN0cyBmb3IgY29tcG9zaXRlIHNjYWZmb2xkaW5nJyk7XG4gICAgICAgIGNvbnN0IHN5biA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoXG4gICAgICAgICAgQVBJX0VORFBPSU5UUy5TWU5BU1RSWV9BU1BFQ1RTLFxuICAgICAgICAgIHsgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnMsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZmlyc3Rfc3ViamVjdDogc3ViamVjdFRvQVBJKHBlcnNvbkEsIHBhc3MpLCBzZWNvbmRfc3ViamVjdDogc3ViamVjdFRvQVBJKHBlcnNvbkIsIHBhc3MpIH0pIH0sXG4gICAgICAgICAgJ1N5bmFzdHJ5IGFzcGVjdHMgZm9yIGNvbXBvc2l0ZSBzY2FmZm9sZGluZydcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3luRGF0YSA9IHN0cmlwR3JhcGhpY3NEZWVwKHN5bi5kYXRhIHx8IHt9KTtcbiAgICAgICAgY29uc3Qgc3luYXN0cnlBc3BlY3RzID0gQXJyYXkuaXNBcnJheShzeW4uYXNwZWN0cykgPyBzeW4uYXNwZWN0cyA6IChzeW5EYXRhLmFzcGVjdHMgfHwgW10pO1xuICAgICAgICBcbiAgICAgICAgLy8gR2VuZXJhdGUgY29tcHJlaGVuc2l2ZSByZWxhdGlvbmFsIG1pcnJvciB3aXRoIGFsbCBtaXNzaW5nIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHJlbGF0aW9uYWxNaXJyb3IgPSBnZW5lcmF0ZVJlbGF0aW9uYWxNaXJyb3IoXG4gICAgICAgICAgcmVzdWx0LnBlcnNvbl9hIHx8IHsgZGV0YWlsczogcGVyc29uQSwgYXNwZWN0czogW10gfSxcbiAgICAgICAgICByZXN1bHQucGVyc29uX2IgfHwgeyBkZXRhaWxzOiBwZXJzb25CLCBhc3BlY3RzOiBbXSB9LFxuICAgICAgICAgIHN5bmFzdHJ5QXNwZWN0cyxcbiAgICAgICAgICBjb21wb3NpdGUsXG4gICAgICAgICAge30gLy8gY29tcG9zaXRlIHRyYW5zaXRzIHdpbGwgYmUgYWRkZWQgbGF0ZXIgaWYgZGF0ZSByYW5nZSBwcm92aWRlZFxuICAgICAgICApO1xuXG4gICAgICAgIHJlc3VsdC5jb21wb3NpdGUgPSB7IFxuICAgICAgICAgIGFzcGVjdHM6IGNvbXBvc2l0ZS5hc3BlY3RzLCAgICAgIC8vIENvbXBvc2l0ZSBjaGFydCBpbnRlcm5hbCBhc3BlY3RzXG4gICAgICAgICAgZGF0YTogY29tcG9zaXRlLnJhdywgICAgICAgICAgICAvLyBSYXcgY29tcG9zaXRlIGNoYXJ0IGRhdGEgZm9yIGZ1cnRoZXIgY2FsY3VsYXRpb25zXG4gICAgICAgICAgc3luYXN0cnlfYXNwZWN0czogc3luYXN0cnlBc3BlY3RzLCAvLyBDcm9zcy1jaGFydCBhc3BlY3RzIGZvciByZWxhdGlvbmFsIG1hcHBpbmdcbiAgICAgICAgICBzeW5hc3RyeV9kYXRhOiBzeW5EYXRhLCAgICAgICAgICAvLyBBZGRpdGlvbmFsIHN5bmFzdHJ5IGRhdGFcbiAgICAgICAgICAuLi5yZWxhdGlvbmFsTWlycm9yICAgICAgICAgICAgIC8vIEluY2x1ZGUgY29tcHJlaGVuc2l2ZSByZWxhdGlvbmFsIHByb2Nlc3NpbmdcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBBZGRlZCAke3N5bmFzdHJ5QXNwZWN0cy5sZW5ndGh9IHN5bmFzdHJ5IGFzcGVjdHMgYW5kIGNvbXBsZXRlIHJlbGF0aW9uYWwgbWlycm9yIHRvIGNvbXBvc2l0ZSBzY2FmZm9sZGluZ2ApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGNvbXB1dGUgc3luYXN0cnkgYXNwZWN0cyBmb3IgY29tcG9zaXRlIHNjYWZmb2xkaW5nJywgZS5tZXNzYWdlKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgcmVsYXRpb25hbCBtaXJyb3IgZXZlbiB3aXRob3V0IHN5bmFzdHJ5IGFzcGVjdHMgKGxpbWl0ZWQgYnV0IHN0aWxsIHJlbGF0aW9uYWwpXG4gICAgICAgIGNvbnN0IHJlbGF0aW9uYWxNaXJyb3IgPSBnZW5lcmF0ZVJlbGF0aW9uYWxNaXJyb3IoXG4gICAgICAgICAgcmVzdWx0LnBlcnNvbl9hIHx8IHsgZGV0YWlsczogcGVyc29uQSwgYXNwZWN0czogW10gfSxcbiAgICAgICAgICByZXN1bHQucGVyc29uX2IgfHwgeyBkZXRhaWxzOiBwZXJzb25CLCBhc3BlY3RzOiBbXSB9LFxuICAgICAgICAgIFtdLCAvLyBObyBzeW5hc3RyeSBhc3BlY3RzIGF2YWlsYWJsZVxuICAgICAgICAgIGNvbXBvc2l0ZSxcbiAgICAgICAgICB7fVxuICAgICAgICApO1xuXG4gICAgICAgIHJlc3VsdC5jb21wb3NpdGUgPSB7IFxuICAgICAgICAgIGFzcGVjdHM6IGNvbXBvc2l0ZS5hc3BlY3RzLCAgICAvLyBDb21wb3NpdGUgY2hhcnQgaW50ZXJuYWwgYXNwZWN0c1xuICAgICAgICAgIGRhdGE6IGNvbXBvc2l0ZS5yYXcsICAgICAgICAgICAvLyBSYXcgY29tcG9zaXRlIGNoYXJ0IGRhdGEgZm9yIGZ1cnRoZXIgY2FsY3VsYXRpb25zXG4gICAgICAgICAgLi4ucmVsYXRpb25hbE1pcnJvciAgICAgICAgICAgIC8vIEluY2x1ZGUgcmVsYXRpb25hbCBwcm9jZXNzaW5nIGV2ZW4gd2l0aG91dCBzeW5hc3RyeVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gIC8vIFN0ZXAgMjogQ29tcG9zaXRlIHRyYW5zaXRzOiBURU1QT1JBUklMWSBESVNBQkxFRCBkdWUgdG8gQVBJIGNvbXBhdGliaWxpdHkgaXNzdWVzXG4gIC8vIFRoZSB0cmFuc2l0IEFQSSBleHBlY3RzIG5hdGFsIGNoYXJ0IGJpcnRoIGRhdGEgYnV0IGNvbXBvc2l0ZSBjaGFydHMgb25seSBoYXZlIHBsYW5ldGFyeSBwb3NpdGlvbnNcbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgdGhlcmUncyBhIHNwZWNpZmljIGNvbXBvc2l0ZSB0cmFuc2l0IGVuZHBvaW50IG9yIGlmIHdlIG5lZWQgc3ludGhldGljIGJpcnRoIGRhdGFcbiAgaWYgKGhhdmVSYW5nZSAmJiAhc2tpcFRyYW5zaXRzICYmIChtb2RlVG9rZW4gPT09ICdDT01QT1NJVEVfVFJBTlNJVFMnKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0NvbXB1dGluZyBjb21wb3NpdGUgdHJhbnNpdHMgZm9yIGRhdGUgcmFuZ2U6JywgeyBzdGFydCwgZW5kLCBzdGVwIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRyYW5zaXRzIHRvIHRoZSBjb21wb3NpdGUgY2hhcnQgdXNpbmcgdGhlIGNvbXBvc2l0ZSBjaGFydCBhcyBiYXNlXG4gIGNvbnN0IHQgPSBhd2FpdCBjb21wdXRlQ29tcG9zaXRlVHJhbnNpdHMoY29tcG9zaXRlLnJhdywgc3RhcnQsIGVuZCwgc3RlcCwgcGFzcywgaGVhZGVycyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSByYXcgdHJhbnNpdCBhc3BlY3RzIGJ5IGRhdGVcbiAgICAgICAgcmVzdWx0LmNvbXBvc2l0ZS50cmFuc2l0c0J5RGF0ZSA9IHQudHJhbnNpdHNCeURhdGU7XG4gICAgICAgIGlmICh0Ll9ub3RlKSByZXN1bHQuY29tcG9zaXRlLm5vdGUgPSB0Ll9ub3RlO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAzOiBBcHBseSBzZWlzbW9ncmFwaCBhbmFseXNpcyB0byBjb21wb3NpdGUgdHJhbnNpdHNcbiAgICAgICAgLy8gVGhpcyBjb252ZXJ0cyByYXcgYXNwZWN0cyBpbnRvIG1hZ25pdHVkZSwgdmFsZW5jZSwgYW5kIHZvbGF0aWxpdHkgbWV0cmljc1xuICBjb25zdCBzZWlzbW9ncmFwaERhdGEgPSBjYWxjdWxhdGVTZWlzbW9ncmFwaCh0LnRyYW5zaXRzQnlEYXRlLCB7fSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIHJhdyBhc3BlY3RzIHdpdGggc2Vpc21vZ3JhcGgtcHJvY2Vzc2VkIGRhaWx5IGRhdGFcbiAgLy8gRW5yaWNoZWQgY29tcG9zaXRlIHRyYW5zaXRzIHdpdGggaG9va3MgJiBmaWx0ZXJlZF9hc3BlY3RzXG4gIHJlc3VsdC5jb21wb3NpdGUudHJhbnNpdHNCeURhdGUgPSBzZWlzbW9ncmFwaERhdGEuZGFpbHk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZGVyaXZlZCBtZXRyaWNzIGZvciBmcm9udGVuZCBjb25zdW1wdGlvblxuICAgICAgICByZXN1bHQuY29tcG9zaXRlLmRlcml2ZWQgPSB7IFxuICAgICAgICAgIHNlaXNtb2dyYXBoX3N1bW1hcnk6IHNlaXNtb2dyYXBoRGF0YS5zdW1tYXJ5IFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHJlbGF0aW9uYWwgQmFsYW5jZSBNZXRlciB3aXRoIHRyYW5zaXQgZGF0YSBpZiByZWxhdGlvbmFsIG1pcnJvciBleGlzdHNcbiAgICAgICAgaWYgKHJlc3VsdC5jb21wb3NpdGUucmVsYXRpb25hbF9taXJyb3IpIHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUmVsYXRpb25hbEJhbGFuY2VNZXRlciA9IGNvbXB1dGVSZWxhdGlvbmFsQmFsYW5jZU1ldGVyKFxuICAgICAgICAgICAgcmVzdWx0LmNvbXBvc2l0ZS5zeW5hc3RyeV9hc3BlY3RzIHx8IFtdLFxuICAgICAgICAgICAgcmVzdWx0LmNvbXBvc2l0ZS5hc3BlY3RzIHx8IFtdLFxuICAgICAgICAgICAgc2Vpc21vZ3JhcGhEYXRhLmRhaWx5XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQuY29tcG9zaXRlLnJlbGF0aW9uYWxfbWlycm9yLnJlbGF0aW9uYWxfYmFsYW5jZV9tZXRlciA9IHVwZGF0ZWRSZWxhdGlvbmFsQmFsYW5jZU1ldGVyO1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnVXBkYXRlZCByZWxhdGlvbmFsIEJhbGFuY2UgTWV0ZXIgd2l0aCBjb21wb3NpdGUgdHJhbnNpdCBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFubm90YXRlIGlmIHRyYW5zaXRzIHdlcmUgYXV0by1hZGRlZCAobW9kZSBub3QgZXhwbGljaXRseSBDT01QT1NJVEVfVFJBTlNJVFMpXG4gICAgICAgIGlmIChtb2RlVG9rZW4gIT09ICdDT01QT1NJVEVfVFJBTlNJVFMnKSB7XG4gICAgICAgICAgcmVzdWx0LmNvbXBvc2l0ZS5hdXRvX3RyYW5zaXRzX2luY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQuY29tcG9zaXRlLnJlcXVlc3RfbW9kZSA9IG1vZGVUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ0NvbXBvc2l0ZSB0cmFuc2l0cyBjb21wbGV0ZWQgd2l0aCBzZWlzbW9ncmFwaCBhbmFseXNpcycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgbm90ZSBhYm91dCBkaXNhYmxlZCBjb21wb3NpdGUgdHJhbnNpdHMgb25seSB3aGVuIG5vdCBleHBsaWNpdGx5IHJlcXVlc3RlZFxuICAgICAgaWYgKGhhdmVSYW5nZSAmJiAhc2tpcFRyYW5zaXRzICYmIG1vZGVUb2tlbiAhPT0gJ0NPTVBPU0lURV9UUkFOU0lUUycpIHtcbiAgICAgICAgcmVzdWx0LmNvbXBvc2l0ZS50cmFuc2l0c0J5RGF0ZSA9IHt9O1xuICAgICAgICByZXN1bHQuY29tcG9zaXRlLm5vdGUgPSAnQ29tcG9zaXRlIHRyYW5zaXRzIHRlbXBvcmFyaWx5IGRpc2FibGVkIGR1ZSB0byBBUEkgY29tcGF0aWJpbGl0eSBpc3N1ZXMnO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0NvbXBvc2l0ZSB0cmFuc2l0cyBkaXNhYmxlZCAtIHJldHVybmluZyBlbXB0eSB0cmFuc2l0IGRhdGEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA9PT0gQkFMQU5DRSBNRVRFUiBNT0RFID09PVxuICAgIC8vIE9ubHkgZ2VuZXJhdGUgQmFsYW5jZSBNZXRlciBmb3Igc29sbyByZXBvcnRzLCBub3QgcmVsYXRpb25hbCBvbmVzXG4gICAgbG9nZ2VyLmRlYnVnKCdDaGVja2luZyBCYWxhbmNlIE1ldGVyIGNvbmRpdGlvbnM6Jywge1xuICAgICAgd2FudEJhbGFuY2VNZXRlcixcbiAgICAgIGhhdmVSYW5nZSxcbiAgICAgIHJlbGF0aW9uc2hpcE1vZGUsXG4gICAgICBzaG91bGRSdW5CYWxhbmNlTWV0ZXI6IHdhbnRCYWxhbmNlTWV0ZXIgJiYgaGF2ZVJhbmdlICYmICFyZWxhdGlvbnNoaXBNb2RlXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHdhbnRCYWxhbmNlTWV0ZXIgJiYgaGF2ZVJhbmdlICYmICFyZWxhdGlvbnNoaXBNb2RlKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1Byb2Nlc3NpbmcgQmFsYW5jZSBNZXRlciBtb2RlIGZvciBzdGFuZGFsb25lIHJlcG9ydCcpO1xuXG4gICAgICAvLyBFbnN1cmUgUGVyc29uIEEgdHJhbnNpdCBzZWlzbW9ncmFwaCBleGlzdHM7IGNvbXB1dGUgaWYgbWlzc2luZ1xuICAgICAgaWYgKCFyZXN1bHQucGVyc29uX2E/LmNoYXJ0Py50cmFuc2l0c0J5RGF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgdHJhbnNpdHNCeURhdGUsIHJldHJvRmxhZ3NCeURhdGUsIHByb3ZlbmFuY2VCeURhdGUgfSA9IGF3YWl0IGdldFRyYW5zaXRzKHBlcnNvbkEsIHsgc3RhcnREYXRlOiBzdGFydCwgZW5kRGF0ZTogZW5kLCBzdGVwIH0sIGhlYWRlcnMsIHBhc3MpO1xuICAgICAgICAgIGNvbnN0IHNlaXNtb2dyYXBoRGF0YSA9IGNhbGN1bGF0ZVNlaXNtb2dyYXBoKHRyYW5zaXRzQnlEYXRlLCByZXRyb0ZsYWdzQnlEYXRlKTtcbiAgICAgICAgICByZXN1bHQucGVyc29uX2EgPSByZXN1bHQucGVyc29uX2EgfHwge307XG4gICAgICAgICAgcmVzdWx0LnBlcnNvbl9hLmRlcml2ZWQgPSByZXN1bHQucGVyc29uX2EuZGVyaXZlZCB8fCB7fTtcbiAgICAgICAgICByZXN1bHQucGVyc29uX2EuZGVyaXZlZC5zZWlzbW9ncmFwaF9zdW1tYXJ5ID0gc2Vpc21vZ3JhcGhEYXRhLnN1bW1hcnk7XG4gICAgICAgICAgcmVzdWx0LnBlcnNvbl9hLmNoYXJ0ID0geyAuLi4ocmVzdWx0LnBlcnNvbl9hLmNoYXJ0IHx8IHt9KSwgdHJhbnNpdHNCeURhdGU6IHNlaXNtb2dyYXBoRGF0YS5kYWlseSwgcHJvdmVuYW5jZUJ5RGF0ZSB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0JhbGFuY2UgTWV0ZXIgZmFsbGJhY2sgdHJhbnNpdCBjb21wdXRlIGZhaWxlZDonLCBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQucGVyc29uX2E/LmNoYXJ0Py50cmFuc2l0c0J5RGF0ZSkge1xuICAgICAgICAvLyBCYWxhbmNlIE1ldGVyIHJlcG9ydCBmb2N1c2VzIG9uIHRyaXBsZS1jaGFubmVsIHNlaXNtb2dyYXBoIG91dHB1dHNcbiAgICAgICAgY29uc3QgYmFsYW5jZU1ldGVyUmVwb3J0ID0ge1xuICAgICAgICAgIHBlcmlvZDoge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGVwOiBzdGVwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2hlbWFfdmVyc2lvbjogJzEuMicsXG4gICAgICAgICAgY2hhbm5lbF9zdW1tYXJ5OiByZXN1bHQucGVyc29uX2EuZGVyaXZlZD8uc2Vpc21vZ3JhcGhfc3VtbWFyeSB8fCBudWxsLFxuICAgICAgICAgIGRhaWx5X2VudHJpZXM6IHJlc3VsdC5wZXJzb25fYS5jaGFydC50cmFuc2l0c0J5RGF0ZSxcbiAgICAgICAgICBwZXJzb246IHtcbiAgICAgICAgICAgIG5hbWU6IHBlcnNvbkEubmFtZSB8fCAnU3ViamVjdCcsXG4gICAgICAgICAgICBiaXJ0aF9kYXRlOiBwZXJzb25BLmJpcnRoX2RhdGUsXG4gICAgICAgICAgICBiaXJ0aF90aW1lOiBwZXJzb25BLmJpcnRoX3RpbWUsXG4gICAgICAgICAgICBiaXJ0aF9sb2NhdGlvbjogcGVyc29uQS5iaXJ0aF9sb2NhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXBsYWNlIHN0YW5kYXJkIG5hdGFsLWNlbnRyaWMgcmVzcG9uc2Ugd2l0aCBCYWxhbmNlIE1ldGVyIGZvY3VzXG4gICAgICAgIHJlc3VsdC5iYWxhbmNlX21ldGVyID0gYmFsYW5jZU1ldGVyUmVwb3J0O1xuICAgICAgICByZXN1bHQubW9kZSA9ICdiYWxhbmNlX21ldGVyJztcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdCYWxhbmNlIE1ldGVyIHN0YW5kYWxvbmUgcmVwb3J0IGdlbmVyYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdCYWxhbmNlIE1ldGVyIHJlcXVlc3RlZCBidXQgbm8gdHJhbnNpdHMgYXZhaWxhYmxlIHRvIGNvbXB1dGUgcmVwb3J0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUG9zdC1jb21wdXRlIGNvbnRyYWN0IGFzc2VydGlvbnM6IGlmIHJlbGF0aW9uc2hpcCBtb2RlIHJlcXVlc3RlZCBlbnN1cmUgcHJlc2VuY2Ugb2YgcGVyc29uX2IvY29tcG9zaXRlXG4gICAgaWYgKHJlbGF0aW9uc2hpcE1vZGUpIHtcbiAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgIGlmICgod2FudFN5bmFzdHJ5IHx8IHdhbnRTeW5hc3RyeUFzcGVjdHNPbmx5KSAmJiAhcmVzdWx0LnBlcnNvbl9iKSBtaXNzaW5nLnB1c2goJ3BlcnNvbl9iJyk7XG4gICAgICBpZiAod2FudENvbXBvc2l0ZSAmJiAhcmVzdWx0LmNvbXBvc2l0ZSkgbWlzc2luZy5wdXNoKCdjb21wb3NpdGUnKTtcbiAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUElQRUxJTkVfRFJPUFBFRF9CJyksIHsgY29kZTogJ1BJUEVMSU5FX0RST1BQRURfQicsIG1pc3NpbmcgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWwgbmFycmF0aXZlIGtleSBzY3J1YiAoZGVmZW5zZS1pbi1kZXB0aCBmb3IgQ2xlYXIgTWlycm9yIGNvbnRyYWN0KVxuICAgIGZ1bmN0aW9uIHNjcnViTmFycmF0aXZlS2V5cyhvYmope1xuICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybiBvYmo7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChzY3J1Yk5hcnJhdGl2ZUtleXMpO1xuICAgICAgY29uc3Qgb3V0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrLHZdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgaWYgKGsgPT09ICdmaWVsZCcgfHwgayA9PT0gJ3ZvaWNlJyB8fCBrID09PSAnbWFwJykgY29udGludWU7XG4gICAgICAgIG91dFtrXSA9IHNjcnViTmFycmF0aXZlS2V5cyh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8vIEF0dGFjaCByZWxvY2F0aW9uIGNvb3JkaW5hdGVzIHdoZW4gYXBwbGllZFxuICAgIHRyeSB7XG4gICAgICBpZiAocmVsb2NhdGlvbk1vZGUgPT09ICdBX2xvY2FsJykge1xuICAgICAgICBjb25zdCBsb2MgPSBhTG9jYWwgfHwgYm9keS5jdXN0b21fbG9jYXRpb24gfHwgbnVsbDtcbiAgICAgICAgaWYgKGxvYyAmJiB0eXBlb2YgbG9jLmxhdCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxvYy5sb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc3QgdHogPSBsb2MudHogfHwgKHRyYW5zaXRBPy50aW1lem9uZSkgfHwgbnVsbDtcbiAgICAgICAgICByZXN1bHQucHJvdmVuYW5jZS5yZWxvY2F0aW9uX2Nvb3JkcyA9IHsgbGF0OiBsb2MubGF0LCBsb246IGxvYy5sb24sIHR6IH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVsb2NhdGlvbk1vZGUgPT09ICdNaWRwb2ludCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2l0QT8ubGF0aXR1ZGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB0cmFuc2l0QT8ubG9uZ2l0dWRlID09PSAnbnVtYmVyJyAmJiB0cmFuc2l0QT8udGltZXpvbmUpIHtcbiAgICAgICAgICByZXN1bHQucHJvdmVuYW5jZS5yZWxvY2F0aW9uX2Nvb3JkcyA9IHsgbGF0OiB0cmFuc2l0QS5sYXRpdHVkZSwgbG9uOiB0cmFuc2l0QS5sb25naXR1ZGUsIHR6OiB0cmFuc2l0QS50aW1lem9uZSB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlbG9jYXRpb25Nb2RlID09PSAnQ3VzdG9tJykge1xuICAgICAgICBjb25zdCBjID0gYm9keS5jdXN0b21fbG9jYXRpb247XG4gICAgICAgIGlmIChjICYmIHR5cGVvZiBjLmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYy5sb25naXR1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmVzdWx0LnByb3ZlbmFuY2UucmVsb2NhdGlvbl9jb29yZHMgPSB7IGxhdDogYy5sYXRpdHVkZSwgbG9uOiBjLmxvbmdpdHVkZSwgdHo6IHRyYW5zaXRBPy50aW1lem9uZSB8fCBjLnRpbWV6b25lIHx8IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggeyAvKiBpZ25vcmUgKi8gfVxuXG4gICAgLy8gSHVtYW4tcmVhZGFibGUgaG91c2Ugc3lzdGVtXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhzID0gcmVzdWx0LnByb3ZlbmFuY2UuaG91c2Vfc3lzdGVtO1xuICAgICAgY29uc3QgbmFtZXMgPSB7IFA6J1BsYWNpZHVzJywgVzonV2hvbGUgU2lnbicsIFI6J1JlZ2lvbW9udGFudXMnLCBLOidLb2NoJywgQzonQ2FtcGFudXMnLCBFOidFcXVhbCcgfTtcbiAgICAgIGlmICh0eXBlb2YgaHMgPT09ICdzdHJpbmcnICYmIGhzLmxlbmd0aCA9PT0gMSAmJiBuYW1lc1toc10pIHtcbiAgICAgICAgcmVzdWx0LnByb3ZlbmFuY2UuaG91c2Vfc3lzdGVtX25hbWUgPSBuYW1lc1toc107XG4gICAgICB9XG4gICAgfSBjYXRjaCB7IC8qIGlnbm9yZSAqLyB9XG5cbiAgICAvLyBBdHRhY2ggYSBkYXRhLW9ubHkgV292ZW4gTWFwIHJlcG9ydCAoZG9lcyBub3QgYWRkIFZPSUNFIGNvbnRlbnQpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBlcmlvZCA9IChzdGFydCAmJiBlbmQpID8geyBzdGFydCwgZW5kLCBzdGVwIH0gOiBudWxsO1xuICAgICAgcmVzdWx0LndvdmVuX21hcCA9IGNvbXBvc2VXb3Zlbk1hcFJlcG9ydCh7IHJlc3VsdCwgbW9kZTogbW9kZVRva2VuLCBwZXJpb2QgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1dvdmVuIE1hcCBjb21wb3NlciBmYWlsZWQ6JywgZS5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzYWZlUmVzdWx0ID0gc2NydWJOYXJyYXRpdmVLZXlzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogMjAwLCBib2R5OiBKU09OLnN0cmluZ2lmeShzYWZlUmVzdWx0KSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcignSGFuZGxlciBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgZXJyb3I6IGVycm9yPy5tZXNzYWdlIHx8ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLFxuICBjb2RlOiBlcnJvcj8uY29kZSB8fCAnSU5URVJOQUxfRVJST1InLFxuICAgICAgICBlcnJvcklkOiBnZW5lcmF0ZUVycm9ySWQoKSxcbiAgICAgICAgc3RhY2s6IGVycm9yPy5zdGFjayB8fCBudWxsLFxuICAgICAgICBkZXRhaWxzOiBlcnJvclxuICAgICAgfSksXG4gICAgfTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDaXR5IFJlc29sdXRpb24gRW5kcG9pbnQgLSBIZWxwZXIgZm9yIGRlYnVnZ2luZyBjaXR5LT5jb29yZHMgcmVzb2x1dGlvblxuLy8gR0VUIC9hcGkvcmVzb2x2ZS1jaXR5P2NpdHk9QnJ5bitNYXdyJnN0YXRlPVBBJm5hdGlvbj1VU1xuLy8gUmV0dXJucyByZXNvbHZlZCBjb29yZGluYXRlcyBhbmQgdGltZXpvbmUgdG8gdmVyaWZ5IHdoYXQgdGhlIEFQSSBzZWVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMucmVzb2x2ZUNpdHkgPSBhc3luYyBmdW5jdGlvbihldmVudCkge1xuICB0cnkge1xuICAgIGNvbnN0IHFzID0gZXZlbnQucXVlcnlTdHJpbmdQYXJhbWV0ZXJzIHx8IHt9O1xuICAgIGNvbnN0IGNpdHkgPSBxcy5jaXR5O1xuICAgIGNvbnN0IHN0YXRlID0gcXMuc3RhdGU7XG4gICAgY29uc3QgbmF0aW9uID0gcXMubmF0aW9uIHx8ICdVUyc7XG4gICAgXG4gICAgaWYgKCFjaXR5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6ICdjaXR5IHBhcmFtZXRlciByZXF1aXJlZCcgfSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVXNlIHNhbWUgZm9ybWF0aW9uIGxvZ2ljIGFzIHRyYW5zaXQgc3ViamVjdHNcbiAgICBjb25zdCBjaXR5RmllbGQgPSBzdGF0ZSA/IGAke2NpdHl9LCAke3N0YXRlfWAgOiBjaXR5O1xuICAgIGNvbnN0IHRlc3RTdWJqZWN0ID0ge1xuICAgICAgbmFtZTogJ1Rlc3QgUmVzb2x1dGlvbicsXG4gICAgICB5ZWFyOiAyMDI1LCBtb250aDogMSwgZGF5OiAxLCBob3VyOiAxMiwgbWludXRlOiAwLFxuICAgICAgY2l0eTogY2l0eUZpZWxkLFxuICAgICAgbmF0aW9uOiBuYXRpb24sXG4gICAgICB6b2RpYWNfdHlwZTogJ1Ryb3BpYydcbiAgICB9O1xuICAgIFxuICAgIGlmIChwcm9jZXNzLmVudi5HRU9OQU1FU19VU0VSTkFNRSkge1xuICAgICAgdGVzdFN1YmplY3QuZ2VvbmFtZXNfdXNlcm5hbWUgPSBwcm9jZXNzLmVudi5HRU9OQU1FU19VU0VSTkFNRTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIG5hbWU6IHRlc3RTdWJqZWN0Lm5hbWUsXG4gICAgICB5ZWFyOiB0ZXN0U3ViamVjdC55ZWFyLFxuICAgICAgbW9udGg6IHRlc3RTdWJqZWN0Lm1vbnRoLFxuICAgICAgZGF5OiB0ZXN0U3ViamVjdC5kYXksXG4gICAgICBob3VyOiB0ZXN0U3ViamVjdC5ob3VyLFxuICAgICAgbWludXRlOiB0ZXN0U3ViamVjdC5taW51dGUsXG4gICAgICBjaXR5OiB0ZXN0U3ViamVjdC5jaXR5LFxuICAgICAgbmF0aW9uOiB0ZXN0U3ViamVjdC5uYXRpb24sXG4gICAgICB6b2RpYWNfdHlwZTogdGVzdFN1YmplY3Quem9kaWFjX3R5cGUsXG4gICAgICAuLi4odGVzdFN1YmplY3QuZ2VvbmFtZXNfdXNlcm5hbWUgJiYgeyBnZW9uYW1lc191c2VybmFtZTogdGVzdFN1YmplY3QuZ2VvbmFtZXNfdXNlcm5hbWUgfSlcbiAgICB9O1xuXG4gICAgLy8gVXNlIGJpcnRoLWRhdGEgZW5kcG9pbnQgZm9yIHF1aWNrIHJlc29sdXRpb24gdGVzdFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeShcbiAgICAgIEFQSV9FTkRQT0lOVFMuQklSVEhfREFUQSxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gICAgICB9LFxuICAgICAgYENpdHkgcmVzb2x1dGlvbiB0ZXN0IGZvciAke2NpdHlGaWVsZH0sICR7bmF0aW9ufWBcbiAgICApO1xuXG4gICAgY29uc3QgcmVzb2x2ZWQgPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcXVlcnk6IHsgY2l0eSwgc3RhdGUsIG5hdGlvbiwgZm9ybWF0dGVkOiBjaXR5RmllbGQgfSxcbiAgICAgIHJlc29sdmVkOiB7XG4gICAgICAgIGxhdGl0dWRlOiByZXNwb25zZS5sYXQgfHwgcmVzcG9uc2UubGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTogcmVzcG9uc2UubG5nIHx8IHJlc3BvbnNlLmxvbmdpdHVkZSwgXG4gICAgICAgIHRpbWV6b25lOiByZXNwb25zZS50el9zdHIgfHwgcmVzcG9uc2UudGltZXpvbmUsXG4gICAgICAgIGNpdHlfcmVzb2x2ZWQ6IHJlc3BvbnNlLmNpdHksXG4gICAgICAgIG5hdGlvbl9yZXNvbHZlZDogcmVzcG9uc2UubmF0aW9uXG4gICAgICB9LFxuICAgICAgZ2VvbmFtZXNfdXNlZDogISF0ZXN0U3ViamVjdC5nZW9uYW1lc191c2VybmFtZSxcbiAgICAgIHJhd19yZXNwb25zZTogcmVzcG9uc2VcbiAgICB9O1xuXG4gICAgbG9nZ2VyLmluZm8oYENpdHkgcmVzb2x1dGlvbjogJHtjaXR5RmllbGR9LCAke25hdGlvbn0gLT4gJHtyZXNvbHZlZC5yZXNvbHZlZC5sYXRpdHVkZX0sICR7cmVzb2x2ZWQucmVzb2x2ZWQubG9uZ2l0dWRlfWApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVzb2x2ZWQpXG4gICAgfTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcignQ2l0eSByZXNvbHV0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0NpdHkgcmVzb2x1dGlvbiBmYWlsZWQnLFxuICAgICAgICBkZXRhaWxzOiBlcnJvclxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpZ2h0d2VpZ2h0IGhlYWx0aCBlbmRwb2ludCBsb2dpYyAoY29uc3VtZWQgYnkgYXN0cm9sb2d5LWhlYWx0aC5qcyB3cmFwcGVyKVxuLy8gUHJvdmlkZXM6IHZlcnNpb24sIGVudmlyb25tZW50LCBjb2xkIHN0YXJ0IGluZm8sIGJhc2ljIGNvbmZpZyB2YWxpZGF0aW9uLFxuLy8gb3B0aW9uYWwgZXh0ZXJuYWwgQVBJIGxhdGVuY3kgcHJvYmUgKG9wdC1pbiB2aWEgP3Bpbmc9bm93KVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5sZXQgX19SQ19DT0xEX1NUQVJUX1RTID0gZ2xvYmFsLl9fUkNfQ09MRF9TVEFSVF9UUyB8fCBEYXRlLm5vdygpO1xuZ2xvYmFsLl9fUkNfQ09MRF9TVEFSVF9UUyA9IF9fUkNfQ09MRF9TVEFSVF9UUztcbmxldCBfX1JDX0hFQUxUSF9JTlZPQ0FUSU9OUyA9IGdsb2JhbC5fX1JDX0hFQUxUSF9JTlZPQ0FUSU9OUyB8fCAwO1xuZ2xvYmFsLl9fUkNfSEVBTFRIX0lOVk9DQVRJT05TID0gX19SQ19IRUFMVEhfSU5WT0NBVElPTlM7XG5cbmFzeW5jIGZ1bmN0aW9uIHJhcGlkQXBpUGluZyhoZWFkZXJzKXtcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3QgdG8gPSBzZXRUaW1lb3V0KCgpPT5jb250cm9sbGVyLmFib3J0KCksIDM1MDApO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9FTkRQT0lOVFMuTk9XfWAsIHsgbWV0aG9kOidHRVQnLCBoZWFkZXJzLCBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgIGNvbnN0IG9rID0gcmVzLm9rO1xuICAgIGNvbnN0IHN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgY2xlYXJUaW1lb3V0KHRvKTtcbiAgICByZXR1cm4geyBvaywgc3RhdHVzIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjbGVhclRpbWVvdXQodG8pO1xuICAgIHJldHVybiB7IG9rOmZhbHNlLCBlcnJvcjogZS5uYW1lID09PSAnQWJvcnRFcnJvcicgPyAndGltZW91dCcgOiBlLm1lc3NhZ2UgfTtcbiAgfVxufVxuXG5leHBvcnRzLmhlYWx0aCA9IGFzeW5jIGZ1bmN0aW9uKGV2ZW50KXtcbiAgX19SQ19IRUFMVEhfSU5WT0NBVElPTlMrKztcbiAgY29uc3QgcXMgPSAoZXZlbnQgJiYgZXZlbnQucXVlcnlTdHJpbmdQYXJhbWV0ZXJzKSB8fCB7fTtcbiAgY29uc3Qgd2FudFBpbmcgPSAncGluZycgaW4gcXMgfHwgJ25vdycgaW4gcXM7IC8vIGVuYWJsZSBBUEkgcHJvYmUgd2l0aCA/cGluZyBvciA/cGluZz0xXG4gIGNvbnN0IHJhcEtleVByZXNlbnQgPSAhIXByb2Nlc3MuZW52LlJBUElEQVBJX0tFWTtcbiAgbGV0IHBpbmcgPSBudWxsO1xuICBpZiAod2FudFBpbmcgJiYgcmFwS2V5UHJlc2VudCkge1xuICAgIHRyeSB7XG4gICAgICBwaW5nID0gYXdhaXQgcmFwaWRBcGlQaW5nKGJ1aWxkSGVhZGVycygpKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcGluZyA9IHsgb2s6ZmFsc2UsIGVycm9yOiBlLm1lc3NhZ2UgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYm9keSA9IHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIHNlcnZpY2U6ICdhc3Ryb2xvZ3ktbWF0aGJyYWluJyxcbiAgICB2ZXJzaW9uOiBNQVRIX0JSQUlOX1ZFUlNJT04sXG4gICAgZXBoZW1lcmlzX3NvdXJjZTogRVBIRU1FUklTX1NPVVJDRSxcbiAgICBjYWxpYnJhdGlvbl9ib3VuZGFyeTogQ0FMSUJSQVRJT05fQk9VTkRBUlksXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCcsXG4gICAgcmFwaWRhcGk6IHtcbiAgICAgIGNvbmZpZ3VyZWQ6IHJhcEtleVByZXNlbnQsXG4gICAgICBwaW5nOiBwaW5nXG4gICAgfSxcbiAgICBjb2xkX3N0YXJ0X21zOiBEYXRlLm5vdygpIC0gX19SQ19DT0xEX1NUQVJUX1RTLFxuICAgIGludm9jYXRpb25zOiBfX1JDX0hFQUxUSF9JTlZPQ0FUSU9OUyxcbiAgICB1cHRpbWVfczogcHJvY2Vzcy51cHRpbWUoKSxcbiAgICBtZW1vcnk6ICgoKT0+e3RyeXtjb25zdCBtPXByb2Nlc3MubWVtb3J5VXNhZ2UoKTtyZXR1cm4geyByc3M6bS5yc3MsIGhlYXBVc2VkOm0uaGVhcFVzZWQsIGhlYXBUb3RhbDptLmhlYXBUb3RhbCB9OyB9Y2F0Y2h7IHJldHVybiBudWxsOyB9fSkoKVxuICB9O1xuICByZXR1cm4geyBzdGF0dXNDb2RlOiAyMDAsIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6J2FwcGxpY2F0aW9uL2pzb24nIH0sIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpIH07XG59O1xuIl0sIm5hbWVzIjpbImFnZ3JlZ2F0ZSIsInJlcXVpcmUiLCJfaW50ZXJuYWxzIiwic2Vpc21vSW50ZXJuYWxzIiwiY29tcHV0ZVNGRCIsImNvbXB1dGVCYWxhbmNlVmFsZW5jZSIsIkFQSV9CQVNFX1VSTCIsIkFQSV9FTkRQT0lOVFMiLCJCSVJUSF9DSEFSVCIsIk5BVEFMX0FTUEVDVFNfREFUQSIsIlNZTkFTVFJZX0NIQVJUIiwiVFJBTlNJVF9DSEFSVCIsIlRSQU5TSVRfQVNQRUNUUyIsIlNZTkFTVFJZX0FTUEVDVFMiLCJCSVJUSF9EQVRBIiwiTk9XIiwiQ09NUE9TSVRFX0FTUEVDVFMiLCJtYXBUMk5Bc3BlY3RzIiwiY29tcG9zZVdvdmVuTWFwUmVwb3J0IiwibG9nZ2VyIiwibG9nIiwiYXJncyIsImNvbnNvbGUiLCJpbmZvIiwid2FybiIsImVycm9yIiwiZGVidWciLCJwcm9jZXNzIiwiZW52IiwiTE9HX0xFVkVMIiwic3RyaXBHcmFwaGljc0RlZXAiLCJvYmoiLCJraWxsIiwiU2V0IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwib3V0IiwiayIsInYiLCJPYmplY3QiLCJlbnRyaWVzIiwiaGFzIiwiTUFUSF9CUkFJTl9WRVJTSU9OIiwiRVBIRU1FUklTX1NPVVJDRSIsIkNBTElCUkFUSU9OX0JPVU5EQVJZIiwibm9ybWFsaXplU3RlcCIsInN0ZXAiLCJzIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIm5vcm1hbGl6ZVRpbWV6b25lIiwidHoiLCJ0IiwidHJpbSIsImRlcml2ZVRpbWVNZXRhIiwic3ViamVjdCIsImgiLCJob3VyIiwibSIsIm1pbnV0ZSIsImtub3duIiwidW5kZWZpbmVkIiwicGFkMiIsIm4iLCJwYWRTdGFydCIsImJpcnRoX3RpbWVfa25vd24iLCJ0aW1lX3ByZWNpc2lvbiIsImVmZmVjdGl2ZV90aW1lX3VzZWQiLCJjYW5vbmljYWxpemVUaW1lUG9saWN5IiwicmF3IiwiZGVyaXZlVGltZU1ldGFXaXRoUG9saWN5IiwidGltZVBvbGljeSIsImJhc2UiLCJ1bmtub3duIiwicG9saWN5IiwidmFsaWRhdGVTdWJqZWN0TGVhbiIsInJlcSIsIm1pc3NpbmciLCJmaWx0ZXIiLCJpc1ZhbGlkIiwibGVuZ3RoIiwibWVzc2FnZSIsImpvaW4iLCJwYXJzZUNvb3JkaW5hdGVzIiwiY29vcmRTdHJpbmciLCJyZXBsYWNlIiwiRE1TIiwiZXhlYyIsImRtc1RvRGVjIiwiZCIsInNlYyIsImhlbSIsImRlZyIsInBhcnNlSW50IiwibWluIiwic2VjRiIsInBhcnNlRmxvYXQiLCJ2YWwiLCJ0ZXN0IiwibGF0IiwibG9uIiwiaXNGaW5pdGUiLCJNYXRoIiwiYWJzIiwiaW5wdXQiLCJvdXRwdXQiLCJERUMiLCJidWlsZEhlYWRlcnMiLCJrZXkiLCJSQVBJREFQSV9LRVkiLCJFcnJvciIsInZhbGlkYXRlU3ViamVjdCIsImJhc2VSZXEiLCJiYXNlTWlzc2luZyIsImYiLCJoYXNDb29yZHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInRpbWV6b25lIiwiaGFzQ2l0eSIsImNpdHkiLCJuYXRpb24iLCJva01vZGUiLCJtb2RlTXNnIiwibWlzc2luZ01zZyIsIkJvb2xlYW4iLCJub3JtYWxpemVTdWJqZWN0RGF0YSIsImRhdGEiLCJub3JtYWxpemVkIiwibmFtZSIsInllYXIiLCJtb250aCIsImRheSIsImxuZyIsInR6X3N0ciIsInpvZGlhY190eXBlIiwiem9kaWFjIiwiZGF0ZSIsInkiLCJzcGxpdCIsIk51bWJlciIsInRpbWUiLCJiaXJ0aF9kYXRlIiwiXyIsImJpcnRoX3RpbWUiLCJiaXJ0aF9jaXR5IiwiY2l0eV9uYW1lIiwidG93biIsImJpcnRoX2NvdW50cnkiLCJjb3VudHJ5IiwiY291bnRyeV9jb2RlIiwib2Zmc2V0IiwidHppZCIsInRpbWVfem9uZSIsImNvb3JkaW5hdGVzIiwiY29vcmRGaWVsZHMiLCJmaWVsZCIsInBhcnNlZCIsInN1YmplY3RUb0FQSSIsInBhc3MiLCJ0ek5vcm0iLCJhcGlTdWJqZWN0IiwiaW5jbHVkZUNvb3JkcyIsImZvcmNlX2NpdHlfbW9kZSIsInN1cHByZXNzX2Nvb3JkcyIsIndhbnRDaXR5IiwicmVxdWlyZV9jaXR5Iiwic3RhdGUiLCJHRU9OQU1FU19VU0VSTkFNRSIsInN1cHByZXNzX2dlb25hbWVzIiwiZ2VvbmFtZXNfdXNlcm5hbWUiLCJoc3lzIiwiaG91c2VzX3N5c3RlbV9pZGVudGlmaWVyIiwiY2FsbE5hdGFsIiwiZW5kcG9pbnQiLCJoZWFkZXJzIiwiZGVzY3JpcHRpb24iLCJjYW5Vc2VHZW8iLCJwYXlsb2FkQ2l0eVdpdGhHZW8iLCJhcGlDYWxsV2l0aFJldHJ5IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlMCIsInBheWxvYWRDb29yZHMiLCJlMSIsImNhblRyeUNpdHkiLCJpczR4eCIsImNvZGUiLCJzdGF0dXMiLCJwYXlsb2FkQ2l0eU5vR2VvIiwiQVNQRUNUX0NMQVNTIiwibWFqb3IiLCJtaW5vciIsImhhcm1vbmljIiwiQVNQRUNUX09SQl9DQVBTIiwiY29uanVuY3Rpb24iLCJvcHBvc2l0aW9uIiwic3F1YXJlIiwidHJpbmUiLCJzZXh0aWxlIiwicXVpbmN1bngiLCJzZXNxdWlxdWFkcmF0ZSIsInF1aW50aWxlIiwiYmlxdWludGlsZSIsIkJPRFlfQ0xBU1NfQ0FQUyIsImx1bWluYXJ5IiwicGVyc29uYWwiLCJzb2NpYWwiLCJvdXRlciIsImFuZ2xlIiwicG9pbnQiLCJvdGhlciIsIlJFVFVSTl9CT0RJRVMiLCJQT0lOVF9CT0RJRVMiLCJjbGFzc2lmeUFzcGVjdE5hbWUiLCJQRVJTT05BTF9TRVQiLCJPVVRFUl9TRVQiLCJhZGp1c3RPcmJDYXBGb3JTcGVjaWFscyIsImJhc2VDYXAiLCJwMSIsInAyIiwiY2FwIiwib3V0ZXJQZXJzb25hbCIsImJvZHlDbGFzcyIsImRpc3BsYXlCb2R5TmFtZSIsIndlaWdodEFzcGVjdCIsImEiLCJfY2xhc3MiLCJhc3BlY3RDYXAiLCJfYXNwZWN0IiwiY2xhc3NDYXBUcmFuc2l0IiwicDFfbmFtZSIsImNsYXNzQ2FwTmF0YWwiLCJwMl9uYW1lIiwiZWZmZWN0aXZlQ2FwIiwibWF4IiwidGlnaHRuZXNzIiwiX29yYiIsImx1bU9yQW5nbGUiLCJwMV9pc0x1bWluYXJ5IiwicDJfaXNMdW1pbmFyeSIsInAxX2lzQW5nbGUiLCJwMl9pc0FuZ2xlIiwidG9GaXhlZCIsImVucmljaERhaWx5QXNwZWN0cyIsInJhd0xpc3QiLCJmaWx0ZXJlZCIsImhvb2tzIiwicmVqZWN0aW9ucyIsImNvdW50cyIsImVucmljaGVkIiwiYXNwZWN0TmFtZSIsImFzcGVjdCIsIm9yYiIsIm9yYml0Iiwic2FtZUJvZHkiLCJjbHMiLCJwMUNsYXNzIiwicDJDbGFzcyIsImNsYXNzQ2FwIiwiZHJvcFJlYXNvbiIsInJlYyIsIl9zYW1lQm9keSIsInAxX2Rpc3BsYXkiLCJwMl9kaXNwbGF5IiwicDFfY2xhc3MiLCJwMl9jbGFzcyIsImVmZmVjdGl2ZV9jYXAiLCJwdXNoIiwicmVhc29uIiwiX3dlaWdodCIsInN0cm9uZyIsInIiLCJwYWlyU2VlbiIsInByaW1hcnlDb3VudHMiLCJNYXAiLCJwYWlyS2V5Iiwic29ydCIsImFkZCIsInByaW1hcmllcyIsInByaW1hcnlEdXAiLCJwIiwiYyIsImdldCIsInNldCIsImhvb2tDYW5kaWRhdGVzIiwiaXNFeGFjdCIsImlzVGlnaHQiLCJpc0x1bSIsImlzQW5nbGUiLCJpc05vZGVDaGlyb24iLCJzbGljZSIsImIiLCJvYSIsIm9iIiwiZWEiLCJlYiIsImxhIiwibGIiLCJyZWplY3RlZCIsImNhbm9uaWNhbGl6ZU1vZGUiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwiU1RSSUNUX1JFUVVJUkVEX0ZJRUxEUyIsInZhbGlkYXRlU3ViamVjdFN0cmljdFdpdGhNYXAiLCJlcnJvcnMiLCJmb3JFYWNoIiwia2V5cyIsInVybCIsIm9wdGlvbnMiLCJvcGVyYXRpb24iLCJtYXhSZXRyaWVzIiwiYXR0ZW1wdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInJhd1RleHQiLCJ0ZXh0IiwicGFyc2VkTWVzc2FnZSIsImoiLCJwYXJzZSIsImhpbnQiLCJlcnIiLCJqc29uIiwiZGVsYXkiLCJwb3ciLCJyYW5kb20iLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsInBhcnNlQ29vcmRpbmF0ZSIsImRlYyIsImRtcyIsImhlbWkiLCJzaWduIiwiZ2V0VHJhbnNpdHMiLCJ0cmFuc2l0UGFyYW1zIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImJ1aWxkV2luZG93U2FtcGxlcyIsInRyYW5zaXRzQnlEYXRlIiwicmV0cm9GbGFnc0J5RGF0ZSIsInByb3ZlbmFuY2VCeURhdGUiLCJpYW5hVHoiLCJzYW1wbGVzIiwic3RhcnQiLCJlbmQiLCJwcm9taXNlcyIsImVuc3VyZUNvb3JkcyIsImdlb1Jlc29sdmUiLCJlIiwicHJlZmVyQ29vcmRzIiwic2FtcGxlSXNvIiwiZHQiLCJEYXRlIiwiZGF0ZVN0cmluZyIsInRyYW5zaXRfc3ViamVjdCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiY2l0eUZpZWxkIiwicGF5bG9hZCIsImZpcnN0X3N1YmplY3QiLCJhY3RpdmVfcG9pbnRzIiwicGFzc19rZXlzIiwicmVzcCIsImZvcm1hdGlvbiIsImF0dGVtcHRzIiwibWF4QXR0ZW1wdHMiLCJoYXNBc3BlY3RzIiwiYXNwZWN0cyIsImFzcGVjdENvdW50IiwicmVzcG9uc2VLZXlzIiwic2FtcGxlIiwiYWx0ZXJuYXRlVHJhbnNpdFN1YmplY3QiLCJhbHRlcm5hdGVQYXlsb2FkIiwiYWx0ZXJuYXRlRm9ybWF0aW9uIiwiYXNwZWN0X2NvdW50IiwicmV0cm9NYXAiLCJmcyIsImZpcnN0U3ViamVjdCIsInRyIiwidHJhbnNpdCIsImNvbGxlY3QiLCJibG9jayIsInJldHJvZ3JhZGUiLCJjYXRjaCIsImFsbCIsInJlcXVlc3RlZERhdGVzIiwiZGF0ZXNXaXRoRGF0YSIsInRvdGFsQXNwZWN0cyIsInZhbHVlcyIsInJlZHVjZSIsInN1bSIsImF2YWlsYWJsZURhdGVzIiwidSIsInEiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZWFyY2hVcmwiLCJyZXMxIiwiajEiLCJnIiwiZ2VvbmFtZXMiLCJ0elVybCIsInJlczIiLCJqMiIsInRpbWV6b25lSWQiLCJleHBvcnRzIiwicmVzb2x2ZUNpdHkiLCJldmVudCIsInFzIiwicXVlcnlTdHJpbmdQYXJhbWV0ZXJzIiwic3RhdHVzQ29kZSIsInJlc29sdmVkIiwiZm9ybWF0VHJhbnNpdFRhYmxlIiwiZW5yaWNoZWRBc3BlY3RzIiwicHJldkRheUFzcGVjdHMiLCJleGFjdCIsInRpZ2h0IiwibW9kZXJhdGUiLCJ3aWRlIiwibWFya2Rvd24iLCJwcmV2T3JiTWFwIiwicHJvY2Vzc2VkQXNwZWN0cyIsInByZXZPcmIiLCJwaGFzZSIsImFzcGVjdEZvclNjb3JlIiwibmF0YWwiLCJ0eXBlIiwib3JiRGVnIiwic2NvcmVkIiwic2NvcmVBc3BlY3QiLCJpc0FuZ2xlUHJveCIsImNyaXRpY2FsIiwic2NvcmUiLCJTIiwiX29yYlZhbHVlIiwiY3JlYXRlTWFya2Rvd25UYWJsZSIsInRpdGxlIiwidGFibGUiLCJjYWxjdWxhdGVTZWlzbW9ncmFwaCIsImRhaWx5Iiwic3VtbWFyeSIsImRheXMiLCJwcmV2IiwicHJldkRheUZpbHRlcmVkIiwicm9sbGluZ01hZ25pdHVkZXMiLCJ2YWxlbmNlSGlzdG9yeSIsImkiLCJyYXdEYXlBc3BlY3RzIiwiZW5yaWNoZWRXaXRoUmV0cm9ncmFkZSIsInAxciIsInAyciIsInAxX3JldHJvZ3JhZGUiLCJwMl9yZXRyb2dyYWRlIiwicmV0cm9ncmFkZV9pbnZvbHZlZCIsInRyYW5zaXRUYWJsZSIsImFzcGVjdHNGb3JBZ2dyZWdhdGUiLCJ4IiwiaXNMdW1pbmFyeSIsImRlZ0NyaXQiLCJyb2xsaW5nQ29udGV4dCIsIm1hZ25pdHVkZXMiLCJhZ2ciLCJzY2FsaW5nU3RyYXRlZ3kiLCJuQ29udGV4dCIsInNjYWxlQ29uZmlkZW5jZSIsIm1hZ25pdHVkZVRvVHJhY2siLCJvcmlnaW5hbE1hZ25pdHVkZSIsInJhd01hZ25pdHVkZSIsIm1hZ25pdHVkZSIsInNoaWZ0IiwidmFsZW5jZSIsInJldHJvZ3JhZGVBc3BlY3RzIiwiZGlzcGVyc2lvblZvbCIsIndlaWdodHMiLCJtZWFuVyIsInZhcmlhbmNlIiwic3FydCIsImRyaXZlcnNDb21wYWN0IiwiYXBwbHlpbmciLCJ3ZWlnaHQiLCJwbGFuZXQxIiwicGxhbmV0MiIsImZpcnN0X3BsYW5ldCIsInNlY29uZF9wbGFuZXQiLCJpc190cmFuc2l0IiwiZGF5RW50cnkiLCJzZWlzbW9ncmFwaCIsInZvbGF0aWxpdHkiLCJzY2FsaW5nX3N0cmF0ZWd5Iiwic2NhbGluZ19jb25maWRlbmNlIiwiZmlsdGVyZWRfYXNwZWN0cyIsImRyaXZlcnMiLCJ0cmFuc2l0X3RhYmxlIiwicmV0cm9ncmFkZV9hc3BlY3RzIiwidmFsZW5jZV90cmVuZCIsImNhbGN1bGF0ZVRyZW5kIiwiYmFsYW5jZVZhbCIsIlNGRCIsIlNwbHVzIiwiU21pbnVzIiwiYmFsYW5jZSIsInZlcnNpb24iLCJzZmQiLCJzUGx1cyIsInNNaW51cyIsIllfZWZmZWN0aXZlIiwibnVtRGF5cyIsIlgiLCJZIiwiVkkiLCJyZWNlbnQiLCJ0cmVuZCIsImNvbXB1dGVDb21wb3NpdGUiLCJBIiwiQiIsIkgiLCJwZXJzb25BIiwicGVyc29uQiIsInNlY29uZF9zdWJqZWN0IiwidG9wQXNwZWN0cyIsImdlbmVyYXRlUG9sYXJpdHlDYXJkcyIsInN5bmFzdHJ5QXNwZWN0cyIsInBvbGFyaXR5Q2FyZHMiLCJwcm9jZXNzZWRQYWlycyIsInRlbnNpb25Bc3BlY3RzIiwiZmlyc3RfcG9pbnQiLCJzZWNvbmRfcG9pbnQiLCJhc3BlY3RUeXBlIiwicGFpcklkIiwicG9sYXJpdHlfYSIsInBvbGFyaXR5X2IiLCJhc3BlY3RfdHlwZSIsIm9yYl9kZWdyZWVzIiwiZmllbGRfZGVzY3JpcHRpb24iLCJtYXBfcGF0dGVybiIsInZvaWNlX3N1bW1hcnkiLCJkZXRlY3RFY2hvTG9vcHMiLCJuYXRhbEFzcGVjdHNBIiwibmF0YWxBc3BlY3RzQiIsImVjaG9Mb29wcyIsInBsYW5ldFBhaXJzIiwicGFpciIsInBhdHRlcm5fdHlwZSIsInBsYW5ldHNfaW52b2x2ZWQiLCJvY2N1cnJlbmNlcyIsImludGVuc2l0eSIsImdlbmVyYXRlU2hhcmVkU1NUVGFncyIsInNzdFRhZ3MiLCJwZXJzb25fYV90YWdzIiwicGVyc29uX2JfdGFncyIsInNoYXJlZF9yZXNvbmFuY2UiLCJzaWduaWZpY2FudEFzcGVjdHMiLCJ2ZWN0b3IiLCJ0YWciLCJzaGFyZWRBc3BlY3RzIiwiY29tcHV0ZVJlbGF0aW9uYWxCYWxhbmNlTWV0ZXIiLCJjb21wb3NpdGVBc3BlY3RzIiwiY29tcG9zaXRlVHJhbnNpdHMiLCJ0b3RhbFN1cHBvcnQiLCJ0b3RhbEZyaWN0aW9uIiwicmVsYXRpb25hbFNGRCIsInJvdW5kIiwicmVsYXRpb25hbFZhbGVuY2UiLCJyZWxhdGlvbmFsX3NmZCIsInJlbGF0aW9uYWxfbWFnbml0dWRlIiwicmVsYXRpb25hbF92YWxlbmNlIiwic3VwcG9ydF9zY29yZSIsImZyaWN0aW9uX3Njb3JlIiwiY2xpbWF0ZV9kZXNjcmlwdGlvbiIsImdlbmVyYXRlVmVjdG9ySW50ZWdyaXR5VGFncyIsInZlY3RvclRhZ3MiLCJ3aWRlQXNwZWN0cyIsInZlY3Rvcl9uYW1lIiwic3RydWN0dXJhbF9wcmVzZW5jZSIsImJlaGF2aW9yYWxfYWN0aXZpdHkiLCJnZW5lcmF0ZVJlbGF0aW9uYWxNaXJyb3IiLCJjb21wb3NpdGUiLCJyZWxhdGlvbmFsQmFsYW5jZU1ldGVyIiwidmVjdG9ySW50ZWdyaXR5VGFncyIsIm1pcnJvclZvaWNlIiwicmVsYXRpb25zaGlwX2NsaW1hdGUiLCJwb2xhcml0eV9zdW1tYXJ5IiwiZWNob19wYXR0ZXJuX3N1bW1hcnkiLCJzaGFyZWRfZmllbGRfZGVzY3JpcHRpb24iLCJyZWxvY2F0aW9uTm90ZXMiLCJyZWxvY2F0aW9uX2FwcGxpZWQiLCJob3VzZV9zeXN0ZW0iLCJhbmdsZXNfcmVsb2NhdGVkIiwiYmFzZWxpbmVfcmVtYWluc19uYXRhbCIsImRpc2Nsb3N1cmUiLCJyZWxhdGlvbmFsX21pcnJvciIsInBvbGFyaXR5X2NhcmRzIiwiZWNob19sb29wcyIsInNzdF90YWdzIiwicmVsYXRpb25hbF9iYWxhbmNlX21ldGVyIiwibWlycm9yX3ZvaWNlIiwidmVjdG9yX2ludGVncml0eV90YWdzIiwicmVsb2NhdGlvbl9ub3RlcyIsInNjYWZmb2xkaW5nX2NvbXBsZXRlIiwibWlycm9yX3R5cGUiLCJjb21wdXRlQ29tcG9zaXRlVHJhbnNpdHMiLCJjb21wb3NpdGVSYXciLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInRvSVNPU3RyaW5nIiwiY29tcG9zaXRlX3N1YmplY3QiLCJ0aGVuIiwiX25vdGUiLCJnZW5lcmF0ZUVycm9ySWQiLCJub3ciLCJ0b1RpbWVTdHJpbmciLCJzdWJzdHIiLCJoYW5kbGVyIiwiaHR0cE1ldGhvZCIsImVycm9ySWQiLCJ3YW50TW9jayIsIk1CX01PQ0siLCJ0b2RheSIsImlzbyIsInJhbmdlU3RhcnQiLCJ0cmFuc2l0U3RhcnREYXRlIiwibW9jayIsInN1Y2Nlc3MiLCJwcm92ZW5hbmNlIiwic291cmNlIiwiZW5naW5lIiwiY29udGV4dCIsIm1vZGUiLCJ0cmFuc2xvY2F0aW9uIiwiYXBwbGllcyIsInBlcnNvbl9hIiwibWV0YSIsImhvdXNlc19zdXBwcmVzc2VkIiwiZGV0YWlscyIsImNoYXJ0IiwiZGVyaXZlZCIsInNlaXNtb2dyYXBoX3N1bW1hcnkiLCJwZXJzb25fYiIsIndvdmVuX21hcCIsInNjaGVtYSIsImhvb2tfc3RhY2siLCJ0aWVyXzFfb3JicyIsIm1vZGVIaW50IiwiY29udGV4dE1vZGUiLCJyZWxhdGlvbmFsIiwic29sbyIsIm1vZGVUb2tlbiIsInRpbWVfcG9saWN5IiwiYmlydGhfdGltZV9wb2xpY3kiLCJ3YW50TmF0YWxBc3BlY3RzT25seSIsInBhdGgiLCJ3YW50QmlydGhEYXRhIiwid2FudFN5bmFzdHJ5Iiwid2FudFN5bmFzdHJ5QXNwZWN0c09ubHkiLCJ3YW50Q29tcG9zaXRlIiwid2FudFNreVRyYW5zaXRzIiwid2FudEJhbGFuY2VNZXRlciIsImluY2x1ZGVUcmFuc2l0VGFnIiwiUkVMX1BSSU1BUlkiLCJQQVJUTkVSX1RJRVJTIiwiRlJJRU5EX1JPTEVTIiwiRkFNSUxZX1JPTEVTIiwibm9ybWFsaXplUmVsVHlwZSIsInVwIiwic3RhcnRzV2l0aCIsInZhbGlkYXRlUmVsYXRpb25zaGlwQ29udGV4dCIsImlzUmVsYXRpb25zaGlwTW9kZSIsInZhbGlkIiwidmFsdWUiLCJjdHgiLCJyZWxhdGlvbnNoaXAiLCJyZWxhdGlvbnNoaXBfY29udGV4dCIsInJlbGF0aW9uc2hpcENvbnRleHQiLCJyZWxhdGlvbmFsQ29udGV4dCIsImNsZWFuZWQiLCJyZWxhdGlvbnNoaXBfdHlwZSIsImNhdGVnb3J5IiwiaW50aW1hY3lfdGllciIsInRpZXIiLCJyb2xlUmF3Iiwicm9sZSIsImZhbWlseV9yb2xlIiwicmVsYXRpb25zaGlwX3JvbGUiLCJyb2xlQ2Fub24iLCJjaGFyQXQiLCJmcmllbmRfcm9sZSIsImV4X2VzdHJhbmdlZCIsImV4IiwiZXN0cmFuZ2VkIiwiaXNfZXhfcmVsYXRpb25zaGlwIiwiZmxhZyIsIm5vdGVzIiwicGVyc29uQU9yaWdpbmFsIiwicGVyc29uQk9yaWdpbmFsIiwiYXBwbHlGYWxsYmFja1RpbWUiLCJhc3NpZ24iLCJ2QSIsInJlbGF0aW9uc2hpcE1vZGUiLCJwZXJzb25CU3RyaWN0VmFsaWRhdGlvbiIsInJlbENvbnRleHRWYWxpZGF0aW9uIiwiaXNzdWVzIiwiZmllbGRFcnJvcnMiLCJ3aW4iLCJ3aW5kb3ciLCJ0cmFuc2l0X3dpbmRvdyIsInRyYW5zaXRfc3RhcnRfZGF0ZSIsInRyYW5zaXRFbmREYXRlIiwidHJhbnNpdF9lbmRfZGF0ZSIsImludGVydmFsIiwidHJhbnNpdFN0ZXAiLCJ0cmFuc2l0X3N0ZXAiLCJoYXZlUmFuZ2UiLCJoYXNMb2MiLCJ0cmFuc2l0QV9yYXciLCJ0cmFuc2l0Ql9yYXciLCJ0cmFuc2l0X3N1YmplY3RfQiIsInNlY29uZF90cmFuc2l0X3N1YmplY3QiLCJyZWxvY2F0aW9uTW9kZSIsInJlbG9jYXRpb25fbW9kZSIsImhhc0R5YWQiLCJhTG9jYWwiLCJBX2xvY2FsIiwic3ViamVjdEEiLCJjaXR5TW9kZUEiLCJjaXR5TW9kZUIiLCJCX2xvY2FsIiwibmF0YWxBIiwibmF0YWxCIiwidHJhbnNpdEEiLCJ0cmFuc2l0QiIsIm1pZCIsIm1pZHBvaW50Q29vcmRzIiwibGF0MSIsImxvbjEiLCJsYXQyIiwibG9uMiIsInRvUmFkIiwiUEkiLCJ0b0RlZyIsIs+GMSIsIs67MSIsIs+GMiIsIs67MiIsIngxIiwiY29zIiwieTEiLCJzaW4iLCJ6MSIsIngyIiwieTIiLCJ6MiIsInhtIiwieW0iLCJ6bSIsIs+GbSIsImF0YW4yIiwizrttIiwibG9jIiwiY3VzdG9tX2xvY2F0aW9uIiwic3VnZ2VzdGVkX3RpbWV6b25lIiwidHpCIiwidW5zdGFibGUiLCJyZXN1bHQiLCJtYXRoX2JyYWluX3ZlcnNpb24iLCJlcGhlbWVyaXNfc291cmNlIiwiYnVpbGRfdHMiLCJjYWxpYnJhdGlvbl9ib3VuZGFyeSIsImVuZ2luZV92ZXJzaW9ucyIsInRpbWVfbWV0YV9hIiwib3Jic19wcm9maWxlIiwidGltZXpvbmVfZGJfdmVyc2lvbiIsIm1pcnJvcl9yZWFkeSIsImNvbnRyYWN0IiwidGltZV9tZXRhX2IiLCJ0bCIsInF1YXJhbnRpbmVLZXlzIiwiYWN0aXZlX2FzcGVjdHMiLCJBU1BFQ1RfU1lOT05ZTVMiLCJjYW5vbmljYWwiLCJhY2MiLCJjdXIiLCJleGlzdGluZyIsImZpbmQiLCJjbGFtcGVkIiwibmF0YWxSZXNwb25zZSIsImJpcnRoX2RhdGEiLCJjaGFydERhdGEiLCJiaXJ0aFRpbWVNaXNzaW5nIiwic2hvdWxkU3VwcHJlc3MiLCJza2lwVHJhbnNpdHMiLCJza3lTdWJqZWN0IiwiYmlydGhfbG9jYXRpb24iLCJzZWlzbW9ncmFwaERhdGEiLCJza3lfdHJhbnNpdHMiLCJhbGxBc3BlY3RzIiwiZmxhdE1hcCIsInQybl9hc3BlY3RzIiwidHJhbnNpdF9kYXRhIiwiZHVhbE5hdGFsTW9kZSIsInZCTGVhblBhc3NpdmUiLCJjaGFydERhdGFCIiwidHJhbnNpdHNCeURhdGVCIiwicmV0cm9GbGFnc0J5RGF0ZUIiLCJwcm92ZW5hbmNlQnlEYXRlQiIsImFsbEIiLCJzZWlzbW9CIiwidHJhbnNpdHNfZXJyb3IiLCJ2YWxpZGF0aW9uX2Vycm9yIiwidkJMZWFuUGFzc2l2ZTIiLCJoYXNCVHJhbnNpdHMiLCJpbXBsaWNpdF9kdWFsX3RyYW5zaXRzIiwidmFsaWRCTGVhbiIsInZhbGlkQlN0cmljdCIsInN5biIsInN5bkRhdGEiLCJzeW5hc3RyeV9hc3BlY3RzIiwic3luYXN0cnlfZGF0YSIsInJlbGF0aW9uYWxNaXJyb3IiLCJzeW5hc3RyeV9yZWxhdGlvbmFsX21pcnJvciIsInN5bkNsZWFuIiwic2Vpc21vZ3JhcGhEYXRhQiIsInZCIiwibm90ZSIsInVwZGF0ZWRSZWxhdGlvbmFsQmFsYW5jZU1ldGVyIiwiYXV0b190cmFuc2l0c19pbmNsdWRlZCIsInJlcXVlc3RfbW9kZSIsInNob3VsZFJ1bkJhbGFuY2VNZXRlciIsImJhbGFuY2VNZXRlclJlcG9ydCIsInBlcmlvZCIsInNjaGVtYV92ZXJzaW9uIiwiY2hhbm5lbF9zdW1tYXJ5IiwiZGFpbHlfZW50cmllcyIsInBlcnNvbiIsImJhbGFuY2VfbWV0ZXIiLCJzY3J1Yk5hcnJhdGl2ZUtleXMiLCJyZWxvY2F0aW9uX2Nvb3JkcyIsImhzIiwibmFtZXMiLCJQIiwiVyIsIlIiLCJLIiwiQyIsIkUiLCJob3VzZV9zeXN0ZW1fbmFtZSIsInNhZmVSZXN1bHQiLCJzdGFjayIsInRlc3RTdWJqZWN0IiwicXVlcnkiLCJmb3JtYXR0ZWQiLCJjaXR5X3Jlc29sdmVkIiwibmF0aW9uX3Jlc29sdmVkIiwiZ2VvbmFtZXNfdXNlZCIsInJhd19yZXNwb25zZSIsIl9fUkNfQ09MRF9TVEFSVF9UUyIsImdsb2JhbCIsIl9fUkNfSEVBTFRIX0lOVk9DQVRJT05TIiwicmFwaWRBcGlQaW5nIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRvIiwiYWJvcnQiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJoZWFsdGgiLCJ3YW50UGluZyIsInJhcEtleVByZXNlbnQiLCJwaW5nIiwic2VydmljZSIsInRpbWVzdGFtcCIsImVudmlyb25tZW50IiwicmFwaWRhcGkiLCJjb25maWd1cmVkIiwiY29sZF9zdGFydF9tcyIsImludm9jYXRpb25zIiwidXB0aW1lX3MiLCJ1cHRpbWUiLCJtZW1vcnkiLCJtZW1vcnlVc2FnZSIsInJzcyIsImhlYXBVc2VkIiwiaGVhcFRvdGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/server/astrology-mathbrain.js\n");

/***/ }),

/***/ "(rsc)/./lib/time-sampling.js":
/*!******************************!*\
  !*** ./lib/time-sampling.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { DateTime } = __webpack_require__(/*! luxon */ \"(rsc)/./node_modules/luxon/build/node/luxon.js\");\nfunction localNoonToUTC(dateOrIso, ianaTz) {\n    if (!ianaTz || typeof ianaTz !== \"string\") {\n        throw new Error(\"localNoonToUTC requires an IANA timezone string\");\n    }\n    const dateOnlyRe = /^\\d{4}-\\d{2}-\\d{2}$/;\n    let dt;\n    if (dateOnlyRe.test(dateOrIso)) {\n        dt = DateTime.fromISO(dateOrIso, {\n            zone: ianaTz\n        }).set({\n            hour: 12,\n            minute: 0,\n            second: 0,\n            millisecond: 0\n        });\n    } else {\n        const hasOffset = /[Zz]|[+\\-]\\d{2}:\\d{2}$/.test(dateOrIso);\n        dt = DateTime.fromISO(dateOrIso, {\n            zone: hasOffset ? undefined : ianaTz\n        });\n        if (!dt.isValid) throw new Error(\"Invalid ISO date/time: \" + dateOrIso);\n    }\n    return dt.toUTC().toISO();\n}\nfunction buildWindowSamples(windowObj, ianaTz) {\n    if (!windowObj || !windowObj.start || !windowObj.end || !windowObj.step) {\n        throw new Error(\"Invalid window object\");\n    }\n    const { start, end, step } = windowObj;\n    const localStart = DateTime.fromISO(start, {\n        zone: ianaTz\n    });\n    const localEnd = DateTime.fromISO(end, {\n        zone: ianaTz\n    });\n    if (!localStart.isValid || !localEnd.isValid) {\n        throw new Error(\"Invalid window dates for timezone \" + ianaTz);\n    }\n    let cursor = DateTime.fromISO(start, {\n        zone: ianaTz\n    }).set({\n        hour: 12,\n        minute: 0,\n        second: 0,\n        millisecond: 0\n    });\n    const samples = [];\n    const stepUnit = step === \"weekly\" ? {\n        days: 7\n    } : {\n        days: 1\n    };\n    while(cursor <= localEnd.set({\n        hour: 23,\n        minute: 59,\n        second: 59\n    })){\n        samples.push(cursor.toUTC().toISO());\n        cursor = cursor.plus(stepUnit);\n    }\n    return samples;\n}\nmodule.exports = {\n    localNoonToUTC,\n    buildWindowSamples\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvdGltZS1zYW1wbGluZy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFN0IsU0FBU0MsZUFBZUMsU0FBUyxFQUFFQyxNQUFNO0lBQ3ZDLElBQUksQ0FBQ0EsVUFBVSxPQUFPQSxXQUFXLFVBQVU7UUFDekMsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsTUFBTUMsYUFBYTtJQUNuQixJQUFJQztJQUNKLElBQUlELFdBQVdFLElBQUksQ0FBQ0wsWUFBWTtRQUM5QkksS0FBS1AsU0FBU1MsT0FBTyxDQUFDTixXQUFXO1lBQUVPLE1BQU1OO1FBQU8sR0FBR08sR0FBRyxDQUFDO1lBQUVDLE1BQU07WUFBSUMsUUFBUTtZQUFHQyxRQUFRO1lBQUdDLGFBQWE7UUFBRTtJQUMxRyxPQUFPO1FBQ0wsTUFBTUMsWUFBWSx5QkFBeUJSLElBQUksQ0FBQ0w7UUFDaERJLEtBQUtQLFNBQVNTLE9BQU8sQ0FBQ04sV0FBVztZQUFFTyxNQUFNTSxZQUFZQyxZQUFZYjtRQUFPO1FBQ3hFLElBQUksQ0FBQ0csR0FBR1csT0FBTyxFQUFFLE1BQU0sSUFBSWIsTUFBTSw0QkFBNEJGO0lBQy9EO0lBQ0EsT0FBT0ksR0FBR1ksS0FBSyxHQUFHQyxLQUFLO0FBQ3pCO0FBRUEsU0FBU0MsbUJBQW1CQyxTQUFTLEVBQUVsQixNQUFNO0lBQzNDLElBQUksQ0FBQ2tCLGFBQWEsQ0FBQ0EsVUFBVUMsS0FBSyxJQUFJLENBQUNELFVBQVVFLEdBQUcsSUFBSSxDQUFDRixVQUFVRyxJQUFJLEVBQUU7UUFDdkUsTUFBTSxJQUFJcEIsTUFBTTtJQUNsQjtJQUNBLE1BQU0sRUFBRWtCLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUUsR0FBR0g7SUFDN0IsTUFBTUksYUFBYTFCLFNBQVNTLE9BQU8sQ0FBQ2MsT0FBTztRQUFFYixNQUFNTjtJQUFPO0lBQzFELE1BQU11QixXQUFXM0IsU0FBU1MsT0FBTyxDQUFDZSxLQUFLO1FBQUVkLE1BQU1OO0lBQU87SUFDdEQsSUFBSSxDQUFDc0IsV0FBV1IsT0FBTyxJQUFJLENBQUNTLFNBQVNULE9BQU8sRUFBRTtRQUM1QyxNQUFNLElBQUliLE1BQU0sdUNBQXVDRDtJQUN6RDtJQUNBLElBQUl3QixTQUFTNUIsU0FBU1MsT0FBTyxDQUFDYyxPQUFPO1FBQUViLE1BQU1OO0lBQU8sR0FBR08sR0FBRyxDQUFDO1FBQUVDLE1BQU07UUFBSUMsUUFBUTtRQUFHQyxRQUFRO1FBQUdDLGFBQWE7SUFBRTtJQUM1RyxNQUFNYyxVQUFVLEVBQUU7SUFDbEIsTUFBTUMsV0FBV0wsU0FBUyxXQUFXO1FBQUVNLE1BQU07SUFBRSxJQUFJO1FBQUVBLE1BQU07SUFBRTtJQUM3RCxNQUFPSCxVQUFVRCxTQUFTaEIsR0FBRyxDQUFDO1FBQUVDLE1BQU07UUFBSUMsUUFBUTtRQUFJQyxRQUFRO0lBQUcsR0FBSTtRQUNuRWUsUUFBUUcsSUFBSSxDQUFDSixPQUFPVCxLQUFLLEdBQUdDLEtBQUs7UUFDakNRLFNBQVNBLE9BQU9LLElBQUksQ0FBQ0g7SUFDdkI7SUFDQSxPQUFPRDtBQUNUO0FBRUFLLE9BQU9DLE9BQU8sR0FBRztJQUFFakM7SUFBZ0JtQjtBQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dvdmVuLXdlYi1hcHAvLi9saWIvdGltZS1zYW1wbGluZy5qcz9lOGFhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgRGF0ZVRpbWUgfSA9IHJlcXVpcmUoJ2x1eG9uJyk7XG5cbmZ1bmN0aW9uIGxvY2FsTm9vblRvVVRDKGRhdGVPcklzbywgaWFuYVR6KSB7XG4gIGlmICghaWFuYVR6IHx8IHR5cGVvZiBpYW5hVHogIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbE5vb25Ub1VUQyByZXF1aXJlcyBhbiBJQU5BIHRpbWV6b25lIHN0cmluZycpO1xuICB9XG4gIGNvbnN0IGRhdGVPbmx5UmUgPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC87XG4gIGxldCBkdDtcbiAgaWYgKGRhdGVPbmx5UmUudGVzdChkYXRlT3JJc28pKSB7XG4gICAgZHQgPSBEYXRlVGltZS5mcm9tSVNPKGRhdGVPcklzbywgeyB6b25lOiBpYW5hVHogfSkuc2V0KHsgaG91cjogMTIsIG1pbnV0ZTogMCwgc2Vjb25kOiAwLCBtaWxsaXNlY29uZDogMCB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoYXNPZmZzZXQgPSAvW1p6XXxbK1xcLV1cXGR7Mn06XFxkezJ9JC8udGVzdChkYXRlT3JJc28pO1xuICAgIGR0ID0gRGF0ZVRpbWUuZnJvbUlTTyhkYXRlT3JJc28sIHsgem9uZTogaGFzT2Zmc2V0ID8gdW5kZWZpbmVkIDogaWFuYVR6IH0pO1xuICAgIGlmICghZHQuaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElTTyBkYXRlL3RpbWU6ICcgKyBkYXRlT3JJc28pO1xuICB9XG4gIHJldHVybiBkdC50b1VUQygpLnRvSVNPKCk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkV2luZG93U2FtcGxlcyh3aW5kb3dPYmosIGlhbmFUeikge1xuICBpZiAoIXdpbmRvd09iaiB8fCAhd2luZG93T2JqLnN0YXJ0IHx8ICF3aW5kb3dPYmouZW5kIHx8ICF3aW5kb3dPYmouc3RlcCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB3aW5kb3cgb2JqZWN0Jyk7XG4gIH1cbiAgY29uc3QgeyBzdGFydCwgZW5kLCBzdGVwIH0gPSB3aW5kb3dPYmo7XG4gIGNvbnN0IGxvY2FsU3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHN0YXJ0LCB7IHpvbmU6IGlhbmFUeiB9KTtcbiAgY29uc3QgbG9jYWxFbmQgPSBEYXRlVGltZS5mcm9tSVNPKGVuZCwgeyB6b25lOiBpYW5hVHogfSk7XG4gIGlmICghbG9jYWxTdGFydC5pc1ZhbGlkIHx8ICFsb2NhbEVuZC5pc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvdyBkYXRlcyBmb3IgdGltZXpvbmUgJyArIGlhbmFUeik7XG4gIH1cbiAgbGV0IGN1cnNvciA9IERhdGVUaW1lLmZyb21JU08oc3RhcnQsIHsgem9uZTogaWFuYVR6IH0pLnNldCh7IGhvdXI6IDEyLCBtaW51dGU6IDAsIHNlY29uZDogMCwgbWlsbGlzZWNvbmQ6IDAgfSk7XG4gIGNvbnN0IHNhbXBsZXMgPSBbXTtcbiAgY29uc3Qgc3RlcFVuaXQgPSBzdGVwID09PSAnd2Vla2x5JyA/IHsgZGF5czogNyB9IDogeyBkYXlzOiAxIH07XG4gIHdoaWxlIChjdXJzb3IgPD0gbG9jYWxFbmQuc2V0KHsgaG91cjogMjMsIG1pbnV0ZTogNTksIHNlY29uZDogNTkgfSkpIHtcbiAgICBzYW1wbGVzLnB1c2goY3Vyc29yLnRvVVRDKCkudG9JU08oKSk7XG4gICAgY3Vyc29yID0gY3Vyc29yLnBsdXMoc3RlcFVuaXQpO1xuICB9XG4gIHJldHVybiBzYW1wbGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbG9jYWxOb29uVG9VVEMsIGJ1aWxkV2luZG93U2FtcGxlcyB9O1xuIl0sIm5hbWVzIjpbIkRhdGVUaW1lIiwicmVxdWlyZSIsImxvY2FsTm9vblRvVVRDIiwiZGF0ZU9ySXNvIiwiaWFuYVR6IiwiRXJyb3IiLCJkYXRlT25seVJlIiwiZHQiLCJ0ZXN0IiwiZnJvbUlTTyIsInpvbmUiLCJzZXQiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJoYXNPZmZzZXQiLCJ1bmRlZmluZWQiLCJpc1ZhbGlkIiwidG9VVEMiLCJ0b0lTTyIsImJ1aWxkV2luZG93U2FtcGxlcyIsIndpbmRvd09iaiIsInN0YXJ0IiwiZW5kIiwic3RlcCIsImxvY2FsU3RhcnQiLCJsb2NhbEVuZCIsImN1cnNvciIsInNhbXBsZXMiLCJzdGVwVW5pdCIsImRheXMiLCJwdXNoIiwicGx1cyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/time-sampling.js\n");

/***/ }),

/***/ "(rsc)/./src/balance-meter.js":
/*!******************************!*\
  !*** ./src/balance-meter.js ***!
  \******************************/
/***/ ((module) => {

eval("// src/balance-meter.js\n// Balance Channel (v1.1) + Support–Friction Differential (SFD, v1.2)\n// Standalone computation based on \"Balance Meter.txt\" spec (v1.2 Draft, Sep 5, 2025)\n\nfunction clamp(n, lo, hi) {\n    return Math.max(lo, Math.min(hi, n));\n}\nfunction round(n, p = 2) {\n    return Math.round(n * 10 ** p) / 10 ** p;\n}\n// Normalize various aspect name spellings to canonical lowercase\nfunction normAspectName(s) {\n    const a = String(s || \"\").toLowerCase().trim();\n    const map = {\n        opposition: \"opposition\",\n        opp: \"opposition\",\n        square: \"square\",\n        sq: \"square\",\n        trine: \"trine\",\n        tri: \"trine\",\n        sextile: \"sextile\",\n        sex: \"sextile\",\n        conjunction: \"conjunction\",\n        conj: \"conjunction\",\n        quintile: \"quintile\",\n        biquintile: \"biquintile\",\n        quincunx: \"quincunx\",\n        inconjunct: \"quincunx\",\n        \"semi-square\": \"semi-square\",\n        sesquisquare: \"sesquiquadrate\",\n        sesquiquadrate: \"sesquiquadrate\",\n        \"semi-sextile\": \"semi-sextile\"\n    };\n    return map[a] || a;\n}\n// Body helpers\nfunction normBody(b) {\n    if (!b) return \"\";\n    const s = typeof b === \"string\" ? b : b.name || b.body || \"\";\n    return String(s || \"\").trim();\n}\nfunction bodyClass(name) {\n    switch(name){\n        case \"Sun\":\n        case \"Moon\":\n            return \"luminary\";\n        case \"Mercury\":\n        case \"Venus\":\n        case \"Mars\":\n            return \"personal\";\n        case \"Jupiter\":\n        case \"Saturn\":\n            return \"social\";\n        case \"Uranus\":\n        case \"Neptune\":\n        case \"Pluto\":\n            return \"outer\";\n        case \"Ascendant\":\n        case \"Medium_Coeli\":\n        case \"Descendant\":\n        case \"Imum_Coeli\":\n            return \"angle\";\n        case \"Chiron\":\n        case \"Mean_Node\":\n        case \"True_Node\":\n        case \"Mean_South_Node\":\n        case \"True_South_Node\":\n        case \"Mean_Lilith\":\n            return \"point\";\n        default:\n            return \"other\";\n    }\n}\nfunction isBenefic(name) {\n    return name === \"Jupiter\" || name === \"Venus\";\n}\nfunction isHeavy(name) {\n    return name === \"Saturn\" || name === \"Pluto\" || name === \"Chiron\";\n}\n// Linear orb multiplier with caps per class, 1.0 at exact → 0 at/over cap.\nfunction orbMultiplier(aspect, orbDeg, aName, bName) {\n    const aClass = bodyClass(aName);\n    const bClass = bodyClass(bName);\n    const isMinor = aspect === \"quintile\" || aspect === \"biquintile\" || aspect === \"quincunx\" || aspect === \"sesquiquadrate\" || aspect === \"semi-square\" || aspect === \"semi-sextile\";\n    const minorCap = 1.0;\n    const capByClass = (cls)=>{\n        if (cls === \"luminary\" || cls === \"angle\") return 6.0;\n        if (cls === \"point\") return 3.0;\n        return 4.0; // planets default\n    };\n    const capBodies = Math.max(capByClass(aClass), capByClass(bClass));\n    const cap = isMinor ? minorCap : capBodies;\n    const o = Math.abs(Number(orbDeg || 0));\n    if (!(o >= 0)) return 0;\n    if (o >= cap) return 0;\n    return +(1 - o / cap);\n}\n// Sensitivity multiplier: angles/luminaries/personals boosted symmetrically\nfunction sensitivity(aName, bName) {\n    const set = new Set([\n        bodyClass(aName),\n        bodyClass(bName)\n    ]);\n    let s = 1.0;\n    if (set.has(\"angle\")) s *= 1.2;\n    if (set.has(\"luminary\")) s *= 1.1;\n    if (set.has(\"personal\")) s *= 1.05;\n    return s;\n}\n// Planetary multipliers vary by channel\nfunction planetMultiplier(body, mode) {\n    switch(mode){\n        case \"support\":\n            if (body === \"Jupiter\" || body === \"Venus\") return 1.4;\n            if (body === \"Moon\" || body === \"Saturn\") return 1.2; // when stabilizing\n            // Sun/Mercury 1.0; others default 1.0\n            return 1.0;\n        case \"counter\":\n            if (body === \"Mars\") return 1.2;\n            if (body === \"Saturn\" || body === \"Pluto\" || body === \"Chiron\") return 1.2;\n            if (body === \"Neptune\") return 1.1;\n            return 1.0;\n        default:\n            return 1.0;\n    }\n}\n// Base weights for SFD\nfunction baseSupportWeight(type, aName, bName) {\n    switch(type){\n        case \"trine\":\n            return +1.5;\n        case \"sextile\":\n            return +1.0;\n        case \"conjunction\":\n            if (isBenefic(aName) || isBenefic(bName)) return +1.2; // benefic conj\n            return 0.0;\n        default:\n            return 0.0;\n    }\n}\nfunction isMoonSaturnSoft(type, aName, bName) {\n    if (!(type === \"trine\" || type === \"sextile\")) return false;\n    const set = new Set([\n        aName,\n        bName\n    ]);\n    return set.has(\"Moon\") && set.has(\"Saturn\");\n}\nfunction isMinorSupport(type) {\n    // Conservative: treat harmonic minors as supportive\n    return type === \"quintile\" || type === \"biquintile\";\n}\nfunction baseCounterWeight(type, aName, bName) {\n    const set = new Set([\n        aName,\n        bName\n    ]);\n    const hard = type === \"square\" || type === \"opposition\";\n    if (hard && (set.has(\"Jupiter\") || set.has(\"Venus\"))) return -1.3; // hard to benefics\n    if (type === \"conjunction\" && (set.has(\"Saturn\") || set.has(\"Pluto\") || set.has(\"Chiron\")) && (set.has(\"Jupiter\") || set.has(\"Venus\"))) return -0.8; // heavy to benefic conj\n    // Specific hard combos handled in logic using support nodes (see below)\n    return 0.0;\n}\n// Utility: whether aspect is a hard aspect between X and Y sets\nfunction isHardBetween(type, aName, bName, setA, setB) {\n    if (!(type === \"square\" || type === \"opposition\")) return false;\n    const A = new Set([\n        aName,\n        bName\n    ]);\n    return [\n        ...setA\n    ].some((x)=>A.has(x)) && [\n        ...setB\n    ].some((x)=>A.has(x));\n}\n// Balance Channel v1.1 (rebalanced valence only)\n// Simple pass: reuse SFD support weights but with gentler base table per Appendix (if needed later)\nfunction computeBalanceValence(dayAspects) {\n    if (!Array.isArray(dayAspects)) return 0;\n    let v = 0;\n    for (const rec of dayAspects){\n        const type = normAspectName(rec.aspect || rec.type || rec._aspect);\n        const a = normBody(rec.p1_name || rec.a || rec.transit);\n        const b = normBody(rec.p2_name || rec.b || rec.natal);\n        const orb = rec.orb != null ? rec.orb : rec.orbit != null ? rec.orbit : rec._orb;\n        const o = orbMultiplier(type, orb, a, b);\n        const s = sensitivity(a, b);\n        // v1.1 base: softer positives/negatives than v1.0; here approximate using SFD support and skip negatives except hard to benefics\n        let base = 0;\n        base += baseSupportWeight(type, a, b);\n        if (isMoonSaturnSoft(type, a, b)) base = Math.max(base, 1.2);\n        if (isMinorSupport(type) && Math.abs(orb) <= 1.0) base = Math.max(base, 0.5);\n        // small negative for hard to benefic\n        const neg = baseCounterWeight(type, a, b);\n        const mA = planetMultiplier(a, base > 0 ? \"support\" : \"counter\");\n        const mB = planetMultiplier(b, base > 0 ? \"support\" : \"counter\");\n        const w = ((base > 0 ? base : 0) + (neg < 0 ? neg : 0)) * mA * mB * o * s;\n        v += w;\n    }\n    // Soft normalization to -5..+5\n    const K = 4.0;\n    return round(5 * Math.tanh(v / K), 2);\n}\n// Core SFD computation (v1.2)\nfunction computeSFD(dayAspects) {\n    if (!Array.isArray(dayAspects)) return {\n        SFD: 0,\n        Splus: 0,\n        Sminus: 0\n    };\n    let support = 0;\n    let counter = 0;\n    const supportNodes = new Set();\n    // First pass: collect S+ and nodes\n    for (const rec of dayAspects){\n        const type = normAspectName(rec.aspect || rec.type || rec._aspect);\n        const a = normBody(rec.p1_name || rec.a || rec.transit);\n        const b = normBody(rec.p2_name || rec.b || rec.natal);\n        const orb = rec.orb != null ? rec.orb : rec.orbit != null ? rec.orbit : rec._orb;\n        let base = baseSupportWeight(type, a, b);\n        if (isMoonSaturnSoft(type, a, b)) base = Math.max(base, 1.2);\n        if (isMinorSupport(type) && Math.abs(orb) <= 1.0) base = Math.max(base, 0.5);\n        if (base > 0) {\n            const mA = planetMultiplier(a, \"support\");\n            const mB = planetMultiplier(b, \"support\");\n            const o = orbMultiplier(type, orb, a, b);\n            const s = sensitivity(a, b);\n            const w = base * mA * mB * o * s;\n            support += Math.max(w, 0);\n            supportNodes.add(a);\n            supportNodes.add(b);\n        }\n    }\n    const touched = (a, b)=>supportNodes.has(a) || supportNodes.has(b);\n    // Second pass: collect S−\n    for (const rec of dayAspects){\n        const type = normAspectName(rec.aspect || rec.type || rec._aspect);\n        const a = normBody(rec.p1_name || rec.a || rec.transit);\n        const b = normBody(rec.p2_name || rec.b || rec.natal);\n        const orb = rec.orb != null ? rec.orb : rec.orbit != null ? rec.orbit : rec._orb;\n        let base = 0;\n        // base negatives\n        base = Math.min(base, baseCounterWeight(type, a, b));\n        // Hard aspects to S+ nodes by Saturn/Mars/Neptune → negative\n        const hard = type === \"square\" || type === \"opposition\";\n        const SplusNodes = new Set([\n            ...supportNodes\n        ]);\n        if (hard && (a === \"Saturn\" || a === \"Mars\" || a === \"Neptune\" || b === \"Saturn\" || b === \"Mars\" || b === \"Neptune\") && (SplusNodes.has(a) || SplusNodes.has(b))) {\n            base = Math.min(base, -1.1); // conservative default\n        }\n        // Sat/Nept hard to Moon/Mercury when Moon/Mercury in S+\n        const specialTargets = new Set([\n            \"Moon\",\n            \"Mercury\"\n        ]);\n        if (hard && (a === \"Saturn\" || a === \"Neptune\" || b === \"Saturn\" || b === \"Neptune\") && (specialTargets.has(a) || specialTargets.has(b)) && (SplusNodes.has(\"Moon\") || SplusNodes.has(\"Mercury\"))) {\n            base = Math.min(base, -1.1);\n        }\n        // Mars hard to Ven/Jup\n        if (hard && (a === \"Mars\" || b === \"Mars\") && (a === \"Venus\" || a === \"Jupiter\" || b === \"Venus\" || b === \"Jupiter\")) {\n            base = Math.min(base, -1.2);\n        }\n        // Saturn hard to Venus\n        if (hard && (a === \"Saturn\" || b === \"Saturn\") && (a === \"Venus\" || b === \"Venus\")) {\n            base = Math.min(base, -1.1);\n        }\n        if (base < 0) {\n            const mA = planetMultiplier(a, \"counter\");\n            const mB = planetMultiplier(b, \"counter\");\n            const o = orbMultiplier(type, orb, a, b);\n            const s = sensitivity(a, b);\n            let w = Math.abs(base) * mA * mB * o * s;\n            if (!touched(a, b)) w *= 0.7; // locality factor if not touching S+ nodes\n            counter += Math.max(w, 0);\n        }\n    }\n    const K = 4.0; // normalization constant, tuneable\n    const Splus = +(5 * Math.tanh(support / K)).toFixed(2);\n    const Sminus = +(5 * Math.tanh(counter / K)).toFixed(2);\n    const SFD = round(clamp(Splus - Sminus, -5, 5), 2);\n    return {\n        SFD,\n        Splus,\n        Sminus\n    };\n}\nmodule.exports = {\n    computeSFD,\n    computeBalanceValence\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2lGLE1BQU0sQ0FBQztRQUN6QjtRQUNBLHVCQUF1QjtRQUN2QixJQUFJckIsUUFBU3ZELENBQUFBLE1BQUksWUFBWXNCLE1BQUksUUFBTyxLQUFPdEIsQ0FBQUEsTUFBSSxXQUFXc0IsTUFBSSxPQUFNLEdBQUc7WUFDekVzRCxPQUFPbkYsS0FBS0UsR0FBRyxDQUFDaUYsTUFBTSxDQUFDO1FBQ3pCO1FBRUEsSUFBSUEsT0FBTyxHQUFFO1lBQ1gsTUFBTUUsS0FBSzlCLGlCQUFpQmhELEdBQUc7WUFDL0IsTUFBTStFLEtBQUsvQixpQkFBaUIxQixHQUFHO1lBQy9CLE1BQU1tQixJQUFJYixjQUFjdUIsTUFBTXNCLEtBQUt6RSxHQUFHc0I7WUFDdEMsTUFBTXZCLElBQUk2QyxZQUFZNUMsR0FBRXNCO1lBQ3hCLElBQUkwRCxJQUFJdkYsS0FBS2lELEdBQUcsQ0FBQ2tDLFFBQVFFLEtBQUtDLEtBQUt0QyxJQUFJMUM7WUFDdkMsSUFBSSxDQUFDNEYsUUFBUTNGLEdBQUVzQixJQUFJMEQsS0FBSyxLQUFLLDJDQUEyQztZQUN4RVEsV0FBVy9GLEtBQUtDLEdBQUcsQ0FBQ3NGLEdBQUc7UUFDekI7SUFDRjtJQUVBLE1BQU1DLElBQUksS0FBSyxtQ0FBbUM7SUFDbEQsTUFBTUksUUFBUyxDQUFDLENBQUMsSUFBSTVGLEtBQUt5RixJQUFJLENBQUNLLFVBQVVOLEVBQUMsRUFBR2EsT0FBTyxDQUFDO0lBQ3JELE1BQU1SLFNBQVMsQ0FBQyxDQUFDLElBQUk3RixLQUFLeUYsSUFBSSxDQUFDTSxVQUFVUCxFQUFDLEVBQUdhLE9BQU8sQ0FBQztJQUNyRCxNQUFNVixNQUFNeEYsTUFBTVAsTUFBTWdHLFFBQVFDLFFBQVEsQ0FBQyxHQUFHLElBQUk7SUFDaEQsT0FBTztRQUFFRjtRQUFLQztRQUFPQztJQUFPO0FBQzlCO0FBRUFTLE9BQU9DLE9BQU8sR0FBRztJQUNmYjtJQUNBckI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dvdmVuLXdlYi1hcHAvLi9zcmMvYmFsYW5jZS1tZXRlci5qcz9jOWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9iYWxhbmNlLW1ldGVyLmpzXG4vLyBCYWxhbmNlIENoYW5uZWwgKHYxLjEpICsgU3VwcG9ydOKAk0ZyaWN0aW9uIERpZmZlcmVudGlhbCAoU0ZELCB2MS4yKVxuLy8gU3RhbmRhbG9uZSBjb21wdXRhdGlvbiBiYXNlZCBvbiBcIkJhbGFuY2UgTWV0ZXIudHh0XCIgc3BlYyAodjEuMiBEcmFmdCwgU2VwIDUsIDIwMjUpXG5cbmZ1bmN0aW9uIGNsYW1wKG4sIGxvLCBoaSl7IHJldHVybiBNYXRoLm1heChsbywgTWF0aC5taW4oaGksIG4pKTsgfVxuZnVuY3Rpb24gcm91bmQobiwgcD0yKXsgcmV0dXJuIE1hdGgucm91bmQobiAqICgxMCoqcCkpIC8gKDEwKipwKTsgfVxuXG4vLyBOb3JtYWxpemUgdmFyaW91cyBhc3BlY3QgbmFtZSBzcGVsbGluZ3MgdG8gY2Fub25pY2FsIGxvd2VyY2FzZVxuZnVuY3Rpb24gbm9ybUFzcGVjdE5hbWUocyl7XG4gIGNvbnN0IGEgPSBTdHJpbmcoc3x8JycpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBjb25zdCBtYXAgPSB7XG4gICAgb3Bwb3NpdGlvbjogJ29wcG9zaXRpb24nLCBvcHA6ICdvcHBvc2l0aW9uJyxcbiAgICBzcXVhcmU6ICdzcXVhcmUnLCBzcTogJ3NxdWFyZScsXG4gICAgdHJpbmU6ICd0cmluZScsIHRyaTogJ3RyaW5lJyxcbiAgICBzZXh0aWxlOiAnc2V4dGlsZScsIHNleDogJ3NleHRpbGUnLFxuICAgIGNvbmp1bmN0aW9uOiAnY29uanVuY3Rpb24nLCBjb25qOiAnY29uanVuY3Rpb24nLFxuICAgIHF1aW50aWxlOiAncXVpbnRpbGUnLCBiaXF1aW50aWxlOiAnYmlxdWludGlsZScsXG4gICAgcXVpbmN1bng6ICdxdWluY3VueCcsIGluY29uanVuY3Q6ICdxdWluY3VueCcsXG4gICAgJ3NlbWktc3F1YXJlJzogJ3NlbWktc3F1YXJlJywgc2VzcXVpc3F1YXJlOiAnc2VzcXVpcXVhZHJhdGUnLCBzZXNxdWlxdWFkcmF0ZTogJ3Nlc3F1aXF1YWRyYXRlJyxcbiAgICAnc2VtaS1zZXh0aWxlJzogJ3NlbWktc2V4dGlsZSdcbiAgfTtcbiAgcmV0dXJuIG1hcFthXSB8fCBhO1xufVxuXG4vLyBCb2R5IGhlbHBlcnNcbmZ1bmN0aW9uIG5vcm1Cb2R5KGIpe1xuICBpZiAoIWIpIHJldHVybiAnJztcbiAgY29uc3QgcyA9IHR5cGVvZiBiID09PSAnc3RyaW5nJyA/IGIgOiAoYi5uYW1lIHx8IGIuYm9keSB8fCAnJyk7XG4gIHJldHVybiBTdHJpbmcocyB8fCAnJykudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBib2R5Q2xhc3MobmFtZSl7XG4gIHN3aXRjaChuYW1lKXtcbiAgICBjYXNlICdTdW4nOlxuICAgIGNhc2UgJ01vb24nOiByZXR1cm4gJ2x1bWluYXJ5JztcbiAgICBjYXNlICdNZXJjdXJ5JzpcbiAgICBjYXNlICdWZW51cyc6XG4gICAgY2FzZSAnTWFycyc6IHJldHVybiAncGVyc29uYWwnO1xuICAgIGNhc2UgJ0p1cGl0ZXInOlxuICAgIGNhc2UgJ1NhdHVybic6IHJldHVybiAnc29jaWFsJztcbiAgICBjYXNlICdVcmFudXMnOlxuICAgIGNhc2UgJ05lcHR1bmUnOlxuICAgIGNhc2UgJ1BsdXRvJzogcmV0dXJuICdvdXRlcic7XG4gICAgY2FzZSAnQXNjZW5kYW50JzpcbiAgICBjYXNlICdNZWRpdW1fQ29lbGknOlxuICAgIGNhc2UgJ0Rlc2NlbmRhbnQnOlxuICAgIGNhc2UgJ0ltdW1fQ29lbGknOiByZXR1cm4gJ2FuZ2xlJztcbiAgICBjYXNlICdDaGlyb24nOlxuICAgIGNhc2UgJ01lYW5fTm9kZSc6XG4gICAgY2FzZSAnVHJ1ZV9Ob2RlJzpcbiAgICBjYXNlICdNZWFuX1NvdXRoX05vZGUnOlxuICAgIGNhc2UgJ1RydWVfU291dGhfTm9kZSc6XG4gICAgY2FzZSAnTWVhbl9MaWxpdGgnOiByZXR1cm4gJ3BvaW50JztcbiAgICBkZWZhdWx0OiByZXR1cm4gJ290aGVyJztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0JlbmVmaWMobmFtZSl7IHJldHVybiBuYW1lPT09J0p1cGl0ZXInIHx8IG5hbWU9PT0nVmVudXMnOyB9XG5mdW5jdGlvbiBpc0hlYXZ5KG5hbWUpeyByZXR1cm4gbmFtZT09PSdTYXR1cm4nIHx8IG5hbWU9PT0nUGx1dG8nIHx8IG5hbWU9PT0nQ2hpcm9uJzsgfVxuXG4vLyBMaW5lYXIgb3JiIG11bHRpcGxpZXIgd2l0aCBjYXBzIHBlciBjbGFzcywgMS4wIGF0IGV4YWN0IOKGkiAwIGF0L292ZXIgY2FwLlxuZnVuY3Rpb24gb3JiTXVsdGlwbGllcihhc3BlY3QsIG9yYkRlZywgYU5hbWUsIGJOYW1lKXtcbiAgY29uc3QgYUNsYXNzID0gYm9keUNsYXNzKGFOYW1lKTtcbiAgY29uc3QgYkNsYXNzID0gYm9keUNsYXNzKGJOYW1lKTtcbiAgY29uc3QgaXNNaW5vciA9IChhc3BlY3Q9PT0ncXVpbnRpbGUnIHx8IGFzcGVjdD09PSdiaXF1aW50aWxlJyB8fCBhc3BlY3Q9PT0ncXVpbmN1bngnIHx8IGFzcGVjdD09PSdzZXNxdWlxdWFkcmF0ZScgfHwgYXNwZWN0PT09J3NlbWktc3F1YXJlJyB8fCBhc3BlY3Q9PT0nc2VtaS1zZXh0aWxlJyk7XG4gIGNvbnN0IG1pbm9yQ2FwID0gMS4wO1xuICBjb25zdCBjYXBCeUNsYXNzID0gKGNscyk9PntcbiAgICBpZiAoY2xzPT09J2x1bWluYXJ5JyB8fCBjbHM9PT0nYW5nbGUnKSByZXR1cm4gNi4wO1xuICAgIGlmIChjbHM9PT0ncG9pbnQnKSByZXR1cm4gMy4wO1xuICAgIHJldHVybiA0LjA7IC8vIHBsYW5ldHMgZGVmYXVsdFxuICB9O1xuICBjb25zdCBjYXBCb2RpZXMgPSBNYXRoLm1heChjYXBCeUNsYXNzKGFDbGFzcyksIGNhcEJ5Q2xhc3MoYkNsYXNzKSk7XG4gIGNvbnN0IGNhcCA9IGlzTWlub3IgPyBtaW5vckNhcCA6IGNhcEJvZGllcztcbiAgY29uc3QgbyA9IE1hdGguYWJzKE51bWJlcihvcmJEZWd8fDApKTtcbiAgaWYgKCEobz49MCkpIHJldHVybiAwO1xuICBpZiAobz49Y2FwKSByZXR1cm4gMDtcbiAgcmV0dXJuICsoMSAtIChvL2NhcCkpO1xufVxuXG4vLyBTZW5zaXRpdml0eSBtdWx0aXBsaWVyOiBhbmdsZXMvbHVtaW5hcmllcy9wZXJzb25hbHMgYm9vc3RlZCBzeW1tZXRyaWNhbGx5XG5mdW5jdGlvbiBzZW5zaXRpdml0eShhTmFtZSwgYk5hbWUpe1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KFtib2R5Q2xhc3MoYU5hbWUpLCBib2R5Q2xhc3MoYk5hbWUpXSk7XG4gIGxldCBzID0gMS4wO1xuICBpZiAoc2V0LmhhcygnYW5nbGUnKSkgcyAqPSAxLjI7XG4gIGlmIChzZXQuaGFzKCdsdW1pbmFyeScpKSBzICo9IDEuMTtcbiAgaWYgKHNldC5oYXMoJ3BlcnNvbmFsJykpIHMgKj0gMS4wNTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vIFBsYW5ldGFyeSBtdWx0aXBsaWVycyB2YXJ5IGJ5IGNoYW5uZWxcbmZ1bmN0aW9uIHBsYW5ldE11bHRpcGxpZXIoYm9keSwgbW9kZSl7XG4gIHN3aXRjaChtb2RlKXtcbiAgICBjYXNlICdzdXBwb3J0JzogLy8gUysgY2hhbm5lbFxuICAgICAgaWYgKGJvZHk9PT0nSnVwaXRlcicgfHwgYm9keT09PSdWZW51cycpIHJldHVybiAxLjQ7XG4gICAgICBpZiAoYm9keT09PSdNb29uJyB8fCBib2R5PT09J1NhdHVybicpIHJldHVybiAxLjI7IC8vIHdoZW4gc3RhYmlsaXppbmdcbiAgICAgIC8vIFN1bi9NZXJjdXJ5IDEuMDsgb3RoZXJzIGRlZmF1bHQgMS4wXG4gICAgICByZXR1cm4gMS4wO1xuICAgIGNhc2UgJ2NvdW50ZXInOiAvLyBT4oiSIGNoYW5uZWxcbiAgICAgIGlmIChib2R5PT09J01hcnMnKSByZXR1cm4gMS4yO1xuICAgICAgaWYgKGJvZHk9PT0nU2F0dXJuJyB8fCBib2R5PT09J1BsdXRvJyB8fCBib2R5PT09J0NoaXJvbicpIHJldHVybiAxLjI7XG4gICAgICBpZiAoYm9keT09PSdOZXB0dW5lJykgcmV0dXJuIDEuMTtcbiAgICAgIHJldHVybiAxLjA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAxLjA7XG4gIH1cbn1cblxuLy8gQmFzZSB3ZWlnaHRzIGZvciBTRkRcbmZ1bmN0aW9uIGJhc2VTdXBwb3J0V2VpZ2h0KHR5cGUsIGFOYW1lLCBiTmFtZSl7XG4gIHN3aXRjaCh0eXBlKXtcbiAgICBjYXNlICd0cmluZSc6IHJldHVybiArMS41O1xuICAgIGNhc2UgJ3NleHRpbGUnOiByZXR1cm4gKzEuMDtcbiAgICBjYXNlICdjb25qdW5jdGlvbic6XG4gICAgICBpZiAoaXNCZW5lZmljKGFOYW1lKSB8fCBpc0JlbmVmaWMoYk5hbWUpKSByZXR1cm4gKzEuMjsgLy8gYmVuZWZpYyBjb25qXG4gICAgICByZXR1cm4gMC4wO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMC4wO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9vblNhdHVyblNvZnQodHlwZSwgYU5hbWUsIGJOYW1lKXtcbiAgaWYgKCEodHlwZT09PSd0cmluZScgfHwgdHlwZT09PSdzZXh0aWxlJykpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldChbYU5hbWUsYk5hbWVdKTtcbiAgcmV0dXJuIHNldC5oYXMoJ01vb24nKSAmJiBzZXQuaGFzKCdTYXR1cm4nKTtcbn1cblxuZnVuY3Rpb24gaXNNaW5vclN1cHBvcnQodHlwZSl7XG4gIC8vIENvbnNlcnZhdGl2ZTogdHJlYXQgaGFybW9uaWMgbWlub3JzIGFzIHN1cHBvcnRpdmVcbiAgcmV0dXJuIHR5cGU9PT0ncXVpbnRpbGUnIHx8IHR5cGU9PT0nYmlxdWludGlsZSc7XG59XG5cbmZ1bmN0aW9uIGJhc2VDb3VudGVyV2VpZ2h0KHR5cGUsIGFOYW1lLCBiTmFtZSl7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoW2FOYW1lLGJOYW1lXSk7XG4gIGNvbnN0IGhhcmQgPSAodHlwZT09PSdzcXVhcmUnIHx8IHR5cGU9PT0nb3Bwb3NpdGlvbicpO1xuICBpZiAoaGFyZCAmJiAoc2V0LmhhcygnSnVwaXRlcicpIHx8IHNldC5oYXMoJ1ZlbnVzJykpKSByZXR1cm4gLTEuMzsgLy8gaGFyZCB0byBiZW5lZmljc1xuICBpZiAodHlwZT09PSdjb25qdW5jdGlvbicgJiYgKHNldC5oYXMoJ1NhdHVybicpIHx8IHNldC5oYXMoJ1BsdXRvJykgfHwgc2V0LmhhcygnQ2hpcm9uJykpICYmIChzZXQuaGFzKCdKdXBpdGVyJykgfHwgc2V0LmhhcygnVmVudXMnKSkpIHJldHVybiAtMC44OyAvLyBoZWF2eSB0byBiZW5lZmljIGNvbmpcbiAgLy8gU3BlY2lmaWMgaGFyZCBjb21ib3MgaGFuZGxlZCBpbiBsb2dpYyB1c2luZyBzdXBwb3J0IG5vZGVzIChzZWUgYmVsb3cpXG4gIHJldHVybiAwLjA7XG59XG5cbi8vIFV0aWxpdHk6IHdoZXRoZXIgYXNwZWN0IGlzIGEgaGFyZCBhc3BlY3QgYmV0d2VlbiBYIGFuZCBZIHNldHNcbmZ1bmN0aW9uIGlzSGFyZEJldHdlZW4odHlwZSwgYU5hbWUsIGJOYW1lLCBzZXRBLCBzZXRCKXtcbiAgaWYgKCEodHlwZT09PSdzcXVhcmUnIHx8IHR5cGU9PT0nb3Bwb3NpdGlvbicpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IEEgPSBuZXcgU2V0KFthTmFtZSxiTmFtZV0pO1xuICByZXR1cm4gKFsuLi5zZXRBXS5zb21lKHg9PkEuaGFzKHgpKSAmJiBbLi4uc2V0Ql0uc29tZSh4PT5BLmhhcyh4KSkpO1xufVxuXG4vLyBCYWxhbmNlIENoYW5uZWwgdjEuMSAocmViYWxhbmNlZCB2YWxlbmNlIG9ubHkpXG4vLyBTaW1wbGUgcGFzczogcmV1c2UgU0ZEIHN1cHBvcnQgd2VpZ2h0cyBidXQgd2l0aCBnZW50bGVyIGJhc2UgdGFibGUgcGVyIEFwcGVuZGl4IChpZiBuZWVkZWQgbGF0ZXIpXG5mdW5jdGlvbiBjb21wdXRlQmFsYW5jZVZhbGVuY2UoZGF5QXNwZWN0cyl7XG4gIGlmICghQXJyYXkuaXNBcnJheShkYXlBc3BlY3RzKSkgcmV0dXJuIDA7XG4gIGxldCB2ID0gMDtcbiAgZm9yIChjb25zdCByZWMgb2YgZGF5QXNwZWN0cyl7XG4gICAgY29uc3QgdHlwZSA9IG5vcm1Bc3BlY3ROYW1lKHJlYy5hc3BlY3QgfHwgcmVjLnR5cGUgfHwgcmVjLl9hc3BlY3QpO1xuICAgIGNvbnN0IGEgPSBub3JtQm9keShyZWMucDFfbmFtZSB8fCByZWMuYSB8fCByZWMudHJhbnNpdCk7XG4gICAgY29uc3QgYiA9IG5vcm1Cb2R5KHJlYy5wMl9uYW1lIHx8IHJlYy5iIHx8IHJlYy5uYXRhbCk7XG4gICAgY29uc3Qgb3JiID0gcmVjLm9yYiAhPSBudWxsID8gcmVjLm9yYiA6IChyZWMub3JiaXQgIT0gbnVsbCA/IHJlYy5vcmJpdCA6IHJlYy5fb3JiKTtcbiAgICBjb25zdCBvID0gb3JiTXVsdGlwbGllcih0eXBlLCBvcmIsIGEsIGIpO1xuICAgIGNvbnN0IHMgPSBzZW5zaXRpdml0eShhLGIpO1xuICAgIC8vIHYxLjEgYmFzZTogc29mdGVyIHBvc2l0aXZlcy9uZWdhdGl2ZXMgdGhhbiB2MS4wOyBoZXJlIGFwcHJveGltYXRlIHVzaW5nIFNGRCBzdXBwb3J0IGFuZCBza2lwIG5lZ2F0aXZlcyBleGNlcHQgaGFyZCB0byBiZW5lZmljc1xuICAgIGxldCBiYXNlID0gMDtcbiAgICBiYXNlICs9IGJhc2VTdXBwb3J0V2VpZ2h0KHR5cGUsIGEsYik7XG4gICAgaWYgKGlzTW9vblNhdHVyblNvZnQodHlwZSxhLGIpKSBiYXNlID0gTWF0aC5tYXgoYmFzZSwgMS4yKTtcbiAgICBpZiAoaXNNaW5vclN1cHBvcnQodHlwZSkgJiYgTWF0aC5hYnMob3JiKSA8PSAxLjApIGJhc2UgPSBNYXRoLm1heChiYXNlLCAwLjUpO1xuICAgIC8vIHNtYWxsIG5lZ2F0aXZlIGZvciBoYXJkIHRvIGJlbmVmaWNcbiAgICBjb25zdCBuZWcgPSBiYXNlQ291bnRlcldlaWdodCh0eXBlLCBhLGIpO1xuICAgIGNvbnN0IG1BID0gcGxhbmV0TXVsdGlwbGllcihhLCBiYXNlPjAgPyAnc3VwcG9ydCcgOiAnY291bnRlcicpO1xuICAgIGNvbnN0IG1CID0gcGxhbmV0TXVsdGlwbGllcihiLCBiYXNlPjAgPyAnc3VwcG9ydCcgOiAnY291bnRlcicpO1xuICAgIGNvbnN0IHcgPSAoKGJhc2U+MD8gYmFzZSA6IDApICsgKG5lZzwwPyBuZWcgOiAwKSkgKiBtQSAqIG1CICogbyAqIHM7XG4gICAgdiArPSB3O1xuICB9XG4gIC8vIFNvZnQgbm9ybWFsaXphdGlvbiB0byAtNS4uKzVcbiAgY29uc3QgSyA9IDQuMDtcbiAgcmV0dXJuIHJvdW5kKDUgKiBNYXRoLnRhbmgodiAvIEspLCAyKTtcbn1cblxuLy8gQ29yZSBTRkQgY29tcHV0YXRpb24gKHYxLjIpXG5mdW5jdGlvbiBjb21wdXRlU0ZEKGRheUFzcGVjdHMpe1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF5QXNwZWN0cykpIHJldHVybiB7IFNGRDogMCwgU3BsdXM6IDAsIFNtaW51czogMCB9O1xuXG4gIGxldCBzdXBwb3J0ID0gMDtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICBjb25zdCBzdXBwb3J0Tm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgLy8gRmlyc3QgcGFzczogY29sbGVjdCBTKyBhbmQgbm9kZXNcbiAgZm9yIChjb25zdCByZWMgb2YgZGF5QXNwZWN0cyl7XG4gICAgY29uc3QgdHlwZSA9IG5vcm1Bc3BlY3ROYW1lKHJlYy5hc3BlY3QgfHwgcmVjLnR5cGUgfHwgcmVjLl9hc3BlY3QpO1xuICAgIGNvbnN0IGEgPSBub3JtQm9keShyZWMucDFfbmFtZSB8fCByZWMuYSB8fCByZWMudHJhbnNpdCk7XG4gICAgY29uc3QgYiA9IG5vcm1Cb2R5KHJlYy5wMl9uYW1lIHx8IHJlYy5iIHx8IHJlYy5uYXRhbCk7XG4gICAgY29uc3Qgb3JiID0gcmVjLm9yYiAhPSBudWxsID8gcmVjLm9yYiA6IChyZWMub3JiaXQgIT0gbnVsbCA/IHJlYy5vcmJpdCA6IHJlYy5fb3JiKTtcblxuICAgIGxldCBiYXNlID0gYmFzZVN1cHBvcnRXZWlnaHQodHlwZSwgYSxiKTtcbiAgICBpZiAoaXNNb29uU2F0dXJuU29mdCh0eXBlLCBhLGIpKSBiYXNlID0gTWF0aC5tYXgoYmFzZSwgMS4yKTtcbiAgICBpZiAoaXNNaW5vclN1cHBvcnQodHlwZSkgJiYgTWF0aC5hYnMob3JiKSA8PSAxLjApIGJhc2UgPSBNYXRoLm1heChiYXNlLCAwLjUpO1xuXG4gICAgaWYgKGJhc2UgPiAwKXtcbiAgICAgIGNvbnN0IG1BID0gcGxhbmV0TXVsdGlwbGllcihhLCAnc3VwcG9ydCcpO1xuICAgICAgY29uc3QgbUIgPSBwbGFuZXRNdWx0aXBsaWVyKGIsICdzdXBwb3J0Jyk7XG4gICAgICBjb25zdCBvID0gb3JiTXVsdGlwbGllcih0eXBlLCBvcmIsIGEsIGIpO1xuICAgICAgY29uc3QgcyA9IHNlbnNpdGl2aXR5KGEsYik7XG4gICAgICBjb25zdCB3ID0gYmFzZSAqIG1BICogbUIgKiBvICogcztcbiAgICAgIHN1cHBvcnQgKz0gTWF0aC5tYXgodywgMCk7XG4gICAgICBzdXBwb3J0Tm9kZXMuYWRkKGEpOyBzdXBwb3J0Tm9kZXMuYWRkKGIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRvdWNoZWQgPSAoYSxiKT0+IHN1cHBvcnROb2Rlcy5oYXMoYSkgfHwgc3VwcG9ydE5vZGVzLmhhcyhiKTtcblxuICAvLyBTZWNvbmQgcGFzczogY29sbGVjdCBT4oiSXG4gIGZvciAoY29uc3QgcmVjIG9mIGRheUFzcGVjdHMpe1xuICAgIGNvbnN0IHR5cGUgPSBub3JtQXNwZWN0TmFtZShyZWMuYXNwZWN0IHx8IHJlYy50eXBlIHx8IHJlYy5fYXNwZWN0KTtcbiAgICBjb25zdCBhID0gbm9ybUJvZHkocmVjLnAxX25hbWUgfHwgcmVjLmEgfHwgcmVjLnRyYW5zaXQpO1xuICAgIGNvbnN0IGIgPSBub3JtQm9keShyZWMucDJfbmFtZSB8fCByZWMuYiB8fCByZWMubmF0YWwpO1xuICAgIGNvbnN0IG9yYiA9IHJlYy5vcmIgIT0gbnVsbCA/IHJlYy5vcmIgOiAocmVjLm9yYml0ICE9IG51bGwgPyByZWMub3JiaXQgOiByZWMuX29yYik7XG5cbiAgICBsZXQgYmFzZSA9IDA7XG4gICAgLy8gYmFzZSBuZWdhdGl2ZXNcbiAgICBiYXNlID0gTWF0aC5taW4oYmFzZSwgYmFzZUNvdW50ZXJXZWlnaHQodHlwZSwgYSxiKSk7XG5cbiAgICAvLyBIYXJkIGFzcGVjdHMgdG8gUysgbm9kZXMgYnkgU2F0dXJuL01hcnMvTmVwdHVuZSDihpIgbmVnYXRpdmVcbiAgICBjb25zdCBoYXJkID0gKHR5cGU9PT0nc3F1YXJlJyB8fCB0eXBlPT09J29wcG9zaXRpb24nKTtcbiAgICBjb25zdCBTcGx1c05vZGVzID0gbmV3IFNldChbLi4uc3VwcG9ydE5vZGVzXSk7XG4gICAgaWYgKGhhcmQgJiYgKGE9PT0nU2F0dXJuJyB8fCBhPT09J01hcnMnIHx8IGE9PT0nTmVwdHVuZScgfHwgYj09PSdTYXR1cm4nIHx8IGI9PT0nTWFycycgfHwgYj09PSdOZXB0dW5lJykgJiYgKFNwbHVzTm9kZXMuaGFzKGEpIHx8IFNwbHVzTm9kZXMuaGFzKGIpKSl7XG4gICAgICBiYXNlID0gTWF0aC5taW4oYmFzZSwgLTEuMSk7IC8vIGNvbnNlcnZhdGl2ZSBkZWZhdWx0XG4gICAgfVxuICAgIC8vIFNhdC9OZXB0IGhhcmQgdG8gTW9vbi9NZXJjdXJ5IHdoZW4gTW9vbi9NZXJjdXJ5IGluIFMrXG4gICAgY29uc3Qgc3BlY2lhbFRhcmdldHMgPSBuZXcgU2V0KFsnTW9vbicsJ01lcmN1cnknXSk7XG4gICAgaWYgKGhhcmQgJiYgKGE9PT0nU2F0dXJuJyB8fCBhPT09J05lcHR1bmUnIHx8IGI9PT0nU2F0dXJuJyB8fCBiPT09J05lcHR1bmUnKSAmJiAoc3BlY2lhbFRhcmdldHMuaGFzKGEpIHx8IHNwZWNpYWxUYXJnZXRzLmhhcyhiKSkgJiYgKFNwbHVzTm9kZXMuaGFzKCdNb29uJykgfHwgU3BsdXNOb2Rlcy5oYXMoJ01lcmN1cnknKSkpe1xuICAgICAgYmFzZSA9IE1hdGgubWluKGJhc2UsIC0xLjEpO1xuICAgIH1cbiAgICAvLyBNYXJzIGhhcmQgdG8gVmVuL0p1cFxuICAgIGlmIChoYXJkICYmIChhPT09J01hcnMnIHx8IGI9PT0nTWFycycpICYmIChhPT09J1ZlbnVzJyB8fCBhPT09J0p1cGl0ZXInIHx8IGI9PT0nVmVudXMnIHx8IGI9PT0nSnVwaXRlcicpKXtcbiAgICAgIGJhc2UgPSBNYXRoLm1pbihiYXNlLCAtMS4yKTtcbiAgICB9XG4gICAgLy8gU2F0dXJuIGhhcmQgdG8gVmVudXNcbiAgICBpZiAoaGFyZCAmJiAoYT09PSdTYXR1cm4nIHx8IGI9PT0nU2F0dXJuJykgJiYgKGE9PT0nVmVudXMnIHx8IGI9PT0nVmVudXMnKSl7XG4gICAgICBiYXNlID0gTWF0aC5taW4oYmFzZSwgLTEuMSk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPCAwKXtcbiAgICAgIGNvbnN0IG1BID0gcGxhbmV0TXVsdGlwbGllcihhLCAnY291bnRlcicpO1xuICAgICAgY29uc3QgbUIgPSBwbGFuZXRNdWx0aXBsaWVyKGIsICdjb3VudGVyJyk7XG4gICAgICBjb25zdCBvID0gb3JiTXVsdGlwbGllcih0eXBlLCBvcmIsIGEsIGIpO1xuICAgICAgY29uc3QgcyA9IHNlbnNpdGl2aXR5KGEsYik7XG4gICAgICBsZXQgdyA9IE1hdGguYWJzKGJhc2UpICogbUEgKiBtQiAqIG8gKiBzO1xuICAgICAgaWYgKCF0b3VjaGVkKGEsYikpIHcgKj0gMC43OyAvLyBsb2NhbGl0eSBmYWN0b3IgaWYgbm90IHRvdWNoaW5nIFMrIG5vZGVzXG4gICAgICBjb3VudGVyICs9IE1hdGgubWF4KHcsIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IEsgPSA0LjA7IC8vIG5vcm1hbGl6YXRpb24gY29uc3RhbnQsIHR1bmVhYmxlXG4gIGNvbnN0IFNwbHVzICA9ICsoNSAqIE1hdGgudGFuaChzdXBwb3J0IC8gSykpLnRvRml4ZWQoMik7XG4gIGNvbnN0IFNtaW51cyA9ICsoNSAqIE1hdGgudGFuaChjb3VudGVyIC8gSykpLnRvRml4ZWQoMik7XG4gIGNvbnN0IFNGRCA9IHJvdW5kKGNsYW1wKFNwbHVzIC0gU21pbnVzLCAtNSwgNSksIDIpO1xuICByZXR1cm4geyBTRkQsIFNwbHVzLCBTbWludXMgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXB1dGVTRkQsXG4gIGNvbXB1dGVCYWxhbmNlVmFsZW5jZVxufTtcblxuIl0sIm5hbWVzIjpbImNsYW1wIiwibiIsImxvIiwiaGkiLCJNYXRoIiwibWF4IiwibWluIiwicm91bmQiLCJwIiwibm9ybUFzcGVjdE5hbWUiLCJzIiwiYSIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwidHJpbSIsIm1hcCIsIm9wcG9zaXRpb24iLCJvcHAiLCJzcXVhcmUiLCJzcSIsInRyaW5lIiwidHJpIiwic2V4dGlsZSIsInNleCIsImNvbmp1bmN0aW9uIiwiY29uaiIsInF1aW50aWxlIiwiYmlxdWludGlsZSIsInF1aW5jdW54IiwiaW5jb25qdW5jdCIsInNlc3F1aXNxdWFyZSIsInNlc3F1aXF1YWRyYXRlIiwibm9ybUJvZHkiLCJiIiwibmFtZSIsImJvZHkiLCJib2R5Q2xhc3MiLCJpc0JlbmVmaWMiLCJpc0hlYXZ5Iiwib3JiTXVsdGlwbGllciIsImFzcGVjdCIsIm9yYkRlZyIsImFOYW1lIiwiYk5hbWUiLCJhQ2xhc3MiLCJiQ2xhc3MiLCJpc01pbm9yIiwibWlub3JDYXAiLCJjYXBCeUNsYXNzIiwiY2xzIiwiY2FwQm9kaWVzIiwiY2FwIiwibyIsImFicyIsIk51bWJlciIsInNlbnNpdGl2aXR5Iiwic2V0IiwiU2V0IiwiaGFzIiwicGxhbmV0TXVsdGlwbGllciIsIm1vZGUiLCJiYXNlU3VwcG9ydFdlaWdodCIsInR5cGUiLCJpc01vb25TYXR1cm5Tb2Z0IiwiaXNNaW5vclN1cHBvcnQiLCJiYXNlQ291bnRlcldlaWdodCIsImhhcmQiLCJpc0hhcmRCZXR3ZWVuIiwic2V0QSIsInNldEIiLCJBIiwic29tZSIsIngiLCJjb21wdXRlQmFsYW5jZVZhbGVuY2UiLCJkYXlBc3BlY3RzIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsInJlYyIsIl9hc3BlY3QiLCJwMV9uYW1lIiwidHJhbnNpdCIsInAyX25hbWUiLCJuYXRhbCIsIm9yYiIsIm9yYml0IiwiX29yYiIsImJhc2UiLCJuZWciLCJtQSIsIm1CIiwidyIsIksiLCJ0YW5oIiwiY29tcHV0ZVNGRCIsIlNGRCIsIlNwbHVzIiwiU21pbnVzIiwic3VwcG9ydCIsImNvdW50ZXIiLCJzdXBwb3J0Tm9kZXMiLCJhZGQiLCJ0b3VjaGVkIiwiU3BsdXNOb2RlcyIsInNwZWNpYWxUYXJnZXRzIiwidG9GaXhlZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/balance-meter.js\n");

/***/ }),

/***/ "(rsc)/./src/feedback/hook-stack-composer.js":
/*!*********************************************!*\
  !*** ./src/feedback/hook-stack-composer.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// Hook Stack Recognition Gateway\n// Generates 2-4 high-charge, dual-polarity titles from tightest aspects\n// Purpose: Bypass analysis, trigger limbic \"that's me\" ping, open door for depth work\n\nfunction safeNum(x, def = 0) {\n    const n = Number(x);\n    return Number.isFinite(n) ? n : def;\n}\n/**\n * Aspect intensity scoring for Hook Stack selection\n * Prioritizes tight orbs and high-charge aspect types\n */ function calculateAspectIntensity(aspect) {\n    if (!aspect) return 0;\n    const orb = safeNum(aspect.orb, 10);\n    const aspectType = (aspect.name || aspect.type || \"\").toLowerCase();\n    // Tier-1 Orbs: Surgical window for immediate recognition\n    const orbWeight = orb <= 1 ? 10 : orb <= 2 ? 8 : orb <= 3 ? 6 : orb <= 4 ? 4 : orb <= 5 ? 2 : 1;\n    // High-charge aspect type multipliers\n    const aspectWeights = {\n        \"conjunction\": 9,\n        \"opposition\": 9,\n        \"square\": 8,\n        \"trine\": 6,\n        \"sextile\": 4,\n        \"quincunx\": 7,\n        \"sesquiquadrate\": 6,\n        \"semi-square\": 5,\n        \"semi-sextile\": 3,\n        \"quintile\": 4,\n        \"biquintile\": 4\n    };\n    const aspectWeight = aspectWeights[aspectType] || 3;\n    // Outer planet multiplier for generational vs personal impact\n    const planet1 = (aspect.planet1 || aspect.first_planet || \"\").toLowerCase();\n    const planet2 = (aspect.planet2 || aspect.second_planet || \"\").toLowerCase();\n    const outerPlanets = [\n        \"uranus\",\n        \"neptune\",\n        \"pluto\"\n    ];\n    const personalPlanets = [\n        \"sun\",\n        \"moon\",\n        \"mercury\",\n        \"venus\",\n        \"mars\"\n    ];\n    let planetWeight = 1;\n    if (personalPlanets.includes(planet1) || personalPlanets.includes(planet2)) {\n        planetWeight = 1.5; // Personal planet involvement increases intensity\n    }\n    if (outerPlanets.includes(planet1) || outerPlanets.includes(planet2)) {\n        planetWeight *= 1.3; // Outer planet adds generational depth\n    }\n    return orbWeight * aspectWeight * planetWeight;\n}\n/**\n * Dual-polarity hook generators for different aspect patterns\n */ const HOOK_TEMPLATES = {\n    // Sun aspects - identity and core expression\n    sun_mars: {\n        conjunction: \"Dynamic & Action-Oriented / Impulsive or Burning Out\",\n        opposition: \"Confident Leadership / Aggressive or Combative\",\n        square: \"Driven & Ambitious / Frustrated or Impatient\",\n        trine: \"Natural Authority / Overconfident or Domineering\"\n    },\n    sun_saturn: {\n        conjunction: \"Disciplined & Structured / Rigid or Self-Critical\",\n        opposition: \"Responsible & Mature / Restricted or Pessimistic\",\n        square: \"Hardworking & Persistent / Blocked or Self-Doubting\",\n        trine: \"Steady Achievement / Overly Conservative\"\n    },\n    sun_uranus: {\n        conjunction: \"Innovative & Independent / Erratic or Rebellious\",\n        opposition: \"Original Thinker / Unpredictable or Detached\",\n        square: \"Creative Breakthrough / Restless or Disruptive\",\n        trine: \"Visionary Freedom / Scattered or Impractical\"\n    },\n    moon_mars: {\n        conjunction: \"Emotionally Intense / Reactive or Moody\",\n        opposition: \"Passionate Feelings / Volatile or Aggressive\",\n        square: \"Strong Instincts / Irritable or Defensive\",\n        trine: \"Emotional Courage / Impulsive or Rash\"\n    },\n    moon_saturn: {\n        conjunction: \"Emotionally Mature / Withdrawn or Depressed\",\n        opposition: \"Responsible Caregiver / Cold or Rejecting\",\n        square: \"Inner Strength / Self-Protective or Isolated\",\n        trine: \"Stable Emotions / Emotionally Controlled\"\n    },\n    venus_mars: {\n        conjunction: \"Magnetic Attraction / Possessive or Jealous\",\n        opposition: \"Dynamic Relationships / Conflicted in Love\",\n        square: \"Passionate Desires / Frustrated or Indulgent\",\n        trine: \"Creative Harmony / Lazy or Self-Indulgent\"\n    },\n    mars_saturn: {\n        conjunction: \"Focused Determination / Blocked or Self-Limiting\",\n        opposition: \"Strategic Action / Frustrated or Rigid\",\n        square: \"Persistent Effort / Angry or Inhibited\",\n        trine: \"Disciplined Energy / Overly Cautious\"\n    },\n    // Transit-to-natal patterns\n    transit_conjunction: \"Intense Focus & New Beginnings / Overwhelming or Obsessive\",\n    transit_opposition: \"External Challenge & Perspective / Confrontational or Polarized\",\n    transit_square: \"Dynamic Tension & Growth / Frustrated or Blocked\",\n    transit_trine: \"Flowing Opportunity / Complacent or Overconfident\"\n};\n/**\n * Generate aspect key for template lookup\n */ function generateAspectKey(aspect) {\n    const p1 = (aspect.planet1 || aspect.first_planet || \"\").toLowerCase();\n    const p2 = (aspect.planet2 || aspect.second_planet || \"\").toLowerCase();\n    const aspectType = (aspect.name || aspect.type || \"\").toLowerCase();\n    // Sort planets alphabetically for consistent keys\n    const [planet1, planet2] = [\n        p1,\n        p2\n    ].sort();\n    // Check for specific planet combinations\n    const comboKey = `${planet1}_${planet2}`;\n    if (HOOK_TEMPLATES[comboKey] && HOOK_TEMPLATES[comboKey][aspectType]) {\n        return `${comboKey}.${aspectType}`;\n    }\n    // Fall back to transit patterns for unmatched combinations\n    if (aspect.is_transit || aspect.transit) {\n        return `transit_${aspectType}`;\n    }\n    return null;\n}\n/**\n * Generate hook title from aspect pattern\n */ function generateHookTitle(aspect) {\n    const key = generateAspectKey(aspect);\n    if (!key) return null;\n    const [templateKey, aspectType] = key.split(\".\");\n    const template = HOOK_TEMPLATES[templateKey];\n    if (template && typeof template === \"object\") {\n        return template[aspectType] || null;\n    } else if (typeof template === \"string\") {\n        return template;\n    }\n    return null;\n}\n/**\n * Build Hook Stack from aspects\n * Returns 2-4 high-charge, dual-polarity titles for immediate recognition\n */ function buildHookStack(aspects, options = {}) {\n    if (!Array.isArray(aspects) || aspects.length === 0) {\n        return {\n            hooks: [],\n            tier_1_orbs: 0,\n            total_intensity: 0,\n            coverage: \"minimal\"\n        };\n    }\n    const maxHooks = options.maxHooks || 4;\n    const minIntensity = options.minIntensity || 10;\n    // Score and sort aspects by intensity\n    const scoredAspects = aspects.map((aspect)=>({\n            aspect,\n            intensity: calculateAspectIntensity(aspect),\n            title: generateHookTitle(aspect),\n            orb: safeNum(aspect.orb, 10)\n        })).filter((item)=>item.title && item.intensity >= minIntensity).sort((a, b)=>b.intensity - a.intensity);\n    // Select top hooks, avoiding duplicates\n    const selectedHooks = [];\n    const usedTitles = new Set();\n    for (const item of scoredAspects){\n        if (selectedHooks.length >= maxHooks) break;\n        if (usedTitles.has(item.title)) continue;\n        selectedHooks.push({\n            title: item.title,\n            intensity: item.intensity,\n            orb: item.orb,\n            planets: [\n                item.aspect.planet1 || item.aspect.first_planet,\n                item.aspect.planet2 || item.aspect.second_planet\n            ].filter(Boolean),\n            aspect_type: item.aspect.name || item.aspect.type,\n            is_tier_1: item.orb <= 1\n        });\n        usedTitles.add(item.title);\n    }\n    const tier1Count = selectedHooks.filter((h)=>h.is_tier_1).length;\n    const totalIntensity = selectedHooks.reduce((sum, h)=>sum + h.intensity, 0);\n    // Determine coverage level\n    let coverage = \"minimal\";\n    if (selectedHooks.length >= 3 && tier1Count >= 1) coverage = \"adequate\";\n    if (selectedHooks.length >= 4 && tier1Count >= 2) coverage = \"strong\";\n    return {\n        hooks: selectedHooks,\n        tier_1_orbs: tier1Count,\n        total_intensity: totalIntensity,\n        coverage,\n        schema: \"HookStack-1.0\"\n    };\n}\n/**\n * Extract aspects from various result structures\n */ function extractAspectsFromResult(result) {\n    const aspects = [];\n    // Natal aspects\n    const personA = result.person_a || {};\n    if (Array.isArray(personA.aspects)) {\n        aspects.push(...personA.aspects.map((a)=>({\n                ...a,\n                source: \"natal_a\"\n            })));\n    }\n    // Transit aspects (current drivers)\n    const transits = personA.chart?.transitsByDate || {};\n    const dates = Object.keys(transits).sort();\n    const latestDate = dates[dates.length - 1];\n    if (latestDate && Array.isArray(transits[latestDate]?.drivers)) {\n        const transitAspects = transits[latestDate].drivers.map((a)=>({\n                ...a,\n                source: \"transit\",\n                is_transit: true\n            }));\n        aspects.push(...transitAspects);\n    }\n    // Synastry aspects\n    if (Array.isArray(result.synastry_aspects)) {\n        aspects.push(...result.synastry_aspects.map((a)=>({\n                ...a,\n                source: \"synastry\"\n            })));\n    }\n    // Composite aspects\n    if (Array.isArray(result.composite?.aspects)) {\n        aspects.push(...result.composite.aspects.map((a)=>({\n                ...a,\n                source: \"composite\"\n            })));\n    }\n    return aspects;\n}\n/**\n * Main Hook Stack composer function\n */ function composeHookStack(result, options = {}) {\n    const aspects = extractAspectsFromResult(result);\n    const hookStack = buildHookStack(aspects, options);\n    return {\n        ...hookStack,\n        timestamp: new Date().toISOString(),\n        source_aspects_count: aspects.length,\n        provenance: {\n            composer: \"hook-stack-composer\",\n            version: \"1.0.0\",\n            tier_1_threshold: 1.0,\n            min_intensity_threshold: options.minIntensity || 10\n        }\n    };\n}\nmodule.exports = {\n    composeHookStack,\n    buildHookStack,\n    calculateAspectIntensity,\n    generateHookTitle,\n    HOOK_TEMPLATES\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvZmVlZGJhY2svaG9vay1zdGFjay1jb21wb3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUM7QUFDakMsd0VBQXdFO0FBQ3hFLHNGQUFzRjs7QUFFdEYsU0FBU0EsUUFBUUMsQ0FBQyxFQUFFQyxNQUFNLENBQUM7SUFDekIsTUFBTUMsSUFBSUMsT0FBT0g7SUFDakIsT0FBT0csT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRDtBQUNsQztBQUVBOzs7Q0FHQyxHQUNELFNBQVNJLHlCQUF5QkMsTUFBTTtJQUN0QyxJQUFJLENBQUNBLFFBQVEsT0FBTztJQUVwQixNQUFNQyxNQUFNUixRQUFRTyxPQUFPQyxHQUFHLEVBQUU7SUFDaEMsTUFBTUMsYUFBYSxDQUFDRixPQUFPRyxJQUFJLElBQUlILE9BQU9JLElBQUksSUFBSSxFQUFDLEVBQUdDLFdBQVc7SUFFakUseURBQXlEO0lBQ3pELE1BQU1DLFlBQVlMLE9BQU8sSUFBSSxLQUFLQSxPQUFPLElBQUksSUFBSUEsT0FBTyxJQUFJLElBQUlBLE9BQU8sSUFBSSxJQUFJQSxPQUFPLElBQUksSUFBSTtJQUU5RixzQ0FBc0M7SUFDdEMsTUFBTU0sZ0JBQWdCO1FBQ3BCLGVBQWU7UUFDZixjQUFjO1FBQ2QsVUFBVTtRQUNWLFNBQVM7UUFDVCxXQUFXO1FBQ1gsWUFBWTtRQUNaLGtCQUFrQjtRQUNsQixlQUFlO1FBQ2YsZ0JBQWdCO1FBQ2hCLFlBQVk7UUFDWixjQUFjO0lBQ2hCO0lBRUEsTUFBTUMsZUFBZUQsYUFBYSxDQUFDTCxXQUFXLElBQUk7SUFFbEQsOERBQThEO0lBQzlELE1BQU1PLFVBQVUsQ0FBQ1QsT0FBT1MsT0FBTyxJQUFJVCxPQUFPVSxZQUFZLElBQUksRUFBQyxFQUFHTCxXQUFXO0lBQ3pFLE1BQU1NLFVBQVUsQ0FBQ1gsT0FBT1csT0FBTyxJQUFJWCxPQUFPWSxhQUFhLElBQUksRUFBQyxFQUFHUCxXQUFXO0lBRTFFLE1BQU1RLGVBQWU7UUFBQztRQUFVO1FBQVc7S0FBUTtJ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QkMseUJBQXlCNUQsUUFBUVMsWUFBWSxJQUFJO1FBQ25EO0lBQ0Y7QUFDRjtBQUVBb0QsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZaO0lBQ0FwRDtJQUNBOUM7SUFDQXlDO0lBQ0F2QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd292ZW4td2ViLWFwcC8uL3NyYy9mZWVkYmFjay9ob29rLXN0YWNrLWNvbXBvc2VyLmpzP2JkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSG9vayBTdGFjayBSZWNvZ25pdGlvbiBHYXRld2F5XG4vLyBHZW5lcmF0ZXMgMi00IGhpZ2gtY2hhcmdlLCBkdWFsLXBvbGFyaXR5IHRpdGxlcyBmcm9tIHRpZ2h0ZXN0IGFzcGVjdHNcbi8vIFB1cnBvc2U6IEJ5cGFzcyBhbmFseXNpcywgdHJpZ2dlciBsaW1iaWMgXCJ0aGF0J3MgbWVcIiBwaW5nLCBvcGVuIGRvb3IgZm9yIGRlcHRoIHdvcmtcblxuZnVuY3Rpb24gc2FmZU51bSh4LCBkZWYgPSAwKSB7XG4gIGNvbnN0IG4gPSBOdW1iZXIoeCk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobikgPyBuIDogZGVmO1xufVxuXG4vKipcbiAqIEFzcGVjdCBpbnRlbnNpdHkgc2NvcmluZyBmb3IgSG9vayBTdGFjayBzZWxlY3Rpb25cbiAqIFByaW9yaXRpemVzIHRpZ2h0IG9yYnMgYW5kIGhpZ2gtY2hhcmdlIGFzcGVjdCB0eXBlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVBc3BlY3RJbnRlbnNpdHkoYXNwZWN0KSB7XG4gIGlmICghYXNwZWN0KSByZXR1cm4gMDtcbiAgXG4gIGNvbnN0IG9yYiA9IHNhZmVOdW0oYXNwZWN0Lm9yYiwgMTApO1xuICBjb25zdCBhc3BlY3RUeXBlID0gKGFzcGVjdC5uYW1lIHx8IGFzcGVjdC50eXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBcbiAgLy8gVGllci0xIE9yYnM6IFN1cmdpY2FsIHdpbmRvdyBmb3IgaW1tZWRpYXRlIHJlY29nbml0aW9uXG4gIGNvbnN0IG9yYldlaWdodCA9IG9yYiA8PSAxID8gMTAgOiBvcmIgPD0gMiA/IDggOiBvcmIgPD0gMyA/IDYgOiBvcmIgPD0gNCA/IDQgOiBvcmIgPD0gNSA/IDIgOiAxO1xuICBcbiAgLy8gSGlnaC1jaGFyZ2UgYXNwZWN0IHR5cGUgbXVsdGlwbGllcnNcbiAgY29uc3QgYXNwZWN0V2VpZ2h0cyA9IHtcbiAgICAnY29uanVuY3Rpb24nOiA5LFxuICAgICdvcHBvc2l0aW9uJzogOSxcbiAgICAnc3F1YXJlJzogOCxcbiAgICAndHJpbmUnOiA2LFxuICAgICdzZXh0aWxlJzogNCxcbiAgICAncXVpbmN1bngnOiA3LFxuICAgICdzZXNxdWlxdWFkcmF0ZSc6IDYsXG4gICAgJ3NlbWktc3F1YXJlJzogNSxcbiAgICAnc2VtaS1zZXh0aWxlJzogMyxcbiAgICAncXVpbnRpbGUnOiA0LFxuICAgICdiaXF1aW50aWxlJzogNFxuICB9O1xuICBcbiAgY29uc3QgYXNwZWN0V2VpZ2h0ID0gYXNwZWN0V2VpZ2h0c1thc3BlY3RUeXBlXSB8fCAzO1xuICBcbiAgLy8gT3V0ZXIgcGxhbmV0IG11bHRpcGxpZXIgZm9yIGdlbmVyYXRpb25hbCB2cyBwZXJzb25hbCBpbXBhY3RcbiAgY29uc3QgcGxhbmV0MSA9IChhc3BlY3QucGxhbmV0MSB8fCBhc3BlY3QuZmlyc3RfcGxhbmV0IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBwbGFuZXQyID0gKGFzcGVjdC5wbGFuZXQyIHx8IGFzcGVjdC5zZWNvbmRfcGxhbmV0IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBcbiAgY29uc3Qgb3V0ZXJQbGFuZXRzID0gWyd1cmFudXMnLCAnbmVwdHVuZScsICdwbHV0byddO1xuICBjb25zdCBwZXJzb25hbFBsYW5ldHMgPSBbJ3N1bicsICdtb29uJywgJ21lcmN1cnknLCAndmVudXMnLCAnbWFycyddO1xuICBcbiAgbGV0IHBsYW5ldFdlaWdodCA9IDE7XG4gIGlmIChwZXJzb25hbFBsYW5ldHMuaW5jbHVkZXMocGxhbmV0MSkgfHwgcGVyc29uYWxQbGFuZXRzLmluY2x1ZGVzKHBsYW5ldDIpKSB7XG4gICAgcGxhbmV0V2VpZ2h0ID0gMS41OyAvLyBQZXJzb25hbCBwbGFuZXQgaW52b2x2ZW1lbnQgaW5jcmVhc2VzIGludGVuc2l0eVxuICB9XG4gIGlmIChvdXRlclBsYW5ldHMuaW5jbHVkZXMocGxhbmV0MSkgfHwgb3V0ZXJQbGFuZXRzLmluY2x1ZGVzKHBsYW5ldDIpKSB7XG4gICAgcGxhbmV0V2VpZ2h0ICo9IDEuMzsgLy8gT3V0ZXIgcGxhbmV0IGFkZHMgZ2VuZXJhdGlvbmFsIGRlcHRoXG4gIH1cbiAgXG4gIHJldHVybiBvcmJXZWlnaHQgKiBhc3BlY3RXZWlnaHQgKiBwbGFuZXRXZWlnaHQ7XG59XG5cbi8qKlxuICogRHVhbC1wb2xhcml0eSBob29rIGdlbmVyYXRvcnMgZm9yIGRpZmZlcmVudCBhc3BlY3QgcGF0dGVybnNcbiAqL1xuY29uc3QgSE9PS19URU1QTEFURVMgPSB7XG4gIC8vIFN1biBhc3BlY3RzIC0gaWRlbnRpdHkgYW5kIGNvcmUgZXhwcmVzc2lvblxuICBzdW5fbWFyczoge1xuICAgIGNvbmp1bmN0aW9uOiBcIkR5bmFtaWMgJiBBY3Rpb24tT3JpZW50ZWQgLyBJbXB1bHNpdmUgb3IgQnVybmluZyBPdXRcIixcbiAgICBvcHBvc2l0aW9uOiBcIkNvbmZpZGVudCBMZWFkZXJzaGlwIC8gQWdncmVzc2l2ZSBvciBDb21iYXRpdmVcIixcbiAgICBzcXVhcmU6IFwiRHJpdmVuICYgQW1iaXRpb3VzIC8gRnJ1c3RyYXRlZCBvciBJbXBhdGllbnRcIixcbiAgICB0cmluZTogXCJOYXR1cmFsIEF1dGhvcml0eSAvIE92ZXJjb25maWRlbnQgb3IgRG9taW5lZXJpbmdcIlxuICB9LFxuICBcbiAgc3VuX3NhdHVybjoge1xuICAgIGNvbmp1bmN0aW9uOiBcIkRpc2NpcGxpbmVkICYgU3RydWN0dXJlZCAvIFJpZ2lkIG9yIFNlbGYtQ3JpdGljYWxcIixcbiAgICBvcHBvc2l0aW9uOiBcIlJlc3BvbnNpYmxlICYgTWF0dXJlIC8gUmVzdHJpY3RlZCBvciBQZXNzaW1pc3RpY1wiLCBcbiAgICBzcXVhcmU6IFwiSGFyZHdvcmtpbmcgJiBQZXJzaXN0ZW50IC8gQmxvY2tlZCBvciBTZWxmLURvdWJ0aW5nXCIsXG4gICAgdHJpbmU6IFwiU3RlYWR5IEFjaGlldmVtZW50IC8gT3Zlcmx5IENvbnNlcnZhdGl2ZVwiXG4gIH0sXG4gIFxuICBzdW5fdXJhbnVzOiB7XG4gICAgY29uanVuY3Rpb246IFwiSW5ub3ZhdGl2ZSAmIEluZGVwZW5kZW50IC8gRXJyYXRpYyBvciBSZWJlbGxpb3VzXCIsXG4gICAgb3Bwb3NpdGlvbjogXCJPcmlnaW5hbCBUaGlua2VyIC8gVW5wcmVkaWN0YWJsZSBvciBEZXRhY2hlZFwiLFxuICAgIHNxdWFyZTogXCJDcmVhdGl2ZSBCcmVha3Rocm91Z2ggLyBSZXN0bGVzcyBvciBEaXNydXB0aXZlXCIsXG4gICAgdHJpbmU6IFwiVmlzaW9uYXJ5IEZyZWVkb20gLyBTY2F0dGVyZWQgb3IgSW1wcmFjdGljYWxcIlxuICB9LFxuICBcbiAgbW9vbl9tYXJzOiB7XG4gICAgY29uanVuY3Rpb246IFwiRW1vdGlvbmFsbHkgSW50ZW5zZSAvIFJlYWN0aXZlIG9yIE1vb2R5XCIsXG4gICAgb3Bwb3NpdGlvbjogXCJQYXNzaW9uYXRlIEZlZWxpbmdzIC8gVm9sYXRpbGUgb3IgQWdncmVzc2l2ZVwiLFxuICAgIHNxdWFyZTogXCJTdHJvbmcgSW5zdGluY3RzIC8gSXJyaXRhYmxlIG9yIERlZmVuc2l2ZVwiLCBcbiAgICB0cmluZTogXCJFbW90aW9uYWwgQ291cmFnZSAvIEltcHVsc2l2ZSBvciBSYXNoXCJcbiAgfSxcbiAgXG4gIG1vb25fc2F0dXJuOiB7XG4gICAgY29uanVuY3Rpb246IFwiRW1vdGlvbmFsbHkgTWF0dXJlIC8gV2l0aGRyYXduIG9yIERlcHJlc3NlZFwiLFxuICAgIG9wcG9zaXRpb246IFwiUmVzcG9uc2libGUgQ2FyZWdpdmVyIC8gQ29sZCBvciBSZWplY3RpbmdcIixcbiAgICBzcXVhcmU6IFwiSW5uZXIgU3RyZW5ndGggLyBTZWxmLVByb3RlY3RpdmUgb3IgSXNvbGF0ZWRcIixcbiAgICB0cmluZTogXCJTdGFibGUgRW1vdGlvbnMgLyBFbW90aW9uYWxseSBDb250cm9sbGVkXCJcbiAgfSxcbiAgXG4gIHZlbnVzX21hcnM6IHtcbiAgICBjb25qdW5jdGlvbjogXCJNYWduZXRpYyBBdHRyYWN0aW9uIC8gUG9zc2Vzc2l2ZSBvciBKZWFsb3VzXCIsXG4gICAgb3Bwb3NpdGlvbjogXCJEeW5hbWljIFJlbGF0aW9uc2hpcHMgLyBDb25mbGljdGVkIGluIExvdmVcIixcbiAgICBzcXVhcmU6IFwiUGFzc2lvbmF0ZSBEZXNpcmVzIC8gRnJ1c3RyYXRlZCBvciBJbmR1bGdlbnRcIixcbiAgICB0cmluZTogXCJDcmVhdGl2ZSBIYXJtb255IC8gTGF6eSBvciBTZWxmLUluZHVsZ2VudFwiXG4gIH0sXG4gIFxuICBtYXJzX3NhdHVybjoge1xuICAgIGNvbmp1bmN0aW9uOiBcIkZvY3VzZWQgRGV0ZXJtaW5hdGlvbiAvIEJsb2NrZWQgb3IgU2VsZi1MaW1pdGluZ1wiLFxuICAgIG9wcG9zaXRpb246IFwiU3RyYXRlZ2ljIEFjdGlvbiAvIEZydXN0cmF0ZWQgb3IgUmlnaWRcIixcbiAgICBzcXVhcmU6IFwiUGVyc2lzdGVudCBFZmZvcnQgLyBBbmdyeSBvciBJbmhpYml0ZWRcIixcbiAgICB0cmluZTogXCJEaXNjaXBsaW5lZCBFbmVyZ3kgLyBPdmVybHkgQ2F1dGlvdXNcIlxuICB9LFxuICBcbiAgLy8gVHJhbnNpdC10by1uYXRhbCBwYXR0ZXJuc1xuICB0cmFuc2l0X2Nvbmp1bmN0aW9uOiBcIkludGVuc2UgRm9jdXMgJiBOZXcgQmVnaW5uaW5ncyAvIE92ZXJ3aGVsbWluZyBvciBPYnNlc3NpdmVcIixcbiAgdHJhbnNpdF9vcHBvc2l0aW9uOiBcIkV4dGVybmFsIENoYWxsZW5nZSAmIFBlcnNwZWN0aXZlIC8gQ29uZnJvbnRhdGlvbmFsIG9yIFBvbGFyaXplZFwiLFxuICB0cmFuc2l0X3NxdWFyZTogXCJEeW5hbWljIFRlbnNpb24gJiBHcm93dGggLyBGcnVzdHJhdGVkIG9yIEJsb2NrZWRcIixcbiAgdHJhbnNpdF90cmluZTogXCJGbG93aW5nIE9wcG9ydHVuaXR5IC8gQ29tcGxhY2VudCBvciBPdmVyY29uZmlkZW50XCJcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYXNwZWN0IGtleSBmb3IgdGVtcGxhdGUgbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQXNwZWN0S2V5KGFzcGVjdCkge1xuICBjb25zdCBwMSA9IChhc3BlY3QucGxhbmV0MSB8fCBhc3BlY3QuZmlyc3RfcGxhbmV0IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBwMiA9IChhc3BlY3QucGxhbmV0MiB8fCBhc3BlY3Quc2Vjb25kX3BsYW5ldCB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgYXNwZWN0VHlwZSA9IChhc3BlY3QubmFtZSB8fCBhc3BlY3QudHlwZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIFNvcnQgcGxhbmV0cyBhbHBoYWJldGljYWxseSBmb3IgY29uc2lzdGVudCBrZXlzXG4gIGNvbnN0IFtwbGFuZXQxLCBwbGFuZXQyXSA9IFtwMSwgcDJdLnNvcnQoKTtcbiAgXG4gIC8vIENoZWNrIGZvciBzcGVjaWZpYyBwbGFuZXQgY29tYmluYXRpb25zXG4gIGNvbnN0IGNvbWJvS2V5ID0gYCR7cGxhbmV0MX1fJHtwbGFuZXQyfWA7XG4gIGlmIChIT09LX1RFTVBMQVRFU1tjb21ib0tleV0gJiYgSE9PS19URU1QTEFURVNbY29tYm9LZXldW2FzcGVjdFR5cGVdKSB7XG4gICAgcmV0dXJuIGAke2NvbWJvS2V5fS4ke2FzcGVjdFR5cGV9YDtcbiAgfVxuICBcbiAgLy8gRmFsbCBiYWNrIHRvIHRyYW5zaXQgcGF0dGVybnMgZm9yIHVubWF0Y2hlZCBjb21iaW5hdGlvbnNcbiAgaWYgKGFzcGVjdC5pc190cmFuc2l0IHx8IGFzcGVjdC50cmFuc2l0KSB7XG4gICAgcmV0dXJuIGB0cmFuc2l0XyR7YXNwZWN0VHlwZX1gO1xuICB9XG4gIFxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBob29rIHRpdGxlIGZyb20gYXNwZWN0IHBhdHRlcm5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVIb29rVGl0bGUoYXNwZWN0KSB7XG4gIGNvbnN0IGtleSA9IGdlbmVyYXRlQXNwZWN0S2V5KGFzcGVjdCk7XG4gIGlmICgha2V5KSByZXR1cm4gbnVsbDtcbiAgXG4gIGNvbnN0IFt0ZW1wbGF0ZUtleSwgYXNwZWN0VHlwZV0gPSBrZXkuc3BsaXQoJy4nKTtcbiAgY29uc3QgdGVtcGxhdGUgPSBIT09LX1RFTVBMQVRFU1t0ZW1wbGF0ZUtleV07XG4gIFxuICBpZiAodGVtcGxhdGUgJiYgdHlwZW9mIHRlbXBsYXRlID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0ZW1wbGF0ZVthc3BlY3RUeXBlXSB8fCBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEJ1aWxkIEhvb2sgU3RhY2sgZnJvbSBhc3BlY3RzXG4gKiBSZXR1cm5zIDItNCBoaWdoLWNoYXJnZSwgZHVhbC1wb2xhcml0eSB0aXRsZXMgZm9yIGltbWVkaWF0ZSByZWNvZ25pdGlvblxuICovXG5mdW5jdGlvbiBidWlsZEhvb2tTdGFjayhhc3BlY3RzLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFzcGVjdHMpIHx8IGFzcGVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvb2tzOiBbXSxcbiAgICAgIHRpZXJfMV9vcmJzOiAwLFxuICAgICAgdG90YWxfaW50ZW5zaXR5OiAwLFxuICAgICAgY292ZXJhZ2U6ICdtaW5pbWFsJ1xuICAgIH07XG4gIH1cbiAgXG4gIGNvbnN0IG1heEhvb2tzID0gb3B0aW9ucy5tYXhIb29rcyB8fCA0O1xuICBjb25zdCBtaW5JbnRlbnNpdHkgPSBvcHRpb25zLm1pbkludGVuc2l0eSB8fCAxMDtcbiAgXG4gIC8vIFNjb3JlIGFuZCBzb3J0IGFzcGVjdHMgYnkgaW50ZW5zaXR5XG4gIGNvbnN0IHNjb3JlZEFzcGVjdHMgPSBhc3BlY3RzXG4gICAgLm1hcChhc3BlY3QgPT4gKHtcbiAgICAgIGFzcGVjdCxcbiAgICAgIGludGVuc2l0eTogY2FsY3VsYXRlQXNwZWN0SW50ZW5zaXR5KGFzcGVjdCksXG4gICAgICB0aXRsZTogZ2VuZXJhdGVIb29rVGl0bGUoYXNwZWN0KSxcbiAgICAgIG9yYjogc2FmZU51bShhc3BlY3Qub3JiLCAxMClcbiAgICB9KSlcbiAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50aXRsZSAmJiBpdGVtLmludGVuc2l0eSA+PSBtaW5JbnRlbnNpdHkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuaW50ZW5zaXR5IC0gYS5pbnRlbnNpdHkpO1xuICBcbiAgLy8gU2VsZWN0IHRvcCBob29rcywgYXZvaWRpbmcgZHVwbGljYXRlc1xuICBjb25zdCBzZWxlY3RlZEhvb2tzID0gW107XG4gIGNvbnN0IHVzZWRUaXRsZXMgPSBuZXcgU2V0KCk7XG4gIFxuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2NvcmVkQXNwZWN0cykge1xuICAgIGlmIChzZWxlY3RlZEhvb2tzLmxlbmd0aCA+PSBtYXhIb29rcykgYnJlYWs7XG4gICAgaWYgKHVzZWRUaXRsZXMuaGFzKGl0ZW0udGl0bGUpKSBjb250aW51ZTtcbiAgICBcbiAgICBzZWxlY3RlZEhvb2tzLnB1c2goe1xuICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXG4gICAgICBpbnRlbnNpdHk6IGl0ZW0uaW50ZW5zaXR5LFxuICAgICAgb3JiOiBpdGVtLm9yYixcbiAgICAgIHBsYW5ldHM6IFtcbiAgICAgICAgaXRlbS5hc3BlY3QucGxhbmV0MSB8fCBpdGVtLmFzcGVjdC5maXJzdF9wbGFuZXQsXG4gICAgICAgIGl0ZW0uYXNwZWN0LnBsYW5ldDIgfHwgaXRlbS5hc3BlY3Quc2Vjb25kX3BsYW5ldFxuICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICBhc3BlY3RfdHlwZTogaXRlbS5hc3BlY3QubmFtZSB8fCBpdGVtLmFzcGVjdC50eXBlLFxuICAgICAgaXNfdGllcl8xOiBpdGVtLm9yYiA8PSAxXG4gICAgfSk7XG4gICAgXG4gICAgdXNlZFRpdGxlcy5hZGQoaXRlbS50aXRsZSk7XG4gIH1cbiAgXG4gIGNvbnN0IHRpZXIxQ291bnQgPSBzZWxlY3RlZEhvb2tzLmZpbHRlcihoID0+IGguaXNfdGllcl8xKS5sZW5ndGg7XG4gIGNvbnN0IHRvdGFsSW50ZW5zaXR5ID0gc2VsZWN0ZWRIb29rcy5yZWR1Y2UoKHN1bSwgaCkgPT4gc3VtICsgaC5pbnRlbnNpdHksIDApO1xuICBcbiAgLy8gRGV0ZXJtaW5lIGNvdmVyYWdlIGxldmVsXG4gIGxldCBjb3ZlcmFnZSA9ICdtaW5pbWFsJztcbiAgaWYgKHNlbGVjdGVkSG9va3MubGVuZ3RoID49IDMgJiYgdGllcjFDb3VudCA+PSAxKSBjb3ZlcmFnZSA9ICdhZGVxdWF0ZSc7XG4gIGlmIChzZWxlY3RlZEhvb2tzLmxlbmd0aCA+PSA0ICYmIHRpZXIxQ291bnQgPj0gMikgY292ZXJhZ2UgPSAnc3Ryb25nJztcbiAgXG4gIHJldHVybiB7XG4gICAgaG9va3M6IHNlbGVjdGVkSG9va3MsXG4gICAgdGllcl8xX29yYnM6IHRpZXIxQ291bnQsXG4gICAgdG90YWxfaW50ZW5zaXR5OiB0b3RhbEludGVuc2l0eSxcbiAgICBjb3ZlcmFnZSxcbiAgICBzY2hlbWE6ICdIb29rU3RhY2stMS4wJ1xuICB9O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYXNwZWN0cyBmcm9tIHZhcmlvdXMgcmVzdWx0IHN0cnVjdHVyZXNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEFzcGVjdHNGcm9tUmVzdWx0KHJlc3VsdCkge1xuICBjb25zdCBhc3BlY3RzID0gW107XG4gIFxuICAvLyBOYXRhbCBhc3BlY3RzXG4gIGNvbnN0IHBlcnNvbkEgPSByZXN1bHQucGVyc29uX2EgfHwge307XG4gIGlmIChBcnJheS5pc0FycmF5KHBlcnNvbkEuYXNwZWN0cykpIHtcbiAgICBhc3BlY3RzLnB1c2goLi4ucGVyc29uQS5hc3BlY3RzLm1hcChhID0+ICh7IC4uLmEsIHNvdXJjZTogJ25hdGFsX2EnIH0pKSk7XG4gIH1cbiAgXG4gIC8vIFRyYW5zaXQgYXNwZWN0cyAoY3VycmVudCBkcml2ZXJzKVxuICBjb25zdCB0cmFuc2l0cyA9IHBlcnNvbkEuY2hhcnQ/LnRyYW5zaXRzQnlEYXRlIHx8IHt9O1xuICBjb25zdCBkYXRlcyA9IE9iamVjdC5rZXlzKHRyYW5zaXRzKS5zb3J0KCk7XG4gIGNvbnN0IGxhdGVzdERhdGUgPSBkYXRlc1tkYXRlcy5sZW5ndGggLSAxXTtcbiAgXG4gIGlmIChsYXRlc3REYXRlICYmIEFycmF5LmlzQXJyYXkodHJhbnNpdHNbbGF0ZXN0RGF0ZV0/LmRyaXZlcnMpKSB7XG4gICAgY29uc3QgdHJhbnNpdEFzcGVjdHMgPSB0cmFuc2l0c1tsYXRlc3REYXRlXS5kcml2ZXJzLm1hcChhID0+ICh7IFxuICAgICAgLi4uYSwgXG4gICAgICBzb3VyY2U6ICd0cmFuc2l0JyxcbiAgICAgIGlzX3RyYW5zaXQ6IHRydWUgXG4gICAgfSkpO1xuICAgIGFzcGVjdHMucHVzaCguLi50cmFuc2l0QXNwZWN0cyk7XG4gIH1cbiAgXG4gIC8vIFN5bmFzdHJ5IGFzcGVjdHNcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0LnN5bmFzdHJ5X2FzcGVjdHMpKSB7XG4gICAgYXNwZWN0cy5wdXNoKC4uLnJlc3VsdC5zeW5hc3RyeV9hc3BlY3RzLm1hcChhID0+ICh7IC4uLmEsIHNvdXJjZTogJ3N5bmFzdHJ5JyB9KSkpO1xuICB9XG4gIFxuICAvLyBDb21wb3NpdGUgYXNwZWN0c1xuICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuY29tcG9zaXRlPy5hc3BlY3RzKSkge1xuICAgIGFzcGVjdHMucHVzaCguLi5yZXN1bHQuY29tcG9zaXRlLmFzcGVjdHMubWFwKGEgPT4gKHsgLi4uYSwgc291cmNlOiAnY29tcG9zaXRlJyB9KSkpO1xuICB9XG4gIFxuICByZXR1cm4gYXNwZWN0cztcbn1cblxuLyoqXG4gKiBNYWluIEhvb2sgU3RhY2sgY29tcG9zZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29tcG9zZUhvb2tTdGFjayhyZXN1bHQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBhc3BlY3RzID0gZXh0cmFjdEFzcGVjdHNGcm9tUmVzdWx0KHJlc3VsdCk7XG4gIGNvbnN0IGhvb2tTdGFjayA9IGJ1aWxkSG9va1N0YWNrKGFzcGVjdHMsIG9wdGlvbnMpO1xuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5ob29rU3RhY2ssXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgc291cmNlX2FzcGVjdHNfY291bnQ6IGFzcGVjdHMubGVuZ3RoLFxuICAgIHByb3ZlbmFuY2U6IHtcbiAgICAgIGNvbXBvc2VyOiAnaG9vay1zdGFjay1jb21wb3NlcicsXG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgdGllcl8xX3RocmVzaG9sZDogMS4wLCAvLyBvcmIgZGVncmVlc1xuICAgICAgbWluX2ludGVuc2l0eV90aHJlc2hvbGQ6IG9wdGlvbnMubWluSW50ZW5zaXR5IHx8IDEwXG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcG9zZUhvb2tTdGFjayxcbiAgYnVpbGRIb29rU3RhY2ssXG4gIGNhbGN1bGF0ZUFzcGVjdEludGVuc2l0eSxcbiAgZ2VuZXJhdGVIb29rVGl0bGUsXG4gIEhPT0tfVEVNUExBVEVTXG59OyJdLCJuYW1lcyI6WyJzYWZlTnVtIiwieCIsImRlZiIsIm4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImNhbGN1bGF0ZUFzcGVjdEludGVuc2l0eSIsImFzcGVjdCIsIm9yYiIsImFzcGVjdFR5cGUiLCJuYW1lIiwidHlwZSIsInRvTG93ZXJDYXNlIiwib3JiV2VpZ2h0IiwiYXNwZWN0V2VpZ2h0cyIsImFzcGVjdFdlaWdodCIsInBsYW5ldDEiLCJmaXJzdF9wbGFuZXQiLCJwbGFuZXQyIiwic2Vjb25kX3BsYW5ldCIsIm91dGVyUGxhbmV0cyIsInBlcnNvbmFsUGxhbmV0cyIsInBsYW5ldFdlaWdodCIsImluY2x1ZGVzIiwiSE9PS19URU1QTEFURVMiLCJzdW5fbWFycyIsImNvbmp1bmN0aW9uIiwib3Bwb3NpdGlvbiIsInNxdWFyZSIsInRyaW5lIiwic3VuX3NhdHVybiIsInN1bl91cmFudXMiLCJtb29uX21hcnMiLCJtb29uX3NhdHVybiIsInZlbnVzX21hcnMiLCJtYXJzX3NhdHVybiIsInRyYW5zaXRfY29uanVuY3Rpb24iLCJ0cmFuc2l0X29wcG9zaXRpb24iLCJ0cmFuc2l0X3NxdWFyZSIsInRyYW5zaXRfdHJpbmUiLCJnZW5lcmF0ZUFzcGVjdEtleSIsInAxIiwicDIiLCJzb3J0IiwiY29tYm9LZXkiLCJpc190cmFuc2l0IiwidHJhbnNpdCIsImdlbmVyYXRlSG9va1RpdGxlIiwia2V5IiwidGVtcGxhdGVLZXkiLCJzcGxpdCIsInRlbXBsYXRlIiwiYnVpbGRIb29rU3RhY2siLCJhc3BlY3RzIiwib3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImhvb2tzIiwidGllcl8xX29yYnMiLCJ0b3RhbF9pbnRlbnNpdHkiLCJjb3ZlcmFnZSIsIm1heEhvb2tzIiwibWluSW50ZW5zaXR5Iiwic2NvcmVkQXNwZWN0cyIsIm1hcCIsImludGVuc2l0eSIsInRpdGxlIiwiZmlsdGVyIiwiaXRlbSIsImEiLCJiIiwic2VsZWN0ZWRIb29rcyIsInVzZWRUaXRsZXMiLCJTZXQiLCJoYXMiLCJwdXNoIiwicGxhbmV0cyIsIkJvb2xlYW4iLCJhc3BlY3RfdHlwZSIsImlzX3RpZXJfMSIsImFkZCIsInRpZXIxQ291bnQiLCJoIiwidG90YWxJbnRlbnNpdHkiLCJyZWR1Y2UiLCJzdW0iLCJzY2hlbWEiLCJleHRyYWN0QXNwZWN0c0Zyb21SZXN1bHQiLCJyZXN1bHQiLCJwZXJzb25BIiwicGVyc29uX2EiLCJzb3VyY2UiLCJ0cmFuc2l0cyIsImNoYXJ0IiwidHJhbnNpdHNCeURhdGUiLCJkYXRlcyIsIk9iamVjdCIsImtleXMiLCJsYXRlc3REYXRlIiwiZHJpdmVycyIsInRyYW5zaXRBc3BlY3RzIiwic3luYXN0cnlfYXNwZWN0cyIsImNvbXBvc2l0ZSIsImNvbXBvc2VIb29rU3RhY2siLCJob29rU3RhY2siLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzb3VyY2VfYXNwZWN0c19jb3VudCIsInByb3ZlbmFuY2UiLCJjb21wb3NlciIsInZlcnNpb24iLCJ0aWVyXzFfdGhyZXNob2xkIiwibWluX2ludGVuc2l0eV90aHJlc2hvbGQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/feedback/hook-stack-composer.js\n");

/***/ }),

/***/ "(rsc)/./src/raven-lite-mapper.js":
/*!**********************************!*\
  !*** ./src/raven-lite-mapper.js ***!
  \**********************************/
/***/ ((module) => {

eval("// Raven-lite AspectModel → t2n_aspects mapper\n// This function normalizes API AspectModel[] into Raven-lite t2n_aspects with flags for Hook/Seismograph logic\n/**\n * Normalize API AspectModel[] into Raven-lite t2n_aspects\n * @param {Array} aspects - Array of AspectModel objects from API\n * @returns {Array} Array of normalized t2n_aspects\n */ \nfunction mapT2NAspects(aspects) {\n    if (!Array.isArray(aspects)) return [];\n    return aspects.map((a)=>({\n            p1: a.p1_name,\n            p2: a.p2_name,\n            aspect: a.aspect,\n            orb: a.orbit,\n            retrograde: !!(a.p2_retrograde || a.retrograde),\n            isOuter: [\n                \"Saturn\",\n                \"Uranus\",\n                \"Neptune\",\n                \"Pluto\"\n            ].includes(a.p2_name),\n            isPersonal: [\n                \"Sun\",\n                \"Moon\",\n                \"Mercury\",\n                \"Venus\",\n                \"Mars\",\n                \"ASC\",\n                \"MC\"\n            ].includes(a.p1_name),\n            hard: [\n                \"square\",\n                \"opposition\",\n                \"conjunction\"\n            ].includes(a.aspect)\n        }));\n}\nmodule.exports = {\n    mapT2NAspects\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvcmF2ZW4tbGl0ZS1tYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsOENBQThDO0FBQzlDLCtHQUErRztBQUUvRzs7OztDQUlDO0FBQ0QsU0FBU0EsY0FBY0MsT0FBTztJQUM1QixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsVUFBVSxPQUFPLEVBQUU7SUFDdEMsT0FBT0EsUUFBUUcsR0FBRyxDQUFDQyxDQUFBQSxJQUFNO1lBQ3ZCQyxJQUFJRCxFQUFFRSxPQUFPO1lBQ2JDLElBQUlILEVBQUVJLE9BQU87WUFDYkMsUUFBUUwsRUFBRUssTUFBTTtZQUNoQkMsS0FBS04sRUFBRU8sS0FBSztZQUNaQyxZQUFZLENBQUMsQ0FBRVIsQ0FBQUEsRUFBRVMsYUFBYSxJQUFJVCxFQUFFUSxVQUFVO1lBQzlDRSxTQUFTO2dCQUFDO2dCQUFTO2dCQUFTO2dCQUFVO2FBQVEsQ0FBQ0MsUUFBUSxDQUFDWCxFQUFFSSxPQUFPO1lBQ2pFUSxZQUFZO2dCQUFDO2dCQUFNO2dCQUFPO2dCQUFVO2dCQUFRO2dCQUFPO2dCQUFNO2FBQUssQ0FBQ0QsUUFBUSxDQUFDWCxFQUFFRSxPQUFPO1lBQ2pGVyxNQUFNO2dCQUFDO2dCQUFTO2dCQUFhO2FBQWMsQ0FBQ0YsUUFBUSxDQUFDWCxFQUFFSyxNQUFNO1FBRS9EO0FBQ0Y7QUFFQVMsT0FBT0MsT0FBTyxHQUFHO0lBQUVwQjtBQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd292ZW4td2ViLWFwcC8uL3NyYy9yYXZlbi1saXRlLW1hcHBlci5qcz85OTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJhdmVuLWxpdGUgQXNwZWN0TW9kZWwg4oaSIHQybl9hc3BlY3RzIG1hcHBlclxuLy8gVGhpcyBmdW5jdGlvbiBub3JtYWxpemVzIEFQSSBBc3BlY3RNb2RlbFtdIGludG8gUmF2ZW4tbGl0ZSB0Mm5fYXNwZWN0cyB3aXRoIGZsYWdzIGZvciBIb29rL1NlaXNtb2dyYXBoIGxvZ2ljXG5cbi8qKlxuICogTm9ybWFsaXplIEFQSSBBc3BlY3RNb2RlbFtdIGludG8gUmF2ZW4tbGl0ZSB0Mm5fYXNwZWN0c1xuICogQHBhcmFtIHtBcnJheX0gYXNwZWN0cyAtIEFycmF5IG9mIEFzcGVjdE1vZGVsIG9iamVjdHMgZnJvbSBBUElcbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygbm9ybWFsaXplZCB0Mm5fYXNwZWN0c1xuICovXG5mdW5jdGlvbiBtYXBUMk5Bc3BlY3RzKGFzcGVjdHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFzcGVjdHMpKSByZXR1cm4gW107XG4gIHJldHVybiBhc3BlY3RzLm1hcChhID0+ICh7XG4gICAgcDE6IGEucDFfbmFtZSwgLy8gbmF0YWwgcGxhbmV0L3BvaW50XG4gICAgcDI6IGEucDJfbmFtZSwgLy8gdHJhbnNpdGluZyBwbGFuZXQvcG9pbnRcbiAgICBhc3BlY3Q6IGEuYXNwZWN0LCAvLyBhc3BlY3QgdHlwZSAoY29uanVuY3Rpb24sIHNxdWFyZSwgZXRjKVxuICAgIG9yYjogYS5vcmJpdCwgLy8gYXNwZWN0IG9yYlxuICAgIHJldHJvZ3JhZGU6ICEhKGEucDJfcmV0cm9ncmFkZSB8fCBhLnJldHJvZ3JhZGUpLCAvLyBmbGFnIGlmIHRyYW5zaXRpbmcgcGxhbmV0IGlzIHJldHJvZ3JhZGVcbiAgICBpc091dGVyOiBbXCJTYXR1cm5cIixcIlVyYW51c1wiLFwiTmVwdHVuZVwiLFwiUGx1dG9cIl0uaW5jbHVkZXMoYS5wMl9uYW1lKSwgLy8gZmxhZyBmb3Igb3V0ZXIgcGxhbmV0XG4gICAgaXNQZXJzb25hbDogW1wiU3VuXCIsXCJNb29uXCIsXCJNZXJjdXJ5XCIsXCJWZW51c1wiLFwiTWFyc1wiLFwiQVNDXCIsXCJNQ1wiXS5pbmNsdWRlcyhhLnAxX25hbWUpLCAvLyBmbGFnIGZvciBwZXJzb25hbCBwb2ludFxuICAgIGhhcmQ6IFtcInNxdWFyZVwiLFwib3Bwb3NpdGlvblwiLFwiY29uanVuY3Rpb25cIl0uaW5jbHVkZXMoYS5hc3BlY3QpLCAvLyBmbGFnIGZvciBoYXJkIGFzcGVjdFxuICAgIC8vIEFkZCBtb3JlIGZsYWdzIGFzIG5lZWRlZCBmb3IgSG9vay9TZWlzbW9ncmFwaCBsb2dpY1xuICB9KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBtYXBUMk5Bc3BlY3RzIH07XG4iXSwibmFtZXMiOlsibWFwVDJOQXNwZWN0cyIsImFzcGVjdHMiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJhIiwicDEiLCJwMV9uYW1lIiwicDIiLCJwMl9uYW1lIiwiYXNwZWN0Iiwib3JiIiwib3JiaXQiLCJyZXRyb2dyYWRlIiwicDJfcmV0cm9ncmFkZSIsImlzT3V0ZXIiLCJpbmNsdWRlcyIsImlzUGVyc29uYWwiLCJoYXJkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/raven-lite-mapper.js\n");

/***/ }),

/***/ "(rsc)/./src/reporters/woven-map-composer.js":
/*!*********************************************!*\
  !*** ./src/reporters/woven-map-composer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Woven Map Report Composer (DATA-ONLY)\n// Builds a clinical, non-VOI CE report envelope from existing Math Brain outputs.\n// Do NOT include narrative fields; avoid keys named 'field', 'map', or 'voice' to pass Clear Mirror scrub.\n\nconst { composeHookStack } = __webpack_require__(/*! ../feedback/hook-stack-composer */ \"(rsc)/./src/feedback/hook-stack-composer.js\");\nfunction safeNum(x, def = null) {\n    const n = Number(x);\n    return Number.isFinite(n) ? n : def;\n}\nfunction clamp(v, min, max) {\n    return Math.max(min, Math.min(max, v));\n}\nfunction computeIntegrationFactors(summary) {\n    if (!summary) return null;\n    const mag = safeNum(summary.magnitude, 0) || 0;\n    const val = safeNum(summary.valence, 0) || 0;\n    const vol = safeNum(summary.volatility, 0) || 0;\n    // Normalize per UI logic\n    const magN = clamp(mag / 5, 0, 1);\n    const volN = clamp(vol / 5, 0, 1);\n    const valN = (clamp(val, -2, 2) + 2) / 4; // map -2..2 -> 0..1\n    const pct = (x)=>Math.round(clamp(x, 0, 1) * 100);\n    return {\n        fertile_field: pct(valN * 0.7 + (1 - volN) * 0.3),\n        harmonic_resonance: pct(valN * 0.6 + (1 - volN) * 0.4),\n        expansion_lift: pct(magN * 0.6 + valN * 0.4),\n        combustion_clarity: pct(magN * 0.5 + volN * 0.5),\n        liberation_release: pct(volN * 0.7 + (1 - valN) * 0.3),\n        integration: pct((1 - volN) * 0.6 + valN * 0.4)\n    };\n}\nfunction extractTimeSeries(transitsByDate) {\n    if (!transitsByDate || typeof transitsByDate !== \"object\") return [];\n    const entries = [];\n    for (const [date, v] of Object.entries(transitsByDate)){\n        const row = {\n            date,\n            magnitude: safeNum(v?.magnitude),\n            valence: safeNum(v?.valence),\n            volatility: safeNum(v?.volatility),\n            drivers: Array.isArray(v?.drivers) ? v.drivers : undefined\n        };\n        entries.push(row);\n    }\n    // Sort by date ascending if ISO-like\n    entries.sort((a, b)=>(a.date || \"\").localeCompare(b.date || \"\"));\n    return entries;\n}\nfunction extractNatalSummary(person) {\n    if (!person) return null;\n    const chart = person.chart || {};\n    const birth = person.birth_data || {};\n    // Prefer chart payload for placements/aspects if present\n    const placements = chart.planets || birth.planets || null;\n    const angles = chart.angles || birth.angles || null;\n    const aspects = Array.isArray(person.aspects) ? person.aspects : chart.aspects || [];\n    return {\n        placements,\n        angles,\n        major_aspects: aspects\n    };\n}\nfunction extractRawGeometry(result) {\n    const a = result.person_a || {};\n    const b = result.person_b || null;\n    const out = {\n        solo: {\n            natal_placements: a.chart?.planets || a.birth_data?.planets || null,\n            angles: a.chart?.angles || a.birth_data?.angles || null,\n            natal_aspects: Array.isArray(a.aspects) ? a.aspects : a.chart?.aspects || [],\n            transit_logs: a.chart?.transitsByDate || null\n        }\n    };\n    if (b) {\n        out.relational = {\n            person_b_natal_placements: b.chart?.planets || b.birth_data?.planets || null,\n            person_b_angles: b.chart?.angles || b.birth_data?.angles || null,\n            person_b_natal_aspects: Array.isArray(b.aspects) ? b.aspects : b.chart?.aspects || [],\n            b_transit_logs: b.chart?.transitsByDate || null\n        };\n    }\n    return out;\n}\n// DATA-ONLY Polarity Cards structure: leave human-facing content null; include geometry hooks only\nfunction buildPolarityCardsHooks(a /* person_a */ ) {\n    // Select a few strongest daily drivers as skeleton; no language\n    const series = a?.chart?.transitsByDate || {};\n    const items = [];\n    for (const [date, v] of Object.entries(series)){\n        if (Array.isArray(v?.drivers) && v.drivers.length) {\n            items.push({\n                date,\n                drivers: v.drivers.slice(0, 3)\n            });\n        }\n    }\n    // Reduce to a small sample window\n    const sample = items.slice(0, 7);\n    return [\n        {\n            id: \"card_1\",\n            field_tone: null,\n            map_geometry: sample,\n            voice_slot: null\n        },\n        {\n            id: \"card_2\",\n            field_tone: null,\n            map_geometry: sample,\n            voice_slot: null\n        },\n        {\n            id: \"card_3\",\n            field_tone: null,\n            map_geometry: sample,\n            voice_slot: null\n        }\n    ];\n}\nfunction inferReportType(modeToken, hasB) {\n    const m = (modeToken || \"\").toUpperCase();\n    if (m.includes(\"SYNASTRY\") || m.includes(\"COMPOSITE\") || hasB) return \"relational\";\n    return \"solo\";\n}\nfunction composeWovenMapReport({ result, mode, period }) {\n    const a = result.person_a || {};\n    const b = result.person_b || null;\n    const type = inferReportType(mode, !!b);\n    const summary = a.derived?.seismograph_summary || null;\n    const integration = computeIntegrationFactors(summary);\n    const timeSeries = extractTimeSeries(a.chart?.transitsByDate);\n    const hookStack = composeHookStack(result, {\n        maxHooks: 4,\n        minIntensity: 8\n    });\n    const report = {\n        schema: \"WM-WovenMap-1.0\",\n        type,\n        context: {\n            mode,\n            period: period || null,\n            translocation: result?.context?.translocation || null,\n            person_a: {\n                name: a?.details?.name || \"Subject\",\n                birth_date: a?.details?.birth_date || null,\n                birth_time: a?.details?.birth_time || null,\n                coordinates: a?.details?.latitude != null && a?.details?.longitude != null ? {\n                    lat: a.details.latitude,\n                    lon: a.details.longitude\n                } : null,\n                timezone: a?.details?.timezone || null\n            },\n            person_b: b ? {\n                name: b?.details?.name || \"Subject B\",\n                birth_date: b?.details?.birth_date || null,\n                birth_time: b?.details?.birth_time || null,\n                coordinates: b?.details?.latitude != null && b?.details?.longitude != null ? {\n                    lat: b.details.latitude,\n                    lon: b.details.longitude\n                } : null,\n                timezone: b?.details?.timezone || null\n            } : null\n        },\n        balance_meter: summary ? {\n            magnitude: summary.magnitude,\n            valence: summary.valence,\n            volatility: summary.volatility\n        } : null,\n        hook_stack: hookStack,\n        integration_factors: integration,\n        time_series: timeSeries,\n        natal_summary: extractNatalSummary(a),\n        vector_integrity: {\n            latent: [],\n            suppressed: [],\n            method: \"stub-0\"\n        },\n        polarity_cards: buildPolarityCardsHooks(a),\n        mirror_voice: null,\n        raw_geometry: extractRawGeometry(result),\n        provenance: result.provenance || null\n    };\n    return report;\n}\nmodule.exports = {\n    composeWovenMapReport\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvcmVwb3J0ZXJzL3dvdmVuLW1hcC1jb21wb3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3Q0FBd0M7QUFDeEMsa0ZBQWtGO0FBQ2xGLDJHQUEyRzs7QUFFM0csTUFBTSxFQUFFQSxnQkFBZ0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUVyQyxTQUFTQyxRQUFRQyxDQUFDLEVBQUVDLE1BQU0sSUFBSTtJQUM1QixNQUFNQyxJQUFJQyxPQUFPSDtJQUNqQixPQUFPRyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlEO0FBQ2xDO0FBRUEsU0FBU0ksTUFBTUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFBSSxPQUFPQyxLQUFLRCxHQUFHLENBQUNELEtBQUtFLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBS0Y7QUFBSztBQUV0RSxTQUFTSSwwQkFBMEJDLE9BQU87SUFDeEMsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFDckIsTUFBTUMsTUFBTWIsUUFBUVksUUFBUUUsU0FBUyxFQUFFLE1BQU07SUFDN0MsTUFBTUMsTUFBTWYsUUFBUVksUUFBUUksT0FBTyxFQUFFLE1BQU07SUFDM0MsTUFBTUMsTUFBTWpCLFFBQVFZLFFBQVFNLFVBQVUsRUFBRSxNQUFNO0lBRTlDLHlCQUF5QjtJQUN6QixNQUFNQyxPQUFPYixNQUFNTyxNQUFNLEdBQUcsR0FBRztJQUMvQixNQUFNTyxPQUFPZCxNQUFNVyxNQUFNLEdBQUcsR0FBRztJQUMvQixNQUFNSSxPQUFPLENBQUNmLE1BQU1TLEtBQUssQ0FBQyxHQUFHLEtBQUssS0FBSyxHQUFHLG9CQUFvQjtJQUU5RCxNQUFNTyxNQUFNLENBQUNyQixJQUFNUyxLQUFLYSxLQUFLLENBQUNqQixNQUFNTCxHQUFHLEdBQUcsS0FBSztJQUMvQyxPQUFPO1FBQ0x1QixlQUFlRixJQUFJRCxPQUFPLE1BQU0sQ0FBQyxJQUFJRCxJQUFHLElBQUs7UUFDN0NLLG9CQUFvQkgsSUFBSUQsT0FBTyxNQUFNLENBQUMsSUFBSUQsSUFB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STtRQUNOO1FBQ0FDLGVBQWVqRyxVQUFVO1lBQ3ZCRSxXQUFXRixRQUFRRSxTQUFTO1lBQzVCRSxTQUFTSixRQUFRSSxPQUFPO1lBQ3hCRSxZQUFZTixRQUFRTSxVQUFVO1FBQ2hDLElBQUk7UUFDSjRGLFlBQVlsQjtRQUNabUIscUJBQXFCbEY7UUFDckJtRixhQUFhckI7UUFDYnNCLGVBQWVwRSxvQkFBb0JIO1FBQ25Dd0Usa0JBQWtCO1lBQ2hCQyxRQUFRLEVBQUU7WUFDVkMsWUFBWSxFQUFFO1lBQ2RDLFFBQVE7UUFDVjtRQUNBQyxnQkFBZ0JqRCx3QkFBd0IzQjtRQUN4QzZFLGNBQWM7UUFDZEMsY0FBY2pFLG1CQUFtQkM7UUFDakNpRSxZQUFZakUsT0FBT2lFLFVBQVUsSUFBSTtJQUNuQztJQUVBLE9BQU8xQjtBQUNUO0FBRUEyQixPQUFPQyxPQUFPLEdBQUc7SUFBRXRDO0FBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd292ZW4td2ViLWFwcC8uL3NyYy9yZXBvcnRlcnMvd292ZW4tbWFwLWNvbXBvc2VyLmpzPzljMDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV292ZW4gTWFwIFJlcG9ydCBDb21wb3NlciAoREFUQS1PTkxZKVxuLy8gQnVpbGRzIGEgY2xpbmljYWwsIG5vbi1WT0kgQ0UgcmVwb3J0IGVudmVsb3BlIGZyb20gZXhpc3RpbmcgTWF0aCBCcmFpbiBvdXRwdXRzLlxuLy8gRG8gTk9UIGluY2x1ZGUgbmFycmF0aXZlIGZpZWxkczsgYXZvaWQga2V5cyBuYW1lZCAnZmllbGQnLCAnbWFwJywgb3IgJ3ZvaWNlJyB0byBwYXNzIENsZWFyIE1pcnJvciBzY3J1Yi5cblxuY29uc3QgeyBjb21wb3NlSG9va1N0YWNrIH0gPSByZXF1aXJlKCcuLi9mZWVkYmFjay9ob29rLXN0YWNrLWNvbXBvc2VyJyk7XG5cbmZ1bmN0aW9uIHNhZmVOdW0oeCwgZGVmID0gbnVsbCkge1xuICBjb25zdCBuID0gTnVtYmVyKHgpO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gbiA6IGRlZjtcbn1cblxuZnVuY3Rpb24gY2xhbXAodiwgbWluLCBtYXgpIHsgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2KSk7IH1cblxuZnVuY3Rpb24gY29tcHV0ZUludGVncmF0aW9uRmFjdG9ycyhzdW1tYXJ5KSB7XG4gIGlmICghc3VtbWFyeSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG1hZyA9IHNhZmVOdW0oc3VtbWFyeS5tYWduaXR1ZGUsIDApIHx8IDA7XG4gIGNvbnN0IHZhbCA9IHNhZmVOdW0oc3VtbWFyeS52YWxlbmNlLCAwKSB8fCAwO1xuICBjb25zdCB2b2wgPSBzYWZlTnVtKHN1bW1hcnkudm9sYXRpbGl0eSwgMCkgfHwgMDtcblxuICAvLyBOb3JtYWxpemUgcGVyIFVJIGxvZ2ljXG4gIGNvbnN0IG1hZ04gPSBjbGFtcChtYWcgLyA1LCAwLCAxKTtcbiAgY29uc3Qgdm9sTiA9IGNsYW1wKHZvbCAvIDUsIDAsIDEpO1xuICBjb25zdCB2YWxOID0gKGNsYW1wKHZhbCwgLTIsIDIpICsgMikgLyA0OyAvLyBtYXAgLTIuLjIgLT4gMC4uMVxuXG4gIGNvbnN0IHBjdCA9ICh4KSA9PiBNYXRoLnJvdW5kKGNsYW1wKHgsIDAsIDEpICogMTAwKTtcbiAgcmV0dXJuIHtcbiAgICBmZXJ0aWxlX2ZpZWxkOiBwY3QodmFsTiAqIDAuNyArICgxIC0gdm9sTikgKiAwLjMpLFxuICAgIGhhcm1vbmljX3Jlc29uYW5jZTogcGN0KHZhbE4gKiAwLjYgKyAoMSAtIHZvbE4pICogMC40KSxcbiAgICBleHBhbnNpb25fbGlmdDogcGN0KG1hZ04gKiAwLjYgKyB2YWxOICogMC40KSxcbiAgICBjb21idXN0aW9uX2NsYXJpdHk6IHBjdChtYWdOICogMC41ICsgdm9sTiAqIDAuNSksXG4gICAgbGliZXJhdGlvbl9yZWxlYXNlOiBwY3Qodm9sTiAqIDAuNyArICgxIC0gdmFsTikgKiAwLjMpLFxuICAgIGludGVncmF0aW9uOiBwY3QoKDEgLSB2b2xOKSAqIDAuNiArIHZhbE4gKiAwLjQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUaW1lU2VyaWVzKHRyYW5zaXRzQnlEYXRlKSB7XG4gIGlmICghdHJhbnNpdHNCeURhdGUgfHwgdHlwZW9mIHRyYW5zaXRzQnlEYXRlICE9PSAnb2JqZWN0JykgcmV0dXJuIFtdO1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGZvciAoY29uc3QgW2RhdGUsIHZdIG9mIE9iamVjdC5lbnRyaWVzKHRyYW5zaXRzQnlEYXRlKSkge1xuICAgIGNvbnN0IHJvdyA9IHtcbiAgICAgIGRhdGUsXG4gICAgICBtYWduaXR1ZGU6IHNhZmVOdW0odj8ubWFnbml0dWRlKSxcbiAgICAgIHZhbGVuY2U6IHNhZmVOdW0odj8udmFsZW5jZSksXG4gICAgICB2b2xhdGlsaXR5OiBzYWZlTnVtKHY/LnZvbGF0aWxpdHkpLFxuICAgICAgZHJpdmVyczogQXJyYXkuaXNBcnJheSh2Py5kcml2ZXJzKSA/IHYuZHJpdmVycyA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgZW50cmllcy5wdXNoKHJvdyk7XG4gIH1cbiAgLy8gU29ydCBieSBkYXRlIGFzY2VuZGluZyBpZiBJU08tbGlrZVxuICBlbnRyaWVzLnNvcnQoKGEsIGIpID0+IChhLmRhdGUgfHwgJycpLmxvY2FsZUNvbXBhcmUoYi5kYXRlIHx8ICcnKSk7XG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0TmF0YWxTdW1tYXJ5KHBlcnNvbikge1xuICBpZiAoIXBlcnNvbikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNoYXJ0ID0gcGVyc29uLmNoYXJ0IHx8IHt9O1xuICBjb25zdCBiaXJ0aCA9IHBlcnNvbi5iaXJ0aF9kYXRhIHx8IHt9O1xuICAvLyBQcmVmZXIgY2hhcnQgcGF5bG9hZCBmb3IgcGxhY2VtZW50cy9hc3BlY3RzIGlmIHByZXNlbnRcbiAgY29uc3QgcGxhY2VtZW50cyA9IGNoYXJ0LnBsYW5ldHMgfHwgYmlydGgucGxhbmV0cyB8fCBudWxsO1xuICBjb25zdCBhbmdsZXMgPSBjaGFydC5hbmdsZXMgfHwgYmlydGguYW5nbGVzIHx8IG51bGw7XG4gIGNvbnN0IGFzcGVjdHMgPSBBcnJheS5pc0FycmF5KHBlcnNvbi5hc3BlY3RzKSA/IHBlcnNvbi5hc3BlY3RzIDogKGNoYXJ0LmFzcGVjdHMgfHwgW10pO1xuICByZXR1cm4ge1xuICAgIHBsYWNlbWVudHMsXG4gICAgYW5nbGVzLFxuICAgIG1ham9yX2FzcGVjdHM6IGFzcGVjdHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFJhd0dlb21ldHJ5KHJlc3VsdCkge1xuICBjb25zdCBhID0gcmVzdWx0LnBlcnNvbl9hIHx8IHt9O1xuICBjb25zdCBiID0gcmVzdWx0LnBlcnNvbl9iIHx8IG51bGw7XG4gIGNvbnN0IG91dCA9IHtcbiAgICBzb2xvOiB7XG4gICAgICBuYXRhbF9wbGFjZW1lbnRzOiBhLmNoYXJ0Py5wbGFuZXRzIHx8IGEuYmlydGhfZGF0YT8ucGxhbmV0cyB8fCBudWxsLFxuICAgICAgYW5nbGVzOiBhLmNoYXJ0Py5hbmdsZXMgfHwgYS5iaXJ0aF9kYXRhPy5hbmdsZXMgfHwgbnVsbCxcbiAgICAgIG5hdGFsX2FzcGVjdHM6IEFycmF5LmlzQXJyYXkoYS5hc3BlY3RzKSA/IGEuYXNwZWN0cyA6IChhLmNoYXJ0Py5hc3BlY3RzIHx8IFtdKSxcbiAgICAgIHRyYW5zaXRfbG9nczogYS5jaGFydD8udHJhbnNpdHNCeURhdGUgfHwgbnVsbFxuICAgIH1cbiAgfTtcbiAgaWYgKGIpIHtcbiAgICBvdXQucmVsYXRpb25hbCA9IHtcbiAgICAgIHBlcnNvbl9iX25hdGFsX3BsYWNlbWVudHM6IGIuY2hhcnQ/LnBsYW5ldHMgfHwgYi5iaXJ0aF9kYXRhPy5wbGFuZXRzIHx8IG51bGwsXG4gICAgICBwZXJzb25fYl9hbmdsZXM6IGIuY2hhcnQ/LmFuZ2xlcyB8fCBiLmJpcnRoX2RhdGE/LmFuZ2xlcyB8fCBudWxsLFxuICAgICAgcGVyc29uX2JfbmF0YWxfYXNwZWN0czogQXJyYXkuaXNBcnJheShiLmFzcGVjdHMpID8gYi5hc3BlY3RzIDogKGIuY2hhcnQ/LmFzcGVjdHMgfHwgW10pLFxuICAgICAgYl90cmFuc2l0X2xvZ3M6IGIuY2hhcnQ/LnRyYW5zaXRzQnlEYXRlIHx8IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIERBVEEtT05MWSBQb2xhcml0eSBDYXJkcyBzdHJ1Y3R1cmU6IGxlYXZlIGh1bWFuLWZhY2luZyBjb250ZW50IG51bGw7IGluY2x1ZGUgZ2VvbWV0cnkgaG9va3Mgb25seVxuZnVuY3Rpb24gYnVpbGRQb2xhcml0eUNhcmRzSG9va3MoYSAvKiBwZXJzb25fYSAqLykge1xuICAvLyBTZWxlY3QgYSBmZXcgc3Ryb25nZXN0IGRhaWx5IGRyaXZlcnMgYXMgc2tlbGV0b247IG5vIGxhbmd1YWdlXG4gIGNvbnN0IHNlcmllcyA9IGE/LmNoYXJ0Py50cmFuc2l0c0J5RGF0ZSB8fCB7fTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgZm9yIChjb25zdCBbZGF0ZSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc2VyaWVzKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHY/LmRyaXZlcnMpICYmIHYuZHJpdmVycy5sZW5ndGgpIHtcbiAgICAgIGl0ZW1zLnB1c2goeyBkYXRlLCBkcml2ZXJzOiB2LmRyaXZlcnMuc2xpY2UoMCwgMykgfSk7XG4gICAgfVxuICB9XG4gIC8vIFJlZHVjZSB0byBhIHNtYWxsIHNhbXBsZSB3aW5kb3dcbiAgY29uc3Qgc2FtcGxlID0gaXRlbXMuc2xpY2UoMCwgNyk7XG4gIHJldHVybiBbXG4gICAgeyBpZDogJ2NhcmRfMScsIGZpZWxkX3RvbmU6IG51bGwsIG1hcF9nZW9tZXRyeTogc2FtcGxlLCB2b2ljZV9zbG90OiBudWxsIH0sXG4gICAgeyBpZDogJ2NhcmRfMicsIGZpZWxkX3RvbmU6IG51bGwsIG1hcF9nZW9tZXRyeTogc2FtcGxlLCB2b2ljZV9zbG90OiBudWxsIH0sXG4gICAgeyBpZDogJ2NhcmRfMycsIGZpZWxkX3RvbmU6IG51bGwsIG1hcF9nZW9tZXRyeTogc2FtcGxlLCB2b2ljZV9zbG90OiBudWxsIH1cbiAgXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJSZXBvcnRUeXBlKG1vZGVUb2tlbiwgaGFzQikge1xuICBjb25zdCBtID0gKG1vZGVUb2tlbiB8fCAnJykudG9VcHBlckNhc2UoKTtcbiAgaWYgKG0uaW5jbHVkZXMoJ1NZTkFTVFJZJykgfHwgbS5pbmNsdWRlcygnQ09NUE9TSVRFJykgfHwgaGFzQikgcmV0dXJuICdyZWxhdGlvbmFsJztcbiAgcmV0dXJuICdzb2xvJztcbn1cblxuZnVuY3Rpb24gY29tcG9zZVdvdmVuTWFwUmVwb3J0KHsgcmVzdWx0LCBtb2RlLCBwZXJpb2QgfSkge1xuICBjb25zdCBhID0gcmVzdWx0LnBlcnNvbl9hIHx8IHt9O1xuICBjb25zdCBiID0gcmVzdWx0LnBlcnNvbl9iIHx8IG51bGw7XG4gIGNvbnN0IHR5cGUgPSBpbmZlclJlcG9ydFR5cGUobW9kZSwgISFiKTtcblxuICBjb25zdCBzdW1tYXJ5ID0gYS5kZXJpdmVkPy5zZWlzbW9ncmFwaF9zdW1tYXJ5IHx8IG51bGw7XG4gIGNvbnN0IGludGVncmF0aW9uID0gY29tcHV0ZUludGVncmF0aW9uRmFjdG9ycyhzdW1tYXJ5KTtcbiAgY29uc3QgdGltZVNlcmllcyA9IGV4dHJhY3RUaW1lU2VyaWVzKGEuY2hhcnQ/LnRyYW5zaXRzQnlEYXRlKTtcbiAgY29uc3QgaG9va1N0YWNrID0gY29tcG9zZUhvb2tTdGFjayhyZXN1bHQsIHsgbWF4SG9va3M6IDQsIG1pbkludGVuc2l0eTogOCB9KTtcblxuICBjb25zdCByZXBvcnQgPSB7XG4gICAgc2NoZW1hOiAnV00tV292ZW5NYXAtMS4wJyxcbiAgICB0eXBlLCAvLyAnc29sbycgfCAncmVsYXRpb25hbCdcbiAgICBjb250ZXh0OiB7XG4gICAgICBtb2RlLFxuICAgICAgcGVyaW9kOiBwZXJpb2QgfHwgbnVsbCxcbiAgICAgIHRyYW5zbG9jYXRpb246IHJlc3VsdD8uY29udGV4dD8udHJhbnNsb2NhdGlvbiB8fCBudWxsLFxuICAgICAgcGVyc29uX2E6IHtcbiAgICAgICAgbmFtZTogYT8uZGV0YWlscz8ubmFtZSB8fCAnU3ViamVjdCcsXG4gICAgICAgIGJpcnRoX2RhdGU6IGE/LmRldGFpbHM/LmJpcnRoX2RhdGUgfHwgbnVsbCxcbiAgICAgICAgYmlydGhfdGltZTogYT8uZGV0YWlscz8uYmlydGhfdGltZSB8fCBudWxsLFxuICAgICAgICBjb29yZGluYXRlczogKGE/LmRldGFpbHM/LmxhdGl0dWRlICE9IG51bGwgJiYgYT8uZGV0YWlscz8ubG9uZ2l0dWRlICE9IG51bGwpXG4gICAgICAgICAgPyB7IGxhdDogYS5kZXRhaWxzLmxhdGl0dWRlLCBsb246IGEuZGV0YWlscy5sb25naXR1ZGUgfVxuICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgdGltZXpvbmU6IGE/LmRldGFpbHM/LnRpbWV6b25lIHx8IG51bGxcbiAgICAgIH0sXG4gICAgICBwZXJzb25fYjogYiA/IHtcbiAgICAgICAgbmFtZTogYj8uZGV0YWlscz8ubmFtZSB8fCAnU3ViamVjdCBCJyxcbiAgICAgICAgYmlydGhfZGF0ZTogYj8uZGV0YWlscz8uYmlydGhfZGF0ZSB8fCBudWxsLFxuICAgICAgICBiaXJ0aF90aW1lOiBiPy5kZXRhaWxzPy5iaXJ0aF90aW1lIHx8IG51bGwsXG4gICAgICAgIGNvb3JkaW5hdGVzOiAoYj8uZGV0YWlscz8ubGF0aXR1ZGUgIT0gbnVsbCAmJiBiPy5kZXRhaWxzPy5sb25naXR1ZGUgIT0gbnVsbClcbiAgICAgICAgICA/IHsgbGF0OiBiLmRldGFpbHMubGF0aXR1ZGUsIGxvbjogYi5kZXRhaWxzLmxvbmdpdHVkZSB9XG4gICAgICAgICAgOiBudWxsLFxuICAgICAgICB0aW1lem9uZTogYj8uZGV0YWlscz8udGltZXpvbmUgfHwgbnVsbFxuICAgICAgfSA6IG51bGxcbiAgICB9LFxuICAgIGJhbGFuY2VfbWV0ZXI6IHN1bW1hcnkgPyB7XG4gICAgICBtYWduaXR1ZGU6IHN1bW1hcnkubWFnbml0dWRlLFxuICAgICAgdmFsZW5jZTogc3VtbWFyeS52YWxlbmNlLFxuICAgICAgdm9sYXRpbGl0eTogc3VtbWFyeS52b2xhdGlsaXR5XG4gICAgfSA6IG51bGwsXG4gICAgaG9va19zdGFjazogaG9va1N0YWNrLFxuICAgIGludGVncmF0aW9uX2ZhY3RvcnM6IGludGVncmF0aW9uLFxuICAgIHRpbWVfc2VyaWVzOiB0aW1lU2VyaWVzLFxuICAgIG5hdGFsX3N1bW1hcnk6IGV4dHJhY3ROYXRhbFN1bW1hcnkoYSksXG4gICAgdmVjdG9yX2ludGVncml0eToge1xuICAgICAgbGF0ZW50OiBbXSwgLy8gVE9ETzogY29tcHV0ZSBoZXVyaXN0aWMgZnJvbSBhc3BlY3QgbmV0d29ya1xuICAgICAgc3VwcHJlc3NlZDogW10sIC8vIFRPRE86IGNvbXB1dGUgaGV1cmlzdGljIGZyb20gY291bnRlci1hc3BlY3RzXG4gICAgICBtZXRob2Q6ICdzdHViLTAnXG4gICAgfSxcbiAgICBwb2xhcml0eV9jYXJkczogYnVpbGRQb2xhcml0eUNhcmRzSG9va3MoYSksIC8vIERBVEEgaG9va3Mgb25seSwgbm8gVk9JQ0VcbiAgICBtaXJyb3Jfdm9pY2U6IG51bGwsIC8vIHJlc2VydmVkIGZvciBSYXZlblxuICAgIHJhd19nZW9tZXRyeTogZXh0cmFjdFJhd0dlb21ldHJ5KHJlc3VsdCksXG4gICAgcHJvdmVuYW5jZTogcmVzdWx0LnByb3ZlbmFuY2UgfHwgbnVsbFxuICB9O1xuXG4gIHJldHVybiByZXBvcnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBjb21wb3NlV292ZW5NYXBSZXBvcnQgfTtcbiJdLCJuYW1lcyI6WyJjb21wb3NlSG9va1N0YWNrIiwicmVxdWlyZSIsInNhZmVOdW0iLCJ4IiwiZGVmIiwibiIsIk51bWJlciIsImlzRmluaXRlIiwiY2xhbXAiLCJ2IiwibWluIiwibWF4IiwiTWF0aCIsImNvbXB1dGVJbnRlZ3JhdGlvbkZhY3RvcnMiLCJzdW1tYXJ5IiwibWFnIiwibWFnbml0dWRlIiwidmFsIiwidmFsZW5jZSIsInZvbCIsInZvbGF0aWxpdHkiLCJtYWdOIiwidm9sTiIsInZhbE4iLCJwY3QiLCJyb3VuZCIsImZlcnRpbGVfZmllbGQiLCJoYXJtb25pY19yZXNvbmFuY2UiLCJleHBhbnNpb25fbGlmdCIsImNvbWJ1c3Rpb25fY2xhcml0eSIsImxpYmVyYXRpb25fcmVsZWFzZSIsImludGVncmF0aW9uIiwiZXh0cmFjdFRpbWVTZXJpZXMiLCJ0cmFuc2l0c0J5RGF0ZSIsImVudHJpZXMiLCJkYXRlIiwiT2JqZWN0Iiwicm93IiwiZHJpdmVycyIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiZXh0cmFjdE5hdGFsU3VtbWFyeSIsInBlcnNvbiIsImNoYXJ0IiwiYmlydGgiLCJiaXJ0aF9kYXRhIiwicGxhY2VtZW50cyIsInBsYW5ldHMiLCJhbmdsZXMiLCJhc3BlY3RzIiwibWFqb3JfYXNwZWN0cyIsImV4dHJhY3RSYXdHZW9tZXRyeSIsInJlc3VsdCIsInBlcnNvbl9hIiwicGVyc29uX2IiLCJvdXQiLCJzb2xvIiwibmF0YWxfcGxhY2VtZW50cyIsIm5hdGFsX2FzcGVjdHMiLCJ0cmFuc2l0X2xvZ3MiLCJyZWxhdGlvbmFsIiwicGVyc29uX2JfbmF0YWxfcGxhY2VtZW50cyIsInBlcnNvbl9iX2FuZ2xlcyIsInBlcnNvbl9iX25hdGFsX2FzcGVjdHMiLCJiX3RyYW5zaXRfbG9ncyIsImJ1aWxkUG9sYXJpdHlDYXJkc0hvb2tzIiwic2VyaWVzIiwiaXRlbXMiLCJsZW5ndGgiLCJzbGljZSIsInNhbXBsZSIsImlkIiwiZmllbGRfdG9uZSIsIm1hcF9nZW9tZXRyeSIsInZvaWNlX3Nsb3QiLCJpbmZlclJlcG9ydFR5cGUiLCJtb2RlVG9rZW4iLCJoYXNCIiwibSIsInRvVXBwZXJDYXNlIiwiaW5jbHVkZXMiLCJjb21wb3NlV292ZW5NYXBSZXBvcnQiLCJtb2RlIiwicGVyaW9kIiwidHlwZSIsImRlcml2ZWQiLCJzZWlzbW9ncmFwaF9zdW1tYXJ5IiwidGltZVNlcmllcyIsImhvb2tTdGFjayIsIm1heEhvb2tzIiwibWluSW50ZW5zaXR5IiwicmVwb3J0Iiwic2NoZW1hIiwiY29udGV4dCIsInRyYW5zbG9jYXRpb24iLCJuYW1lIiwiZGV0YWlscyIsImJpcnRoX2RhdGUiLCJiaXJ0aF90aW1lIiwiY29vcmRpbmF0ZXMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImxhdCIsImxvbiIsInRpbWV6b25lIiwiYmFsYW5jZV9tZXRlciIsImhvb2tfc3RhY2siLCJpbnRlZ3JhdGlvbl9mYWN0b3JzIiwidGltZV9zZXJpZXMiLCJuYXRhbF9zdW1tYXJ5IiwidmVjdG9yX2ludGVncml0eSIsImxhdGVudCIsInN1cHByZXNzZWQiLCJtZXRob2QiLCJwb2xhcml0eV9jYXJkcyIsIm1pcnJvcl92b2ljZSIsInJhd19nZW9tZXRyeSIsInByb3ZlbmFuY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/reporters/woven-map-composer.js\n");

/***/ }),

/***/ "(rsc)/./src/seismograph.js":
/*!****************************!*\
  !*** ./src/seismograph.js ***!
  \****************************/
/***/ ((module) => {

eval("// src/seismograph.js\n/**\n * @typedef {Object} AspectIn\n * @property {{name?:string, body?:string} | string} [a]      // transit (alt)\n * @property {{name?:string, body?:string} | string} [b]      // natal (alt)\n * @property {{name?:string, body?:string, retrograde?:boolean, deg?:number, sign?:string}} [transit]\n * @property {{name?:string, body?:string, retrograde?:boolean, deg?:number, sign?:string}} [natal]\n * @property {string} [type]     // conjunction|square|opposition|trine|sextile\n * @property {string|number} [aspect] // alt for type\n * @property {number|string} [orb]    // degrees or \"1°23'\"\n * @property {number|string} [orbit]  // alt for orb\n */ /**\n * @typedef {Object} PrevContext\n * @property {Array<ScoredAspect>} [scored] // previous day's scored aspects\n * @property {number} [Y_effective]         // previous day's Y_effective (after asymmetry)\n */ /**\n * @typedef {Object} ScoredAspect\n * @property {{body:string}} transit\n * @property {{body:string}} natal\n * @property {string} type\n * @property {number} orbDeg\n * @property {number} S\n */ \nconst OUTER = new Set([\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n    \"Pluto\"\n]);\nconst PERSONAL = new Set([\n    \"Sun\",\n    \"Moon\",\n    \"Mercury\",\n    \"Venus\",\n    \"Mars\",\n    \"ASC\",\n    \"MC\",\n    \"IC\",\n    \"DSC\"\n]);\nconst ANGLES = new Set([\n    \"ASC\",\n    \"MC\",\n    \"IC\",\n    \"DSC\"\n]);\nconst DEFAULTS = {\n    magnitudeDivisor: 4,\n    hubBonusCap: 0.6,\n    sameTargetBonusCap: 0.3,\n    tightBandDeg: 1.5,\n    outerTightenStep: 0.2,\n    uranusTightFlagDeg: 3.0,\n    // Enhanced volatility settings\n    fastComponentThreshold: 1.0,\n    rollingWindowDays: 14,\n    hookStackCap: 5,\n    // Planetary weights for volatility dispersion\n    planetaryWeights: {\n        \"Sun\": 1.2,\n        \"Moon\": 1.5,\n        \"ASC\": 1.3,\n        \"MC\": 1.3,\n        \"IC\": 1.1,\n        \"DSC\": 1.1,\n        \"Mercury\": 1.0,\n        \"Venus\": 1.0,\n        \"Mars\": 1.1,\n        \"Jupiter\": 0.9,\n        \"Saturn\": 0.8,\n        \"Uranus\": 0.7,\n        \"Neptune\": 0.6,\n        \"Pluto\": 0.6,\n        \"Chiron\": 0.8,\n        \"Mean_Node\": 0.7,\n        \"Mean_South_Node\": 0.7\n    }\n};\nfunction round(n, p = 2) {\n    return Math.round(n * 10 ** p) / 10 ** p;\n}\nfunction asNum(x, fallback = NaN) {\n    if (typeof x === \"number\") return x;\n    if (typeof x === \"string\") {\n        const m = x.match(/(-?\\d+)(?:[°:\\s]+(\\d+))?/);\n        if (m) {\n            const d = +m[1];\n            const min = m[2] ? +m[2] : 0;\n            return d + min / 60;\n        }\n        const f = parseFloat(x);\n        return Number.isFinite(f) ? f : fallback;\n    }\n    return fallback;\n}\nfunction nameOf(node) {\n    if (!node) return undefined;\n    return typeof node === \"string\" ? node : node.name || node.body;\n}\nfunction normalizeAspect(a) {\n    const tName = nameOf(a?.transit) || nameOf(a?.a);\n    const nName = nameOf(a?.natal) || nameOf(a?.b);\n    const type = String(a?.type || a?.aspect || \"\").toLowerCase();\n    const orbDeg = asNum(a?.orb ?? a?.orbit, 6.01);\n    return {\n        transit: {\n            body: tName || \"?\"\n        },\n        natal: {\n            body: nName || \"?\"\n        },\n        type,\n        orbDeg\n    };\n}\n// ---------- per-aspect S = v × p × o × s ----------\nfunction baseValence(type, aBody, bBody) {\n    switch(type){\n        case \"trine\":\n            return +1.0;\n        case \"sextile\":\n            return +0.7;\n        case \"square\":\n        case \"opposition\":\n            return -1.2;\n        case \"conjunction\":\n            {\n                const set = new Set([\n                    aBody,\n                    bBody\n                ]);\n                if (set.has(\"Venus\") || set.has(\"Jupiter\")) return +0.6;\n                if (set.has(\"Saturn\") || set.has(\"Pluto\") || set.has(\"Chiron\")) return -0.8;\n                return 0.0;\n            }\n        default:\n            return 0.0;\n    }\n}\nfunction planetTier(body) {\n    if (body === \"Chiron\") return 1.2;\n    if (OUTER.has(body)) return 1.5;\n    if (body === \"Moon\") return 0.5;\n    return 1.0;\n}\nfunction orbMultiplier(orbDeg) {\n    const o = Math.abs(orbDeg);\n    if (o <= 0.5) return 1.5;\n    if (o <= 1.5) return 1.3;\n    if (o <= 3.0) return 1.2;\n    if (o <= 6.0) return 1.0;\n    return 0.6;\n}\nfunction sensitivityMultiplier(natalBody, isAngle = false, isLum = false, critical = false) {\n    let s = 1.0;\n    if (isAngle) s *= 1.3;\n    else if (isLum) s *= 1.2;\n    else if (PERSONAL.has(natalBody)) s *= 1.1;\n    if (critical) s *= 1.1;\n    return s;\n}\nfunction scoreAspect(inA, flags = {}) {\n    const a = normalizeAspect(inA);\n    const tBody = a.transit.body, nBody = a.natal.body;\n    const v = baseValence(a.type, tBody, nBody);\n    const p = Math.max(planetTier(tBody), planetTier(nBody));\n    const o = orbMultiplier(a.orbDeg);\n    const s = sensitivityMultiplier(nBody, !!flags.isAngleProx, nBody === \"Sun\" || nBody === \"Moon\", !!flags.critical);\n    const S = v * p * o * s;\n    return {\n        ...a,\n        S\n    };\n}\n// ---------- stacking bonuses for Magnitude ----------\nfunction multiplicityBonus(scored, opts = DEFAULTS) {\n    let hub = 0, target = 0;\n    const byTransit = new Map();\n    for (const x of scored){\n        const k = x.transit.body;\n        byTransit.set(k, (byTransit.get(k) || 0) + 1);\n    }\n    for (const [, n] of byTransit)if (n >= 3) hub += 0.2 * (n - 2);\n    hub = Math.min(opts.hubBonusCap, hub);\n    const byTarget = new Map();\n    for (const x of scored){\n        const k = x.natal.body;\n        byTarget.set(k, (byTarget.get(k) || 0) + 1);\n    }\n    for (const [, m] of byTarget)if (m >= 2) target += 0.1 * (m - 1);\n    target = Math.min(opts.sameTargetBonusCap, target);\n    return hub + target;\n}\n// ---------- Enhanced Volatility Index (weighted dispersion) ----------\nfunction volatility(scoredToday, prevCtx = null, opts = DEFAULTS) {\n    let A = 0, B = 0, C = 0, D = 0;\n    const key = (x)=>`${x.transit.body}|${x.natal.body}|${x.type}`;\n    // A: Tight aspects entering/leaving\n    if (prevCtx?.scored) {\n        const tight = (arr)=>arr.filter((x)=>x.orbDeg <= opts.tightBandDeg);\n        const prevTight = new Set(tight(prevCtx.scored).map(key));\n        const nowTight = new Set(tight(scoredToday).map(key));\n        for (const k of nowTight)if (!prevTight.has(k)) A++;\n        for (const k of prevTight)if (!nowTight.has(k)) A++;\n    }\n    // B: Valence sign flip \n    if (typeof prevCtx?.Y_effective === \"number\") {\n        const prevY = prevCtx.Y_effective;\n        const nowY = scoredToday.reduce((s, x)=>s + x.S, 0);\n        if (Math.sign(prevY) !== Math.sign(nowY) && Math.abs(prevY) > 0.05 && Math.abs(nowY) > 0.05) B = 1;\n    }\n    // C: Outer planet hard aspects tightening\n    if (prevCtx?.scored) {\n        const prevMap = new Map(prevCtx.scored.map((x)=>[\n                key(x),\n                x\n            ]));\n        for (const cur of scoredToday){\n            const pX = prevMap.get(key(cur));\n            const isOuterHard = (OUTER.has(cur.transit.body) || OUTER.has(cur.natal.body)) && (cur.type === \"square\" || cur.type === \"opposition\");\n            if (pX && isOuterHard && pX.orbDeg - cur.orbDeg >= opts.outerTightenStep) C++;\n        }\n    }\n    // D: Uranus exact activation\n    if (scoredToday.some((x)=>(x.transit.body === \"Uranus\" || x.natal.body === \"Uranus\") && x.orbDeg <= opts.uranusTightFlagDeg)) D = 1;\n    // Enhanced: Add weighted valence dispersion component\n    const weightedValences = scoredToday.map((x)=>{\n        const transitWeight = opts.planetaryWeights[x.transit.body] || 0.5;\n        const natalWeight = opts.planetaryWeights[x.natal.body] || 0.5;\n        const combinedWeight = Math.max(transitWeight, natalWeight);\n        return x.S * combinedWeight;\n    });\n    let E = 0; // Dispersion component\n    if (weightedValences.length >= 3) {\n        const mean = weightedValences.reduce((s, v)=>s + v, 0) / weightedValences.length;\n        const variance = weightedValences.reduce((s, v)=>s + Math.pow(v - mean, 2), 0) / weightedValences.length;\n        const stdDev = Math.sqrt(variance);\n        E = Math.min(2, stdDev * 0.5); // Scale to 0-2 range\n    }\n    return A + B + C + D + Math.round(E);\n}\n// ---------- Rolling magnitude normalization with fallback scaling ----------\nfunction normalizeWithRollingWindow(magnitude, rollingContext = null, opts = DEFAULTS) {\n    // System prior from original spec (X = min(5, X_raw/4)), i.e., a \"typical\" day\n    const X_prior = 4.0;\n    const epsilon = 1e-6;\n    if (!rollingContext || !rollingContext.magnitudes || rollingContext.magnitudes.length < 1) {\n        // No context at all, use original magnitude\n        return magnitude;\n    }\n    const { magnitudes } = rollingContext;\n    const n = magnitudes.length;\n    // Calculate blend weight: λ = n/14 (cap to [0,1])\n    const lambda = Math.min(1, n / 14);\n    let X_ref;\n    if (n >= 14) {\n        // Full window: use median of last 14 days\n        const sorted = [\n            ...magnitudes\n        ].sort((a, b)=>a - b);\n        const mid = Math.floor(sorted.length / 2);\n        X_ref = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n    } else if (n >= 2) {\n        // Thin slice: blend available median with system prior\n        const sorted = [\n            ...magnitudes\n        ].sort((a, b)=>a - b);\n        const mid = Math.floor(sorted.length / 2);\n        const median_available = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n        X_ref = lambda * median_available + (1 - lambda) * X_prior;\n    } else {\n        // n = 1: use system prior\n        X_ref = X_prior;\n    }\n    // Ensure X_ref is not too small to avoid division issues\n    if (X_ref < epsilon) X_ref = X_prior;\n    // Apply magnitude formula: magnitude = clip(5 * X_raw / (X_ref * 1.6), 0, 10)\n    const normalized = Math.max(0, Math.min(10, 5 * magnitude / (X_ref * 1.6)));\n    return normalized;\n}\n// ---------- main aggregate ----------\nfunction aggregate(aspects = [], prevCtx = null, options = {}) {\n    if (!Array.isArray(aspects) || aspects.length === 0) {\n        return {\n            magnitude: 0,\n            valence: prevCtx?.Y_effective ? round(prevCtx.Y_effective, 2) : 0,\n            volatility: 0,\n            scored: []\n        };\n    }\n    const opts = {\n        ...DEFAULTS,\n        ...options\n    };\n    const scored = aspects.map((a)=>scoreAspect(a, {\n            isAngleProx: ANGLES.has(a?.natal?.body || a?.b?.name || a?.b || \"\"),\n            critical: false\n        }));\n    const X_raw = scored.reduce((acc, x)=>acc + Math.abs(x.S), 0);\n    const Y_raw = scored.reduce((acc, x)=>acc + x.S, 0);\n    let X = Math.min(5, X_raw / opts.magnitudeDivisor);\n    X = Math.min(5, X + multiplicityBonus(scored, opts));\n    // Store the original magnitude before normalization\n    const X_original = X;\n    // Calculate confidence based on available data\n    let scale_confidence = 1.0;\n    if (options.rollingContext && options.rollingContext.magnitudes) {\n        const n = options.rollingContext.magnitudes.length;\n        scale_confidence = round(n / 14, 2);\n    }\n    // Apply rolling magnitude normalization if context provided\n    if (options.rollingContext) {\n        X = normalizeWithRollingWindow(X, options.rollingContext, opts);\n    }\n    const Y_effective = Y_raw * (0.8 + 0.2 * X);\n    const VI = volatility(scored, prevCtx, opts);\n    return {\n        magnitude: round(X, 2),\n        valence: round(Y_effective, 2),\n        volatility: VI,\n        scored,\n        rawMagnitude: round(X_raw / opts.magnitudeDivisor, 2),\n        originalMagnitude: round(X_original, 2),\n        scaleConfidence: scale_confidence\n    };\n}\nmodule.exports = {\n    aggregate,\n    _internals: {\n        normalizeAspect,\n        baseValence,\n        planetTier,\n        orbMultiplier,\n        sensitivityMultiplier,\n        scoreAspect,\n        multiplicityBonus,\n        volatility,\n        normalizeWithRollingWindow\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SXVILFFBQVFkLGNBQWMsQ0FBQ0csVUFBVSxDQUFDWCxNQUFNO1FBQ2xEK0IsbUJBQW1CakksTUFBTUMsSUFBSSxJQUFJO0lBQ25DO0lBRUEsNERBQTREO0lBQzVELElBQUl1SCxRQUFRZCxjQUFjLEVBQUU7UUFDMUJxQixJQUFJdkIsMkJBQTJCdUIsR0FBR1AsUUFBUWQsY0FBYyxFQUFFN0M7SUFDNUQ7SUFFQSxNQUFNc0IsY0FBYzJDLFFBQVMsT0FBTSxNQUFNQyxDQUFBQTtJQUV6QyxNQUFNRyxLQUFLN0QsV0FBV1QsUUFBUVcsU0FBU1Y7SUFFdkMsT0FBTztRQUNMNEMsV0FBV3pHLE1BQU0rSCxHQUFHO1FBQ3BCSixTQUFTM0gsTUFBTW1GLGFBQWE7UUFDNUJkLFlBQVk2RDtRQUNadEU7UUFDQXVFLGNBQWNuSSxNQUFNNEgsUUFBUS9ELEtBQUt2RSxnQkFBZ0IsRUFBRTtRQUNuRDhJLG1CQUFtQnBJLE1BQU1nSSxZQUFZO1FBQ3JDSyxpQkFBaUJKO0lBQ25CO0FBQ0Y7QUFFQUssT0FBT0MsT0FBTyxHQUFHO0lBQ2ZqQjtJQUNBa0IsWUFBWTtRQUNWbkg7UUFBaUJjO1FBQWFLO1FBQVlDO1FBQWVHO1FBQ3pETTtRQUFhUztRQUFtQlU7UUFBWW1DO0lBQzlDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Zlbi13ZWItYXBwLy4vc3JjL3NlaXNtb2dyYXBoLmpzP2I4ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3NlaXNtb2dyYXBoLmpzXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXNwZWN0SW5cbiAqIEBwcm9wZXJ0eSB7e25hbWU/OnN0cmluZywgYm9keT86c3RyaW5nfSB8IHN0cmluZ30gW2FdICAgICAgLy8gdHJhbnNpdCAoYWx0KVxuICogQHByb3BlcnR5IHt7bmFtZT86c3RyaW5nLCBib2R5PzpzdHJpbmd9IHwgc3RyaW5nfSBbYl0gICAgICAvLyBuYXRhbCAoYWx0KVxuICogQHByb3BlcnR5IHt7bmFtZT86c3RyaW5nLCBib2R5PzpzdHJpbmcsIHJldHJvZ3JhZGU/OmJvb2xlYW4sIGRlZz86bnVtYmVyLCBzaWduPzpzdHJpbmd9fSBbdHJhbnNpdF1cbiAqIEBwcm9wZXJ0eSB7e25hbWU/OnN0cmluZywgYm9keT86c3RyaW5nLCByZXRyb2dyYWRlPzpib29sZWFuLCBkZWc/Om51bWJlciwgc2lnbj86c3RyaW5nfX0gW25hdGFsXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXSAgICAgLy8gY29uanVuY3Rpb258c3F1YXJlfG9wcG9zaXRpb258dHJpbmV8c2V4dGlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSBbYXNwZWN0XSAvLyBhbHQgZm9yIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHN0cmluZ30gW29yYl0gICAgLy8gZGVncmVlcyBvciBcIjHCsDIzJ1wiXG4gKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IFtvcmJpdF0gIC8vIGFsdCBmb3Igb3JiXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcmV2Q29udGV4dFxuICogQHByb3BlcnR5IHtBcnJheTxTY29yZWRBc3BlY3Q+fSBbc2NvcmVkXSAvLyBwcmV2aW91cyBkYXkncyBzY29yZWQgYXNwZWN0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtZX2VmZmVjdGl2ZV0gICAgICAgICAvLyBwcmV2aW91cyBkYXkncyBZX2VmZmVjdGl2ZSAoYWZ0ZXIgYXN5bW1ldHJ5KVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NvcmVkQXNwZWN0XG4gKiBAcHJvcGVydHkge3tib2R5OnN0cmluZ319IHRyYW5zaXRcbiAqIEBwcm9wZXJ0eSB7e2JvZHk6c3RyaW5nfX0gbmF0YWxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3JiRGVnXG4gKiBAcHJvcGVydHkge251bWJlcn0gU1xuICovXG5cbmNvbnN0IE9VVEVSID0gbmV3IFNldChbXCJTYXR1cm5cIixcIlVyYW51c1wiLFwiTmVwdHVuZVwiLFwiUGx1dG9cIl0pO1xuY29uc3QgUEVSU09OQUwgPSBuZXcgU2V0KFtcIlN1blwiLFwiTW9vblwiLFwiTWVyY3VyeVwiLFwiVmVudXNcIixcIk1hcnNcIixcIkFTQ1wiLFwiTUNcIixcIklDXCIsXCJEU0NcIl0pO1xuY29uc3QgQU5HTEVTID0gbmV3IFNldChbXCJBU0NcIixcIk1DXCIsXCJJQ1wiLFwiRFNDXCJdKTtcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIG1hZ25pdHVkZURpdmlzb3I6IDQsICAgICAgICAgICAgICAgXG4gIGh1YkJvbnVzQ2FwOiAwLjYsICAgICAgICAgICAgICAgICAgXG4gIHNhbWVUYXJnZXRCb251c0NhcDogMC4zLCAgICAgICAgICAgXG4gIHRpZ2h0QmFuZERlZzogMS41LCAgICAgICAgICAgICAgICAgXG4gIG91dGVyVGlnaHRlblN0ZXA6IDAuMiwgICAgICAgICAgICAgXG4gIHVyYW51c1RpZ2h0RmxhZ0RlZzogMy4wLFxuICAvLyBFbmhhbmNlZCB2b2xhdGlsaXR5IHNldHRpbmdzXG4gIGZhc3RDb21wb25lbnRUaHJlc2hvbGQ6IDEuMCwgICAgICAgLy8gb3JiIHRocmVzaG9sZCBmb3IgZmFzdC1tb3ZpbmcgYXNwZWN0cyAoTW9vbi1NZXJjdXJ5L01hcnMpXG4gIHJvbGxpbmdXaW5kb3dEYXlzOiAxNCwgICAgICAgICAgICAgLy8gbWFnbml0dWRlIG5vcm1hbGl6YXRpb24gd2luZG93XG4gIGhvb2tTdGFja0NhcDogNSwgICAgICAgICAgICAgICAgICAgLy8gbWF4IGhvb2tzIHRvIHN1cmZhY2UgaW4gc3VtbWFyeVxuICAvLyBQbGFuZXRhcnkgd2VpZ2h0cyBmb3Igdm9sYXRpbGl0eSBkaXNwZXJzaW9uXG4gIHBsYW5ldGFyeVdlaWdodHM6IHtcbiAgICAnU3VuJzogMS4yLCAnTW9vbic6IDEuNSwgJ0FTQyc6IDEuMywgJ01DJzogMS4zLCAnSUMnOiAxLjEsICdEU0MnOiAxLjEsXG4gICAgJ01lcmN1cnknOiAxLjAsICdWZW51cyc6IDEuMCwgJ01hcnMnOiAxLjEsICdKdXBpdGVyJzogMC45LFxuICAgICdTYXR1cm4nOiAwLjgsICdVcmFudXMnOiAwLjcsICdOZXB0dW5lJzogMC42LCAnUGx1dG8nOiAwLjYsXG4gICAgJ0NoaXJvbic6IDAuOCwgJ01lYW5fTm9kZSc6IDAuNywgJ01lYW5fU291dGhfTm9kZSc6IDAuN1xuICB9XG59O1xuXG5mdW5jdGlvbiByb3VuZChuLCBwPTIpeyByZXR1cm4gTWF0aC5yb3VuZChuICogKDEwKipwKSkgLyAoMTAqKnApOyB9XG5mdW5jdGlvbiBhc051bSh4LCBmYWxsYmFjaz1OYU4pe1xuICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHJldHVybiB4O1xuICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBtID0geC5tYXRjaCgvKC0/XFxkKykoPzpbwrA6XFxzXSsoXFxkKykpPy8pOyBcbiAgICBpZiAobSl7IGNvbnN0IGQgPSArbVsxXTsgY29uc3QgbWluID0gbVsyXSA/ICttWzJdIDogMDsgcmV0dXJuIGQgKyBtaW4vNjA7IH1cbiAgICBjb25zdCBmID0gcGFyc2VGbG9hdCh4KTsgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShmKSA/IGYgOiBmYWxsYmFjaztcbiAgfVxuICByZXR1cm4gZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBuYW1lT2Yobm9kZSl7IGlmICghbm9kZSkgcmV0dXJuIHVuZGVmaW5lZDsgcmV0dXJuIHR5cGVvZiBub2RlPT09XCJzdHJpbmdcIiA/IG5vZGUgOiAobm9kZS5uYW1lIHx8IG5vZGUuYm9keSk7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXNwZWN0KGEpe1xuICBjb25zdCB0TmFtZSA9IG5hbWVPZihhPy50cmFuc2l0KSB8fCBuYW1lT2YoYT8uYSk7XG4gIGNvbnN0IG5OYW1lID0gbmFtZU9mKGE/Lm5hdGFsKSAgIHx8IG5hbWVPZihhPy5iKTtcbiAgY29uc3QgdHlwZSAgPSBTdHJpbmcoYT8udHlwZSB8fCBhPy5hc3BlY3QgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qgb3JiRGVnID0gYXNOdW0oYT8ub3JiID8/IGE/Lm9yYml0LCA2LjAxKTtcbiAgcmV0dXJuIHsgdHJhbnNpdDp7Ym9keTp0TmFtZXx8XCI/XCJ9LCBuYXRhbDp7Ym9keTpuTmFtZXx8XCI/XCJ9LCB0eXBlLCBvcmJEZWcgfTtcbn1cblxuLy8gLS0tLS0tLS0tLSBwZXItYXNwZWN0IFMgPSB2IMOXIHAgw5cgbyDDlyBzIC0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJhc2VWYWxlbmNlKHR5cGUsIGFCb2R5LCBiQm9keSl7XG4gIHN3aXRjaCAodHlwZSl7XG4gICAgY2FzZSBcInRyaW5lXCI6IHJldHVybiArMS4wO1xuICAgIGNhc2UgXCJzZXh0aWxlXCI6IHJldHVybiArMC43O1xuICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICBjYXNlIFwib3Bwb3NpdGlvblwiOiByZXR1cm4gLTEuMjtcbiAgICBjYXNlIFwiY29uanVuY3Rpb25cIjp7XG4gICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KFthQm9keSxiQm9keV0pO1xuICAgICAgaWYgKHNldC5oYXMoXCJWZW51c1wiKSB8fCBzZXQuaGFzKFwiSnVwaXRlclwiKSkgcmV0dXJuICswLjY7XG4gICAgICBpZiAoc2V0LmhhcyhcIlNhdHVyblwiKSB8fCBzZXQuaGFzKFwiUGx1dG9cIikgfHwgc2V0LmhhcyhcIkNoaXJvblwiKSkgcmV0dXJuIC0wLjg7XG4gICAgICByZXR1cm4gMC4wO1xuICAgIH1cbiAgICBkZWZhdWx0OiByZXR1cm4gMC4wO1xuICB9XG59IFxuXG5mdW5jdGlvbiBwbGFuZXRUaWVyKGJvZHkpe1xuICBpZiAoYm9keT09PVwiQ2hpcm9uXCIpIHJldHVybiAxLjI7XG4gIGlmIChPVVRFUi5oYXMoYm9keSkpIHJldHVybiAxLjU7XG4gIGlmIChib2R5PT09XCJNb29uXCIpIHJldHVybiAwLjU7XG4gIHJldHVybiAxLjA7XG59IFxuXG5mdW5jdGlvbiBvcmJNdWx0aXBsaWVyKG9yYkRlZyl7XG4gIGNvbnN0IG8gPSBNYXRoLmFicyhvcmJEZWcpO1xuICBpZiAobyA8PSAwLjUpIHJldHVybiAxLjU7XG4gIGlmIChvIDw9IDEuNSkgcmV0dXJuIDEuMztcbiAgaWYgKG8gPD0gMy4wKSByZXR1cm4gMS4yO1xuICBpZiAobyA8PSA2LjApIHJldHVybiAxLjA7XG4gIHJldHVybiAwLjY7XG59IFxuXG5mdW5jdGlvbiBzZW5zaXRpdml0eU11bHRpcGxpZXIobmF0YWxCb2R5LCBpc0FuZ2xlPWZhbHNlLCBpc0x1bT1mYWxzZSwgY3JpdGljYWw9ZmFsc2Upe1xuICBsZXQgcyA9IDEuMDtcbiAgaWYgKGlzQW5nbGUpIHMgKj0gMS4zO1xuICBlbHNlIGlmIChpc0x1bSkgcyAqPSAxLjI7XG4gIGVsc2UgaWYgKFBFUlNPTkFMLmhhcyhuYXRhbEJvZHkpKSBzICo9IDEuMTtcbiAgaWYgKGNyaXRpY2FsKSBzICo9IDEuMTtcbiAgcmV0dXJuIHM7XG59IFxuXG5mdW5jdGlvbiBzY29yZUFzcGVjdChpbkEsIGZsYWdzPXt9KXtcbiAgY29uc3QgYSA9IG5vcm1hbGl6ZUFzcGVjdChpbkEpO1xuICBjb25zdCB0Qm9keSA9IGEudHJhbnNpdC5ib2R5LCBuQm9keSA9IGEubmF0YWwuYm9keTtcbiAgY29uc3QgdiA9IGJhc2VWYWxlbmNlKGEudHlwZSwgdEJvZHksIG5Cb2R5KTtcbiAgY29uc3QgcCA9IE1hdGgubWF4KHBsYW5ldFRpZXIodEJvZHkpLCBwbGFuZXRUaWVyKG5Cb2R5KSk7XG4gIGNvbnN0IG8gPSBvcmJNdWx0aXBsaWVyKGEub3JiRGVnKTtcbiAgY29uc3QgcyA9IHNlbnNpdGl2aXR5TXVsdGlwbGllcihuQm9keSwgISFmbGFncy5pc0FuZ2xlUHJveCwgKG5Cb2R5PT09XCJTdW5cInx8bkJvZHk9PT1cIk1vb25cIiksICEhZmxhZ3MuY3JpdGljYWwpO1xuICBjb25zdCBTID0gdiAqIHAgKiBvICogcztcbiAgcmV0dXJuIHsgLi4uYSwgUyB9O1xufVxuXG4vLyAtLS0tLS0tLS0tIHN0YWNraW5nIGJvbnVzZXMgZm9yIE1hZ25pdHVkZSAtLS0tLS0tLS0tXG5mdW5jdGlvbiBtdWx0aXBsaWNpdHlCb251cyhzY29yZWQsIG9wdHM9REVGQVVMVFMpe1xuICBsZXQgaHViID0gMCwgdGFyZ2V0ID0gMDtcblxuICBjb25zdCBieVRyYW5zaXQgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgeCBvZiBzY29yZWQpeyBjb25zdCBrID0geC50cmFuc2l0LmJvZHk7IGJ5VHJhbnNpdC5zZXQoaywoYnlUcmFuc2l0LmdldChrKXx8MCkrMSk7IH1cbiAgZm9yIChjb25zdCBbLG5dIG9mIGJ5VHJhbnNpdCkgaWYgKG4+PTMpIGh1YiArPSAwLjIqKG4tMik7XG4gIGh1YiA9IE1hdGgubWluKG9wdHMuaHViQm9udXNDYXAsIGh1Yik7XG5cbiAgY29uc3QgYnlUYXJnZXQgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgeCBvZiBzY29yZWQpeyBjb25zdCBrID0geC5uYXRhbC5ib2R5OyBieVRhcmdldC5zZXQoaywoYnlUYXJnZXQuZ2V0KGspfHwwKSsxKTsgfVxuICBmb3IgKGNvbnN0IFssbV0gb2YgYnlUYXJnZXQpIGlmIChtPj0yKSB0YXJnZXQgKz0gMC4xKihtLTEpO1xuICB0YXJnZXQgPSBNYXRoLm1pbihvcHRzLnNhbWVUYXJnZXRCb251c0NhcCwgdGFyZ2V0KTtcblxuICByZXR1cm4gaHViICsgdGFyZ2V0O1xufSBcblxuLy8gLS0tLS0tLS0tLSBFbmhhbmNlZCBWb2xhdGlsaXR5IEluZGV4ICh3ZWlnaHRlZCBkaXNwZXJzaW9uKSAtLS0tLS0tLS0tXG5mdW5jdGlvbiB2b2xhdGlsaXR5KHNjb3JlZFRvZGF5LCBwcmV2Q3R4PW51bGwsIG9wdHM9REVGQVVMVFMpe1xuICBsZXQgQT0wLEI9MCxDPTAsRD0wO1xuICBjb25zdCBrZXkgPSAoeCk9PmAke3gudHJhbnNpdC5ib2R5fXwke3gubmF0YWwuYm9keX18JHt4LnR5cGV9YDtcblxuICAvLyBBOiBUaWdodCBhc3BlY3RzIGVudGVyaW5nL2xlYXZpbmdcbiAgaWYgKHByZXZDdHg/LnNjb3JlZCl7XG4gICAgY29uc3QgdGlnaHQgPSBhcnIgPT4gYXJyLmZpbHRlcih4PT54Lm9yYkRlZyA8PSBvcHRzLnRpZ2h0QmFuZERlZyk7XG4gICAgY29uc3QgcHJldlRpZ2h0ID0gbmV3IFNldCh0aWdodChwcmV2Q3R4LnNjb3JlZCkubWFwKGtleSkpO1xuICAgIGNvbnN0IG5vd1RpZ2h0ICA9IG5ldyBTZXQodGlnaHQoc2NvcmVkVG9kYXkpLm1hcChrZXkpKTtcbiAgICBmb3IgKGNvbnN0IGsgb2Ygbm93VGlnaHQpIGlmICghcHJldlRpZ2h0LmhhcyhrKSkgQSsrO1xuICAgIGZvciAoY29uc3QgayBvZiBwcmV2VGlnaHQpIGlmICghbm93VGlnaHQuaGFzKGspKSBBKys7XG4gIH1cblxuICAvLyBCOiBWYWxlbmNlIHNpZ24gZmxpcCBcbiAgaWYgKHR5cGVvZiBwcmV2Q3R4Py5ZX2VmZmVjdGl2ZSA9PT0gXCJudW1iZXJcIil7XG4gICAgY29uc3QgcHJldlkgPSBwcmV2Q3R4LllfZWZmZWN0aXZlO1xuICAgIGNvbnN0IG5vd1kgID0gc2NvcmVkVG9kYXkucmVkdWNlKChzLHgpPT5zK3guUywwKTtcbiAgICBpZiAoTWF0aC5zaWduKHByZXZZKSAhPT0gTWF0aC5zaWduKG5vd1kpICYmIE1hdGguYWJzKHByZXZZKT4wLjA1ICYmIE1hdGguYWJzKG5vd1kpPjAuMDUpIEIgPSAxO1xuICB9XG5cbiAgLy8gQzogT3V0ZXIgcGxhbmV0IGhhcmQgYXNwZWN0cyB0aWdodGVuaW5nXG4gIGlmIChwcmV2Q3R4Py5zY29yZWQpe1xuICAgIGNvbnN0IHByZXZNYXAgPSBuZXcgTWFwKHByZXZDdHguc2NvcmVkLm1hcCh4PT5ba2V5KHgpLHhdKSk7XG4gICAgZm9yIChjb25zdCBjdXIgb2Ygc2NvcmVkVG9kYXkpe1xuICAgICAgY29uc3QgcFggPSBwcmV2TWFwLmdldChrZXkoY3VyKSk7XG4gICAgICBjb25zdCBpc091dGVySGFyZCA9IChPVVRFUi5oYXMoY3VyLnRyYW5zaXQuYm9keSkgfHwgT1VURVIuaGFzKGN1ci5uYXRhbC5ib2R5KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1ci50eXBlPT09XCJzcXVhcmVcIiB8fCBjdXIudHlwZT09PVwib3Bwb3NpdGlvblwiKTtcbiAgICAgIGlmIChwWCAmJiBpc091dGVySGFyZCAmJiAocFgub3JiRGVnIC0gY3VyLm9yYkRlZykgPj0gb3B0cy5vdXRlclRpZ2h0ZW5TdGVwKSBDKys7XG4gICAgfVxuICB9XG5cbiAgLy8gRDogVXJhbnVzIGV4YWN0IGFjdGl2YXRpb25cbiAgaWYgKHNjb3JlZFRvZGF5LnNvbWUoeCA9PiAoeC50cmFuc2l0LmJvZHk9PT1cIlVyYW51c1wiIHx8IHgubmF0YWwuYm9keT09PVwiVXJhbnVzXCIpICYmIHgub3JiRGVnIDw9IG9wdHMudXJhbnVzVGlnaHRGbGFnRGVnKSkgRCA9IDE7XG5cbiAgLy8gRW5oYW5jZWQ6IEFkZCB3ZWlnaHRlZCB2YWxlbmNlIGRpc3BlcnNpb24gY29tcG9uZW50XG4gIGNvbnN0IHdlaWdodGVkVmFsZW5jZXMgPSBzY29yZWRUb2RheS5tYXAoeCA9PiB7XG4gICAgY29uc3QgdHJhbnNpdFdlaWdodCA9IG9wdHMucGxhbmV0YXJ5V2VpZ2h0c1t4LnRyYW5zaXQuYm9keV0gfHwgMC41O1xuICAgIGNvbnN0IG5hdGFsV2VpZ2h0ID0gb3B0cy5wbGFuZXRhcnlXZWlnaHRzW3gubmF0YWwuYm9keV0gfHwgMC41O1xuICAgIGNvbnN0IGNvbWJpbmVkV2VpZ2h0ID0gTWF0aC5tYXgodHJhbnNpdFdlaWdodCwgbmF0YWxXZWlnaHQpO1xuICAgIHJldHVybiB4LlMgKiBjb21iaW5lZFdlaWdodDtcbiAgfSk7XG5cbiAgbGV0IEUgPSAwOyAvLyBEaXNwZXJzaW9uIGNvbXBvbmVudFxuICBpZiAod2VpZ2h0ZWRWYWxlbmNlcy5sZW5ndGggPj0gMykge1xuICAgIGNvbnN0IG1lYW4gPSB3ZWlnaHRlZFZhbGVuY2VzLnJlZHVjZSgocywgdikgPT4gcyArIHYsIDApIC8gd2VpZ2h0ZWRWYWxlbmNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB3ZWlnaHRlZFZhbGVuY2VzLnJlZHVjZSgocywgdikgPT4gcyArIE1hdGgucG93KHYgLSBtZWFuLCAyKSwgMCkgLyB3ZWlnaHRlZFZhbGVuY2VzLmxlbmd0aDtcbiAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuICAgIEUgPSBNYXRoLm1pbigyLCBzdGREZXYgKiAwLjUpOyAvLyBTY2FsZSB0byAwLTIgcmFuZ2VcbiAgfVxuXG4gIHJldHVybiBBICsgQiArIEMgKyBEICsgTWF0aC5yb3VuZChFKTtcbn0gXG5cbi8vIC0tLS0tLS0tLS0gUm9sbGluZyBtYWduaXR1ZGUgbm9ybWFsaXphdGlvbiB3aXRoIGZhbGxiYWNrIHNjYWxpbmcgLS0tLS0tLS0tLVxuZnVuY3Rpb24gbm9ybWFsaXplV2l0aFJvbGxpbmdXaW5kb3cobWFnbml0dWRlLCByb2xsaW5nQ29udGV4dCA9IG51bGwsIG9wdHMgPSBERUZBVUxUUykge1xuICAvLyBTeXN0ZW0gcHJpb3IgZnJvbSBvcmlnaW5hbCBzcGVjIChYID0gbWluKDUsIFhfcmF3LzQpKSwgaS5lLiwgYSBcInR5cGljYWxcIiBkYXlcbiAgY29uc3QgWF9wcmlvciA9IDQuMDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gIFxuICBpZiAoIXJvbGxpbmdDb250ZXh0IHx8ICFyb2xsaW5nQ29udGV4dC5tYWduaXR1ZGVzIHx8IHJvbGxpbmdDb250ZXh0Lm1hZ25pdHVkZXMubGVuZ3RoIDwgMSkge1xuICAgIC8vIE5vIGNvbnRleHQgYXQgYWxsLCB1c2Ugb3JpZ2luYWwgbWFnbml0dWRlXG4gICAgcmV0dXJuIG1hZ25pdHVkZTtcbiAgfVxuICBcbiAgY29uc3QgeyBtYWduaXR1ZGVzIH0gPSByb2xsaW5nQ29udGV4dDtcbiAgY29uc3QgbiA9IG1hZ25pdHVkZXMubGVuZ3RoO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGJsZW5kIHdlaWdodDogzrsgPSBuLzE0IChjYXAgdG8gWzAsMV0pXG4gIGNvbnN0IGxhbWJkYSA9IE1hdGgubWluKDEsIG4gLyAxNCk7XG4gIFxuICBsZXQgWF9yZWY7XG4gIFxuICBpZiAobiA+PSAxNCkge1xuICAgIC8vIEZ1bGwgd2luZG93OiB1c2UgbWVkaWFuIG9mIGxhc3QgMTQgZGF5c1xuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5tYWduaXR1ZGVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihzb3J0ZWQubGVuZ3RoIC8gMik7XG4gICAgWF9yZWYgPSBzb3J0ZWQubGVuZ3RoICUgMiA9PT0gMCA/IFxuICAgICAgKHNvcnRlZFttaWQgLSAxXSArIHNvcnRlZFttaWRdKSAvIDIgOiBcbiAgICAgIHNvcnRlZFttaWRdO1xuICB9IGVsc2UgaWYgKG4gPj0gMikge1xuICAgIC8vIFRoaW4gc2xpY2U6IGJsZW5kIGF2YWlsYWJsZSBtZWRpYW4gd2l0aCBzeXN0ZW0gcHJpb3JcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4ubWFnbml0dWRlc10uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3Ioc29ydGVkLmxlbmd0aCAvIDIpO1xuICAgIGNvbnN0IG1lZGlhbl9hdmFpbGFibGUgPSBzb3J0ZWQubGVuZ3RoICUgMiA9PT0gMCA/IFxuICAgICAgKHNvcnRlZFttaWQgLSAxXSArIHNvcnRlZFttaWRdKSAvIDIgOiBcbiAgICAgIHNvcnRlZFttaWRdO1xuICAgIFxuICAgIFhfcmVmID0gbGFtYmRhICogbWVkaWFuX2F2YWlsYWJsZSArICgxIC0gbGFtYmRhKSAqIFhfcHJpb3I7XG4gIH0gZWxzZSB7XG4gICAgLy8gbiA9IDE6IHVzZSBzeXN0ZW0gcHJpb3JcbiAgICBYX3JlZiA9IFhfcHJpb3I7XG4gIH1cbiAgXG4gIC8vIEVuc3VyZSBYX3JlZiBpcyBub3QgdG9vIHNtYWxsIHRvIGF2b2lkIGRpdmlzaW9uIGlzc3Vlc1xuICBpZiAoWF9yZWYgPCBlcHNpbG9uKSBYX3JlZiA9IFhfcHJpb3I7XG4gIFxuICAvLyBBcHBseSBtYWduaXR1ZGUgZm9ybXVsYTogbWFnbml0dWRlID0gY2xpcCg1ICogWF9yYXcgLyAoWF9yZWYgKiAxLjYpLCAwLCAxMClcbiAgY29uc3Qgbm9ybWFsaXplZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwLCA1ICogbWFnbml0dWRlIC8gKFhfcmVmICogMS42KSkpO1xuICBcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIC0tLS0tLS0tLS0gbWFpbiBhZ2dyZWdhdGUgLS0tLS0tLS0tLVxuZnVuY3Rpb24gYWdncmVnYXRlKGFzcGVjdHMgPSBbXSwgcHJldkN0eCA9IG51bGwsIG9wdGlvbnMgPSB7fSl7XG4gIGlmICghQXJyYXkuaXNBcnJheShhc3BlY3RzKSB8fCBhc3BlY3RzLmxlbmd0aCA9PT0gMCl7XG4gICAgcmV0dXJuIHsgbWFnbml0dWRlOiAwLCB2YWxlbmNlOiBwcmV2Q3R4Py5ZX2VmZmVjdGl2ZSA/IHJvdW5kKHByZXZDdHguWV9lZmZlY3RpdmUsMikgOiAwLCB2b2xhdGlsaXR5OiAwLCBzY29yZWQ6IFtdIH07XG4gIH1cbiAgY29uc3Qgb3B0cyA9IHsgLi4uREVGQVVMVFMsIC4uLm9wdGlvbnMgfTtcblxuICBjb25zdCBzY29yZWQgPSBhc3BlY3RzLm1hcChhID0+IHNjb3JlQXNwZWN0KGEsIHtcbiAgICBpc0FuZ2xlUHJveDogQU5HTEVTLmhhcygoYT8ubmF0YWw/LmJvZHl8fGE/LmI/Lm5hbWV8fGE/LmIpfHxcIlwiKSxcbiAgICBjcml0aWNhbDogZmFsc2VcbiAgfSkpO1xuXG4gIGNvbnN0IFhfcmF3ID0gc2NvcmVkLnJlZHVjZSgoYWNjLHgpPT5hY2MgKyBNYXRoLmFicyh4LlMpLCAwKTtcbiAgY29uc3QgWV9yYXcgPSBzY29yZWQucmVkdWNlKChhY2MseCk9PmFjYyArIHguUywgMCk7XG5cbiAgbGV0IFggPSBNYXRoLm1pbig1LCBYX3JhdyAvIG9wdHMubWFnbml0dWRlRGl2aXNvcik7XG4gIFggPSBNYXRoLm1pbig1LCBYICsgbXVsdGlwbGljaXR5Qm9udXMoc2NvcmVkLCBvcHRzKSk7XG4gIFxuICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgbWFnbml0dWRlIGJlZm9yZSBub3JtYWxpemF0aW9uXG4gIGNvbnN0IFhfb3JpZ2luYWwgPSBYO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGNvbmZpZGVuY2UgYmFzZWQgb24gYXZhaWxhYmxlIGRhdGFcbiAgbGV0IHNjYWxlX2NvbmZpZGVuY2UgPSAxLjA7XG4gIGlmIChvcHRpb25zLnJvbGxpbmdDb250ZXh0ICYmIG9wdGlvbnMucm9sbGluZ0NvbnRleHQubWFnbml0dWRlcykge1xuICAgIGNvbnN0IG4gPSBvcHRpb25zLnJvbGxpbmdDb250ZXh0Lm1hZ25pdHVkZXMubGVuZ3RoO1xuICAgIHNjYWxlX2NvbmZpZGVuY2UgPSByb3VuZChuIC8gMTQsIDIpO1xuICB9XG4gIFxuICAvLyBBcHBseSByb2xsaW5nIG1hZ25pdHVkZSBub3JtYWxpemF0aW9uIGlmIGNvbnRleHQgcHJvdmlkZWRcbiAgaWYgKG9wdGlvbnMucm9sbGluZ0NvbnRleHQpIHtcbiAgICBYID0gbm9ybWFsaXplV2l0aFJvbGxpbmdXaW5kb3coWCwgb3B0aW9ucy5yb2xsaW5nQ29udGV4dCwgb3B0cyk7XG4gIH1cblxuICBjb25zdCBZX2VmZmVjdGl2ZSA9IFlfcmF3ICogKDAuOCArIDAuMiAqIFgpO1xuXG4gIGNvbnN0IFZJID0gdm9sYXRpbGl0eShzY29yZWQsIHByZXZDdHgsIG9wdHMpO1xuXG4gIHJldHVybiB7XG4gICAgbWFnbml0dWRlOiByb3VuZChYLCAyKSxcbiAgICB2YWxlbmNlOiByb3VuZChZX2VmZmVjdGl2ZSwgMiksXG4gICAgdm9sYXRpbGl0eTogVkksXG4gICAgc2NvcmVkLFxuICAgIHJhd01hZ25pdHVkZTogcm91bmQoWF9yYXcgLyBvcHRzLm1hZ25pdHVkZURpdmlzb3IsIDIpLCAvLyBGb3IgZGVidWdnaW5nL3RyYWNraW5nXG4gICAgb3JpZ2luYWxNYWduaXR1ZGU6IHJvdW5kKFhfb3JpZ2luYWwsIDIpLCAvLyBCZWZvcmUgcm9sbGluZyBub3JtYWxpemF0aW9uXG4gICAgc2NhbGVDb25maWRlbmNlOiBzY2FsZV9jb25maWRlbmNlXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZ2dyZWdhdGUsXG4gIF9pbnRlcm5hbHM6IHtcbiAgICBub3JtYWxpemVBc3BlY3QsIGJhc2VWYWxlbmNlLCBwbGFuZXRUaWVyLCBvcmJNdWx0aXBsaWVyLCBzZW5zaXRpdml0eU11bHRpcGxpZXIsXG4gICAgc2NvcmVBc3BlY3QsIG11bHRpcGxpY2l0eUJvbnVzLCB2b2xhdGlsaXR5LCBub3JtYWxpemVXaXRoUm9sbGluZ1dpbmRvd1xuICB9XG59O1xuIl0sIm5hbWVzIjpbIk9VVEVSIiwiU2V0IiwiUEVSU09OQUwiLCJBTkdMRVMiLCJERUZBVUxUUyIsIm1hZ25pdHVkZURpdmlzb3IiLCJodWJCb251c0NhcCIsInNhbWVUYXJnZXRCb251c0NhcCIsInRpZ2h0QmFuZERlZyIsIm91dGVyVGlnaHRlblN0ZXAiLCJ1cmFudXNUaWdodEZsYWdEZWciLCJmYXN0Q29tcG9uZW50VGhyZXNob2xkIiwicm9sbGluZ1dpbmRvd0RheXMiLCJob29rU3RhY2tDYXAiLCJwbGFuZXRhcnlXZWlnaHRzIiwicm91bmQiLCJuIiwicCIsIk1hdGgiLCJhc051bSIsIngiLCJmYWxsYmFjayIsIk5hTiIsIm0iLCJtYXRjaCIsImQiLCJtaW4iLCJmIiwicGFyc2VGbG9hdCIsIk51bWJlciIsImlzRmluaXRlIiwibmFtZU9mIiwibm9kZSIsInVuZGVmaW5lZCIsIm5hbWUiLCJib2R5Iiwibm9ybWFsaXplQXNwZWN0IiwiYSIsInROYW1lIiwidHJhbnNpdCIsIm5OYW1lIiwibmF0YWwiLCJiIiwidHlwZSIsIlN0cmluZyIsImFzcGVjdCIsInRvTG93ZXJDYXNlIiwib3JiRGVnIiwib3JiIiwib3JiaXQiLCJiYXNlVmFsZW5jZSIsImFCb2R5IiwiYkJvZHkiLCJzZXQiLCJoYXMiLCJwbGFuZXRUaWVyIiwib3JiTXVsdGlwbGllciIsIm8iLCJhYnMiLCJzZW5zaXRpdml0eU11bHRpcGxpZXIiLCJuYXRhbEJvZHkiLCJpc0FuZ2xlIiwiaXNMdW0iLCJjcml0aWNhbCIsInMiLCJzY29yZUFzcGVjdCIsImluQSIsImZsYWdzIiwidEJvZHkiLCJuQm9keSIsInYiLCJtYXgiLCJpc0FuZ2xlUHJveCIsIlMiLCJtdWx0aXBsaWNpdHlCb251cyIsInNjb3JlZCIsIm9wdHMiLCJodWIiLCJ0YXJnZXQiLCJieVRyYW5zaXQiLCJNYXAiLCJrIiwiZ2V0IiwiYnlUYXJnZXQiLCJ2b2xhdGlsaXR5Iiwic2NvcmVkVG9kYXkiLCJwcmV2Q3R4IiwiQSIsIkIiLCJDIiwiRCIsImtleSIsInRpZ2h0IiwiYXJyIiwiZmlsdGVyIiwicHJldlRpZ2h0IiwibWFwIiwibm93VGlnaHQiLCJZX2VmZmVjdGl2ZSIsInByZXZZIiwibm93WSIsInJlZHVjZSIsInNpZ24iLCJwcmV2TWFwIiwiY3VyIiwicFgiLCJpc091dGVySGFyZCIsInNvbWUiLCJ3ZWlnaHRlZFZhbGVuY2VzIiwidHJhbnNpdFdlaWdodCIsIm5hdGFsV2VpZ2h0IiwiY29tYmluZWRXZWlnaHQiLCJFIiwibGVuZ3RoIiwibWVhbiIsInZhcmlhbmNlIiwicG93Iiwic3RkRGV2Iiwic3FydCIsIm5vcm1hbGl6ZVdpdGhSb2xsaW5nV2luZG93IiwibWFnbml0dWRlIiwicm9sbGluZ0NvbnRleHQiLCJYX3ByaW9yIiwiZXBzaWxvbiIsIm1hZ25pdHVkZXMiLCJsYW1iZGEiLCJYX3JlZiIsInNvcnRlZCIsInNvcnQiLCJtaWQiLCJmbG9vciIsIm1lZGlhbl9hdmFpbGFibGUiLCJub3JtYWxpemVkIiwiYWdncmVnYXRlIiwiYXNwZWN0cyIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxlbmNlIiwiWF9yYXciLCJhY2MiLCJZX3JhdyIsIlgiLCJYX29yaWdpbmFsIiwic2NhbGVfY29uZmlkZW5jZSIsIlZJIiwicmF3TWFnbml0dWRlIiwib3JpZ2luYWxNYWduaXR1ZGUiLCJzY2FsZUNvbmZpZGVuY2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiX2ludGVybmFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/seismograph.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/tz-lookup","vendor-chunks/luxon"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fastrology-mathbrain%2Froute&page=%2Fapi%2Fastrology-mathbrain%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fastrology-mathbrain%2Froute.ts&appDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frunner%2Fwork%2FWovenWebApp%2FWovenWebApp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();